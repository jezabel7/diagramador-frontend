;(function () {
  const e = document.createElement('link').relList
  if (e && e.supports && e.supports('modulepreload')) return
  for (const s of document.querySelectorAll('link[rel="modulepreload"]')) i(s)
  new MutationObserver(s => {
    for (const o of s)
      if (o.type === 'childList')
        for (const u of o.addedNodes) u.tagName === 'LINK' && u.rel === 'modulepreload' && i(u)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(s) {
    const o = {}
    return (
      s.integrity && (o.integrity = s.integrity),
      s.referrerPolicy && (o.referrerPolicy = s.referrerPolicy),
      s.crossOrigin === 'use-credentials'
        ? (o.credentials = 'include')
        : s.crossOrigin === 'anonymous'
          ? (o.credentials = 'omit')
          : (o.credentials = 'same-origin'),
      o
    )
  }
  function i(s) {
    if (s.ep) return
    s.ep = !0
    const o = n(s)
    fetch(s.href, o)
  }
})()
function Hu(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t
}
function oT(t) {
  if (Object.prototype.hasOwnProperty.call(t, '__esModule')) return t
  var e = t.default
  if (typeof e == 'function') {
    var n = function i() {
      var s = !1
      try {
        s = this instanceof i
      } catch {}
      return s ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
    }
    n.prototype = e.prototype
  } else n = {}
  return (
    Object.defineProperty(n, '__esModule', { value: !0 }),
    Object.keys(t).forEach(function (i) {
      var s = Object.getOwnPropertyDescriptor(t, i)
      Object.defineProperty(
        n,
        i,
        s.get
          ? s
          : {
              enumerable: !0,
              get: function () {
                return t[i]
              },
            }
      )
    }),
    n
  )
}
var _g = { exports: {} },
  bu = {}
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var JA
function lT() {
  if (JA) return bu
  JA = 1
  var t = Symbol.for('react.transitional.element'),
    e = Symbol.for('react.fragment')
  function n(i, s, o) {
    var u = null
    if ((o !== void 0 && (u = '' + o), s.key !== void 0 && (u = '' + s.key), 'key' in s)) {
      o = {}
      for (var c in s) c !== 'key' && (o[c] = s[c])
    } else o = s
    return ((s = o.ref), { $$typeof: t, type: i, key: u, ref: s !== void 0 ? s : null, props: o })
  }
  return ((bu.Fragment = e), (bu.jsx = n), (bu.jsxs = n), bu)
}
var qA
function uT() {
  return (qA || ((qA = 1), (_g.exports = lT())), _g.exports)
}
var Gt = uT(),
  Bg = { exports: {} },
  ve = {}
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var QA
function cT() {
  if (QA) return ve
  QA = 1
  var t = Symbol.for('react.transitional.element'),
    e = Symbol.for('react.portal'),
    n = Symbol.for('react.fragment'),
    i = Symbol.for('react.strict_mode'),
    s = Symbol.for('react.profiler'),
    o = Symbol.for('react.consumer'),
    u = Symbol.for('react.context'),
    c = Symbol.for('react.forward_ref'),
    h = Symbol.for('react.suspense'),
    p = Symbol.for('react.memo'),
    y = Symbol.for('react.lazy'),
    v = Symbol.iterator
  function C(F) {
    return F === null || typeof F != 'object'
      ? null
      : ((F = (v && F[v]) || F['@@iterator']), typeof F == 'function' ? F : null)
  }
  var w = {
      isMounted: function () {
        return !1
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    N = Object.assign,
    T = {}
  function z(F, ht, ct) {
    ;((this.props = F), (this.context = ht), (this.refs = T), (this.updater = ct || w))
  }
  ;((z.prototype.isReactComponent = {}),
    (z.prototype.setState = function (F, ht) {
      if (typeof F != 'object' && typeof F != 'function' && F != null)
        throw Error(
          'takes an object of state variables to update or a function which returns an object of state variables.'
        )
      this.updater.enqueueSetState(this, F, ht, 'setState')
    }),
    (z.prototype.forceUpdate = function (F) {
      this.updater.enqueueForceUpdate(this, F, 'forceUpdate')
    }))
  function R() {}
  R.prototype = z.prototype
  function B(F, ht, ct) {
    ;((this.props = F), (this.context = ht), (this.refs = T), (this.updater = ct || w))
  }
  var H = (B.prototype = new R())
  ;((H.constructor = B), N(H, z.prototype), (H.isPureReactComponent = !0))
  var Z = Array.isArray,
    U = { H: null, A: null, T: null, S: null, V: null },
    nt = Object.prototype.hasOwnProperty
  function g(F, ht, ct, St, bt, kt) {
    return (
      (ct = kt.ref),
      { $$typeof: t, type: F, key: ht, ref: ct !== void 0 ? ct : null, props: kt }
    )
  }
  function S(F, ht) {
    return g(F.type, ht, void 0, void 0, void 0, F.props)
  }
  function M(F) {
    return typeof F == 'object' && F !== null && F.$$typeof === t
  }
  function _(F) {
    var ht = { '=': '=0', ':': '=2' }
    return (
      '$' +
      F.replace(/[=:]/g, function (ct) {
        return ht[ct]
      })
    )
  }
  var W = /\/+/g
  function $(F, ht) {
    return typeof F == 'object' && F !== null && F.key != null ? _('' + F.key) : ht.toString(36)
  }
  function X() {}
  function Ct(F) {
    switch (F.status) {
      case 'fulfilled':
        return F.value
      case 'rejected':
        throw F.reason
      default:
        switch (
          (typeof F.status == 'string'
            ? F.then(X, X)
            : ((F.status = 'pending'),
              F.then(
                function (ht) {
                  F.status === 'pending' && ((F.status = 'fulfilled'), (F.value = ht))
                },
                function (ht) {
                  F.status === 'pending' && ((F.status = 'rejected'), (F.reason = ht))
                }
              )),
          F.status)
        ) {
          case 'fulfilled':
            return F.value
          case 'rejected':
            throw F.reason
        }
    }
    throw F
  }
  function Tt(F, ht, ct, St, bt) {
    var kt = typeof F
    ;(kt === 'undefined' || kt === 'boolean') && (F = null)
    var lt = !1
    if (F === null) lt = !0
    else
      switch (kt) {
        case 'bigint':
        case 'string':
        case 'number':
          lt = !0
          break
        case 'object':
          switch (F.$$typeof) {
            case t:
            case e:
              lt = !0
              break
            case y:
              return ((lt = F._init), Tt(lt(F._payload), ht, ct, St, bt))
          }
      }
    if (lt)
      return (
        (bt = bt(F)),
        (lt = St === '' ? '.' + $(F, 0) : St),
        Z(bt)
          ? ((ct = ''),
            lt != null && (ct = lt.replace(W, '$&/') + '/'),
            Tt(bt, ht, ct, '', function (Ft) {
              return Ft
            }))
          : bt != null &&
            (M(bt) &&
              (bt = S(
                bt,
                ct +
                  (bt.key == null || (F && F.key === bt.key)
                    ? ''
                    : ('' + bt.key).replace(W, '$&/') + '/') +
                  lt
              )),
            ht.push(bt)),
        1
      )
    lt = 0
    var gt = St === '' ? '.' : St + ':'
    if (Z(F))
      for (var Et = 0; Et < F.length; Et++)
        ((St = F[Et]), (kt = gt + $(St, Et)), (lt += Tt(St, ht, ct, kt, bt)))
    else if (((Et = C(F)), typeof Et == 'function'))
      for (F = Et.call(F), Et = 0; !(St = F.next()).done; )
        ((St = St.value), (kt = gt + $(St, Et++)), (lt += Tt(St, ht, ct, kt, bt)))
    else if (kt === 'object') {
      if (typeof F.then == 'function') return Tt(Ct(F), ht, ct, St, bt)
      throw (
        (ht = String(F)),
        Error(
          'Objects are not valid as a React child (found: ' +
            (ht === '[object Object]'
              ? 'object with keys {' + Object.keys(F).join(', ') + '}'
              : ht) +
            '). If you meant to render a collection of children, use an array instead.'
        )
      )
    }
    return lt
  }
  function G(F, ht, ct) {
    if (F == null) return F
    var St = [],
      bt = 0
    return (
      Tt(F, St, '', '', function (kt) {
        return ht.call(ct, kt, bt++)
      }),
      St
    )
  }
  function Q(F) {
    if (F._status === -1) {
      var ht = F._result
      ;((ht = ht()),
        ht.then(
          function (ct) {
            ;(F._status === 0 || F._status === -1) && ((F._status = 1), (F._result = ct))
          },
          function (ct) {
            ;(F._status === 0 || F._status === -1) && ((F._status = 2), (F._result = ct))
          }
        ),
        F._status === -1 && ((F._status = 0), (F._result = ht)))
    }
    if (F._status === 1) return F._result.default
    throw F._result
  }
  var it =
    typeof reportError == 'function'
      ? reportError
      : function (F) {
          if (typeof window == 'object' && typeof window.ErrorEvent == 'function') {
            var ht = new window.ErrorEvent('error', {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof F == 'object' && F !== null && typeof F.message == 'string'
                  ? String(F.message)
                  : String(F),
              error: F,
            })
            if (!window.dispatchEvent(ht)) return
          } else if (typeof process == 'object' && typeof process.emit == 'function') {
            process.emit('uncaughtException', F)
            return
          }
          console.error(F)
        }
  function st() {}
  return (
    (ve.Children = {
      map: G,
      forEach: function (F, ht, ct) {
        G(
          F,
          function () {
            ht.apply(this, arguments)
          },
          ct
        )
      },
      count: function (F) {
        var ht = 0
        return (
          G(F, function () {
            ht++
          }),
          ht
        )
      },
      toArray: function (F) {
        return (
          G(F, function (ht) {
            return ht
          }) || []
        )
      },
      only: function (F) {
        if (!M(F))
          throw Error('React.Children.only expected to receive a single React element child.')
        return F
      },
    }),
    (ve.Component = z),
    (ve.Fragment = n),
    (ve.Profiler = s),
    (ve.PureComponent = B),
    (ve.StrictMode = i),
    (ve.Suspense = h),
    (ve.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = U),
    (ve.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function (F) {
        return U.H.useMemoCache(F)
      },
    }),
    (ve.cache = function (F) {
      return function () {
        return F.apply(null, arguments)
      }
    }),
    (ve.cloneElement = function (F, ht, ct) {
      if (F == null) throw Error('The argument must be a React element, but you passed ' + F + '.')
      var St = N({}, F.props),
        bt = F.key,
        kt = void 0
      if (ht != null)
        for (lt in (ht.ref !== void 0 && (kt = void 0),
        ht.key !== void 0 && (bt = '' + ht.key),
        ht))
          !nt.call(ht, lt) ||
            lt === 'key' ||
            lt === '__self' ||
            lt === '__source' ||
            (lt === 'ref' && ht.ref === void 0) ||
            (St[lt] = ht[lt])
      var lt = arguments.length - 2
      if (lt === 1) St.children = ct
      else if (1 < lt) {
        for (var gt = Array(lt), Et = 0; Et < lt; Et++) gt[Et] = arguments[Et + 2]
        St.children = gt
      }
      return g(F.type, bt, void 0, void 0, kt, St)
    }),
    (ve.createContext = function (F) {
      return (
        (F = {
          $$typeof: u,
          _currentValue: F,
          _currentValue2: F,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
        }),
        (F.Provider = F),
        (F.Consumer = { $$typeof: o, _context: F }),
        F
      )
    }),
    (ve.createElement = function (F, ht, ct) {
      var St,
        bt = {},
        kt = null
      if (ht != null)
        for (St in (ht.key !== void 0 && (kt = '' + ht.key), ht))
          nt.call(ht, St) &&
            St !== 'key' &&
            St !== '__self' &&
            St !== '__source' &&
            (bt[St] = ht[St])
      var lt = arguments.length - 2
      if (lt === 1) bt.children = ct
      else if (1 < lt) {
        for (var gt = Array(lt), Et = 0; Et < lt; Et++) gt[Et] = arguments[Et + 2]
        bt.children = gt
      }
      if (F && F.defaultProps)
        for (St in ((lt = F.defaultProps), lt)) bt[St] === void 0 && (bt[St] = lt[St])
      return g(F, kt, void 0, void 0, null, bt)
    }),
    (ve.createRef = function () {
      return { current: null }
    }),
    (ve.forwardRef = function (F) {
      return { $$typeof: c, render: F }
    }),
    (ve.isValidElement = M),
    (ve.lazy = function (F) {
      return { $$typeof: y, _payload: { _status: -1, _result: F }, _init: Q }
    }),
    (ve.memo = function (F, ht) {
      return { $$typeof: p, type: F, compare: ht === void 0 ? null : ht }
    }),
    (ve.startTransition = function (F) {
      var ht = U.T,
        ct = {}
      U.T = ct
      try {
        var St = F(),
          bt = U.S
        ;(bt !== null && bt(ct, St),
          typeof St == 'object' && St !== null && typeof St.then == 'function' && St.then(st, it))
      } catch (kt) {
        it(kt)
      } finally {
        U.T = ht
      }
    }),
    (ve.unstable_useCacheRefresh = function () {
      return U.H.useCacheRefresh()
    }),
    (ve.use = function (F) {
      return U.H.use(F)
    }),
    (ve.useActionState = function (F, ht, ct) {
      return U.H.useActionState(F, ht, ct)
    }),
    (ve.useCallback = function (F, ht) {
      return U.H.useCallback(F, ht)
    }),
    (ve.useContext = function (F) {
      return U.H.useContext(F)
    }),
    (ve.useDebugValue = function () {}),
    (ve.useDeferredValue = function (F, ht) {
      return U.H.useDeferredValue(F, ht)
    }),
    (ve.useEffect = function (F, ht, ct) {
      var St = U.H
      if (typeof ct == 'function')
        throw Error('useEffect CRUD overload is not enabled in this build of React.')
      return St.useEffect(F, ht)
    }),
    (ve.useId = function () {
      return U.H.useId()
    }),
    (ve.useImperativeHandle = function (F, ht, ct) {
      return U.H.useImperativeHandle(F, ht, ct)
    }),
    (ve.useInsertionEffect = function (F, ht) {
      return U.H.useInsertionEffect(F, ht)
    }),
    (ve.useLayoutEffect = function (F, ht) {
      return U.H.useLayoutEffect(F, ht)
    }),
    (ve.useMemo = function (F, ht) {
      return U.H.useMemo(F, ht)
    }),
    (ve.useOptimistic = function (F, ht) {
      return U.H.useOptimistic(F, ht)
    }),
    (ve.useReducer = function (F, ht, ct) {
      return U.H.useReducer(F, ht, ct)
    }),
    (ve.useRef = function (F) {
      return U.H.useRef(F)
    }),
    (ve.useState = function (F) {
      return U.H.useState(F)
    }),
    (ve.useSyncExternalStore = function (F, ht, ct) {
      return U.H.useSyncExternalStore(F, ht, ct)
    }),
    (ve.useTransition = function () {
      return U.H.useTransition()
    }),
    (ve.version = '19.1.1'),
    ve
  )
}
var KA
function xv() {
  return (KA || ((KA = 1), (Bg.exports = cT())), Bg.exports)
}
var ce = xv()
const fT = Hu(ce)
var jg = { exports: {} },
  Iu = {},
  Pg = { exports: {} },
  Gg = {}
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var $A
function hT() {
  return (
    $A ||
      (($A = 1),
      (function (t) {
        function e(G, Q) {
          var it = G.length
          G.push(Q)
          t: for (; 0 < it; ) {
            var st = (it - 1) >>> 1,
              F = G[st]
            if (0 < s(F, Q)) ((G[st] = Q), (G[it] = F), (it = st))
            else break t
          }
        }
        function n(G) {
          return G.length === 0 ? null : G[0]
        }
        function i(G) {
          if (G.length === 0) return null
          var Q = G[0],
            it = G.pop()
          if (it !== Q) {
            G[0] = it
            t: for (var st = 0, F = G.length, ht = F >>> 1; st < ht; ) {
              var ct = 2 * (st + 1) - 1,
                St = G[ct],
                bt = ct + 1,
                kt = G[bt]
              if (0 > s(St, it))
                bt < F && 0 > s(kt, St)
                  ? ((G[st] = kt), (G[bt] = it), (st = bt))
                  : ((G[st] = St), (G[ct] = it), (st = ct))
              else if (bt < F && 0 > s(kt, it)) ((G[st] = kt), (G[bt] = it), (st = bt))
              else break t
            }
          }
          return Q
        }
        function s(G, Q) {
          var it = G.sortIndex - Q.sortIndex
          return it !== 0 ? it : G.id - Q.id
        }
        if (
          ((t.unstable_now = void 0),
          typeof performance == 'object' && typeof performance.now == 'function')
        ) {
          var o = performance
          t.unstable_now = function () {
            return o.now()
          }
        } else {
          var u = Date,
            c = u.now()
          t.unstable_now = function () {
            return u.now() - c
          }
        }
        var h = [],
          p = [],
          y = 1,
          v = null,
          C = 3,
          w = !1,
          N = !1,
          T = !1,
          z = !1,
          R = typeof setTimeout == 'function' ? setTimeout : null,
          B = typeof clearTimeout == 'function' ? clearTimeout : null,
          H = typeof setImmediate < 'u' ? setImmediate : null
        function Z(G) {
          for (var Q = n(p); Q !== null; ) {
            if (Q.callback === null) i(p)
            else if (Q.startTime <= G) (i(p), (Q.sortIndex = Q.expirationTime), e(h, Q))
            else break
            Q = n(p)
          }
        }
        function U(G) {
          if (((T = !1), Z(G), !N))
            if (n(h) !== null) ((N = !0), nt || ((nt = !0), $()))
            else {
              var Q = n(p)
              Q !== null && Tt(U, Q.startTime - G)
            }
        }
        var nt = !1,
          g = -1,
          S = 5,
          M = -1
        function _() {
          return z ? !0 : !(t.unstable_now() - M < S)
        }
        function W() {
          if (((z = !1), nt)) {
            var G = t.unstable_now()
            M = G
            var Q = !0
            try {
              t: {
                ;((N = !1), T && ((T = !1), B(g), (g = -1)), (w = !0))
                var it = C
                try {
                  e: {
                    for (Z(G), v = n(h); v !== null && !(v.expirationTime > G && _()); ) {
                      var st = v.callback
                      if (typeof st == 'function') {
                        ;((v.callback = null), (C = v.priorityLevel))
                        var F = st(v.expirationTime <= G)
                        if (((G = t.unstable_now()), typeof F == 'function')) {
                          ;((v.callback = F), Z(G), (Q = !0))
                          break e
                        }
                        ;(v === n(h) && i(h), Z(G))
                      } else i(h)
                      v = n(h)
                    }
                    if (v !== null) Q = !0
                    else {
                      var ht = n(p)
                      ;(ht !== null && Tt(U, ht.startTime - G), (Q = !1))
                    }
                  }
                  break t
                } finally {
                  ;((v = null), (C = it), (w = !1))
                }
                Q = void 0
              }
            } finally {
              Q ? $() : (nt = !1)
            }
          }
        }
        var $
        if (typeof H == 'function')
          $ = function () {
            H(W)
          }
        else if (typeof MessageChannel < 'u') {
          var X = new MessageChannel(),
            Ct = X.port2
          ;((X.port1.onmessage = W),
            ($ = function () {
              Ct.postMessage(null)
            }))
        } else
          $ = function () {
            R(W, 0)
          }
        function Tt(G, Q) {
          g = R(function () {
            G(t.unstable_now())
          }, Q)
        }
        ;((t.unstable_IdlePriority = 5),
          (t.unstable_ImmediatePriority = 1),
          (t.unstable_LowPriority = 4),
          (t.unstable_NormalPriority = 3),
          (t.unstable_Profiling = null),
          (t.unstable_UserBlockingPriority = 2),
          (t.unstable_cancelCallback = function (G) {
            G.callback = null
          }),
          (t.unstable_forceFrameRate = function (G) {
            0 > G || 125 < G
              ? console.error(
                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
                )
              : (S = 0 < G ? Math.floor(1e3 / G) : 5)
          }),
          (t.unstable_getCurrentPriorityLevel = function () {
            return C
          }),
          (t.unstable_next = function (G) {
            switch (C) {
              case 1:
              case 2:
              case 3:
                var Q = 3
                break
              default:
                Q = C
            }
            var it = C
            C = Q
            try {
              return G()
            } finally {
              C = it
            }
          }),
          (t.unstable_requestPaint = function () {
            z = !0
          }),
          (t.unstable_runWithPriority = function (G, Q) {
            switch (G) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break
              default:
                G = 3
            }
            var it = C
            C = G
            try {
              return Q()
            } finally {
              C = it
            }
          }),
          (t.unstable_scheduleCallback = function (G, Q, it) {
            var st = t.unstable_now()
            switch (
              (typeof it == 'object' && it !== null
                ? ((it = it.delay), (it = typeof it == 'number' && 0 < it ? st + it : st))
                : (it = st),
              G)
            ) {
              case 1:
                var F = -1
                break
              case 2:
                F = 250
                break
              case 5:
                F = 1073741823
                break
              case 4:
                F = 1e4
                break
              default:
                F = 5e3
            }
            return (
              (F = it + F),
              (G = {
                id: y++,
                callback: Q,
                priorityLevel: G,
                startTime: it,
                expirationTime: F,
                sortIndex: -1,
              }),
              it > st
                ? ((G.sortIndex = it),
                  e(p, G),
                  n(h) === null && G === n(p) && (T ? (B(g), (g = -1)) : (T = !0), Tt(U, it - st)))
                : ((G.sortIndex = F), e(h, G), N || w || ((N = !0), nt || ((nt = !0), $()))),
              G
            )
          }),
          (t.unstable_shouldYield = _),
          (t.unstable_wrapCallback = function (G) {
            var Q = C
            return function () {
              var it = C
              C = Q
              try {
                return G.apply(this, arguments)
              } finally {
                C = it
              }
            }
          }))
      })(Gg)),
    Gg
  )
}
var tb
function dT() {
  return (tb || ((tb = 1), (Pg.exports = hT())), Pg.exports)
}
var Zg = { exports: {} },
  Kn = {}
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var eb
function gT() {
  if (eb) return Kn
  eb = 1
  var t = xv()
  function e(h) {
    var p = 'https://react.dev/errors/' + h
    if (1 < arguments.length) {
      p += '?args[]=' + encodeURIComponent(arguments[1])
      for (var y = 2; y < arguments.length; y++) p += '&args[]=' + encodeURIComponent(arguments[y])
    }
    return (
      'Minified React error #' +
      h +
      '; visit ' +
      p +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    )
  }
  function n() {}
  var i = {
      d: {
        f: n,
        r: function () {
          throw Error(e(522))
        },
        D: n,
        C: n,
        L: n,
        m: n,
        X: n,
        S: n,
        M: n,
      },
      p: 0,
      findDOMNode: null,
    },
    s = Symbol.for('react.portal')
  function o(h, p, y) {
    var v = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
    return {
      $$typeof: s,
      key: v == null ? null : '' + v,
      children: h,
      containerInfo: p,
      implementation: y,
    }
  }
  var u = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
  function c(h, p) {
    if (h === 'font') return ''
    if (typeof p == 'string') return p === 'use-credentials' ? p : ''
  }
  return (
    (Kn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i),
    (Kn.createPortal = function (h, p) {
      var y = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
      if (!p || (p.nodeType !== 1 && p.nodeType !== 9 && p.nodeType !== 11)) throw Error(e(299))
      return o(h, p, null, y)
    }),
    (Kn.flushSync = function (h) {
      var p = u.T,
        y = i.p
      try {
        if (((u.T = null), (i.p = 2), h)) return h()
      } finally {
        ;((u.T = p), (i.p = y), i.d.f())
      }
    }),
    (Kn.preconnect = function (h, p) {
      typeof h == 'string' &&
        (p
          ? ((p = p.crossOrigin),
            (p = typeof p == 'string' ? (p === 'use-credentials' ? p : '') : void 0))
          : (p = null),
        i.d.C(h, p))
    }),
    (Kn.prefetchDNS = function (h) {
      typeof h == 'string' && i.d.D(h)
    }),
    (Kn.preinit = function (h, p) {
      if (typeof h == 'string' && p && typeof p.as == 'string') {
        var y = p.as,
          v = c(y, p.crossOrigin),
          C = typeof p.integrity == 'string' ? p.integrity : void 0,
          w = typeof p.fetchPriority == 'string' ? p.fetchPriority : void 0
        y === 'style'
          ? i.d.S(h, typeof p.precedence == 'string' ? p.precedence : void 0, {
              crossOrigin: v,
              integrity: C,
              fetchPriority: w,
            })
          : y === 'script' &&
            i.d.X(h, {
              crossOrigin: v,
              integrity: C,
              fetchPriority: w,
              nonce: typeof p.nonce == 'string' ? p.nonce : void 0,
            })
      }
    }),
    (Kn.preinitModule = function (h, p) {
      if (typeof h == 'string')
        if (typeof p == 'object' && p !== null) {
          if (p.as == null || p.as === 'script') {
            var y = c(p.as, p.crossOrigin)
            i.d.M(h, {
              crossOrigin: y,
              integrity: typeof p.integrity == 'string' ? p.integrity : void 0,
              nonce: typeof p.nonce == 'string' ? p.nonce : void 0,
            })
          }
        } else p == null && i.d.M(h)
    }),
    (Kn.preload = function (h, p) {
      if (typeof h == 'string' && typeof p == 'object' && p !== null && typeof p.as == 'string') {
        var y = p.as,
          v = c(y, p.crossOrigin)
        i.d.L(h, y, {
          crossOrigin: v,
          integrity: typeof p.integrity == 'string' ? p.integrity : void 0,
          nonce: typeof p.nonce == 'string' ? p.nonce : void 0,
          type: typeof p.type == 'string' ? p.type : void 0,
          fetchPriority: typeof p.fetchPriority == 'string' ? p.fetchPriority : void 0,
          referrerPolicy: typeof p.referrerPolicy == 'string' ? p.referrerPolicy : void 0,
          imageSrcSet: typeof p.imageSrcSet == 'string' ? p.imageSrcSet : void 0,
          imageSizes: typeof p.imageSizes == 'string' ? p.imageSizes : void 0,
          media: typeof p.media == 'string' ? p.media : void 0,
        })
      }
    }),
    (Kn.preloadModule = function (h, p) {
      if (typeof h == 'string')
        if (p) {
          var y = c(p.as, p.crossOrigin)
          i.d.m(h, {
            as: typeof p.as == 'string' && p.as !== 'script' ? p.as : void 0,
            crossOrigin: y,
            integrity: typeof p.integrity == 'string' ? p.integrity : void 0,
          })
        } else i.d.m(h)
    }),
    (Kn.requestFormReset = function (h) {
      i.d.r(h)
    }),
    (Kn.unstable_batchedUpdates = function (h, p) {
      return h(p)
    }),
    (Kn.useFormState = function (h, p, y) {
      return u.H.useFormState(h, p, y)
    }),
    (Kn.useFormStatus = function () {
      return u.H.useHostTransitionStatus()
    }),
    (Kn.version = '19.1.1'),
    Kn
  )
}
var nb
function pT() {
  if (nb) return Zg.exports
  nb = 1
  function t() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)
      } catch (e) {
        console.error(e)
      }
  }
  return (t(), (Zg.exports = gT()), Zg.exports)
}
var ib
function vT() {
  if (ib) return Iu
  ib = 1
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var t = dT(),
    e = xv(),
    n = pT()
  function i(r) {
    var a = 'https://react.dev/errors/' + r
    if (1 < arguments.length) {
      a += '?args[]=' + encodeURIComponent(arguments[1])
      for (var l = 2; l < arguments.length; l++) a += '&args[]=' + encodeURIComponent(arguments[l])
    }
    return (
      'Minified React error #' +
      r +
      '; visit ' +
      a +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    )
  }
  function s(r) {
    return !(!r || (r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11))
  }
  function o(r) {
    var a = r,
      l = r
    if (r.alternate) for (; a.return; ) a = a.return
    else {
      r = a
      do ((a = r), (a.flags & 4098) !== 0 && (l = a.return), (r = a.return))
      while (r)
    }
    return a.tag === 3 ? l : null
  }
  function u(r) {
    if (r.tag === 13) {
      var a = r.memoizedState
      if ((a === null && ((r = r.alternate), r !== null && (a = r.memoizedState)), a !== null))
        return a.dehydrated
    }
    return null
  }
  function c(r) {
    if (o(r) !== r) throw Error(i(188))
  }
  function h(r) {
    var a = r.alternate
    if (!a) {
      if (((a = o(r)), a === null)) throw Error(i(188))
      return a !== r ? null : r
    }
    for (var l = r, f = a; ; ) {
      var m = l.return
      if (m === null) break
      var b = m.alternate
      if (b === null) {
        if (((f = m.return), f !== null)) {
          l = f
          continue
        }
        break
      }
      if (m.child === b.child) {
        for (b = m.child; b; ) {
          if (b === l) return (c(m), r)
          if (b === f) return (c(m), a)
          b = b.sibling
        }
        throw Error(i(188))
      }
      if (l.return !== f.return) ((l = m), (f = b))
      else {
        for (var O = !1, j = m.child; j; ) {
          if (j === l) {
            ;((O = !0), (l = m), (f = b))
            break
          }
          if (j === f) {
            ;((O = !0), (f = m), (l = b))
            break
          }
          j = j.sibling
        }
        if (!O) {
          for (j = b.child; j; ) {
            if (j === l) {
              ;((O = !0), (l = b), (f = m))
              break
            }
            if (j === f) {
              ;((O = !0), (f = b), (l = m))
              break
            }
            j = j.sibling
          }
          if (!O) throw Error(i(189))
        }
      }
      if (l.alternate !== f) throw Error(i(190))
    }
    if (l.tag !== 3) throw Error(i(188))
    return l.stateNode.current === l ? r : a
  }
  function p(r) {
    var a = r.tag
    if (a === 5 || a === 26 || a === 27 || a === 6) return r
    for (r = r.child; r !== null; ) {
      if (((a = p(r)), a !== null)) return a
      r = r.sibling
    }
    return null
  }
  var y = Object.assign,
    v = Symbol.for('react.element'),
    C = Symbol.for('react.transitional.element'),
    w = Symbol.for('react.portal'),
    N = Symbol.for('react.fragment'),
    T = Symbol.for('react.strict_mode'),
    z = Symbol.for('react.profiler'),
    R = Symbol.for('react.provider'),
    B = Symbol.for('react.consumer'),
    H = Symbol.for('react.context'),
    Z = Symbol.for('react.forward_ref'),
    U = Symbol.for('react.suspense'),
    nt = Symbol.for('react.suspense_list'),
    g = Symbol.for('react.memo'),
    S = Symbol.for('react.lazy'),
    M = Symbol.for('react.activity'),
    _ = Symbol.for('react.memo_cache_sentinel'),
    W = Symbol.iterator
  function $(r) {
    return r === null || typeof r != 'object'
      ? null
      : ((r = (W && r[W]) || r['@@iterator']), typeof r == 'function' ? r : null)
  }
  var X = Symbol.for('react.client.reference')
  function Ct(r) {
    if (r == null) return null
    if (typeof r == 'function') return r.$$typeof === X ? null : r.displayName || r.name || null
    if (typeof r == 'string') return r
    switch (r) {
      case N:
        return 'Fragment'
      case z:
        return 'Profiler'
      case T:
        return 'StrictMode'
      case U:
        return 'Suspense'
      case nt:
        return 'SuspenseList'
      case M:
        return 'Activity'
    }
    if (typeof r == 'object')
      switch (r.$$typeof) {
        case w:
          return 'Portal'
        case H:
          return (r.displayName || 'Context') + '.Provider'
        case B:
          return (r._context.displayName || 'Context') + '.Consumer'
        case Z:
          var a = r.render
          return (
            (r = r.displayName),
            r ||
              ((r = a.displayName || a.name || ''),
              (r = r !== '' ? 'ForwardRef(' + r + ')' : 'ForwardRef')),
            r
          )
        case g:
          return ((a = r.displayName || null), a !== null ? a : Ct(r.type) || 'Memo')
        case S:
          ;((a = r._payload), (r = r._init))
          try {
            return Ct(r(a))
          } catch {}
      }
    return null
  }
  var Tt = Array.isArray,
    G = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    Q = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    it = { pending: !1, data: null, method: null, action: null },
    st = [],
    F = -1
  function ht(r) {
    return { current: r }
  }
  function ct(r) {
    0 > F || ((r.current = st[F]), (st[F] = null), F--)
  }
  function St(r, a) {
    ;(F++, (st[F] = r.current), (r.current = a))
  }
  var bt = ht(null),
    kt = ht(null),
    lt = ht(null),
    gt = ht(null)
  function Et(r, a) {
    switch ((St(lt, a), St(kt, r), St(bt, null), a.nodeType)) {
      case 9:
      case 11:
        r = (r = a.documentElement) && (r = r.namespaceURI) ? wA(r) : 0
        break
      default:
        if (((r = a.tagName), (a = a.namespaceURI))) ((a = wA(a)), (r = xA(a, r)))
        else
          switch (r) {
            case 'svg':
              r = 1
              break
            case 'math':
              r = 2
              break
            default:
              r = 0
          }
    }
    ;(ct(bt), St(bt, r))
  }
  function Ft() {
    ;(ct(bt), ct(kt), ct(lt))
  }
  function Qt(r) {
    r.memoizedState !== null && St(gt, r)
    var a = bt.current,
      l = xA(a, r.type)
    a !== l && (St(kt, r), St(bt, l))
  }
  function qt(r) {
    ;(kt.current === r && (ct(bt), ct(kt)), gt.current === r && (ct(gt), (pu._currentValue = it)))
  }
  var de = Object.prototype.hasOwnProperty,
    Xt = t.unstable_scheduleCallback,
    E = t.unstable_cancelCallback,
    P = t.unstable_shouldYield,
    Y = t.unstable_requestPaint,
    J = t.unstable_now,
    At = t.unstable_getCurrentPriorityLevel,
    Nt = t.unstable_ImmediatePriority,
    Yt = t.unstable_UserBlockingPriority,
    se = t.unstable_NormalPriority,
    Se = t.unstable_LowPriority,
    $e = t.unstable_IdlePriority,
    Ye = t.log,
    Bt = t.unstable_setDisableYieldValue,
    ae = null,
    fe = null
  function Fn(r) {
    if ((typeof Ye == 'function' && Bt(r), fe && typeof fe.setStrictMode == 'function'))
      try {
        fe.setStrictMode(ae, r)
      } catch {}
  }
  var Ne = Math.clz32 ? Math.clz32 : wi,
    ln = Math.log,
    Zn = Math.LN2
  function wi(r) {
    return ((r >>>= 0), r === 0 ? 32 : (31 - ((ln(r) / Zn) | 0)) | 0)
  }
  var xn = 256,
    Jn = 4194304
  function Ln(r) {
    var a = r & 42
    if (a !== 0) return a
    switch (r & -r) {
      case 1:
        return 1
      case 2:
        return 2
      case 4:
        return 4
      case 8:
        return 8
      case 16:
        return 16
      case 32:
        return 32
      case 64:
        return 64
      case 128:
        return 128
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r & 4194048
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return r & 62914560
      case 67108864:
        return 67108864
      case 134217728:
        return 134217728
      case 268435456:
        return 268435456
      case 536870912:
        return 536870912
      case 1073741824:
        return 0
      default:
        return r
    }
  }
  function fr(r, a, l) {
    var f = r.pendingLanes
    if (f === 0) return 0
    var m = 0,
      b = r.suspendedLanes,
      O = r.pingedLanes
    r = r.warmLanes
    var j = f & 134217727
    return (
      j !== 0
        ? ((f = j & ~b),
          f !== 0
            ? (m = Ln(f))
            : ((O &= j), O !== 0 ? (m = Ln(O)) : l || ((l = j & ~r), l !== 0 && (m = Ln(l)))))
        : ((j = f & ~b),
          j !== 0
            ? (m = Ln(j))
            : O !== 0
              ? (m = Ln(O))
              : l || ((l = f & ~r), l !== 0 && (m = Ln(l)))),
      m === 0
        ? 0
        : a !== 0 &&
            a !== m &&
            (a & b) === 0 &&
            ((b = m & -m), (l = a & -a), b >= l || (b === 32 && (l & 4194048) !== 0))
          ? a
          : m
    )
  }
  function xi(r, a) {
    return (r.pendingLanes & ~(r.suspendedLanes & ~r.pingedLanes) & a) === 0
  }
  function ms(r, a) {
    switch (r) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return a + 250
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a + 5e3
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1
      default:
        return -1
    }
  }
  function Sa() {
    var r = xn
    return ((xn <<= 1), (xn & 4194048) === 0 && (xn = 256), r)
  }
  function hr() {
    var r = Jn
    return ((Jn <<= 1), (Jn & 62914560) === 0 && (Jn = 4194304), r)
  }
  function Si(r) {
    for (var a = [], l = 0; 31 > l; l++) a.push(r)
    return a
  }
  function hi(r, a) {
    ;((r.pendingLanes |= a),
      a !== 268435456 && ((r.suspendedLanes = 0), (r.pingedLanes = 0), (r.warmLanes = 0)))
  }
  function ys(r, a, l, f, m, b) {
    var O = r.pendingLanes
    ;((r.pendingLanes = l),
      (r.suspendedLanes = 0),
      (r.pingedLanes = 0),
      (r.warmLanes = 0),
      (r.expiredLanes &= l),
      (r.entangledLanes &= l),
      (r.errorRecoveryDisabledLanes &= l),
      (r.shellSuspendCounter = 0))
    var j = r.entanglements,
      K = r.expirationTimes,
      pt = r.hiddenUpdates
    for (l = O & ~l; 0 < l; ) {
      var Ot = 31 - Ne(l),
        zt = 1 << Ot
      ;((j[Ot] = 0), (K[Ot] = -1))
      var mt = pt[Ot]
      if (mt !== null)
        for (pt[Ot] = null, Ot = 0; Ot < mt.length; Ot++) {
          var It = mt[Ot]
          It !== null && (It.lane &= -536870913)
        }
      l &= ~zt
    }
    ;(f !== 0 && As(r, f, 0),
      b !== 0 && m === 0 && r.tag !== 0 && (r.suspendedLanes |= b & ~(O & ~a)))
  }
  function As(r, a, l) {
    ;((r.pendingLanes |= a), (r.suspendedLanes &= ~a))
    var f = 31 - Ne(a)
    ;((r.entangledLanes |= a),
      (r.entanglements[f] = r.entanglements[f] | 1073741824 | (l & 4194090)))
  }
  function en(r, a) {
    var l = (r.entangledLanes |= a)
    for (r = r.entanglements; l; ) {
      var f = 31 - Ne(l),
        m = 1 << f
      ;((m & a) | (r[f] & a) && (r[f] |= a), (l &= ~m))
    }
  }
  function zn(r) {
    switch (r) {
      case 2:
        r = 1
        break
      case 8:
        r = 4
        break
      case 32:
        r = 16
        break
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        r = 128
        break
      case 268435456:
        r = 134217728
        break
      default:
        r = 0
    }
    return r
  }
  function bs(r) {
    return ((r &= -r), 2 < r ? (8 < r ? ((r & 134217727) !== 0 ? 32 : 268435456) : 8) : 2)
  }
  function oc() {
    var r = Q.p
    return r !== 0 ? r : ((r = window.event), r === void 0 ? 32 : YA(r.type))
  }
  function lc(r, a) {
    var l = Q.p
    try {
      return ((Q.p = r), a())
    } finally {
      Q.p = l
    }
  }
  var dr = Math.random().toString(36).slice(2),
    sn = '__reactFiber$' + dr,
    gn = '__reactProps$' + dr,
    Lr = '__reactContainer$' + dr,
    Na = '__reactEvents$' + dr,
    Uh = '__reactListeners$' + dr,
    Yh = '__reactHandles$' + dr,
    uc = '__reactResources$' + dr,
    Ta = '__reactMarker$' + dr
  function Il(r) {
    ;(delete r[sn], delete r[gn], delete r[Na], delete r[Uh], delete r[Yh])
  }
  function Ma(r) {
    var a = r[sn]
    if (a) return a
    for (var l = r.parentNode; l; ) {
      if ((a = l[Lr] || l[sn])) {
        if (((l = a.alternate), a.child !== null || (l !== null && l.child !== null)))
          for (r = MA(r); r !== null; ) {
            if ((l = r[sn])) return l
            r = MA(r)
          }
        return a
      }
      ;((r = l), (l = r.parentNode))
    }
    return null
  }
  function Wr(r) {
    if ((r = r[sn] || r[Lr])) {
      var a = r.tag
      if (a === 5 || a === 6 || a === 13 || a === 26 || a === 27 || a === 3) return r
    }
    return null
  }
  function Is(r) {
    var a = r.tag
    if (a === 5 || a === 26 || a === 27 || a === 6) return r.stateNode
    throw Error(i(33))
  }
  function Ni(r) {
    var a = r[uc]
    return (a || (a = r[uc] = { hoistableStyles: new Map(), hoistableScripts: new Map() }), a)
  }
  function pn(r) {
    r[Ta] = !0
  }
  var uo = new Set(),
    co = {}
  function Xi(r, a) {
    ;(Fr(r, a), Fr(r + 'Capture', a))
  }
  function Fr(r, a) {
    for (co[r] = a, r = 0; r < a.length; r++) uo.add(a[r])
  }
  var Hh = RegExp(
      '^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'
    ),
    Ea = {},
    Cl = {}
  function cc(r) {
    return de.call(Cl, r)
      ? !0
      : de.call(Ea, r)
        ? !1
        : Hh.test(r)
          ? (Cl[r] = !0)
          : ((Ea[r] = !0), !1)
  }
  function Cs(r, a, l) {
    if (cc(a))
      if (l === null) r.removeAttribute(a)
      else {
        switch (typeof l) {
          case 'undefined':
          case 'function':
          case 'symbol':
            r.removeAttribute(a)
            return
          case 'boolean':
            var f = a.toLowerCase().slice(0, 5)
            if (f !== 'data-' && f !== 'aria-') {
              r.removeAttribute(a)
              return
            }
        }
        r.setAttribute(a, '' + l)
      }
  }
  function ws(r, a, l) {
    if (l === null) r.removeAttribute(a)
    else {
      switch (typeof l) {
        case 'undefined':
        case 'function':
        case 'symbol':
        case 'boolean':
          r.removeAttribute(a)
          return
      }
      r.setAttribute(a, '' + l)
    }
  }
  function gr(r, a, l, f) {
    if (f === null) r.removeAttribute(l)
    else {
      switch (typeof f) {
        case 'undefined':
        case 'function':
        case 'symbol':
        case 'boolean':
          r.removeAttribute(l)
          return
      }
      r.setAttributeNS(a, l, '' + f)
    }
  }
  var xs, fc
  function Da(r) {
    if (xs === void 0)
      try {
        throw Error()
      } catch (l) {
        var a = l.stack.trim().match(/\n( *(at )?)/)
        ;((xs = (a && a[1]) || ''),
          (fc =
            -1 <
            l.stack.indexOf(`
    at`)
              ? ' (<anonymous>)'
              : -1 < l.stack.indexOf('@')
                ? '@unknown:0:0'
                : ''))
      }
    return (
      `
` +
      xs +
      r +
      fc
    )
  }
  var fo = !1
  function ho(r, a) {
    if (!r || fo) return ''
    fo = !0
    var l = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    try {
      var f = {
        DetermineComponentFrameRoot: function () {
          try {
            if (a) {
              var zt = function () {
                throw Error()
              }
              if (
                (Object.defineProperty(zt.prototype, 'props', {
                  set: function () {
                    throw Error()
                  },
                }),
                typeof Reflect == 'object' && Reflect.construct)
              ) {
                try {
                  Reflect.construct(zt, [])
                } catch (It) {
                  var mt = It
                }
                Reflect.construct(r, [], zt)
              } else {
                try {
                  zt.call()
                } catch (It) {
                  mt = It
                }
                r.call(zt.prototype)
              }
            } else {
              try {
                throw Error()
              } catch (It) {
                mt = It
              }
              ;(zt = r()) && typeof zt.catch == 'function' && zt.catch(function () {})
            }
          } catch (It) {
            if (It && mt && typeof It.stack == 'string') return [It.stack, mt.stack]
          }
          return [null, null]
        },
      }
      f.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot'
      var m = Object.getOwnPropertyDescriptor(f.DetermineComponentFrameRoot, 'name')
      m &&
        m.configurable &&
        Object.defineProperty(f.DetermineComponentFrameRoot, 'name', {
          value: 'DetermineComponentFrameRoot',
        })
      var b = f.DetermineComponentFrameRoot(),
        O = b[0],
        j = b[1]
      if (O && j) {
        var K = O.split(`
`),
          pt = j.split(`
`)
        for (m = f = 0; f < K.length && !K[f].includes('DetermineComponentFrameRoot'); ) f++
        for (; m < pt.length && !pt[m].includes('DetermineComponentFrameRoot'); ) m++
        if (f === K.length || m === pt.length)
          for (f = K.length - 1, m = pt.length - 1; 1 <= f && 0 <= m && K[f] !== pt[m]; ) m--
        for (; 1 <= f && 0 <= m; f--, m--)
          if (K[f] !== pt[m]) {
            if (f !== 1 || m !== 1)
              do
                if ((f--, m--, 0 > m || K[f] !== pt[m])) {
                  var Ot =
                    `
` + K[f].replace(' at new ', ' at ')
                  return (
                    r.displayName &&
                      Ot.includes('<anonymous>') &&
                      (Ot = Ot.replace('<anonymous>', r.displayName)),
                    Ot
                  )
                }
              while (1 <= f && 0 <= m)
            break
          }
      }
    } finally {
      ;((fo = !1), (Error.prepareStackTrace = l))
    }
    return (l = r ? r.displayName || r.name : '') ? Da(l) : ''
  }
  function wl(r) {
    switch (r.tag) {
      case 26:
      case 27:
      case 5:
        return Da(r.type)
      case 16:
        return Da('Lazy')
      case 13:
        return Da('Suspense')
      case 19:
        return Da('SuspenseList')
      case 0:
      case 15:
        return ho(r.type, !1)
      case 11:
        return ho(r.type.render, !1)
      case 1:
        return ho(r.type, !0)
      case 31:
        return Da('Activity')
      default:
        return ''
    }
  }
  function xl(r) {
    try {
      var a = ''
      do ((a += wl(r)), (r = r.return))
      while (r)
      return a
    } catch (l) {
      return (
        `
Error generating stack: ` +
        l.message +
        `
` +
        l.stack
      )
    }
  }
  function Qe(r) {
    switch (typeof r) {
      case 'bigint':
      case 'boolean':
      case 'number':
      case 'string':
      case 'undefined':
        return r
      case 'object':
        return r
      default:
        return ''
    }
  }
  function Jr(r) {
    var a = r.type
    return (r = r.nodeName) && r.toLowerCase() === 'input' && (a === 'checkbox' || a === 'radio')
  }
  function go(r) {
    var a = Jr(r) ? 'checked' : 'value',
      l = Object.getOwnPropertyDescriptor(r.constructor.prototype, a),
      f = '' + r[a]
    if (
      !r.hasOwnProperty(a) &&
      typeof l < 'u' &&
      typeof l.get == 'function' &&
      typeof l.set == 'function'
    ) {
      var m = l.get,
        b = l.set
      return (
        Object.defineProperty(r, a, {
          configurable: !0,
          get: function () {
            return m.call(this)
          },
          set: function (O) {
            ;((f = '' + O), b.call(this, O))
          },
        }),
        Object.defineProperty(r, a, { enumerable: l.enumerable }),
        {
          getValue: function () {
            return f
          },
          setValue: function (O) {
            f = '' + O
          },
          stopTracking: function () {
            ;((r._valueTracker = null), delete r[a])
          },
        }
      )
    }
  }
  function po(r) {
    r._valueTracker || (r._valueTracker = go(r))
  }
  function hc(r) {
    if (!r) return !1
    var a = r._valueTracker
    if (!a) return !0
    var l = a.getValue(),
      f = ''
    return (
      r && (f = Jr(r) ? (r.checked ? 'true' : 'false') : r.value),
      (r = f),
      r !== l ? (a.setValue(r), !0) : !1
    )
  }
  function Oa(r) {
    if (((r = r || (typeof document < 'u' ? document : void 0)), typeof r > 'u')) return null
    try {
      return r.activeElement || r.body
    } catch {
      return r.body
    }
  }
  var dc = /[\n"\\]/g
  function Un(r) {
    return r.replace(dc, function (a) {
      return '\\' + a.charCodeAt(0).toString(16) + ' '
    })
  }
  function vo(r, a, l, f, m, b, O, j) {
    ;((r.name = ''),
      O != null && typeof O != 'function' && typeof O != 'symbol' && typeof O != 'boolean'
        ? (r.type = O)
        : r.removeAttribute('type'),
      a != null
        ? O === 'number'
          ? ((a === 0 && r.value === '') || r.value != a) && (r.value = '' + Qe(a))
          : r.value !== '' + Qe(a) && (r.value = '' + Qe(a))
        : (O !== 'submit' && O !== 'reset') || r.removeAttribute('value'),
      a != null
        ? Sl(r, O, Qe(a))
        : l != null
          ? Sl(r, O, Qe(l))
          : f != null && r.removeAttribute('value'),
      m == null && b != null && (r.defaultChecked = !!b),
      m != null && (r.checked = m && typeof m != 'function' && typeof m != 'symbol'),
      j != null && typeof j != 'function' && typeof j != 'symbol' && typeof j != 'boolean'
        ? (r.name = '' + Qe(j))
        : r.removeAttribute('name'))
  }
  function gc(r, a, l, f, m, b, O, j) {
    if (
      (b != null &&
        typeof b != 'function' &&
        typeof b != 'symbol' &&
        typeof b != 'boolean' &&
        (r.type = b),
      a != null || l != null)
    ) {
      if (!((b !== 'submit' && b !== 'reset') || a != null)) return
      ;((l = l != null ? '' + Qe(l) : ''),
        (a = a != null ? '' + Qe(a) : l),
        j || a === r.value || (r.value = a),
        (r.defaultValue = a))
    }
    ;((f = f ?? m),
      (f = typeof f != 'function' && typeof f != 'symbol' && !!f),
      (r.checked = j ? r.checked : !!f),
      (r.defaultChecked = !!f),
      O != null &&
        typeof O != 'function' &&
        typeof O != 'symbol' &&
        typeof O != 'boolean' &&
        (r.name = O))
  }
  function Sl(r, a, l) {
    ;(a === 'number' && Oa(r.ownerDocument) === r) ||
      r.defaultValue === '' + l ||
      (r.defaultValue = '' + l)
  }
  function Rn(r, a, l, f) {
    if (((r = r.options), a)) {
      a = {}
      for (var m = 0; m < l.length; m++) a['$' + l[m]] = !0
      for (l = 0; l < r.length; l++)
        ((m = a.hasOwnProperty('$' + r[l].value)),
          r[l].selected !== m && (r[l].selected = m),
          m && f && (r[l].defaultSelected = !0))
    } else {
      for (l = '' + Qe(l), a = null, m = 0; m < r.length; m++) {
        if (r[m].value === l) {
          ;((r[m].selected = !0), f && (r[m].defaultSelected = !0))
          return
        }
        a !== null || r[m].disabled || (a = r[m])
      }
      a !== null && (a.selected = !0)
    }
  }
  function Nl(r, a, l) {
    if (a != null && ((a = '' + Qe(a)), a !== r.value && (r.value = a), l == null)) {
      r.defaultValue !== a && (r.defaultValue = a)
      return
    }
    r.defaultValue = l != null ? '' + Qe(l) : ''
  }
  function La(r, a, l, f) {
    if (a == null) {
      if (f != null) {
        if (l != null) throw Error(i(92))
        if (Tt(f)) {
          if (1 < f.length) throw Error(i(93))
          f = f[0]
        }
        l = f
      }
      ;(l == null && (l = ''), (a = l))
    }
    ;((l = Qe(a)),
      (r.defaultValue = l),
      (f = r.textContent),
      f === l && f !== '' && f !== null && (r.value = f))
  }
  function za(r, a) {
    if (a) {
      var l = r.firstChild
      if (l && l === r.lastChild && l.nodeType === 3) {
        l.nodeValue = a
        return
      }
    }
    r.textContent = a
  }
  var Vh = new Set(
    'animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp'.split(
      ' '
    )
  )
  function zr(r, a, l) {
    var f = a.indexOf('--') === 0
    l == null || typeof l == 'boolean' || l === ''
      ? f
        ? r.setProperty(a, '')
        : a === 'float'
          ? (r.cssFloat = '')
          : (r[a] = '')
      : f
        ? r.setProperty(a, l)
        : typeof l != 'number' || l === 0 || Vh.has(a)
          ? a === 'float'
            ? (r.cssFloat = l)
            : (r[a] = ('' + l).trim())
          : (r[a] = l + 'px')
  }
  function Rr(r, a, l) {
    if (a != null && typeof a != 'object') throw Error(i(62))
    if (((r = r.style), l != null)) {
      for (var f in l)
        !l.hasOwnProperty(f) ||
          (a != null && a.hasOwnProperty(f)) ||
          (f.indexOf('--') === 0
            ? r.setProperty(f, '')
            : f === 'float'
              ? (r.cssFloat = '')
              : (r[f] = ''))
      for (var m in a) ((f = a[m]), a.hasOwnProperty(m) && l[m] !== f && zr(r, m, f))
    } else for (var b in a) a.hasOwnProperty(b) && zr(r, b, a[b])
  }
  function Ss(r) {
    if (r.indexOf('-') === -1) return !1
    switch (r) {
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return !1
      default:
        return !0
    }
  }
  var Xh = new Map([
      ['acceptCharset', 'accept-charset'],
      ['htmlFor', 'for'],
      ['httpEquiv', 'http-equiv'],
      ['crossOrigin', 'crossorigin'],
      ['accentHeight', 'accent-height'],
      ['alignmentBaseline', 'alignment-baseline'],
      ['arabicForm', 'arabic-form'],
      ['baselineShift', 'baseline-shift'],
      ['capHeight', 'cap-height'],
      ['clipPath', 'clip-path'],
      ['clipRule', 'clip-rule'],
      ['colorInterpolation', 'color-interpolation'],
      ['colorInterpolationFilters', 'color-interpolation-filters'],
      ['colorProfile', 'color-profile'],
      ['colorRendering', 'color-rendering'],
      ['dominantBaseline', 'dominant-baseline'],
      ['enableBackground', 'enable-background'],
      ['fillOpacity', 'fill-opacity'],
      ['fillRule', 'fill-rule'],
      ['floodColor', 'flood-color'],
      ['floodOpacity', 'flood-opacity'],
      ['fontFamily', 'font-family'],
      ['fontSize', 'font-size'],
      ['fontSizeAdjust', 'font-size-adjust'],
      ['fontStretch', 'font-stretch'],
      ['fontStyle', 'font-style'],
      ['fontVariant', 'font-variant'],
      ['fontWeight', 'font-weight'],
      ['glyphName', 'glyph-name'],
      ['glyphOrientationHorizontal', 'glyph-orientation-horizontal'],
      ['glyphOrientationVertical', 'glyph-orientation-vertical'],
      ['horizAdvX', 'horiz-adv-x'],
      ['horizOriginX', 'horiz-origin-x'],
      ['imageRendering', 'image-rendering'],
      ['letterSpacing', 'letter-spacing'],
      ['lightingColor', 'lighting-color'],
      ['markerEnd', 'marker-end'],
      ['markerMid', 'marker-mid'],
      ['markerStart', 'marker-start'],
      ['overlinePosition', 'overline-position'],
      ['overlineThickness', 'overline-thickness'],
      ['paintOrder', 'paint-order'],
      ['panose-1', 'panose-1'],
      ['pointerEvents', 'pointer-events'],
      ['renderingIntent', 'rendering-intent'],
      ['shapeRendering', 'shape-rendering'],
      ['stopColor', 'stop-color'],
      ['stopOpacity', 'stop-opacity'],
      ['strikethroughPosition', 'strikethrough-position'],
      ['strikethroughThickness', 'strikethrough-thickness'],
      ['strokeDasharray', 'stroke-dasharray'],
      ['strokeDashoffset', 'stroke-dashoffset'],
      ['strokeLinecap', 'stroke-linecap'],
      ['strokeLinejoin', 'stroke-linejoin'],
      ['strokeMiterlimit', 'stroke-miterlimit'],
      ['strokeOpacity', 'stroke-opacity'],
      ['strokeWidth', 'stroke-width'],
      ['textAnchor', 'text-anchor'],
      ['textDecoration', 'text-decoration'],
      ['textRendering', 'text-rendering'],
      ['transformOrigin', 'transform-origin'],
      ['underlinePosition', 'underline-position'],
      ['underlineThickness', 'underline-thickness'],
      ['unicodeBidi', 'unicode-bidi'],
      ['unicodeRange', 'unicode-range'],
      ['unitsPerEm', 'units-per-em'],
      ['vAlphabetic', 'v-alphabetic'],
      ['vHanging', 'v-hanging'],
      ['vIdeographic', 'v-ideographic'],
      ['vMathematical', 'v-mathematical'],
      ['vectorEffect', 'vector-effect'],
      ['vertAdvY', 'vert-adv-y'],
      ['vertOriginX', 'vert-origin-x'],
      ['vertOriginY', 'vert-origin-y'],
      ['wordSpacing', 'word-spacing'],
      ['writingMode', 'writing-mode'],
      ['xmlnsXlink', 'xmlns:xlink'],
      ['xHeight', 'x-height'],
    ]),
    Ns =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i
  function Ts(r) {
    return Ns.test('' + r)
      ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
      : r
  }
  var Ms = null
  function mo(r) {
    return (
      (r = r.target || r.srcElement || window),
      r.correspondingUseElement && (r = r.correspondingUseElement),
      r.nodeType === 3 ? r.parentNode : r
    )
  }
  var qr = null,
    Ra = null
  function Tl(r) {
    var a = Wr(r)
    if (a && (r = a.stateNode)) {
      var l = r[gn] || null
      t: switch (((r = a.stateNode), a.type)) {
        case 'input':
          if (
            (vo(
              r,
              l.value,
              l.defaultValue,
              l.defaultValue,
              l.checked,
              l.defaultChecked,
              l.type,
              l.name
            ),
            (a = l.name),
            l.type === 'radio' && a != null)
          ) {
            for (l = r; l.parentNode; ) l = l.parentNode
            for (
              l = l.querySelectorAll('input[name="' + Un('' + a) + '"][type="radio"]'), a = 0;
              a < l.length;
              a++
            ) {
              var f = l[a]
              if (f !== r && f.form === r.form) {
                var m = f[gn] || null
                if (!m) throw Error(i(90))
                vo(
                  f,
                  m.value,
                  m.defaultValue,
                  m.defaultValue,
                  m.checked,
                  m.defaultChecked,
                  m.type,
                  m.name
                )
              }
            }
            for (a = 0; a < l.length; a++) ((f = l[a]), f.form === r.form && hc(f))
          }
          break t
        case 'textarea':
          Nl(r, l.value, l.defaultValue)
          break t
        case 'select':
          ;((a = l.value), a != null && Rn(r, !!l.multiple, a, !1))
      }
    }
  }
  var Ml = !1
  function pc(r, a, l) {
    if (Ml) return r(a, l)
    Ml = !0
    try {
      var f = r(a)
      return f
    } finally {
      if (
        ((Ml = !1),
        (qr !== null || Ra !== null) &&
          (tf(), qr && ((a = qr), (r = Ra), (Ra = qr = null), Tl(a), r)))
      )
        for (a = 0; a < r.length; a++) Tl(r[a])
    }
  }
  function Qr(r, a) {
    var l = r.stateNode
    if (l === null) return null
    var f = l[gn] || null
    if (f === null) return null
    l = f[a]
    t: switch (a) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
      case 'onMouseEnter':
        ;((f = !f.disabled) ||
          ((r = r.type),
          (f = !(r === 'button' || r === 'input' || r === 'select' || r === 'textarea'))),
          (r = !f))
        break t
      default:
        r = !1
    }
    if (r) return null
    if (l && typeof l != 'function') throw Error(i(231, a, typeof l))
    return l
  }
  var pr = !(
      typeof window > 'u' ||
      typeof window.document > 'u' ||
      typeof window.document.createElement > 'u'
    ),
    El = !1
  if (pr)
    try {
      var Es = {}
      ;(Object.defineProperty(Es, 'passive', {
        get: function () {
          El = !0
        },
      }),
        window.addEventListener('test', Es, Es),
        window.removeEventListener('test', Es, Es))
    } catch {
      El = !1
    }
  var kr = null,
    Dl = null,
    yo = null
  function vc() {
    if (yo) return yo
    var r,
      a = Dl,
      l = a.length,
      f,
      m = 'value' in kr ? kr.value : kr.textContent,
      b = m.length
    for (r = 0; r < l && a[r] === m[r]; r++);
    var O = l - r
    for (f = 1; f <= O && a[l - f] === m[b - f]; f++);
    return (yo = m.slice(r, 1 < f ? 1 - f : void 0))
  }
  function Ds(r) {
    var a = r.keyCode
    return (
      'charCode' in r ? ((r = r.charCode), r === 0 && a === 13 && (r = 13)) : (r = a),
      r === 10 && (r = 13),
      32 <= r || r === 13 ? r : 0
    )
  }
  function ka() {
    return !0
  }
  function Ol() {
    return !1
  }
  function kn(r) {
    function a(l, f, m, b, O) {
      ;((this._reactName = l),
        (this._targetInst = m),
        (this.type = f),
        (this.nativeEvent = b),
        (this.target = O),
        (this.currentTarget = null))
      for (var j in r) r.hasOwnProperty(j) && ((l = r[j]), (this[j] = l ? l(b) : b[j]))
      return (
        (this.isDefaultPrevented = (
          b.defaultPrevented != null ? b.defaultPrevented : b.returnValue === !1
        )
          ? ka
          : Ol),
        (this.isPropagationStopped = Ol),
        this
      )
    }
    return (
      y(a.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0
          var l = this.nativeEvent
          l &&
            (l.preventDefault
              ? l.preventDefault()
              : typeof l.returnValue != 'unknown' && (l.returnValue = !1),
            (this.isDefaultPrevented = ka))
        },
        stopPropagation: function () {
          var l = this.nativeEvent
          l &&
            (l.stopPropagation
              ? l.stopPropagation()
              : typeof l.cancelBubble != 'unknown' && (l.cancelBubble = !0),
            (this.isPropagationStopped = ka))
        },
        persist: function () {},
        isPersistent: ka,
      }),
      a
    )
  }
  var _r = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (r) {
        return r.timeStamp || Date.now()
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    Os = kn(_r),
    Kr = y({}, _r, { view: 0, detail: 0 }),
    Wh = kn(Kr),
    Ll,
    zl,
    vr,
    Ls = y({}, Kr, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Dt,
      button: 0,
      buttons: 0,
      relatedTarget: function (r) {
        return r.relatedTarget === void 0
          ? r.fromElement === r.srcElement
            ? r.toElement
            : r.fromElement
          : r.relatedTarget
      },
      movementX: function (r) {
        return 'movementX' in r
          ? r.movementX
          : (r !== vr &&
              (vr && r.type === 'mousemove'
                ? ((Ll = r.screenX - vr.screenX), (zl = r.screenY - vr.screenY))
                : (zl = Ll = 0),
              (vr = r)),
            Ll)
      },
      movementY: function (r) {
        return 'movementY' in r ? r.movementY : zl
      },
    }),
    Ao = kn(Ls),
    Fh = y({}, Ls, { dataTransfer: 0 }),
    Jh = kn(Fh),
    qh = y({}, Kr, { relatedTarget: 0 }),
    d = kn(qh),
    A = y({}, _r, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    I = kn(A),
    x = y({}, _r, {
      clipboardData: function (r) {
        return 'clipboardData' in r ? r.clipboardData : window.clipboardData
      },
    }),
    D = kn(x),
    L = y({}, _r, { data: 0 }),
    k = kn(L),
    tt = {
      Esc: 'Escape',
      Spacebar: ' ',
      Left: 'ArrowLeft',
      Up: 'ArrowUp',
      Right: 'ArrowRight',
      Down: 'ArrowDown',
      Del: 'Delete',
      Win: 'OS',
      Menu: 'ContextMenu',
      Apps: 'ContextMenu',
      Scroll: 'ScrollLock',
      MozPrintableKey: 'Unidentified',
    },
    q = {
      8: 'Backspace',
      9: 'Tab',
      12: 'Clear',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Escape',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      45: 'Insert',
      46: 'Delete',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'NumLock',
      145: 'ScrollLock',
      224: 'Meta',
    },
    ot = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
  function xt(r) {
    var a = this.nativeEvent
    return a.getModifierState ? a.getModifierState(r) : (r = ot[r]) ? !!a[r] : !1
  }
  function Dt() {
    return xt
  }
  var vt = y({}, Kr, {
      key: function (r) {
        if (r.key) {
          var a = tt[r.key] || r.key
          if (a !== 'Unidentified') return a
        }
        return r.type === 'keypress'
          ? ((r = Ds(r)), r === 13 ? 'Enter' : String.fromCharCode(r))
          : r.type === 'keydown' || r.type === 'keyup'
            ? q[r.keyCode] || 'Unidentified'
            : ''
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Dt,
      charCode: function (r) {
        return r.type === 'keypress' ? Ds(r) : 0
      },
      keyCode: function (r) {
        return r.type === 'keydown' || r.type === 'keyup' ? r.keyCode : 0
      },
      which: function (r) {
        return r.type === 'keypress'
          ? Ds(r)
          : r.type === 'keydown' || r.type === 'keyup'
            ? r.keyCode
            : 0
      },
    }),
    _t = kn(vt),
    oe = y({}, Ls, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    Te = kn(oe),
    ge = y({}, Kr, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Dt,
    }),
    Sn = kn(ge),
    vn = y({}, _r, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Wi = kn(vn),
    Fi = y({}, Ls, {
      deltaX: function (r) {
        return 'deltaX' in r ? r.deltaX : 'wheelDeltaX' in r ? -r.wheelDeltaX : 0
      },
      deltaY: function (r) {
        return 'deltaY' in r
          ? r.deltaY
          : 'wheelDeltaY' in r
            ? -r.wheelDeltaY
            : 'wheelDelta' in r
              ? -r.wheelDelta
              : 0
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    Ce = kn(Fi),
    $r = y({}, _r, { newState: 0, oldState: 0 }),
    Oe = kn($r),
    nn = [9, 13, 27, 32],
    ta = pr && 'CompositionEvent' in window,
    ea = null
  pr && 'documentMode' in document && (ea = document.documentMode)
  var Ji = pr && 'TextEvent' in window && !ea,
    _a = pr && (!ta || (ea && 8 < ea && 11 >= ea)),
    Ti = ' ',
    mr = !1
  function yr(r, a) {
    switch (r) {
      case 'keyup':
        return nn.indexOf(a.keyCode) !== -1
      case 'keydown':
        return a.keyCode !== 229
      case 'keypress':
      case 'mousedown':
      case 'focusout':
        return !0
      default:
        return !1
    }
  }
  function ii(r) {
    return ((r = r.detail), typeof r == 'object' && 'data' in r ? r.data : null)
  }
  var Br = !1
  function Ar(r, a) {
    switch (r) {
      case 'compositionend':
        return ii(a)
      case 'keypress':
        return a.which !== 32 ? null : ((mr = !0), Ti)
      case 'textInput':
        return ((r = a.data), r === Ti && mr ? null : r)
      default:
        return null
    }
  }
  function br(r, a) {
    if (Br)
      return r === 'compositionend' || (!ta && yr(r, a))
        ? ((r = vc()), (yo = Dl = kr = null), (Br = !1), r)
        : null
    switch (r) {
      case 'paste':
        return null
      case 'keypress':
        if (!(a.ctrlKey || a.altKey || a.metaKey) || (a.ctrlKey && a.altKey)) {
          if (a.char && 1 < a.char.length) return a.char
          if (a.which) return String.fromCharCode(a.which)
        }
        return null
      case 'compositionend':
        return _a && a.locale !== 'ko' ? null : a.data
      default:
        return null
    }
  }
  var Qh = {
    color: !0,
    date: !0,
    datetime: !0,
    'datetime-local': !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  }
  function mc(r) {
    var a = r && r.nodeName && r.nodeName.toLowerCase()
    return a === 'input' ? !!Qh[r.type] : a === 'textarea'
  }
  function yc(r, a, l, f) {
    ;(qr ? (Ra ? Ra.push(f) : (Ra = [f])) : (qr = f),
      (a = of(a, 'onChange')),
      0 < a.length &&
        ((l = new Os('onChange', 'change', null, l, f)), r.push({ event: l, listeners: a })))
  }
  var Le = null,
    jr = null
  function Mi(r) {
    yA(r, 0)
  }
  function Ir(r) {
    var a = Is(r)
    if (hc(a)) return r
  }
  function Ac(r, a) {
    if (r === 'change') return a
  }
  var bc = !1
  if (pr) {
    var bo
    if (pr) {
      var Cr = 'oninput' in document
      if (!Cr) {
        var Io = document.createElement('div')
        ;(Io.setAttribute('oninput', 'return;'), (Cr = typeof Io.oninput == 'function'))
      }
      bo = Cr
    } else bo = !1
    bc = bo && (!document.documentMode || 9 < document.documentMode)
  }
  function wr() {
    Le && (Le.detachEvent('onpropertychange', Rl), (jr = Le = null))
  }
  function Rl(r) {
    if (r.propertyName === 'value' && Ir(jr)) {
      var a = []
      ;(yc(a, jr, r, mo(r)), pc(Mi, a))
    }
  }
  function zs(r, a, l) {
    r === 'focusin'
      ? (wr(), (Le = a), (jr = l), Le.attachEvent('onpropertychange', Rl))
      : r === 'focusout' && wr()
  }
  function Co(r) {
    if (r === 'selectionchange' || r === 'keyup' || r === 'keydown') return Ir(jr)
  }
  function wo(r, a) {
    if (r === 'click') return Ir(a)
  }
  function kl(r, a) {
    if (r === 'input' || r === 'change') return Ir(a)
  }
  function Kh(r, a) {
    return (r === a && (r !== 0 || 1 / r === 1 / a)) || (r !== r && a !== a)
  }
  var _n = typeof Object.is == 'function' ? Object.is : Kh
  function na(r, a) {
    if (_n(r, a)) return !0
    if (typeof r != 'object' || r === null || typeof a != 'object' || a === null) return !1
    var l = Object.keys(r),
      f = Object.keys(a)
    if (l.length !== f.length) return !1
    for (f = 0; f < l.length; f++) {
      var m = l[f]
      if (!de.call(a, m) || !_n(r[m], a[m])) return !1
    }
    return !0
  }
  function xo(r) {
    for (; r && r.firstChild; ) r = r.firstChild
    return r
  }
  function Ic(r, a) {
    var l = xo(r)
    r = 0
    for (var f; l; ) {
      if (l.nodeType === 3) {
        if (((f = r + l.textContent.length), r <= a && f >= a)) return { node: l, offset: a - r }
        r = f
      }
      t: {
        for (; l; ) {
          if (l.nextSibling) {
            l = l.nextSibling
            break t
          }
          l = l.parentNode
        }
        l = void 0
      }
      l = xo(l)
    }
  }
  function So(r, a) {
    return r && a
      ? r === a
        ? !0
        : r && r.nodeType === 3
          ? !1
          : a && a.nodeType === 3
            ? So(r, a.parentNode)
            : 'contains' in r
              ? r.contains(a)
              : r.compareDocumentPosition
                ? !!(r.compareDocumentPosition(a) & 16)
                : !1
      : !1
  }
  function _l(r) {
    r =
      r != null && r.ownerDocument != null && r.ownerDocument.defaultView != null
        ? r.ownerDocument.defaultView
        : window
    for (var a = Oa(r.document); a instanceof r.HTMLIFrameElement; ) {
      try {
        var l = typeof a.contentWindow.location.href == 'string'
      } catch {
        l = !1
      }
      if (l) r = a.contentWindow
      else break
      a = Oa(r.document)
    }
    return a
  }
  function V(r) {
    var a = r && r.nodeName && r.nodeName.toLowerCase()
    return (
      a &&
      ((a === 'input' &&
        (r.type === 'text' ||
          r.type === 'search' ||
          r.type === 'tel' ||
          r.type === 'url' ||
          r.type === 'password')) ||
        a === 'textarea' ||
        r.contentEditable === 'true')
    )
  }
  var rt = pr && 'documentMode' in document && 11 >= document.documentMode,
    dt = null,
    wt = null,
    Mt = null,
    jt = !1
  function Ht(r, a, l) {
    var f = l.window === l ? l.document : l.nodeType === 9 ? l : l.ownerDocument
    jt ||
      dt == null ||
      dt !== Oa(f) ||
      ((f = dt),
      'selectionStart' in f && V(f)
        ? (f = { start: f.selectionStart, end: f.selectionEnd })
        : ((f = ((f.ownerDocument && f.ownerDocument.defaultView) || window).getSelection()),
          (f = {
            anchorNode: f.anchorNode,
            anchorOffset: f.anchorOffset,
            focusNode: f.focusNode,
            focusOffset: f.focusOffset,
          })),
      (Mt && na(Mt, f)) ||
        ((Mt = f),
        (f = of(wt, 'onSelect')),
        0 < f.length &&
          ((a = new Os('onSelect', 'select', null, a, l)),
          r.push({ event: a, listeners: f }),
          (a.target = dt))))
  }
  function Vt(r, a) {
    var l = {}
    return (
      (l[r.toLowerCase()] = a.toLowerCase()),
      (l['Webkit' + r] = 'webkit' + a),
      (l['Moz' + r] = 'moz' + a),
      l
    )
  }
  var Zt = {
      animationend: Vt('Animation', 'AnimationEnd'),
      animationiteration: Vt('Animation', 'AnimationIteration'),
      animationstart: Vt('Animation', 'AnimationStart'),
      transitionrun: Vt('Transition', 'TransitionRun'),
      transitionstart: Vt('Transition', 'TransitionStart'),
      transitioncancel: Vt('Transition', 'TransitionCancel'),
      transitionend: Vt('Transition', 'TransitionEnd'),
    },
    pe = {},
    ne = {}
  pr &&
    ((ne = document.createElement('div').style),
    'AnimationEvent' in window ||
      (delete Zt.animationend.animation,
      delete Zt.animationiteration.animation,
      delete Zt.animationstart.animation),
    'TransitionEvent' in window || delete Zt.transitionend.transition)
  function ee(r) {
    if (pe[r]) return pe[r]
    if (!Zt[r]) return r
    var a = Zt[r],
      l
    for (l in a) if (a.hasOwnProperty(l) && l in ne) return (pe[r] = a[l])
    return r
  }
  var ye = ee('animationend'),
    te = ee('animationiteration'),
    He = ee('animationstart'),
    qn = ee('transitionrun'),
    Bn = ee('transitionstart'),
    di = ee('transitioncancel'),
    Ei = ee('transitionend'),
    ia = new Map(),
    Nn =
      'abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
        ' '
      )
  Nn.push('scrollEnd')
  function xr(r, a) {
    ;(ia.set(r, a), Xi(a, [r]))
  }
  var e0 = new WeakMap()
  function qi(r, a) {
    if (typeof r == 'object' && r !== null) {
      var l = e0.get(r)
      return l !== void 0 ? l : ((a = { value: r, source: a, stack: xl(a) }), e0.set(r, a), a)
    }
    return { value: r, source: a, stack: xl(a) }
  }
  var Qi = [],
    No = 0,
    $h = 0
  function Cc() {
    for (var r = No, a = ($h = No = 0); a < r; ) {
      var l = Qi[a]
      Qi[a++] = null
      var f = Qi[a]
      Qi[a++] = null
      var m = Qi[a]
      Qi[a++] = null
      var b = Qi[a]
      if (((Qi[a++] = null), f !== null && m !== null)) {
        var O = f.pending
        ;(O === null ? (m.next = m) : ((m.next = O.next), (O.next = m)), (f.pending = m))
      }
      b !== 0 && n0(l, m, b)
    }
  }
  function wc(r, a, l, f) {
    ;((Qi[No++] = r),
      (Qi[No++] = a),
      (Qi[No++] = l),
      (Qi[No++] = f),
      ($h |= f),
      (r.lanes |= f),
      (r = r.alternate),
      r !== null && (r.lanes |= f))
  }
  function td(r, a, l, f) {
    return (wc(r, a, l, f), xc(r))
  }
  function To(r, a) {
    return (wc(r, null, null, a), xc(r))
  }
  function n0(r, a, l) {
    r.lanes |= l
    var f = r.alternate
    f !== null && (f.lanes |= l)
    for (var m = !1, b = r.return; b !== null; )
      ((b.childLanes |= l),
        (f = b.alternate),
        f !== null && (f.childLanes |= l),
        b.tag === 22 && ((r = b.stateNode), r === null || r._visibility & 1 || (m = !0)),
        (r = b),
        (b = b.return))
    return r.tag === 3
      ? ((b = r.stateNode),
        m &&
          a !== null &&
          ((m = 31 - Ne(l)),
          (r = b.hiddenUpdates),
          (f = r[m]),
          f === null ? (r[m] = [a]) : f.push(a),
          (a.lane = l | 536870912)),
        b)
      : null
  }
  function xc(r) {
    if (50 < ou) throw ((ou = 0), (sg = null), Error(i(185)))
    for (var a = r.return; a !== null; ) ((r = a), (a = r.return))
    return r.tag === 3 ? r.stateNode : null
  }
  var Mo = {}
  function XS(r, a, l, f) {
    ;((this.tag = r),
      (this.key = l),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.refCleanup = this.ref = null),
      (this.pendingProps = a),
      (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
      (this.mode = f),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null))
  }
  function Di(r, a, l, f) {
    return new XS(r, a, l, f)
  }
  function ed(r) {
    return ((r = r.prototype), !(!r || !r.isReactComponent))
  }
  function ra(r, a) {
    var l = r.alternate
    return (
      l === null
        ? ((l = Di(r.tag, a, r.key, r.mode)),
          (l.elementType = r.elementType),
          (l.type = r.type),
          (l.stateNode = r.stateNode),
          (l.alternate = r),
          (r.alternate = l))
        : ((l.pendingProps = a),
          (l.type = r.type),
          (l.flags = 0),
          (l.subtreeFlags = 0),
          (l.deletions = null)),
      (l.flags = r.flags & 65011712),
      (l.childLanes = r.childLanes),
      (l.lanes = r.lanes),
      (l.child = r.child),
      (l.memoizedProps = r.memoizedProps),
      (l.memoizedState = r.memoizedState),
      (l.updateQueue = r.updateQueue),
      (a = r.dependencies),
      (l.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }),
      (l.sibling = r.sibling),
      (l.index = r.index),
      (l.ref = r.ref),
      (l.refCleanup = r.refCleanup),
      l
    )
  }
  function i0(r, a) {
    r.flags &= 65011714
    var l = r.alternate
    return (
      l === null
        ? ((r.childLanes = 0),
          (r.lanes = a),
          (r.child = null),
          (r.subtreeFlags = 0),
          (r.memoizedProps = null),
          (r.memoizedState = null),
          (r.updateQueue = null),
          (r.dependencies = null),
          (r.stateNode = null))
        : ((r.childLanes = l.childLanes),
          (r.lanes = l.lanes),
          (r.child = l.child),
          (r.subtreeFlags = 0),
          (r.deletions = null),
          (r.memoizedProps = l.memoizedProps),
          (r.memoizedState = l.memoizedState),
          (r.updateQueue = l.updateQueue),
          (r.type = l.type),
          (a = l.dependencies),
          (r.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext })),
      r
    )
  }
  function Sc(r, a, l, f, m, b) {
    var O = 0
    if (((f = r), typeof r == 'function')) ed(r) && (O = 1)
    else if (typeof r == 'string')
      O = FN(r, l, bt.current) ? 26 : r === 'html' || r === 'head' || r === 'body' ? 27 : 5
    else
      t: switch (r) {
        case M:
          return ((r = Di(31, l, a, m)), (r.elementType = M), (r.lanes = b), r)
        case N:
          return Rs(l.children, m, b, a)
        case T:
          ;((O = 8), (m |= 24))
          break
        case z:
          return ((r = Di(12, l, a, m | 2)), (r.elementType = z), (r.lanes = b), r)
        case U:
          return ((r = Di(13, l, a, m)), (r.elementType = U), (r.lanes = b), r)
        case nt:
          return ((r = Di(19, l, a, m)), (r.elementType = nt), (r.lanes = b), r)
        default:
          if (typeof r == 'object' && r !== null)
            switch (r.$$typeof) {
              case R:
              case H:
                O = 10
                break t
              case B:
                O = 9
                break t
              case Z:
                O = 11
                break t
              case g:
                O = 14
                break t
              case S:
                ;((O = 16), (f = null))
                break t
            }
          ;((O = 29), (l = Error(i(130, r === null ? 'null' : typeof r, ''))), (f = null))
      }
    return ((a = Di(O, l, a, m)), (a.elementType = r), (a.type = f), (a.lanes = b), a)
  }
  function Rs(r, a, l, f) {
    return ((r = Di(7, r, f, a)), (r.lanes = l), r)
  }
  function nd(r, a, l) {
    return ((r = Di(6, r, null, a)), (r.lanes = l), r)
  }
  function id(r, a, l) {
    return (
      (a = Di(4, r.children !== null ? r.children : [], r.key, a)),
      (a.lanes = l),
      (a.stateNode = {
        containerInfo: r.containerInfo,
        pendingChildren: null,
        implementation: r.implementation,
      }),
      a
    )
  }
  var Eo = [],
    Do = 0,
    Nc = null,
    Tc = 0,
    Ki = [],
    $i = 0,
    ks = null,
    aa = 1,
    sa = ''
  function _s(r, a) {
    ;((Eo[Do++] = Tc), (Eo[Do++] = Nc), (Nc = r), (Tc = a))
  }
  function r0(r, a, l) {
    ;((Ki[$i++] = aa), (Ki[$i++] = sa), (Ki[$i++] = ks), (ks = r))
    var f = aa
    r = sa
    var m = 32 - Ne(f) - 1
    ;((f &= ~(1 << m)), (l += 1))
    var b = 32 - Ne(a) + m
    if (30 < b) {
      var O = m - (m % 5)
      ;((b = (f & ((1 << O) - 1)).toString(32)),
        (f >>= O),
        (m -= O),
        (aa = (1 << (32 - Ne(a) + m)) | (l << m) | f),
        (sa = b + r))
    } else ((aa = (1 << b) | (l << m) | f), (sa = r))
  }
  function rd(r) {
    r.return !== null && (_s(r, 1), r0(r, 1, 0))
  }
  function ad(r) {
    for (; r === Nc; ) ((Nc = Eo[--Do]), (Eo[Do] = null), (Tc = Eo[--Do]), (Eo[Do] = null))
    for (; r === ks; )
      ((ks = Ki[--$i]),
        (Ki[$i] = null),
        (sa = Ki[--$i]),
        (Ki[$i] = null),
        (aa = Ki[--$i]),
        (Ki[$i] = null))
  }
  var ri = null,
    un = null,
    je = !1,
    Bs = null,
    Pr = !1,
    sd = Error(i(519))
  function js(r) {
    var a = Error(i(418, ''))
    throw (Pl(qi(a, r)), sd)
  }
  function a0(r) {
    var a = r.stateNode,
      l = r.type,
      f = r.memoizedProps
    switch (((a[sn] = r), (a[gn] = f), l)) {
      case 'dialog':
        ;(Ee('cancel', a), Ee('close', a))
        break
      case 'iframe':
      case 'object':
      case 'embed':
        Ee('load', a)
        break
      case 'video':
      case 'audio':
        for (l = 0; l < uu.length; l++) Ee(uu[l], a)
        break
      case 'source':
        Ee('error', a)
        break
      case 'img':
      case 'image':
      case 'link':
        ;(Ee('error', a), Ee('load', a))
        break
      case 'details':
        Ee('toggle', a)
        break
      case 'input':
        ;(Ee('invalid', a),
          gc(a, f.value, f.defaultValue, f.checked, f.defaultChecked, f.type, f.name, !0),
          po(a))
        break
      case 'select':
        Ee('invalid', a)
        break
      case 'textarea':
        ;(Ee('invalid', a), La(a, f.value, f.defaultValue, f.children), po(a))
    }
    ;((l = f.children),
      (typeof l != 'string' && typeof l != 'number' && typeof l != 'bigint') ||
      a.textContent === '' + l ||
      f.suppressHydrationWarning === !0 ||
      CA(a.textContent, l)
        ? (f.popover != null && (Ee('beforetoggle', a), Ee('toggle', a)),
          f.onScroll != null && Ee('scroll', a),
          f.onScrollEnd != null && Ee('scrollend', a),
          f.onClick != null && (a.onclick = lf),
          (a = !0))
        : (a = !1),
      a || js(r))
  }
  function s0(r) {
    for (ri = r.return; ri; )
      switch (ri.tag) {
        case 5:
        case 13:
          Pr = !1
          return
        case 27:
        case 3:
          Pr = !0
          return
        default:
          ri = ri.return
      }
  }
  function Bl(r) {
    if (r !== ri) return !1
    if (!je) return (s0(r), (je = !0), !1)
    var a = r.tag,
      l
    if (
      ((l = a !== 3 && a !== 27) &&
        ((l = a === 5) &&
          ((l = r.type), (l = !(l !== 'form' && l !== 'button') || Cg(r.type, r.memoizedProps))),
        (l = !l)),
      l && un && js(r),
      s0(r),
      a === 13)
    ) {
      if (((r = r.memoizedState), (r = r !== null ? r.dehydrated : null), !r)) throw Error(i(317))
      t: {
        for (r = r.nextSibling, a = 0; r; ) {
          if (r.nodeType === 8)
            if (((l = r.data), l === '/$')) {
              if (a === 0) {
                un = Nr(r.nextSibling)
                break t
              }
              a--
            } else (l !== '$' && l !== '$!' && l !== '$?') || a++
          r = r.nextSibling
        }
        un = null
      }
    } else
      a === 27
        ? ((a = un), Ka(r.type) ? ((r = Ng), (Ng = null), (un = r)) : (un = a))
        : (un = ri ? Nr(r.stateNode.nextSibling) : null)
    return !0
  }
  function jl() {
    ;((un = ri = null), (je = !1))
  }
  function o0() {
    var r = Bs
    return (r !== null && (vi === null ? (vi = r) : vi.push.apply(vi, r), (Bs = null)), r)
  }
  function Pl(r) {
    Bs === null ? (Bs = [r]) : Bs.push(r)
  }
  var od = ht(null),
    Ps = null,
    oa = null
  function Ba(r, a, l) {
    ;(St(od, a._currentValue), (a._currentValue = l))
  }
  function la(r) {
    ;((r._currentValue = od.current), ct(od))
  }
  function ld(r, a, l) {
    for (; r !== null; ) {
      var f = r.alternate
      if (
        ((r.childLanes & a) !== a
          ? ((r.childLanes |= a), f !== null && (f.childLanes |= a))
          : f !== null && (f.childLanes & a) !== a && (f.childLanes |= a),
        r === l)
      )
        break
      r = r.return
    }
  }
  function ud(r, a, l, f) {
    var m = r.child
    for (m !== null && (m.return = r); m !== null; ) {
      var b = m.dependencies
      if (b !== null) {
        var O = m.child
        b = b.firstContext
        t: for (; b !== null; ) {
          var j = b
          b = m
          for (var K = 0; K < a.length; K++)
            if (j.context === a[K]) {
              ;((b.lanes |= l),
                (j = b.alternate),
                j !== null && (j.lanes |= l),
                ld(b.return, l, r),
                f || (O = null))
              break t
            }
          b = j.next
        }
      } else if (m.tag === 18) {
        if (((O = m.return), O === null)) throw Error(i(341))
        ;((O.lanes |= l), (b = O.alternate), b !== null && (b.lanes |= l), ld(O, l, r), (O = null))
      } else O = m.child
      if (O !== null) O.return = m
      else
        for (O = m; O !== null; ) {
          if (O === r) {
            O = null
            break
          }
          if (((m = O.sibling), m !== null)) {
            ;((m.return = O.return), (O = m))
            break
          }
          O = O.return
        }
      m = O
    }
  }
  function Gl(r, a, l, f) {
    r = null
    for (var m = a, b = !1; m !== null; ) {
      if (!b) {
        if ((m.flags & 524288) !== 0) b = !0
        else if ((m.flags & 262144) !== 0) break
      }
      if (m.tag === 10) {
        var O = m.alternate
        if (O === null) throw Error(i(387))
        if (((O = O.memoizedProps), O !== null)) {
          var j = m.type
          _n(m.pendingProps.value, O.value) || (r !== null ? r.push(j) : (r = [j]))
        }
      } else if (m === gt.current) {
        if (((O = m.alternate), O === null)) throw Error(i(387))
        O.memoizedState.memoizedState !== m.memoizedState.memoizedState &&
          (r !== null ? r.push(pu) : (r = [pu]))
      }
      m = m.return
    }
    ;(r !== null && ud(a, r, l, f), (a.flags |= 262144))
  }
  function Mc(r) {
    for (r = r.firstContext; r !== null; ) {
      if (!_n(r.context._currentValue, r.memoizedValue)) return !0
      r = r.next
    }
    return !1
  }
  function Gs(r) {
    ;((Ps = r), (oa = null), (r = r.dependencies), r !== null && (r.firstContext = null))
  }
  function Qn(r) {
    return l0(Ps, r)
  }
  function Ec(r, a) {
    return (Ps === null && Gs(r), l0(r, a))
  }
  function l0(r, a) {
    var l = a._currentValue
    if (((a = { context: a, memoizedValue: l, next: null }), oa === null)) {
      if (r === null) throw Error(i(308))
      ;((oa = a), (r.dependencies = { lanes: 0, firstContext: a }), (r.flags |= 524288))
    } else oa = oa.next = a
    return l
  }
  var WS =
      typeof AbortController < 'u'
        ? AbortController
        : function () {
            var r = [],
              a = (this.signal = {
                aborted: !1,
                addEventListener: function (l, f) {
                  r.push(f)
                },
              })
            this.abort = function () {
              ;((a.aborted = !0),
                r.forEach(function (l) {
                  return l()
                }))
            }
          },
    FS = t.unstable_scheduleCallback,
    JS = t.unstable_NormalPriority,
    Tn = {
      $$typeof: H,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
    }
  function cd() {
    return { controller: new WS(), data: new Map(), refCount: 0 }
  }
  function Zl(r) {
    ;(r.refCount--,
      r.refCount === 0 &&
        FS(JS, function () {
          r.controller.abort()
        }))
  }
  var Ul = null,
    fd = 0,
    Oo = 0,
    Lo = null
  function qS(r, a) {
    if (Ul === null) {
      var l = (Ul = [])
      ;((fd = 0),
        (Oo = dg()),
        (Lo = {
          status: 'pending',
          value: void 0,
          then: function (f) {
            l.push(f)
          },
        }))
    }
    return (fd++, a.then(u0, u0), a)
  }
  function u0() {
    if (--fd === 0 && Ul !== null) {
      Lo !== null && (Lo.status = 'fulfilled')
      var r = Ul
      ;((Ul = null), (Oo = 0), (Lo = null))
      for (var a = 0; a < r.length; a++) (0, r[a])()
    }
  }
  function QS(r, a) {
    var l = [],
      f = {
        status: 'pending',
        value: null,
        reason: null,
        then: function (m) {
          l.push(m)
        },
      }
    return (
      r.then(
        function () {
          ;((f.status = 'fulfilled'), (f.value = a))
          for (var m = 0; m < l.length; m++) (0, l[m])(a)
        },
        function (m) {
          for (f.status = 'rejected', f.reason = m, m = 0; m < l.length; m++) (0, l[m])(void 0)
        }
      ),
      f
    )
  }
  var c0 = G.S
  G.S = function (r, a) {
    ;(typeof a == 'object' && a !== null && typeof a.then == 'function' && qS(r, a),
      c0 !== null && c0(r, a))
  }
  var Zs = ht(null)
  function hd() {
    var r = Zs.current
    return r !== null ? r : tn.pooledCache
  }
  function Dc(r, a) {
    a === null ? St(Zs, Zs.current) : St(Zs, a.pool)
  }
  function f0() {
    var r = hd()
    return r === null ? null : { parent: Tn._currentValue, pool: r }
  }
  var Yl = Error(i(460)),
    h0 = Error(i(474)),
    Oc = Error(i(542)),
    dd = { then: function () {} }
  function d0(r) {
    return ((r = r.status), r === 'fulfilled' || r === 'rejected')
  }
  function Lc() {}
  function g0(r, a, l) {
    switch (
      ((l = r[l]), l === void 0 ? r.push(a) : l !== a && (a.then(Lc, Lc), (a = l)), a.status)
    ) {
      case 'fulfilled':
        return a.value
      case 'rejected':
        throw ((r = a.reason), v0(r), r)
      default:
        if (typeof a.status == 'string') a.then(Lc, Lc)
        else {
          if (((r = tn), r !== null && 100 < r.shellSuspendCounter)) throw Error(i(482))
          ;((r = a),
            (r.status = 'pending'),
            r.then(
              function (f) {
                if (a.status === 'pending') {
                  var m = a
                  ;((m.status = 'fulfilled'), (m.value = f))
                }
              },
              function (f) {
                if (a.status === 'pending') {
                  var m = a
                  ;((m.status = 'rejected'), (m.reason = f))
                }
              }
            ))
        }
        switch (a.status) {
          case 'fulfilled':
            return a.value
          case 'rejected':
            throw ((r = a.reason), v0(r), r)
        }
        throw ((Hl = a), Yl)
    }
  }
  var Hl = null
  function p0() {
    if (Hl === null) throw Error(i(459))
    var r = Hl
    return ((Hl = null), r)
  }
  function v0(r) {
    if (r === Yl || r === Oc) throw Error(i(483))
  }
  var ja = !1
  function gd(r) {
    r.updateQueue = {
      baseState: r.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null,
    }
  }
  function pd(r, a) {
    ;((r = r.updateQueue),
      a.updateQueue === r &&
        (a.updateQueue = {
          baseState: r.baseState,
          firstBaseUpdate: r.firstBaseUpdate,
          lastBaseUpdate: r.lastBaseUpdate,
          shared: r.shared,
          callbacks: null,
        }))
  }
  function Pa(r) {
    return { lane: r, tag: 0, payload: null, callback: null, next: null }
  }
  function Ga(r, a, l) {
    var f = r.updateQueue
    if (f === null) return null
    if (((f = f.shared), (Ve & 2) !== 0)) {
      var m = f.pending
      return (
        m === null ? (a.next = a) : ((a.next = m.next), (m.next = a)),
        (f.pending = a),
        (a = xc(r)),
        n0(r, null, l),
        a
      )
    }
    return (wc(r, f, a, l), xc(r))
  }
  function Vl(r, a, l) {
    if (((a = a.updateQueue), a !== null && ((a = a.shared), (l & 4194048) !== 0))) {
      var f = a.lanes
      ;((f &= r.pendingLanes), (l |= f), (a.lanes = l), en(r, l))
    }
  }
  function vd(r, a) {
    var l = r.updateQueue,
      f = r.alternate
    if (f !== null && ((f = f.updateQueue), l === f)) {
      var m = null,
        b = null
      if (((l = l.firstBaseUpdate), l !== null)) {
        do {
          var O = { lane: l.lane, tag: l.tag, payload: l.payload, callback: null, next: null }
          ;(b === null ? (m = b = O) : (b = b.next = O), (l = l.next))
        } while (l !== null)
        b === null ? (m = b = a) : (b = b.next = a)
      } else m = b = a
      ;((l = {
        baseState: f.baseState,
        firstBaseUpdate: m,
        lastBaseUpdate: b,
        shared: f.shared,
        callbacks: f.callbacks,
      }),
        (r.updateQueue = l))
      return
    }
    ;((r = l.lastBaseUpdate),
      r === null ? (l.firstBaseUpdate = a) : (r.next = a),
      (l.lastBaseUpdate = a))
  }
  var md = !1
  function Xl() {
    if (md) {
      var r = Lo
      if (r !== null) throw r
    }
  }
  function Wl(r, a, l, f) {
    md = !1
    var m = r.updateQueue
    ja = !1
    var b = m.firstBaseUpdate,
      O = m.lastBaseUpdate,
      j = m.shared.pending
    if (j !== null) {
      m.shared.pending = null
      var K = j,
        pt = K.next
      ;((K.next = null), O === null ? (b = pt) : (O.next = pt), (O = K))
      var Ot = r.alternate
      Ot !== null &&
        ((Ot = Ot.updateQueue),
        (j = Ot.lastBaseUpdate),
        j !== O &&
          (j === null ? (Ot.firstBaseUpdate = pt) : (j.next = pt), (Ot.lastBaseUpdate = K)))
    }
    if (b !== null) {
      var zt = m.baseState
      ;((O = 0), (Ot = pt = K = null), (j = b))
      do {
        var mt = j.lane & -536870913,
          It = mt !== j.lane
        if (It ? (Re & mt) === mt : (f & mt) === mt) {
          ;(mt !== 0 && mt === Oo && (md = !0),
            Ot !== null &&
              (Ot = Ot.next =
                { lane: 0, tag: j.tag, payload: j.payload, callback: null, next: null }))
          t: {
            var le = r,
              ie = j
            mt = a
            var Je = l
            switch (ie.tag) {
              case 1:
                if (((le = ie.payload), typeof le == 'function')) {
                  zt = le.call(Je, zt, mt)
                  break t
                }
                zt = le
                break t
              case 3:
                le.flags = (le.flags & -65537) | 128
              case 0:
                if (
                  ((le = ie.payload),
                  (mt = typeof le == 'function' ? le.call(Je, zt, mt) : le),
                  mt == null)
                )
                  break t
                zt = y({}, zt, mt)
                break t
              case 2:
                ja = !0
            }
          }
          ;((mt = j.callback),
            mt !== null &&
              ((r.flags |= 64),
              It && (r.flags |= 8192),
              (It = m.callbacks),
              It === null ? (m.callbacks = [mt]) : It.push(mt)))
        } else
          ((It = { lane: mt, tag: j.tag, payload: j.payload, callback: j.callback, next: null }),
            Ot === null ? ((pt = Ot = It), (K = zt)) : (Ot = Ot.next = It),
            (O |= mt))
        if (((j = j.next), j === null)) {
          if (((j = m.shared.pending), j === null)) break
          ;((It = j),
            (j = It.next),
            (It.next = null),
            (m.lastBaseUpdate = It),
            (m.shared.pending = null))
        }
      } while (!0)
      ;(Ot === null && (K = zt),
        (m.baseState = K),
        (m.firstBaseUpdate = pt),
        (m.lastBaseUpdate = Ot),
        b === null && (m.shared.lanes = 0),
        (Fa |= O),
        (r.lanes = O),
        (r.memoizedState = zt))
    }
  }
  function m0(r, a) {
    if (typeof r != 'function') throw Error(i(191, r))
    r.call(a)
  }
  function y0(r, a) {
    var l = r.callbacks
    if (l !== null) for (r.callbacks = null, r = 0; r < l.length; r++) m0(l[r], a)
  }
  var zo = ht(null),
    zc = ht(0)
  function A0(r, a) {
    ;((r = pa), St(zc, r), St(zo, a), (pa = r | a.baseLanes))
  }
  function yd() {
    ;(St(zc, pa), St(zo, zo.current))
  }
  function Ad() {
    ;((pa = zc.current), ct(zo), ct(zc))
  }
  var Za = 0,
    be = null,
    We = null,
    In = null,
    Rc = !1,
    Ro = !1,
    Us = !1,
    kc = 0,
    Fl = 0,
    ko = null,
    KS = 0
  function mn() {
    throw Error(i(321))
  }
  function bd(r, a) {
    if (a === null) return !1
    for (var l = 0; l < a.length && l < r.length; l++) if (!_n(r[l], a[l])) return !1
    return !0
  }
  function Id(r, a, l, f, m, b) {
    return (
      (Za = b),
      (be = a),
      (a.memoizedState = null),
      (a.updateQueue = null),
      (a.lanes = 0),
      (G.H = r === null || r.memoizedState === null ? ny : iy),
      (Us = !1),
      (b = l(f, m)),
      (Us = !1),
      Ro && (b = I0(a, l, f, m)),
      b0(r),
      b
    )
  }
  function b0(r) {
    G.H = Zc
    var a = We !== null && We.next !== null
    if (((Za = 0), (In = We = be = null), (Rc = !1), (Fl = 0), (ko = null), a)) throw Error(i(300))
    r === null || jn || ((r = r.dependencies), r !== null && Mc(r) && (jn = !0))
  }
  function I0(r, a, l, f) {
    be = r
    var m = 0
    do {
      if ((Ro && (ko = null), (Fl = 0), (Ro = !1), 25 <= m)) throw Error(i(301))
      if (((m += 1), (In = We = null), r.updateQueue != null)) {
        var b = r.updateQueue
        ;((b.lastEffect = null),
          (b.events = null),
          (b.stores = null),
          b.memoCache != null && (b.memoCache.index = 0))
      }
      ;((G.H = aN), (b = a(l, f)))
    } while (Ro)
    return b
  }
  function $S() {
    var r = G.H,
      a = r.useState()[0]
    return (
      (a = typeof a.then == 'function' ? Jl(a) : a),
      (r = r.useState()[0]),
      (We !== null ? We.memoizedState : null) !== r && (be.flags |= 1024),
      a
    )
  }
  function Cd() {
    var r = kc !== 0
    return ((kc = 0), r)
  }
  function wd(r, a, l) {
    ;((a.updateQueue = r.updateQueue), (a.flags &= -2053), (r.lanes &= ~l))
  }
  function xd(r) {
    if (Rc) {
      for (r = r.memoizedState; r !== null; ) {
        var a = r.queue
        ;(a !== null && (a.pending = null), (r = r.next))
      }
      Rc = !1
    }
    ;((Za = 0), (In = We = be = null), (Ro = !1), (Fl = kc = 0), (ko = null))
  }
  function gi() {
    var r = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
    return (In === null ? (be.memoizedState = In = r) : (In = In.next = r), In)
  }
  function Cn() {
    if (We === null) {
      var r = be.alternate
      r = r !== null ? r.memoizedState : null
    } else r = We.next
    var a = In === null ? be.memoizedState : In.next
    if (a !== null) ((In = a), (We = r))
    else {
      if (r === null) throw be.alternate === null ? Error(i(467)) : Error(i(310))
      ;((We = r),
        (r = {
          memoizedState: We.memoizedState,
          baseState: We.baseState,
          baseQueue: We.baseQueue,
          queue: We.queue,
          next: null,
        }),
        In === null ? (be.memoizedState = In = r) : (In = In.next = r))
    }
    return In
  }
  function Sd() {
    return { lastEffect: null, events: null, stores: null, memoCache: null }
  }
  function Jl(r) {
    var a = Fl
    return (
      (Fl += 1),
      ko === null && (ko = []),
      (r = g0(ko, r, a)),
      (a = be),
      (In === null ? a.memoizedState : In.next) === null &&
        ((a = a.alternate), (G.H = a === null || a.memoizedState === null ? ny : iy)),
      r
    )
  }
  function _c(r) {
    if (r !== null && typeof r == 'object') {
      if (typeof r.then == 'function') return Jl(r)
      if (r.$$typeof === H) return Qn(r)
    }
    throw Error(i(438, String(r)))
  }
  function Nd(r) {
    var a = null,
      l = be.updateQueue
    if ((l !== null && (a = l.memoCache), a == null)) {
      var f = be.alternate
      f !== null &&
        ((f = f.updateQueue),
        f !== null &&
          ((f = f.memoCache),
          f != null &&
            (a = {
              data: f.data.map(function (m) {
                return m.slice()
              }),
              index: 0,
            })))
    }
    if (
      (a == null && (a = { data: [], index: 0 }),
      l === null && ((l = Sd()), (be.updateQueue = l)),
      (l.memoCache = a),
      (l = a.data[a.index]),
      l === void 0)
    )
      for (l = a.data[a.index] = Array(r), f = 0; f < r; f++) l[f] = _
    return (a.index++, l)
  }
  function ua(r, a) {
    return typeof a == 'function' ? a(r) : a
  }
  function Bc(r) {
    var a = Cn()
    return Td(a, We, r)
  }
  function Td(r, a, l) {
    var f = r.queue
    if (f === null) throw Error(i(311))
    f.lastRenderedReducer = l
    var m = r.baseQueue,
      b = f.pending
    if (b !== null) {
      if (m !== null) {
        var O = m.next
        ;((m.next = b.next), (b.next = O))
      }
      ;((a.baseQueue = m = b), (f.pending = null))
    }
    if (((b = r.baseState), m === null)) r.memoizedState = b
    else {
      a = m.next
      var j = (O = null),
        K = null,
        pt = a,
        Ot = !1
      do {
        var zt = pt.lane & -536870913
        if (zt !== pt.lane ? (Re & zt) === zt : (Za & zt) === zt) {
          var mt = pt.revertLane
          if (mt === 0)
            (K !== null &&
              (K = K.next =
                {
                  lane: 0,
                  revertLane: 0,
                  action: pt.action,
                  hasEagerState: pt.hasEagerState,
                  eagerState: pt.eagerState,
                  next: null,
                }),
              zt === Oo && (Ot = !0))
          else if ((Za & mt) === mt) {
            ;((pt = pt.next), mt === Oo && (Ot = !0))
            continue
          } else
            ((zt = {
              lane: 0,
              revertLane: pt.revertLane,
              action: pt.action,
              hasEagerState: pt.hasEagerState,
              eagerState: pt.eagerState,
              next: null,
            }),
              K === null ? ((j = K = zt), (O = b)) : (K = K.next = zt),
              (be.lanes |= mt),
              (Fa |= mt))
          ;((zt = pt.action), Us && l(b, zt), (b = pt.hasEagerState ? pt.eagerState : l(b, zt)))
        } else
          ((mt = {
            lane: zt,
            revertLane: pt.revertLane,
            action: pt.action,
            hasEagerState: pt.hasEagerState,
            eagerState: pt.eagerState,
            next: null,
          }),
            K === null ? ((j = K = mt), (O = b)) : (K = K.next = mt),
            (be.lanes |= zt),
            (Fa |= zt))
        pt = pt.next
      } while (pt !== null && pt !== a)
      if (
        (K === null ? (O = b) : (K.next = j),
        !_n(b, r.memoizedState) && ((jn = !0), Ot && ((l = Lo), l !== null)))
      )
        throw l
      ;((r.memoizedState = b), (r.baseState = O), (r.baseQueue = K), (f.lastRenderedState = b))
    }
    return (m === null && (f.lanes = 0), [r.memoizedState, f.dispatch])
  }
  function Md(r) {
    var a = Cn(),
      l = a.queue
    if (l === null) throw Error(i(311))
    l.lastRenderedReducer = r
    var f = l.dispatch,
      m = l.pending,
      b = a.memoizedState
    if (m !== null) {
      l.pending = null
      var O = (m = m.next)
      do ((b = r(b, O.action)), (O = O.next))
      while (O !== m)
      ;(_n(b, a.memoizedState) || (jn = !0),
        (a.memoizedState = b),
        a.baseQueue === null && (a.baseState = b),
        (l.lastRenderedState = b))
    }
    return [b, f]
  }
  function C0(r, a, l) {
    var f = be,
      m = Cn(),
      b = je
    if (b) {
      if (l === void 0) throw Error(i(407))
      l = l()
    } else l = a()
    var O = !_n((We || m).memoizedState, l)
    ;(O && ((m.memoizedState = l), (jn = !0)), (m = m.queue))
    var j = S0.bind(null, f, m, r)
    if (
      (ql(2048, 8, j, [r]), m.getSnapshot !== a || O || (In !== null && In.memoizedState.tag & 1))
    ) {
      if (((f.flags |= 2048), _o(9, jc(), x0.bind(null, f, m, l, a), null), tn === null))
        throw Error(i(349))
      b || (Za & 124) !== 0 || w0(f, a, l)
    }
    return l
  }
  function w0(r, a, l) {
    ;((r.flags |= 16384),
      (r = { getSnapshot: a, value: l }),
      (a = be.updateQueue),
      a === null
        ? ((a = Sd()), (be.updateQueue = a), (a.stores = [r]))
        : ((l = a.stores), l === null ? (a.stores = [r]) : l.push(r)))
  }
  function x0(r, a, l, f) {
    ;((a.value = l), (a.getSnapshot = f), N0(a) && T0(r))
  }
  function S0(r, a, l) {
    return l(function () {
      N0(a) && T0(r)
    })
  }
  function N0(r) {
    var a = r.getSnapshot
    r = r.value
    try {
      var l = a()
      return !_n(r, l)
    } catch {
      return !0
    }
  }
  function T0(r) {
    var a = To(r, 2)
    a !== null && ki(a, r, 2)
  }
  function Ed(r) {
    var a = gi()
    if (typeof r == 'function') {
      var l = r
      if (((r = l()), Us)) {
        Fn(!0)
        try {
          l()
        } finally {
          Fn(!1)
        }
      }
    }
    return (
      (a.memoizedState = a.baseState = r),
      (a.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ua,
        lastRenderedState: r,
      }),
      a
    )
  }
  function M0(r, a, l, f) {
    return ((r.baseState = l), Td(r, We, typeof f == 'function' ? f : ua))
  }
  function tN(r, a, l, f, m) {
    if (Gc(r)) throw Error(i(485))
    if (((r = a.action), r !== null)) {
      var b = {
        payload: m,
        action: r,
        next: null,
        isTransition: !0,
        status: 'pending',
        value: null,
        reason: null,
        listeners: [],
        then: function (O) {
          b.listeners.push(O)
        },
      }
      ;(G.T !== null ? l(!0) : (b.isTransition = !1),
        f(b),
        (l = a.pending),
        l === null
          ? ((b.next = a.pending = b), E0(a, b))
          : ((b.next = l.next), (a.pending = l.next = b)))
    }
  }
  function E0(r, a) {
    var l = a.action,
      f = a.payload,
      m = r.state
    if (a.isTransition) {
      var b = G.T,
        O = {}
      G.T = O
      try {
        var j = l(m, f),
          K = G.S
        ;(K !== null && K(O, j), D0(r, a, j))
      } catch (pt) {
        Dd(r, a, pt)
      } finally {
        G.T = b
      }
    } else
      try {
        ;((b = l(m, f)), D0(r, a, b))
      } catch (pt) {
        Dd(r, a, pt)
      }
  }
  function D0(r, a, l) {
    l !== null && typeof l == 'object' && typeof l.then == 'function'
      ? l.then(
          function (f) {
            O0(r, a, f)
          },
          function (f) {
            return Dd(r, a, f)
          }
        )
      : O0(r, a, l)
  }
  function O0(r, a, l) {
    ;((a.status = 'fulfilled'),
      (a.value = l),
      L0(a),
      (r.state = l),
      (a = r.pending),
      a !== null &&
        ((l = a.next), l === a ? (r.pending = null) : ((l = l.next), (a.next = l), E0(r, l))))
  }
  function Dd(r, a, l) {
    var f = r.pending
    if (((r.pending = null), f !== null)) {
      f = f.next
      do ((a.status = 'rejected'), (a.reason = l), L0(a), (a = a.next))
      while (a !== f)
    }
    r.action = null
  }
  function L0(r) {
    r = r.listeners
    for (var a = 0; a < r.length; a++) (0, r[a])()
  }
  function z0(r, a) {
    return a
  }
  function R0(r, a) {
    if (je) {
      var l = tn.formState
      if (l !== null) {
        t: {
          var f = be
          if (je) {
            if (un) {
              e: {
                for (var m = un, b = Pr; m.nodeType !== 8; ) {
                  if (!b) {
                    m = null
                    break e
                  }
                  if (((m = Nr(m.nextSibling)), m === null)) {
                    m = null
                    break e
                  }
                }
                ;((b = m.data), (m = b === 'F!' || b === 'F' ? m : null))
              }
              if (m) {
                ;((un = Nr(m.nextSibling)), (f = m.data === 'F!'))
                break t
              }
            }
            js(f)
          }
          f = !1
        }
        f && (a = l[0])
      }
    }
    return (
      (l = gi()),
      (l.memoizedState = l.baseState = a),
      (f = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: z0,
        lastRenderedState: a,
      }),
      (l.queue = f),
      (l = $0.bind(null, be, f)),
      (f.dispatch = l),
      (f = Ed(!1)),
      (b = kd.bind(null, be, !1, f.queue)),
      (f = gi()),
      (m = { state: a, dispatch: null, action: r, pending: null }),
      (f.queue = m),
      (l = tN.bind(null, be, m, b, l)),
      (m.dispatch = l),
      (f.memoizedState = r),
      [a, l, !1]
    )
  }
  function k0(r) {
    var a = Cn()
    return _0(a, We, r)
  }
  function _0(r, a, l) {
    if (
      ((a = Td(r, a, z0)[0]),
      (r = Bc(ua)[0]),
      typeof a == 'object' && a !== null && typeof a.then == 'function')
    )
      try {
        var f = Jl(a)
      } catch (O) {
        throw O === Yl ? Oc : O
      }
    else f = a
    a = Cn()
    var m = a.queue,
      b = m.dispatch
    return (
      l !== a.memoizedState && ((be.flags |= 2048), _o(9, jc(), eN.bind(null, m, l), null)),
      [f, b, r]
    )
  }
  function eN(r, a) {
    r.action = a
  }
  function B0(r) {
    var a = Cn(),
      l = We
    if (l !== null) return _0(a, l, r)
    ;(Cn(), (a = a.memoizedState), (l = Cn()))
    var f = l.queue.dispatch
    return ((l.memoizedState = r), [a, f, !1])
  }
  function _o(r, a, l, f) {
    return (
      (r = { tag: r, create: l, deps: f, inst: a, next: null }),
      (a = be.updateQueue),
      a === null && ((a = Sd()), (be.updateQueue = a)),
      (l = a.lastEffect),
      l === null
        ? (a.lastEffect = r.next = r)
        : ((f = l.next), (l.next = r), (r.next = f), (a.lastEffect = r)),
      r
    )
  }
  function jc() {
    return { destroy: void 0, resource: void 0 }
  }
  function j0() {
    return Cn().memoizedState
  }
  function Pc(r, a, l, f) {
    var m = gi()
    ;((f = f === void 0 ? null : f), (be.flags |= r), (m.memoizedState = _o(1 | a, jc(), l, f)))
  }
  function ql(r, a, l, f) {
    var m = Cn()
    f = f === void 0 ? null : f
    var b = m.memoizedState.inst
    We !== null && f !== null && bd(f, We.memoizedState.deps)
      ? (m.memoizedState = _o(a, b, l, f))
      : ((be.flags |= r), (m.memoizedState = _o(1 | a, b, l, f)))
  }
  function P0(r, a) {
    Pc(8390656, 8, r, a)
  }
  function G0(r, a) {
    ql(2048, 8, r, a)
  }
  function Z0(r, a) {
    return ql(4, 2, r, a)
  }
  function U0(r, a) {
    return ql(4, 4, r, a)
  }
  function Y0(r, a) {
    if (typeof a == 'function') {
      r = r()
      var l = a(r)
      return function () {
        typeof l == 'function' ? l() : a(null)
      }
    }
    if (a != null)
      return (
        (r = r()),
        (a.current = r),
        function () {
          a.current = null
        }
      )
  }
  function H0(r, a, l) {
    ;((l = l != null ? l.concat([r]) : null), ql(4, 4, Y0.bind(null, a, r), l))
  }
  function Od() {}
  function V0(r, a) {
    var l = Cn()
    a = a === void 0 ? null : a
    var f = l.memoizedState
    return a !== null && bd(a, f[1]) ? f[0] : ((l.memoizedState = [r, a]), r)
  }
  function X0(r, a) {
    var l = Cn()
    a = a === void 0 ? null : a
    var f = l.memoizedState
    if (a !== null && bd(a, f[1])) return f[0]
    if (((f = r()), Us)) {
      Fn(!0)
      try {
        r()
      } finally {
        Fn(!1)
      }
    }
    return ((l.memoizedState = [f, a]), f)
  }
  function Ld(r, a, l) {
    return l === void 0 || (Za & 1073741824) !== 0
      ? (r.memoizedState = a)
      : ((r.memoizedState = l), (r = Jy()), (be.lanes |= r), (Fa |= r), l)
  }
  function W0(r, a, l, f) {
    return _n(l, a)
      ? l
      : zo.current !== null
        ? ((r = Ld(r, l, f)), _n(r, a) || (jn = !0), r)
        : (Za & 42) === 0
          ? ((jn = !0), (r.memoizedState = l))
          : ((r = Jy()), (be.lanes |= r), (Fa |= r), a)
  }
  function F0(r, a, l, f, m) {
    var b = Q.p
    Q.p = b !== 0 && 8 > b ? b : 8
    var O = G.T,
      j = {}
    ;((G.T = j), kd(r, !1, a, l))
    try {
      var K = m(),
        pt = G.S
      if (
        (pt !== null && pt(j, K), K !== null && typeof K == 'object' && typeof K.then == 'function')
      ) {
        var Ot = QS(K, f)
        Ql(r, a, Ot, Ri(r))
      } else Ql(r, a, f, Ri(r))
    } catch (zt) {
      Ql(r, a, { then: function () {}, status: 'rejected', reason: zt }, Ri())
    } finally {
      ;((Q.p = b), (G.T = O))
    }
  }
  function nN() {}
  function zd(r, a, l, f) {
    if (r.tag !== 5) throw Error(i(476))
    var m = J0(r).queue
    F0(
      r,
      m,
      a,
      it,
      l === null
        ? nN
        : function () {
            return (q0(r), l(f))
          }
    )
  }
  function J0(r) {
    var a = r.memoizedState
    if (a !== null) return a
    a = {
      memoizedState: it,
      baseState: it,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ua,
        lastRenderedState: it,
      },
      next: null,
    }
    var l = {}
    return (
      (a.next = {
        memoizedState: l,
        baseState: l,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ua,
          lastRenderedState: l,
        },
        next: null,
      }),
      (r.memoizedState = a),
      (r = r.alternate),
      r !== null && (r.memoizedState = a),
      a
    )
  }
  function q0(r) {
    var a = J0(r).next.queue
    Ql(r, a, {}, Ri())
  }
  function Rd() {
    return Qn(pu)
  }
  function Q0() {
    return Cn().memoizedState
  }
  function K0() {
    return Cn().memoizedState
  }
  function iN(r) {
    for (var a = r.return; a !== null; ) {
      switch (a.tag) {
        case 24:
        case 3:
          var l = Ri()
          r = Pa(l)
          var f = Ga(a, r, l)
          ;(f !== null && (ki(f, a, l), Vl(f, a, l)), (a = { cache: cd() }), (r.payload = a))
          return
      }
      a = a.return
    }
  }
  function rN(r, a, l) {
    var f = Ri()
    ;((l = { lane: f, revertLane: 0, action: l, hasEagerState: !1, eagerState: null, next: null }),
      Gc(r) ? ty(a, l) : ((l = td(r, a, l, f)), l !== null && (ki(l, r, f), ey(l, a, f))))
  }
  function $0(r, a, l) {
    var f = Ri()
    Ql(r, a, l, f)
  }
  function Ql(r, a, l, f) {
    var m = { lane: f, revertLane: 0, action: l, hasEagerState: !1, eagerState: null, next: null }
    if (Gc(r)) ty(a, m)
    else {
      var b = r.alternate
      if (
        r.lanes === 0 &&
        (b === null || b.lanes === 0) &&
        ((b = a.lastRenderedReducer), b !== null)
      )
        try {
          var O = a.lastRenderedState,
            j = b(O, l)
          if (((m.hasEagerState = !0), (m.eagerState = j), _n(j, O)))
            return (wc(r, a, m, 0), tn === null && Cc(), !1)
        } catch {
        } finally {
        }
      if (((l = td(r, a, m, f)), l !== null)) return (ki(l, r, f), ey(l, a, f), !0)
    }
    return !1
  }
  function kd(r, a, l, f) {
    if (
      ((f = {
        lane: 2,
        revertLane: dg(),
        action: f,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      Gc(r))
    ) {
      if (a) throw Error(i(479))
    } else ((a = td(r, l, f, 2)), a !== null && ki(a, r, 2))
  }
  function Gc(r) {
    var a = r.alternate
    return r === be || (a !== null && a === be)
  }
  function ty(r, a) {
    Ro = Rc = !0
    var l = r.pending
    ;(l === null ? (a.next = a) : ((a.next = l.next), (l.next = a)), (r.pending = a))
  }
  function ey(r, a, l) {
    if ((l & 4194048) !== 0) {
      var f = a.lanes
      ;((f &= r.pendingLanes), (l |= f), (a.lanes = l), en(r, l))
    }
  }
  var Zc = {
      readContext: Qn,
      use: _c,
      useCallback: mn,
      useContext: mn,
      useEffect: mn,
      useImperativeHandle: mn,
      useLayoutEffect: mn,
      useInsertionEffect: mn,
      useMemo: mn,
      useReducer: mn,
      useRef: mn,
      useState: mn,
      useDebugValue: mn,
      useDeferredValue: mn,
      useTransition: mn,
      useSyncExternalStore: mn,
      useId: mn,
      useHostTransitionStatus: mn,
      useFormState: mn,
      useActionState: mn,
      useOptimistic: mn,
      useMemoCache: mn,
      useCacheRefresh: mn,
    },
    ny = {
      readContext: Qn,
      use: _c,
      useCallback: function (r, a) {
        return ((gi().memoizedState = [r, a === void 0 ? null : a]), r)
      },
      useContext: Qn,
      useEffect: P0,
      useImperativeHandle: function (r, a, l) {
        ;((l = l != null ? l.concat([r]) : null), Pc(4194308, 4, Y0.bind(null, a, r), l))
      },
      useLayoutEffect: function (r, a) {
        return Pc(4194308, 4, r, a)
      },
      useInsertionEffect: function (r, a) {
        Pc(4, 2, r, a)
      },
      useMemo: function (r, a) {
        var l = gi()
        a = a === void 0 ? null : a
        var f = r()
        if (Us) {
          Fn(!0)
          try {
            r()
          } finally {
            Fn(!1)
          }
        }
        return ((l.memoizedState = [f, a]), f)
      },
      useReducer: function (r, a, l) {
        var f = gi()
        if (l !== void 0) {
          var m = l(a)
          if (Us) {
            Fn(!0)
            try {
              l(a)
            } finally {
              Fn(!1)
            }
          }
        } else m = a
        return (
          (f.memoizedState = f.baseState = m),
          (r = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: r,
            lastRenderedState: m,
          }),
          (f.queue = r),
          (r = r.dispatch = rN.bind(null, be, r)),
          [f.memoizedState, r]
        )
      },
      useRef: function (r) {
        var a = gi()
        return ((r = { current: r }), (a.memoizedState = r))
      },
      useState: function (r) {
        r = Ed(r)
        var a = r.queue,
          l = $0.bind(null, be, a)
        return ((a.dispatch = l), [r.memoizedState, l])
      },
      useDebugValue: Od,
      useDeferredValue: function (r, a) {
        var l = gi()
        return Ld(l, r, a)
      },
      useTransition: function () {
        var r = Ed(!1)
        return ((r = F0.bind(null, be, r.queue, !0, !1)), (gi().memoizedState = r), [!1, r])
      },
      useSyncExternalStore: function (r, a, l) {
        var f = be,
          m = gi()
        if (je) {
          if (l === void 0) throw Error(i(407))
          l = l()
        } else {
          if (((l = a()), tn === null)) throw Error(i(349))
          ;(Re & 124) !== 0 || w0(f, a, l)
        }
        m.memoizedState = l
        var b = { value: l, getSnapshot: a }
        return (
          (m.queue = b),
          P0(S0.bind(null, f, b, r), [r]),
          (f.flags |= 2048),
          _o(9, jc(), x0.bind(null, f, b, l, a), null),
          l
        )
      },
      useId: function () {
        var r = gi(),
          a = tn.identifierPrefix
        if (je) {
          var l = sa,
            f = aa
          ;((l = (f & ~(1 << (32 - Ne(f) - 1))).toString(32) + l),
            (a = '«' + a + 'R' + l),
            (l = kc++),
            0 < l && (a += 'H' + l.toString(32)),
            (a += '»'))
        } else ((l = KS++), (a = '«' + a + 'r' + l.toString(32) + '»'))
        return (r.memoizedState = a)
      },
      useHostTransitionStatus: Rd,
      useFormState: R0,
      useActionState: R0,
      useOptimistic: function (r) {
        var a = gi()
        a.memoizedState = a.baseState = r
        var l = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null,
        }
        return ((a.queue = l), (a = kd.bind(null, be, !0, l)), (l.dispatch = a), [r, a])
      },
      useMemoCache: Nd,
      useCacheRefresh: function () {
        return (gi().memoizedState = iN.bind(null, be))
      },
    },
    iy = {
      readContext: Qn,
      use: _c,
      useCallback: V0,
      useContext: Qn,
      useEffect: G0,
      useImperativeHandle: H0,
      useInsertionEffect: Z0,
      useLayoutEffect: U0,
      useMemo: X0,
      useReducer: Bc,
      useRef: j0,
      useState: function () {
        return Bc(ua)
      },
      useDebugValue: Od,
      useDeferredValue: function (r, a) {
        var l = Cn()
        return W0(l, We.memoizedState, r, a)
      },
      useTransition: function () {
        var r = Bc(ua)[0],
          a = Cn().memoizedState
        return [typeof r == 'boolean' ? r : Jl(r), a]
      },
      useSyncExternalStore: C0,
      useId: Q0,
      useHostTransitionStatus: Rd,
      useFormState: k0,
      useActionState: k0,
      useOptimistic: function (r, a) {
        var l = Cn()
        return M0(l, We, r, a)
      },
      useMemoCache: Nd,
      useCacheRefresh: K0,
    },
    aN = {
      readContext: Qn,
      use: _c,
      useCallback: V0,
      useContext: Qn,
      useEffect: G0,
      useImperativeHandle: H0,
      useInsertionEffect: Z0,
      useLayoutEffect: U0,
      useMemo: X0,
      useReducer: Md,
      useRef: j0,
      useState: function () {
        return Md(ua)
      },
      useDebugValue: Od,
      useDeferredValue: function (r, a) {
        var l = Cn()
        return We === null ? Ld(l, r, a) : W0(l, We.memoizedState, r, a)
      },
      useTransition: function () {
        var r = Md(ua)[0],
          a = Cn().memoizedState
        return [typeof r == 'boolean' ? r : Jl(r), a]
      },
      useSyncExternalStore: C0,
      useId: Q0,
      useHostTransitionStatus: Rd,
      useFormState: B0,
      useActionState: B0,
      useOptimistic: function (r, a) {
        var l = Cn()
        return We !== null ? M0(l, We, r, a) : ((l.baseState = r), [r, l.queue.dispatch])
      },
      useMemoCache: Nd,
      useCacheRefresh: K0,
    },
    Bo = null,
    Kl = 0
  function Uc(r) {
    var a = Kl
    return ((Kl += 1), Bo === null && (Bo = []), g0(Bo, r, a))
  }
  function $l(r, a) {
    ;((a = a.props.ref), (r.ref = a !== void 0 ? a : null))
  }
  function Yc(r, a) {
    throw a.$$typeof === v
      ? Error(i(525))
      : ((r = Object.prototype.toString.call(a)),
        Error(
          i(
            31,
            r === '[object Object]' ? 'object with keys {' + Object.keys(a).join(', ') + '}' : r
          )
        ))
  }
  function ry(r) {
    var a = r._init
    return a(r._payload)
  }
  function ay(r) {
    function a(ut, at) {
      if (r) {
        var ft = ut.deletions
        ft === null ? ((ut.deletions = [at]), (ut.flags |= 16)) : ft.push(at)
      }
    }
    function l(ut, at) {
      if (!r) return null
      for (; at !== null; ) (a(ut, at), (at = at.sibling))
      return null
    }
    function f(ut) {
      for (var at = new Map(); ut !== null; )
        (ut.key !== null ? at.set(ut.key, ut) : at.set(ut.index, ut), (ut = ut.sibling))
      return at
    }
    function m(ut, at) {
      return ((ut = ra(ut, at)), (ut.index = 0), (ut.sibling = null), ut)
    }
    function b(ut, at, ft) {
      return (
        (ut.index = ft),
        r
          ? ((ft = ut.alternate),
            ft !== null
              ? ((ft = ft.index), ft < at ? ((ut.flags |= 67108866), at) : ft)
              : ((ut.flags |= 67108866), at))
          : ((ut.flags |= 1048576), at)
      )
    }
    function O(ut) {
      return (r && ut.alternate === null && (ut.flags |= 67108866), ut)
    }
    function j(ut, at, ft, Lt) {
      return at === null || at.tag !== 6
        ? ((at = nd(ft, ut.mode, Lt)), (at.return = ut), at)
        : ((at = m(at, ft)), (at.return = ut), at)
    }
    function K(ut, at, ft, Lt) {
      var Wt = ft.type
      return Wt === N
        ? Ot(ut, at, ft.props.children, Lt, ft.key)
        : at !== null &&
            (at.elementType === Wt ||
              (typeof Wt == 'object' && Wt !== null && Wt.$$typeof === S && ry(Wt) === at.type))
          ? ((at = m(at, ft.props)), $l(at, ft), (at.return = ut), at)
          : ((at = Sc(ft.type, ft.key, ft.props, null, ut.mode, Lt)),
            $l(at, ft),
            (at.return = ut),
            at)
    }
    function pt(ut, at, ft, Lt) {
      return at === null ||
        at.tag !== 4 ||
        at.stateNode.containerInfo !== ft.containerInfo ||
        at.stateNode.implementation !== ft.implementation
        ? ((at = id(ft, ut.mode, Lt)), (at.return = ut), at)
        : ((at = m(at, ft.children || [])), (at.return = ut), at)
    }
    function Ot(ut, at, ft, Lt, Wt) {
      return at === null || at.tag !== 7
        ? ((at = Rs(ft, ut.mode, Lt, Wt)), (at.return = ut), at)
        : ((at = m(at, ft)), (at.return = ut), at)
    }
    function zt(ut, at, ft) {
      if ((typeof at == 'string' && at !== '') || typeof at == 'number' || typeof at == 'bigint')
        return ((at = nd('' + at, ut.mode, ft)), (at.return = ut), at)
      if (typeof at == 'object' && at !== null) {
        switch (at.$$typeof) {
          case C:
            return (
              (ft = Sc(at.type, at.key, at.props, null, ut.mode, ft)),
              $l(ft, at),
              (ft.return = ut),
              ft
            )
          case w:
            return ((at = id(at, ut.mode, ft)), (at.return = ut), at)
          case S:
            var Lt = at._init
            return ((at = Lt(at._payload)), zt(ut, at, ft))
        }
        if (Tt(at) || $(at)) return ((at = Rs(at, ut.mode, ft, null)), (at.return = ut), at)
        if (typeof at.then == 'function') return zt(ut, Uc(at), ft)
        if (at.$$typeof === H) return zt(ut, Ec(ut, at), ft)
        Yc(ut, at)
      }
      return null
    }
    function mt(ut, at, ft, Lt) {
      var Wt = at !== null ? at.key : null
      if ((typeof ft == 'string' && ft !== '') || typeof ft == 'number' || typeof ft == 'bigint')
        return Wt !== null ? null : j(ut, at, '' + ft, Lt)
      if (typeof ft == 'object' && ft !== null) {
        switch (ft.$$typeof) {
          case C:
            return ft.key === Wt ? K(ut, at, ft, Lt) : null
          case w:
            return ft.key === Wt ? pt(ut, at, ft, Lt) : null
          case S:
            return ((Wt = ft._init), (ft = Wt(ft._payload)), mt(ut, at, ft, Lt))
        }
        if (Tt(ft) || $(ft)) return Wt !== null ? null : Ot(ut, at, ft, Lt, null)
        if (typeof ft.then == 'function') return mt(ut, at, Uc(ft), Lt)
        if (ft.$$typeof === H) return mt(ut, at, Ec(ut, ft), Lt)
        Yc(ut, ft)
      }
      return null
    }
    function It(ut, at, ft, Lt, Wt) {
      if ((typeof Lt == 'string' && Lt !== '') || typeof Lt == 'number' || typeof Lt == 'bigint')
        return ((ut = ut.get(ft) || null), j(at, ut, '' + Lt, Wt))
      if (typeof Lt == 'object' && Lt !== null) {
        switch (Lt.$$typeof) {
          case C:
            return ((ut = ut.get(Lt.key === null ? ft : Lt.key) || null), K(at, ut, Lt, Wt))
          case w:
            return ((ut = ut.get(Lt.key === null ? ft : Lt.key) || null), pt(at, ut, Lt, Wt))
          case S:
            var we = Lt._init
            return ((Lt = we(Lt._payload)), It(ut, at, ft, Lt, Wt))
        }
        if (Tt(Lt) || $(Lt)) return ((ut = ut.get(ft) || null), Ot(at, ut, Lt, Wt, null))
        if (typeof Lt.then == 'function') return It(ut, at, ft, Uc(Lt), Wt)
        if (Lt.$$typeof === H) return It(ut, at, ft, Ec(at, Lt), Wt)
        Yc(at, Lt)
      }
      return null
    }
    function le(ut, at, ft, Lt) {
      for (
        var Wt = null, we = null, $t = at, re = (at = 0), Gn = null;
        $t !== null && re < ft.length;
        re++
      ) {
        $t.index > re ? ((Gn = $t), ($t = null)) : (Gn = $t.sibling)
        var _e = mt(ut, $t, ft[re], Lt)
        if (_e === null) {
          $t === null && ($t = Gn)
          break
        }
        ;(r && $t && _e.alternate === null && a(ut, $t),
          (at = b(_e, at, re)),
          we === null ? (Wt = _e) : (we.sibling = _e),
          (we = _e),
          ($t = Gn))
      }
      if (re === ft.length) return (l(ut, $t), je && _s(ut, re), Wt)
      if ($t === null) {
        for (; re < ft.length; re++)
          (($t = zt(ut, ft[re], Lt)),
            $t !== null &&
              ((at = b($t, at, re)), we === null ? (Wt = $t) : (we.sibling = $t), (we = $t)))
        return (je && _s(ut, re), Wt)
      }
      for ($t = f($t); re < ft.length; re++)
        ((Gn = It($t, ut, re, ft[re], Lt)),
          Gn !== null &&
            (r && Gn.alternate !== null && $t.delete(Gn.key === null ? re : Gn.key),
            (at = b(Gn, at, re)),
            we === null ? (Wt = Gn) : (we.sibling = Gn),
            (we = Gn)))
      return (
        r &&
          $t.forEach(function (is) {
            return a(ut, is)
          }),
        je && _s(ut, re),
        Wt
      )
    }
    function ie(ut, at, ft, Lt) {
      if (ft == null) throw Error(i(151))
      for (
        var Wt = null, we = null, $t = at, re = (at = 0), Gn = null, _e = ft.next();
        $t !== null && !_e.done;
        re++, _e = ft.next()
      ) {
        $t.index > re ? ((Gn = $t), ($t = null)) : (Gn = $t.sibling)
        var is = mt(ut, $t, _e.value, Lt)
        if (is === null) {
          $t === null && ($t = Gn)
          break
        }
        ;(r && $t && is.alternate === null && a(ut, $t),
          (at = b(is, at, re)),
          we === null ? (Wt = is) : (we.sibling = is),
          (we = is),
          ($t = Gn))
      }
      if (_e.done) return (l(ut, $t), je && _s(ut, re), Wt)
      if ($t === null) {
        for (; !_e.done; re++, _e = ft.next())
          ((_e = zt(ut, _e.value, Lt)),
            _e !== null &&
              ((at = b(_e, at, re)), we === null ? (Wt = _e) : (we.sibling = _e), (we = _e)))
        return (je && _s(ut, re), Wt)
      }
      for ($t = f($t); !_e.done; re++, _e = ft.next())
        ((_e = It($t, ut, re, _e.value, Lt)),
          _e !== null &&
            (r && _e.alternate !== null && $t.delete(_e.key === null ? re : _e.key),
            (at = b(_e, at, re)),
            we === null ? (Wt = _e) : (we.sibling = _e),
            (we = _e)))
      return (
        r &&
          $t.forEach(function (sT) {
            return a(ut, sT)
          }),
        je && _s(ut, re),
        Wt
      )
    }
    function Je(ut, at, ft, Lt) {
      if (
        (typeof ft == 'object' &&
          ft !== null &&
          ft.type === N &&
          ft.key === null &&
          (ft = ft.props.children),
        typeof ft == 'object' && ft !== null)
      ) {
        switch (ft.$$typeof) {
          case C:
            t: {
              for (var Wt = ft.key; at !== null; ) {
                if (at.key === Wt) {
                  if (((Wt = ft.type), Wt === N)) {
                    if (at.tag === 7) {
                      ;(l(ut, at.sibling),
                        (Lt = m(at, ft.props.children)),
                        (Lt.return = ut),
                        (ut = Lt))
                      break t
                    }
                  } else if (
                    at.elementType === Wt ||
                    (typeof Wt == 'object' &&
                      Wt !== null &&
                      Wt.$$typeof === S &&
                      ry(Wt) === at.type)
                  ) {
                    ;(l(ut, at.sibling),
                      (Lt = m(at, ft.props)),
                      $l(Lt, ft),
                      (Lt.return = ut),
                      (ut = Lt))
                    break t
                  }
                  l(ut, at)
                  break
                } else a(ut, at)
                at = at.sibling
              }
              ft.type === N
                ? ((Lt = Rs(ft.props.children, ut.mode, Lt, ft.key)), (Lt.return = ut), (ut = Lt))
                : ((Lt = Sc(ft.type, ft.key, ft.props, null, ut.mode, Lt)),
                  $l(Lt, ft),
                  (Lt.return = ut),
                  (ut = Lt))
            }
            return O(ut)
          case w:
            t: {
              for (Wt = ft.key; at !== null; ) {
                if (at.key === Wt)
                  if (
                    at.tag === 4 &&
                    at.stateNode.containerInfo === ft.containerInfo &&
                    at.stateNode.implementation === ft.implementation
                  ) {
                    ;(l(ut, at.sibling),
                      (Lt = m(at, ft.children || [])),
                      (Lt.return = ut),
                      (ut = Lt))
                    break t
                  } else {
                    l(ut, at)
                    break
                  }
                else a(ut, at)
                at = at.sibling
              }
              ;((Lt = id(ft, ut.mode, Lt)), (Lt.return = ut), (ut = Lt))
            }
            return O(ut)
          case S:
            return ((Wt = ft._init), (ft = Wt(ft._payload)), Je(ut, at, ft, Lt))
        }
        if (Tt(ft)) return le(ut, at, ft, Lt)
        if ($(ft)) {
          if (((Wt = $(ft)), typeof Wt != 'function')) throw Error(i(150))
          return ((ft = Wt.call(ft)), ie(ut, at, ft, Lt))
        }
        if (typeof ft.then == 'function') return Je(ut, at, Uc(ft), Lt)
        if (ft.$$typeof === H) return Je(ut, at, Ec(ut, ft), Lt)
        Yc(ut, ft)
      }
      return (typeof ft == 'string' && ft !== '') || typeof ft == 'number' || typeof ft == 'bigint'
        ? ((ft = '' + ft),
          at !== null && at.tag === 6
            ? (l(ut, at.sibling), (Lt = m(at, ft)), (Lt.return = ut), (ut = Lt))
            : (l(ut, at), (Lt = nd(ft, ut.mode, Lt)), (Lt.return = ut), (ut = Lt)),
          O(ut))
        : l(ut, at)
    }
    return function (ut, at, ft, Lt) {
      try {
        Kl = 0
        var Wt = Je(ut, at, ft, Lt)
        return ((Bo = null), Wt)
      } catch ($t) {
        if ($t === Yl || $t === Oc) throw $t
        var we = Di(29, $t, null, ut.mode)
        return ((we.lanes = Lt), (we.return = ut), we)
      } finally {
      }
    }
  }
  var jo = ay(!0),
    sy = ay(!1),
    tr = ht(null),
    Gr = null
  function Ua(r) {
    var a = r.alternate
    ;(St(Mn, Mn.current & 1),
      St(tr, r),
      Gr === null && (a === null || zo.current !== null || a.memoizedState !== null) && (Gr = r))
  }
  function oy(r) {
    if (r.tag === 22) {
      if ((St(Mn, Mn.current), St(tr, r), Gr === null)) {
        var a = r.alternate
        a !== null && a.memoizedState !== null && (Gr = r)
      }
    } else Ya()
  }
  function Ya() {
    ;(St(Mn, Mn.current), St(tr, tr.current))
  }
  function ca(r) {
    ;(ct(tr), Gr === r && (Gr = null), ct(Mn))
  }
  var Mn = ht(0)
  function Hc(r) {
    for (var a = r; a !== null; ) {
      if (a.tag === 13) {
        var l = a.memoizedState
        if (l !== null && ((l = l.dehydrated), l === null || l.data === '$?' || Sg(l))) return a
      } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
        if ((a.flags & 128) !== 0) return a
      } else if (a.child !== null) {
        ;((a.child.return = a), (a = a.child))
        continue
      }
      if (a === r) break
      for (; a.sibling === null; ) {
        if (a.return === null || a.return === r) return null
        a = a.return
      }
      ;((a.sibling.return = a.return), (a = a.sibling))
    }
    return null
  }
  function _d(r, a, l, f) {
    ;((a = r.memoizedState),
      (l = l(f, a)),
      (l = l == null ? a : y({}, a, l)),
      (r.memoizedState = l),
      r.lanes === 0 && (r.updateQueue.baseState = l))
  }
  var Bd = {
    enqueueSetState: function (r, a, l) {
      r = r._reactInternals
      var f = Ri(),
        m = Pa(f)
      ;((m.payload = a),
        l != null && (m.callback = l),
        (a = Ga(r, m, f)),
        a !== null && (ki(a, r, f), Vl(a, r, f)))
    },
    enqueueReplaceState: function (r, a, l) {
      r = r._reactInternals
      var f = Ri(),
        m = Pa(f)
      ;((m.tag = 1),
        (m.payload = a),
        l != null && (m.callback = l),
        (a = Ga(r, m, f)),
        a !== null && (ki(a, r, f), Vl(a, r, f)))
    },
    enqueueForceUpdate: function (r, a) {
      r = r._reactInternals
      var l = Ri(),
        f = Pa(l)
      ;((f.tag = 2),
        a != null && (f.callback = a),
        (a = Ga(r, f, l)),
        a !== null && (ki(a, r, l), Vl(a, r, l)))
    },
  }
  function ly(r, a, l, f, m, b, O) {
    return (
      (r = r.stateNode),
      typeof r.shouldComponentUpdate == 'function'
        ? r.shouldComponentUpdate(f, b, O)
        : a.prototype && a.prototype.isPureReactComponent
          ? !na(l, f) || !na(m, b)
          : !0
    )
  }
  function uy(r, a, l, f) {
    ;((r = a.state),
      typeof a.componentWillReceiveProps == 'function' && a.componentWillReceiveProps(l, f),
      typeof a.UNSAFE_componentWillReceiveProps == 'function' &&
        a.UNSAFE_componentWillReceiveProps(l, f),
      a.state !== r && Bd.enqueueReplaceState(a, a.state, null))
  }
  function Ys(r, a) {
    var l = a
    if ('ref' in a) {
      l = {}
      for (var f in a) f !== 'ref' && (l[f] = a[f])
    }
    if ((r = r.defaultProps)) {
      l === a && (l = y({}, l))
      for (var m in r) l[m] === void 0 && (l[m] = r[m])
    }
    return l
  }
  var Vc =
    typeof reportError == 'function'
      ? reportError
      : function (r) {
          if (typeof window == 'object' && typeof window.ErrorEvent == 'function') {
            var a = new window.ErrorEvent('error', {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof r == 'object' && r !== null && typeof r.message == 'string'
                  ? String(r.message)
                  : String(r),
              error: r,
            })
            if (!window.dispatchEvent(a)) return
          } else if (typeof process == 'object' && typeof process.emit == 'function') {
            process.emit('uncaughtException', r)
            return
          }
          console.error(r)
        }
  function cy(r) {
    Vc(r)
  }
  function fy(r) {
    console.error(r)
  }
  function hy(r) {
    Vc(r)
  }
  function Xc(r, a) {
    try {
      var l = r.onUncaughtError
      l(a.value, { componentStack: a.stack })
    } catch (f) {
      setTimeout(function () {
        throw f
      })
    }
  }
  function dy(r, a, l) {
    try {
      var f = r.onCaughtError
      f(l.value, { componentStack: l.stack, errorBoundary: a.tag === 1 ? a.stateNode : null })
    } catch (m) {
      setTimeout(function () {
        throw m
      })
    }
  }
  function jd(r, a, l) {
    return (
      (l = Pa(l)),
      (l.tag = 3),
      (l.payload = { element: null }),
      (l.callback = function () {
        Xc(r, a)
      }),
      l
    )
  }
  function gy(r) {
    return ((r = Pa(r)), (r.tag = 3), r)
  }
  function py(r, a, l, f) {
    var m = l.type.getDerivedStateFromError
    if (typeof m == 'function') {
      var b = f.value
      ;((r.payload = function () {
        return m(b)
      }),
        (r.callback = function () {
          dy(a, l, f)
        }))
    }
    var O = l.stateNode
    O !== null &&
      typeof O.componentDidCatch == 'function' &&
      (r.callback = function () {
        ;(dy(a, l, f),
          typeof m != 'function' && (Ja === null ? (Ja = new Set([this])) : Ja.add(this)))
        var j = f.stack
        this.componentDidCatch(f.value, { componentStack: j !== null ? j : '' })
      })
  }
  function sN(r, a, l, f, m) {
    if (((l.flags |= 32768), f !== null && typeof f == 'object' && typeof f.then == 'function')) {
      if (((a = l.alternate), a !== null && Gl(a, l, m, !0), (l = tr.current), l !== null)) {
        switch (l.tag) {
          case 13:
            return (
              Gr === null ? lg() : l.alternate === null && cn === 0 && (cn = 3),
              (l.flags &= -257),
              (l.flags |= 65536),
              (l.lanes = m),
              f === dd
                ? (l.flags |= 16384)
                : ((a = l.updateQueue),
                  a === null ? (l.updateQueue = new Set([f])) : a.add(f),
                  cg(r, f, m)),
              !1
            )
          case 22:
            return (
              (l.flags |= 65536),
              f === dd
                ? (l.flags |= 16384)
                : ((a = l.updateQueue),
                  a === null
                    ? ((a = { transitions: null, markerInstances: null, retryQueue: new Set([f]) }),
                      (l.updateQueue = a))
                    : ((l = a.retryQueue), l === null ? (a.retryQueue = new Set([f])) : l.add(f)),
                  cg(r, f, m)),
              !1
            )
        }
        throw Error(i(435, l.tag))
      }
      return (cg(r, f, m), lg(), !1)
    }
    if (je)
      return (
        (a = tr.current),
        a !== null
          ? ((a.flags & 65536) === 0 && (a.flags |= 256),
            (a.flags |= 65536),
            (a.lanes = m),
            f !== sd && ((r = Error(i(422), { cause: f })), Pl(qi(r, l))))
          : (f !== sd && ((a = Error(i(423), { cause: f })), Pl(qi(a, l))),
            (r = r.current.alternate),
            (r.flags |= 65536),
            (m &= -m),
            (r.lanes |= m),
            (f = qi(f, l)),
            (m = jd(r.stateNode, f, m)),
            vd(r, m),
            cn !== 4 && (cn = 2)),
        !1
      )
    var b = Error(i(520), { cause: f })
    if (((b = qi(b, l)), su === null ? (su = [b]) : su.push(b), cn !== 4 && (cn = 2), a === null))
      return !0
    ;((f = qi(f, l)), (l = a))
    do {
      switch (l.tag) {
        case 3:
          return (
            (l.flags |= 65536),
            (r = m & -m),
            (l.lanes |= r),
            (r = jd(l.stateNode, f, r)),
            vd(l, r),
            !1
          )
        case 1:
          if (
            ((a = l.type),
            (b = l.stateNode),
            (l.flags & 128) === 0 &&
              (typeof a.getDerivedStateFromError == 'function' ||
                (b !== null &&
                  typeof b.componentDidCatch == 'function' &&
                  (Ja === null || !Ja.has(b)))))
          )
            return (
              (l.flags |= 65536),
              (m &= -m),
              (l.lanes |= m),
              (m = gy(m)),
              py(m, r, l, f),
              vd(l, m),
              !1
            )
      }
      l = l.return
    } while (l !== null)
    return !1
  }
  var vy = Error(i(461)),
    jn = !1
  function Yn(r, a, l, f) {
    a.child = r === null ? sy(a, null, l, f) : jo(a, r.child, l, f)
  }
  function my(r, a, l, f, m) {
    l = l.render
    var b = a.ref
    if ('ref' in f) {
      var O = {}
      for (var j in f) j !== 'ref' && (O[j] = f[j])
    } else O = f
    return (
      Gs(a),
      (f = Id(r, a, l, O, b, m)),
      (j = Cd()),
      r !== null && !jn
        ? (wd(r, a, m), fa(r, a, m))
        : (je && j && rd(a), (a.flags |= 1), Yn(r, a, f, m), a.child)
    )
  }
  function yy(r, a, l, f, m) {
    if (r === null) {
      var b = l.type
      return typeof b == 'function' && !ed(b) && b.defaultProps === void 0 && l.compare === null
        ? ((a.tag = 15), (a.type = b), Ay(r, a, b, f, m))
        : ((r = Sc(l.type, null, f, a, a.mode, m)), (r.ref = a.ref), (r.return = a), (a.child = r))
    }
    if (((b = r.child), !Xd(r, m))) {
      var O = b.memoizedProps
      if (((l = l.compare), (l = l !== null ? l : na), l(O, f) && r.ref === a.ref))
        return fa(r, a, m)
    }
    return ((a.flags |= 1), (r = ra(b, f)), (r.ref = a.ref), (r.return = a), (a.child = r))
  }
  function Ay(r, a, l, f, m) {
    if (r !== null) {
      var b = r.memoizedProps
      if (na(b, f) && r.ref === a.ref)
        if (((jn = !1), (a.pendingProps = f = b), Xd(r, m))) (r.flags & 131072) !== 0 && (jn = !0)
        else return ((a.lanes = r.lanes), fa(r, a, m))
    }
    return Pd(r, a, l, f, m)
  }
  function by(r, a, l) {
    var f = a.pendingProps,
      m = f.children,
      b = r !== null ? r.memoizedState : null
    if (f.mode === 'hidden') {
      if ((a.flags & 128) !== 0) {
        if (((f = b !== null ? b.baseLanes | l : l), r !== null)) {
          for (m = a.child = r.child, b = 0; m !== null; )
            ((b = b | m.lanes | m.childLanes), (m = m.sibling))
          a.childLanes = b & ~f
        } else ((a.childLanes = 0), (a.child = null))
        return Iy(r, a, f, l)
      }
      if ((l & 536870912) !== 0)
        ((a.memoizedState = { baseLanes: 0, cachePool: null }),
          r !== null && Dc(a, b !== null ? b.cachePool : null),
          b !== null ? A0(a, b) : yd(),
          oy(a))
      else
        return ((a.lanes = a.childLanes = 536870912), Iy(r, a, b !== null ? b.baseLanes | l : l, l))
    } else
      b !== null
        ? (Dc(a, b.cachePool), A0(a, b), Ya(), (a.memoizedState = null))
        : (r !== null && Dc(a, null), yd(), Ya())
    return (Yn(r, a, m, l), a.child)
  }
  function Iy(r, a, l, f) {
    var m = hd()
    return (
      (m = m === null ? null : { parent: Tn._currentValue, pool: m }),
      (a.memoizedState = { baseLanes: l, cachePool: m }),
      r !== null && Dc(a, null),
      yd(),
      oy(a),
      r !== null && Gl(r, a, f, !0),
      null
    )
  }
  function Wc(r, a) {
    var l = a.ref
    if (l === null) r !== null && r.ref !== null && (a.flags |= 4194816)
    else {
      if (typeof l != 'function' && typeof l != 'object') throw Error(i(284))
      ;(r === null || r.ref !== l) && (a.flags |= 4194816)
    }
  }
  function Pd(r, a, l, f, m) {
    return (
      Gs(a),
      (l = Id(r, a, l, f, void 0, m)),
      (f = Cd()),
      r !== null && !jn
        ? (wd(r, a, m), fa(r, a, m))
        : (je && f && rd(a), (a.flags |= 1), Yn(r, a, l, m), a.child)
    )
  }
  function Cy(r, a, l, f, m, b) {
    return (
      Gs(a),
      (a.updateQueue = null),
      (l = I0(a, f, l, m)),
      b0(r),
      (f = Cd()),
      r !== null && !jn
        ? (wd(r, a, b), fa(r, a, b))
        : (je && f && rd(a), (a.flags |= 1), Yn(r, a, l, b), a.child)
    )
  }
  function wy(r, a, l, f, m) {
    if ((Gs(a), a.stateNode === null)) {
      var b = Mo,
        O = l.contextType
      ;(typeof O == 'object' && O !== null && (b = Qn(O)),
        (b = new l(f, b)),
        (a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null),
        (b.updater = Bd),
        (a.stateNode = b),
        (b._reactInternals = a),
        (b = a.stateNode),
        (b.props = f),
        (b.state = a.memoizedState),
        (b.refs = {}),
        gd(a),
        (O = l.contextType),
        (b.context = typeof O == 'object' && O !== null ? Qn(O) : Mo),
        (b.state = a.memoizedState),
        (O = l.getDerivedStateFromProps),
        typeof O == 'function' && (_d(a, l, O, f), (b.state = a.memoizedState)),
        typeof l.getDerivedStateFromProps == 'function' ||
          typeof b.getSnapshotBeforeUpdate == 'function' ||
          (typeof b.UNSAFE_componentWillMount != 'function' &&
            typeof b.componentWillMount != 'function') ||
          ((O = b.state),
          typeof b.componentWillMount == 'function' && b.componentWillMount(),
          typeof b.UNSAFE_componentWillMount == 'function' && b.UNSAFE_componentWillMount(),
          O !== b.state && Bd.enqueueReplaceState(b, b.state, null),
          Wl(a, f, b, m),
          Xl(),
          (b.state = a.memoizedState)),
        typeof b.componentDidMount == 'function' && (a.flags |= 4194308),
        (f = !0))
    } else if (r === null) {
      b = a.stateNode
      var j = a.memoizedProps,
        K = Ys(l, j)
      b.props = K
      var pt = b.context,
        Ot = l.contextType
      ;((O = Mo), typeof Ot == 'object' && Ot !== null && (O = Qn(Ot)))
      var zt = l.getDerivedStateFromProps
      ;((Ot = typeof zt == 'function' || typeof b.getSnapshotBeforeUpdate == 'function'),
        (j = a.pendingProps !== j),
        Ot ||
          (typeof b.UNSAFE_componentWillReceiveProps != 'function' &&
            typeof b.componentWillReceiveProps != 'function') ||
          ((j || pt !== O) && uy(a, b, f, O)),
        (ja = !1))
      var mt = a.memoizedState
      ;((b.state = mt),
        Wl(a, f, b, m),
        Xl(),
        (pt = a.memoizedState),
        j || mt !== pt || ja
          ? (typeof zt == 'function' && (_d(a, l, zt, f), (pt = a.memoizedState)),
            (K = ja || ly(a, l, K, f, mt, pt, O))
              ? (Ot ||
                  (typeof b.UNSAFE_componentWillMount != 'function' &&
                    typeof b.componentWillMount != 'function') ||
                  (typeof b.componentWillMount == 'function' && b.componentWillMount(),
                  typeof b.UNSAFE_componentWillMount == 'function' &&
                    b.UNSAFE_componentWillMount()),
                typeof b.componentDidMount == 'function' && (a.flags |= 4194308))
              : (typeof b.componentDidMount == 'function' && (a.flags |= 4194308),
                (a.memoizedProps = f),
                (a.memoizedState = pt)),
            (b.props = f),
            (b.state = pt),
            (b.context = O),
            (f = K))
          : (typeof b.componentDidMount == 'function' && (a.flags |= 4194308), (f = !1)))
    } else {
      ;((b = a.stateNode),
        pd(r, a),
        (O = a.memoizedProps),
        (Ot = Ys(l, O)),
        (b.props = Ot),
        (zt = a.pendingProps),
        (mt = b.context),
        (pt = l.contextType),
        (K = Mo),
        typeof pt == 'object' && pt !== null && (K = Qn(pt)),
        (j = l.getDerivedStateFromProps),
        (pt = typeof j == 'function' || typeof b.getSnapshotBeforeUpdate == 'function') ||
          (typeof b.UNSAFE_componentWillReceiveProps != 'function' &&
            typeof b.componentWillReceiveProps != 'function') ||
          ((O !== zt || mt !== K) && uy(a, b, f, K)),
        (ja = !1),
        (mt = a.memoizedState),
        (b.state = mt),
        Wl(a, f, b, m),
        Xl())
      var It = a.memoizedState
      O !== zt || mt !== It || ja || (r !== null && r.dependencies !== null && Mc(r.dependencies))
        ? (typeof j == 'function' && (_d(a, l, j, f), (It = a.memoizedState)),
          (Ot =
            ja ||
            ly(a, l, Ot, f, mt, It, K) ||
            (r !== null && r.dependencies !== null && Mc(r.dependencies)))
            ? (pt ||
                (typeof b.UNSAFE_componentWillUpdate != 'function' &&
                  typeof b.componentWillUpdate != 'function') ||
                (typeof b.componentWillUpdate == 'function' && b.componentWillUpdate(f, It, K),
                typeof b.UNSAFE_componentWillUpdate == 'function' &&
                  b.UNSAFE_componentWillUpdate(f, It, K)),
              typeof b.componentDidUpdate == 'function' && (a.flags |= 4),
              typeof b.getSnapshotBeforeUpdate == 'function' && (a.flags |= 1024))
            : (typeof b.componentDidUpdate != 'function' ||
                (O === r.memoizedProps && mt === r.memoizedState) ||
                (a.flags |= 4),
              typeof b.getSnapshotBeforeUpdate != 'function' ||
                (O === r.memoizedProps && mt === r.memoizedState) ||
                (a.flags |= 1024),
              (a.memoizedProps = f),
              (a.memoizedState = It)),
          (b.props = f),
          (b.state = It),
          (b.context = K),
          (f = Ot))
        : (typeof b.componentDidUpdate != 'function' ||
            (O === r.memoizedProps && mt === r.memoizedState) ||
            (a.flags |= 4),
          typeof b.getSnapshotBeforeUpdate != 'function' ||
            (O === r.memoizedProps && mt === r.memoizedState) ||
            (a.flags |= 1024),
          (f = !1))
    }
    return (
      (b = f),
      Wc(r, a),
      (f = (a.flags & 128) !== 0),
      b || f
        ? ((b = a.stateNode),
          (l = f && typeof l.getDerivedStateFromError != 'function' ? null : b.render()),
          (a.flags |= 1),
          r !== null && f
            ? ((a.child = jo(a, r.child, null, m)), (a.child = jo(a, null, l, m)))
            : Yn(r, a, l, m),
          (a.memoizedState = b.state),
          (r = a.child))
        : (r = fa(r, a, m)),
      r
    )
  }
  function xy(r, a, l, f) {
    return (jl(), (a.flags |= 256), Yn(r, a, l, f), a.child)
  }
  var Gd = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }
  function Zd(r) {
    return { baseLanes: r, cachePool: f0() }
  }
  function Ud(r, a, l) {
    return ((r = r !== null ? r.childLanes & ~l : 0), a && (r |= er), r)
  }
  function Sy(r, a, l) {
    var f = a.pendingProps,
      m = !1,
      b = (a.flags & 128) !== 0,
      O
    if (
      ((O = b) || (O = r !== null && r.memoizedState === null ? !1 : (Mn.current & 2) !== 0),
      O && ((m = !0), (a.flags &= -129)),
      (O = (a.flags & 32) !== 0),
      (a.flags &= -33),
      r === null)
    ) {
      if (je) {
        if ((m ? Ua(a) : Ya(), je)) {
          var j = un,
            K
          if ((K = j)) {
            t: {
              for (K = j, j = Pr; K.nodeType !== 8; ) {
                if (!j) {
                  j = null
                  break t
                }
                if (((K = Nr(K.nextSibling)), K === null)) {
                  j = null
                  break t
                }
              }
              j = K
            }
            j !== null
              ? ((a.memoizedState = {
                  dehydrated: j,
                  treeContext: ks !== null ? { id: aa, overflow: sa } : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (K = Di(18, null, null, 0)),
                (K.stateNode = j),
                (K.return = a),
                (a.child = K),
                (ri = a),
                (un = null),
                (K = !0))
              : (K = !1)
          }
          K || js(a)
        }
        if (((j = a.memoizedState), j !== null && ((j = j.dehydrated), j !== null)))
          return (Sg(j) ? (a.lanes = 32) : (a.lanes = 536870912), null)
        ca(a)
      }
      return (
        (j = f.children),
        (f = f.fallback),
        m
          ? (Ya(),
            (m = a.mode),
            (j = Fc({ mode: 'hidden', children: j }, m)),
            (f = Rs(f, m, l, null)),
            (j.return = a),
            (f.return = a),
            (j.sibling = f),
            (a.child = j),
            (m = a.child),
            (m.memoizedState = Zd(l)),
            (m.childLanes = Ud(r, O, l)),
            (a.memoizedState = Gd),
            f)
          : (Ua(a), Yd(a, j))
      )
    }
    if (((K = r.memoizedState), K !== null && ((j = K.dehydrated), j !== null))) {
      if (b)
        a.flags & 256
          ? (Ua(a), (a.flags &= -257), (a = Hd(r, a, l)))
          : a.memoizedState !== null
            ? (Ya(), (a.child = r.child), (a.flags |= 128), (a = null))
            : (Ya(),
              (m = f.fallback),
              (j = a.mode),
              (f = Fc({ mode: 'visible', children: f.children }, j)),
              (m = Rs(m, j, l, null)),
              (m.flags |= 2),
              (f.return = a),
              (m.return = a),
              (f.sibling = m),
              (a.child = f),
              jo(a, r.child, null, l),
              (f = a.child),
              (f.memoizedState = Zd(l)),
              (f.childLanes = Ud(r, O, l)),
              (a.memoizedState = Gd),
              (a = m))
      else if ((Ua(a), Sg(j))) {
        if (((O = j.nextSibling && j.nextSibling.dataset), O)) var pt = O.dgst
        ;((O = pt),
          (f = Error(i(419))),
          (f.stack = ''),
          (f.digest = O),
          Pl({ value: f, source: null, stack: null }),
          (a = Hd(r, a, l)))
      } else if ((jn || Gl(r, a, l, !1), (O = (l & r.childLanes) !== 0), jn || O)) {
        if (
          ((O = tn),
          O !== null &&
            ((f = l & -l),
            (f = (f & 42) !== 0 ? 1 : zn(f)),
            (f = (f & (O.suspendedLanes | l)) !== 0 ? 0 : f),
            f !== 0 && f !== K.retryLane))
        )
          throw ((K.retryLane = f), To(r, f), ki(O, r, f), vy)
        ;(j.data === '$?' || lg(), (a = Hd(r, a, l)))
      } else
        j.data === '$?'
          ? ((a.flags |= 192), (a.child = r.child), (a = null))
          : ((r = K.treeContext),
            (un = Nr(j.nextSibling)),
            (ri = a),
            (je = !0),
            (Bs = null),
            (Pr = !1),
            r !== null &&
              ((Ki[$i++] = aa),
              (Ki[$i++] = sa),
              (Ki[$i++] = ks),
              (aa = r.id),
              (sa = r.overflow),
              (ks = a)),
            (a = Yd(a, f.children)),
            (a.flags |= 4096))
      return a
    }
    return m
      ? (Ya(),
        (m = f.fallback),
        (j = a.mode),
        (K = r.child),
        (pt = K.sibling),
        (f = ra(K, { mode: 'hidden', children: f.children })),
        (f.subtreeFlags = K.subtreeFlags & 65011712),
        pt !== null ? (m = ra(pt, m)) : ((m = Rs(m, j, l, null)), (m.flags |= 2)),
        (m.return = a),
        (f.return = a),
        (f.sibling = m),
        (a.child = f),
        (f = m),
        (m = a.child),
        (j = r.child.memoizedState),
        j === null
          ? (j = Zd(l))
          : ((K = j.cachePool),
            K !== null
              ? ((pt = Tn._currentValue), (K = K.parent !== pt ? { parent: pt, pool: pt } : K))
              : (K = f0()),
            (j = { baseLanes: j.baseLanes | l, cachePool: K })),
        (m.memoizedState = j),
        (m.childLanes = Ud(r, O, l)),
        (a.memoizedState = Gd),
        f)
      : (Ua(a),
        (l = r.child),
        (r = l.sibling),
        (l = ra(l, { mode: 'visible', children: f.children })),
        (l.return = a),
        (l.sibling = null),
        r !== null &&
          ((O = a.deletions), O === null ? ((a.deletions = [r]), (a.flags |= 16)) : O.push(r)),
        (a.child = l),
        (a.memoizedState = null),
        l)
  }
  function Yd(r, a) {
    return ((a = Fc({ mode: 'visible', children: a }, r.mode)), (a.return = r), (r.child = a))
  }
  function Fc(r, a) {
    return (
      (r = Di(22, r, null, a)),
      (r.lanes = 0),
      (r.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null,
      }),
      r
    )
  }
  function Hd(r, a, l) {
    return (
      jo(a, r.child, null, l),
      (r = Yd(a, a.pendingProps.children)),
      (r.flags |= 2),
      (a.memoizedState = null),
      r
    )
  }
  function Ny(r, a, l) {
    r.lanes |= a
    var f = r.alternate
    ;(f !== null && (f.lanes |= a), ld(r.return, a, l))
  }
  function Vd(r, a, l, f, m) {
    var b = r.memoizedState
    b === null
      ? (r.memoizedState = {
          isBackwards: a,
          rendering: null,
          renderingStartTime: 0,
          last: f,
          tail: l,
          tailMode: m,
        })
      : ((b.isBackwards = a),
        (b.rendering = null),
        (b.renderingStartTime = 0),
        (b.last = f),
        (b.tail = l),
        (b.tailMode = m))
  }
  function Ty(r, a, l) {
    var f = a.pendingProps,
      m = f.revealOrder,
      b = f.tail
    if ((Yn(r, a, f.children, l), (f = Mn.current), (f & 2) !== 0))
      ((f = (f & 1) | 2), (a.flags |= 128))
    else {
      if (r !== null && (r.flags & 128) !== 0)
        t: for (r = a.child; r !== null; ) {
          if (r.tag === 13) r.memoizedState !== null && Ny(r, l, a)
          else if (r.tag === 19) Ny(r, l, a)
          else if (r.child !== null) {
            ;((r.child.return = r), (r = r.child))
            continue
          }
          if (r === a) break t
          for (; r.sibling === null; ) {
            if (r.return === null || r.return === a) break t
            r = r.return
          }
          ;((r.sibling.return = r.return), (r = r.sibling))
        }
      f &= 1
    }
    switch ((St(Mn, f), m)) {
      case 'forwards':
        for (l = a.child, m = null; l !== null; )
          ((r = l.alternate), r !== null && Hc(r) === null && (m = l), (l = l.sibling))
        ;((l = m),
          l === null ? ((m = a.child), (a.child = null)) : ((m = l.sibling), (l.sibling = null)),
          Vd(a, !1, m, l, b))
        break
      case 'backwards':
        for (l = null, m = a.child, a.child = null; m !== null; ) {
          if (((r = m.alternate), r !== null && Hc(r) === null)) {
            a.child = m
            break
          }
          ;((r = m.sibling), (m.sibling = l), (l = m), (m = r))
        }
        Vd(a, !0, l, null, b)
        break
      case 'together':
        Vd(a, !1, null, null, void 0)
        break
      default:
        a.memoizedState = null
    }
    return a.child
  }
  function fa(r, a, l) {
    if (
      (r !== null && (a.dependencies = r.dependencies), (Fa |= a.lanes), (l & a.childLanes) === 0)
    )
      if (r !== null) {
        if ((Gl(r, a, l, !1), (l & a.childLanes) === 0)) return null
      } else return null
    if (r !== null && a.child !== r.child) throw Error(i(153))
    if (a.child !== null) {
      for (r = a.child, l = ra(r, r.pendingProps), a.child = l, l.return = a; r.sibling !== null; )
        ((r = r.sibling), (l = l.sibling = ra(r, r.pendingProps)), (l.return = a))
      l.sibling = null
    }
    return a.child
  }
  function Xd(r, a) {
    return (r.lanes & a) !== 0 ? !0 : ((r = r.dependencies), !!(r !== null && Mc(r)))
  }
  function oN(r, a, l) {
    switch (a.tag) {
      case 3:
        ;(Et(a, a.stateNode.containerInfo), Ba(a, Tn, r.memoizedState.cache), jl())
        break
      case 27:
      case 5:
        Qt(a)
        break
      case 4:
        Et(a, a.stateNode.containerInfo)
        break
      case 10:
        Ba(a, a.type, a.memoizedProps.value)
        break
      case 13:
        var f = a.memoizedState
        if (f !== null)
          return f.dehydrated !== null
            ? (Ua(a), (a.flags |= 128), null)
            : (l & a.child.childLanes) !== 0
              ? Sy(r, a, l)
              : (Ua(a), (r = fa(r, a, l)), r !== null ? r.sibling : null)
        Ua(a)
        break
      case 19:
        var m = (r.flags & 128) !== 0
        if (
          ((f = (l & a.childLanes) !== 0),
          f || (Gl(r, a, l, !1), (f = (l & a.childLanes) !== 0)),
          m)
        ) {
          if (f) return Ty(r, a, l)
          a.flags |= 128
        }
        if (
          ((m = a.memoizedState),
          m !== null && ((m.rendering = null), (m.tail = null), (m.lastEffect = null)),
          St(Mn, Mn.current),
          f)
        )
          break
        return null
      case 22:
      case 23:
        return ((a.lanes = 0), by(r, a, l))
      case 24:
        Ba(a, Tn, r.memoizedState.cache)
    }
    return fa(r, a, l)
  }
  function My(r, a, l) {
    if (r !== null)
      if (r.memoizedProps !== a.pendingProps) jn = !0
      else {
        if (!Xd(r, l) && (a.flags & 128) === 0) return ((jn = !1), oN(r, a, l))
        jn = (r.flags & 131072) !== 0
      }
    else ((jn = !1), je && (a.flags & 1048576) !== 0 && r0(a, Tc, a.index))
    switch (((a.lanes = 0), a.tag)) {
      case 16:
        t: {
          r = a.pendingProps
          var f = a.elementType,
            m = f._init
          if (((f = m(f._payload)), (a.type = f), typeof f == 'function'))
            ed(f)
              ? ((r = Ys(f, r)), (a.tag = 1), (a = wy(null, a, f, r, l)))
              : ((a.tag = 0), (a = Pd(null, a, f, r, l)))
          else {
            if (f != null) {
              if (((m = f.$$typeof), m === Z)) {
                ;((a.tag = 11), (a = my(null, a, f, r, l)))
                break t
              } else if (m === g) {
                ;((a.tag = 14), (a = yy(null, a, f, r, l)))
                break t
              }
            }
            throw ((a = Ct(f) || f), Error(i(306, a, '')))
          }
        }
        return a
      case 0:
        return Pd(r, a, a.type, a.pendingProps, l)
      case 1:
        return ((f = a.type), (m = Ys(f, a.pendingProps)), wy(r, a, f, m, l))
      case 3:
        t: {
          if ((Et(a, a.stateNode.containerInfo), r === null)) throw Error(i(387))
          f = a.pendingProps
          var b = a.memoizedState
          ;((m = b.element), pd(r, a), Wl(a, f, null, l))
          var O = a.memoizedState
          if (
            ((f = O.cache),
            Ba(a, Tn, f),
            f !== b.cache && ud(a, [Tn], l, !0),
            Xl(),
            (f = O.element),
            b.isDehydrated)
          )
            if (
              ((b = { element: f, isDehydrated: !1, cache: O.cache }),
              (a.updateQueue.baseState = b),
              (a.memoizedState = b),
              a.flags & 256)
            ) {
              a = xy(r, a, f, l)
              break t
            } else if (f !== m) {
              ;((m = qi(Error(i(424)), a)), Pl(m), (a = xy(r, a, f, l)))
              break t
            } else {
              switch (((r = a.stateNode.containerInfo), r.nodeType)) {
                case 9:
                  r = r.body
                  break
                default:
                  r = r.nodeName === 'HTML' ? r.ownerDocument.body : r
              }
              for (
                un = Nr(r.firstChild),
                  ri = a,
                  je = !0,
                  Bs = null,
                  Pr = !0,
                  l = sy(a, null, f, l),
                  a.child = l;
                l;

              )
                ((l.flags = (l.flags & -3) | 4096), (l = l.sibling))
            }
          else {
            if ((jl(), f === m)) {
              a = fa(r, a, l)
              break t
            }
            Yn(r, a, f, l)
          }
          a = a.child
        }
        return a
      case 26:
        return (
          Wc(r, a),
          r === null
            ? (l = LA(a.type, null, a.pendingProps, null))
              ? (a.memoizedState = l)
              : je ||
                ((l = a.type),
                (r = a.pendingProps),
                (f = uf(lt.current).createElement(l)),
                (f[sn] = a),
                (f[gn] = r),
                Vn(f, l, r),
                pn(f),
                (a.stateNode = f))
            : (a.memoizedState = LA(a.type, r.memoizedProps, a.pendingProps, r.memoizedState)),
          null
        )
      case 27:
        return (
          Qt(a),
          r === null &&
            je &&
            ((f = a.stateNode = EA(a.type, a.pendingProps, lt.current)),
            (ri = a),
            (Pr = !0),
            (m = un),
            Ka(a.type) ? ((Ng = m), (un = Nr(f.firstChild))) : (un = m)),
          Yn(r, a, a.pendingProps.children, l),
          Wc(r, a),
          r === null && (a.flags |= 4194304),
          a.child
        )
      case 5:
        return (
          r === null &&
            je &&
            ((m = f = un) &&
              ((f = kN(f, a.type, a.pendingProps, Pr)),
              f !== null
                ? ((a.stateNode = f), (ri = a), (un = Nr(f.firstChild)), (Pr = !1), (m = !0))
                : (m = !1)),
            m || js(a)),
          Qt(a),
          (m = a.type),
          (b = a.pendingProps),
          (O = r !== null ? r.memoizedProps : null),
          (f = b.children),
          Cg(m, b) ? (f = null) : O !== null && Cg(m, O) && (a.flags |= 32),
          a.memoizedState !== null && ((m = Id(r, a, $S, null, null, l)), (pu._currentValue = m)),
          Wc(r, a),
          Yn(r, a, f, l),
          a.child
        )
      case 6:
        return (
          r === null &&
            je &&
            ((r = l = un) &&
              ((l = _N(l, a.pendingProps, Pr)),
              l !== null ? ((a.stateNode = l), (ri = a), (un = null), (r = !0)) : (r = !1)),
            r || js(a)),
          null
        )
      case 13:
        return Sy(r, a, l)
      case 4:
        return (
          Et(a, a.stateNode.containerInfo),
          (f = a.pendingProps),
          r === null ? (a.child = jo(a, null, f, l)) : Yn(r, a, f, l),
          a.child
        )
      case 11:
        return my(r, a, a.type, a.pendingProps, l)
      case 7:
        return (Yn(r, a, a.pendingProps, l), a.child)
      case 8:
        return (Yn(r, a, a.pendingProps.children, l), a.child)
      case 12:
        return (Yn(r, a, a.pendingProps.children, l), a.child)
      case 10:
        return ((f = a.pendingProps), Ba(a, a.type, f.value), Yn(r, a, f.children, l), a.child)
      case 9:
        return (
          (m = a.type._context),
          (f = a.pendingProps.children),
          Gs(a),
          (m = Qn(m)),
          (f = f(m)),
          (a.flags |= 1),
          Yn(r, a, f, l),
          a.child
        )
      case 14:
        return yy(r, a, a.type, a.pendingProps, l)
      case 15:
        return Ay(r, a, a.type, a.pendingProps, l)
      case 19:
        return Ty(r, a, l)
      case 31:
        return (
          (f = a.pendingProps),
          (l = a.mode),
          (f = { mode: f.mode, children: f.children }),
          r === null
            ? ((l = Fc(f, l)), (l.ref = a.ref), (a.child = l), (l.return = a), (a = l))
            : ((l = ra(r.child, f)), (l.ref = a.ref), (a.child = l), (l.return = a), (a = l)),
          a
        )
      case 22:
        return by(r, a, l)
      case 24:
        return (
          Gs(a),
          (f = Qn(Tn)),
          r === null
            ? ((m = hd()),
              m === null &&
                ((m = tn),
                (b = cd()),
                (m.pooledCache = b),
                b.refCount++,
                b !== null && (m.pooledCacheLanes |= l),
                (m = b)),
              (a.memoizedState = { parent: f, cache: m }),
              gd(a),
              Ba(a, Tn, m))
            : ((r.lanes & l) !== 0 && (pd(r, a), Wl(a, null, null, l), Xl()),
              (m = r.memoizedState),
              (b = a.memoizedState),
              m.parent !== f
                ? ((m = { parent: f, cache: f }),
                  (a.memoizedState = m),
                  a.lanes === 0 && (a.memoizedState = a.updateQueue.baseState = m),
                  Ba(a, Tn, f))
                : ((f = b.cache), Ba(a, Tn, f), f !== m.cache && ud(a, [Tn], l, !0))),
          Yn(r, a, a.pendingProps.children, l),
          a.child
        )
      case 29:
        throw a.pendingProps
    }
    throw Error(i(156, a.tag))
  }
  function ha(r) {
    r.flags |= 4
  }
  function Ey(r, a) {
    if (a.type !== 'stylesheet' || (a.state.loading & 4) !== 0) r.flags &= -16777217
    else if (((r.flags |= 16777216), !BA(a))) {
      if (
        ((a = tr.current),
        a !== null &&
          ((Re & 4194048) === Re
            ? Gr !== null
            : ((Re & 62914560) !== Re && (Re & 536870912) === 0) || a !== Gr))
      )
        throw ((Hl = dd), h0)
      r.flags |= 8192
    }
  }
  function Jc(r, a) {
    ;(a !== null && (r.flags |= 4),
      r.flags & 16384 && ((a = r.tag !== 22 ? hr() : 536870912), (r.lanes |= a), (Uo |= a)))
  }
  function tu(r, a) {
    if (!je)
      switch (r.tailMode) {
        case 'hidden':
          a = r.tail
          for (var l = null; a !== null; ) (a.alternate !== null && (l = a), (a = a.sibling))
          l === null ? (r.tail = null) : (l.sibling = null)
          break
        case 'collapsed':
          l = r.tail
          for (var f = null; l !== null; ) (l.alternate !== null && (f = l), (l = l.sibling))
          f === null
            ? a || r.tail === null
              ? (r.tail = null)
              : (r.tail.sibling = null)
            : (f.sibling = null)
      }
  }
  function on(r) {
    var a = r.alternate !== null && r.alternate.child === r.child,
      l = 0,
      f = 0
    if (a)
      for (var m = r.child; m !== null; )
        ((l |= m.lanes | m.childLanes),
          (f |= m.subtreeFlags & 65011712),
          (f |= m.flags & 65011712),
          (m.return = r),
          (m = m.sibling))
    else
      for (m = r.child; m !== null; )
        ((l |= m.lanes | m.childLanes),
          (f |= m.subtreeFlags),
          (f |= m.flags),
          (m.return = r),
          (m = m.sibling))
    return ((r.subtreeFlags |= f), (r.childLanes = l), a)
  }
  function lN(r, a, l) {
    var f = a.pendingProps
    switch ((ad(a), a.tag)) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return (on(a), null)
      case 1:
        return (on(a), null)
      case 3:
        return (
          (l = a.stateNode),
          (f = null),
          r !== null && (f = r.memoizedState.cache),
          a.memoizedState.cache !== f && (a.flags |= 2048),
          la(Tn),
          Ft(),
          l.pendingContext && ((l.context = l.pendingContext), (l.pendingContext = null)),
          (r === null || r.child === null) &&
            (Bl(a)
              ? ha(a)
              : r === null ||
                (r.memoizedState.isDehydrated && (a.flags & 256) === 0) ||
                ((a.flags |= 1024), o0())),
          on(a),
          null
        )
      case 26:
        return (
          (l = a.memoizedState),
          r === null
            ? (ha(a), l !== null ? (on(a), Ey(a, l)) : (on(a), (a.flags &= -16777217)))
            : l
              ? l !== r.memoizedState
                ? (ha(a), on(a), Ey(a, l))
                : (on(a), (a.flags &= -16777217))
              : (r.memoizedProps !== f && ha(a), on(a), (a.flags &= -16777217)),
          null
        )
      case 27:
        ;(qt(a), (l = lt.current))
        var m = a.type
        if (r !== null && a.stateNode != null) r.memoizedProps !== f && ha(a)
        else {
          if (!f) {
            if (a.stateNode === null) throw Error(i(166))
            return (on(a), null)
          }
          ;((r = bt.current), Bl(a) ? a0(a) : ((r = EA(m, f, l)), (a.stateNode = r), ha(a)))
        }
        return (on(a), null)
      case 5:
        if ((qt(a), (l = a.type), r !== null && a.stateNode != null)) r.memoizedProps !== f && ha(a)
        else {
          if (!f) {
            if (a.stateNode === null) throw Error(i(166))
            return (on(a), null)
          }
          if (((r = bt.current), Bl(a))) a0(a)
          else {
            switch (((m = uf(lt.current)), r)) {
              case 1:
                r = m.createElementNS('http://www.w3.org/2000/svg', l)
                break
              case 2:
                r = m.createElementNS('http://www.w3.org/1998/Math/MathML', l)
                break
              default:
                switch (l) {
                  case 'svg':
                    r = m.createElementNS('http://www.w3.org/2000/svg', l)
                    break
                  case 'math':
                    r = m.createElementNS('http://www.w3.org/1998/Math/MathML', l)
                    break
                  case 'script':
                    ;((r = m.createElement('div')),
                      (r.innerHTML = '<script><\/script>'),
                      (r = r.removeChild(r.firstChild)))
                    break
                  case 'select':
                    ;((r =
                      typeof f.is == 'string'
                        ? m.createElement('select', { is: f.is })
                        : m.createElement('select')),
                      f.multiple ? (r.multiple = !0) : f.size && (r.size = f.size))
                    break
                  default:
                    r =
                      typeof f.is == 'string'
                        ? m.createElement(l, { is: f.is })
                        : m.createElement(l)
                }
            }
            ;((r[sn] = a), (r[gn] = f))
            t: for (m = a.child; m !== null; ) {
              if (m.tag === 5 || m.tag === 6) r.appendChild(m.stateNode)
              else if (m.tag !== 4 && m.tag !== 27 && m.child !== null) {
                ;((m.child.return = m), (m = m.child))
                continue
              }
              if (m === a) break t
              for (; m.sibling === null; ) {
                if (m.return === null || m.return === a) break t
                m = m.return
              }
              ;((m.sibling.return = m.return), (m = m.sibling))
            }
            a.stateNode = r
            t: switch ((Vn(r, l, f), l)) {
              case 'button':
              case 'input':
              case 'select':
              case 'textarea':
                r = !!f.autoFocus
                break t
              case 'img':
                r = !0
                break t
              default:
                r = !1
            }
            r && ha(a)
          }
        }
        return (on(a), (a.flags &= -16777217), null)
      case 6:
        if (r && a.stateNode != null) r.memoizedProps !== f && ha(a)
        else {
          if (typeof f != 'string' && a.stateNode === null) throw Error(i(166))
          if (((r = lt.current), Bl(a))) {
            if (((r = a.stateNode), (l = a.memoizedProps), (f = null), (m = ri), m !== null))
              switch (m.tag) {
                case 27:
                case 5:
                  f = m.memoizedProps
              }
            ;((r[sn] = a),
              (r = !!(
                r.nodeValue === l ||
                (f !== null && f.suppressHydrationWarning === !0) ||
                CA(r.nodeValue, l)
              )),
              r || js(a))
          } else ((r = uf(r).createTextNode(f)), (r[sn] = a), (a.stateNode = r))
        }
        return (on(a), null)
      case 13:
        if (
          ((f = a.memoizedState),
          r === null || (r.memoizedState !== null && r.memoizedState.dehydrated !== null))
        ) {
          if (((m = Bl(a)), f !== null && f.dehydrated !== null)) {
            if (r === null) {
              if (!m) throw Error(i(318))
              if (((m = a.memoizedState), (m = m !== null ? m.dehydrated : null), !m))
                throw Error(i(317))
              m[sn] = a
            } else (jl(), (a.flags & 128) === 0 && (a.memoizedState = null), (a.flags |= 4))
            ;(on(a), (m = !1))
          } else
            ((m = o0()),
              r !== null && r.memoizedState !== null && (r.memoizedState.hydrationErrors = m),
              (m = !0))
          if (!m) return a.flags & 256 ? (ca(a), a) : (ca(a), null)
        }
        if ((ca(a), (a.flags & 128) !== 0)) return ((a.lanes = l), a)
        if (((l = f !== null), (r = r !== null && r.memoizedState !== null), l)) {
          ;((f = a.child),
            (m = null),
            f.alternate !== null &&
              f.alternate.memoizedState !== null &&
              f.alternate.memoizedState.cachePool !== null &&
              (m = f.alternate.memoizedState.cachePool.pool))
          var b = null
          ;(f.memoizedState !== null &&
            f.memoizedState.cachePool !== null &&
            (b = f.memoizedState.cachePool.pool),
            b !== m && (f.flags |= 2048))
        }
        return (l !== r && l && (a.child.flags |= 8192), Jc(a, a.updateQueue), on(a), null)
      case 4:
        return (Ft(), r === null && mg(a.stateNode.containerInfo), on(a), null)
      case 10:
        return (la(a.type), on(a), null)
      case 19:
        if ((ct(Mn), (m = a.memoizedState), m === null)) return (on(a), null)
        if (((f = (a.flags & 128) !== 0), (b = m.rendering), b === null))
          if (f) tu(m, !1)
          else {
            if (cn !== 0 || (r !== null && (r.flags & 128) !== 0))
              for (r = a.child; r !== null; ) {
                if (((b = Hc(r)), b !== null)) {
                  for (
                    a.flags |= 128,
                      tu(m, !1),
                      r = b.updateQueue,
                      a.updateQueue = r,
                      Jc(a, r),
                      a.subtreeFlags = 0,
                      r = l,
                      l = a.child;
                    l !== null;

                  )
                    (i0(l, r), (l = l.sibling))
                  return (St(Mn, (Mn.current & 1) | 2), a.child)
                }
                r = r.sibling
              }
            m.tail !== null &&
              J() > Kc &&
              ((a.flags |= 128), (f = !0), tu(m, !1), (a.lanes = 4194304))
          }
        else {
          if (!f)
            if (((r = Hc(b)), r !== null)) {
              if (
                ((a.flags |= 128),
                (f = !0),
                (r = r.updateQueue),
                (a.updateQueue = r),
                Jc(a, r),
                tu(m, !0),
                m.tail === null && m.tailMode === 'hidden' && !b.alternate && !je)
              )
                return (on(a), null)
            } else
              2 * J() - m.renderingStartTime > Kc &&
                l !== 536870912 &&
                ((a.flags |= 128), (f = !0), tu(m, !1), (a.lanes = 4194304))
          m.isBackwards
            ? ((b.sibling = a.child), (a.child = b))
            : ((r = m.last), r !== null ? (r.sibling = b) : (a.child = b), (m.last = b))
        }
        return m.tail !== null
          ? ((a = m.tail),
            (m.rendering = a),
            (m.tail = a.sibling),
            (m.renderingStartTime = J()),
            (a.sibling = null),
            (r = Mn.current),
            St(Mn, f ? (r & 1) | 2 : r & 1),
            a)
          : (on(a), null)
      case 22:
      case 23:
        return (
          ca(a),
          Ad(),
          (f = a.memoizedState !== null),
          r !== null
            ? (r.memoizedState !== null) !== f && (a.flags |= 8192)
            : f && (a.flags |= 8192),
          f
            ? (l & 536870912) !== 0 &&
              (a.flags & 128) === 0 &&
              (on(a), a.subtreeFlags & 6 && (a.flags |= 8192))
            : on(a),
          (l = a.updateQueue),
          l !== null && Jc(a, l.retryQueue),
          (l = null),
          r !== null &&
            r.memoizedState !== null &&
            r.memoizedState.cachePool !== null &&
            (l = r.memoizedState.cachePool.pool),
          (f = null),
          a.memoizedState !== null &&
            a.memoizedState.cachePool !== null &&
            (f = a.memoizedState.cachePool.pool),
          f !== l && (a.flags |= 2048),
          r !== null && ct(Zs),
          null
        )
      case 24:
        return (
          (l = null),
          r !== null && (l = r.memoizedState.cache),
          a.memoizedState.cache !== l && (a.flags |= 2048),
          la(Tn),
          on(a),
          null
        )
      case 25:
        return null
      case 30:
        return null
    }
    throw Error(i(156, a.tag))
  }
  function uN(r, a) {
    switch ((ad(a), a.tag)) {
      case 1:
        return ((r = a.flags), r & 65536 ? ((a.flags = (r & -65537) | 128), a) : null)
      case 3:
        return (
          la(Tn),
          Ft(),
          (r = a.flags),
          (r & 65536) !== 0 && (r & 128) === 0 ? ((a.flags = (r & -65537) | 128), a) : null
        )
      case 26:
      case 27:
      case 5:
        return (qt(a), null)
      case 13:
        if ((ca(a), (r = a.memoizedState), r !== null && r.dehydrated !== null)) {
          if (a.alternate === null) throw Error(i(340))
          jl()
        }
        return ((r = a.flags), r & 65536 ? ((a.flags = (r & -65537) | 128), a) : null)
      case 19:
        return (ct(Mn), null)
      case 4:
        return (Ft(), null)
      case 10:
        return (la(a.type), null)
      case 22:
      case 23:
        return (
          ca(a),
          Ad(),
          r !== null && ct(Zs),
          (r = a.flags),
          r & 65536 ? ((a.flags = (r & -65537) | 128), a) : null
        )
      case 24:
        return (la(Tn), null)
      case 25:
        return null
      default:
        return null
    }
  }
  function Dy(r, a) {
    switch ((ad(a), a.tag)) {
      case 3:
        ;(la(Tn), Ft())
        break
      case 26:
      case 27:
      case 5:
        qt(a)
        break
      case 4:
        Ft()
        break
      case 13:
        ca(a)
        break
      case 19:
        ct(Mn)
        break
      case 10:
        la(a.type)
        break
      case 22:
      case 23:
        ;(ca(a), Ad(), r !== null && ct(Zs))
        break
      case 24:
        la(Tn)
    }
  }
  function eu(r, a) {
    try {
      var l = a.updateQueue,
        f = l !== null ? l.lastEffect : null
      if (f !== null) {
        var m = f.next
        l = m
        do {
          if ((l.tag & r) === r) {
            f = void 0
            var b = l.create,
              O = l.inst
            ;((f = b()), (O.destroy = f))
          }
          l = l.next
        } while (l !== m)
      }
    } catch (j) {
      Ke(a, a.return, j)
    }
  }
  function Ha(r, a, l) {
    try {
      var f = a.updateQueue,
        m = f !== null ? f.lastEffect : null
      if (m !== null) {
        var b = m.next
        f = b
        do {
          if ((f.tag & r) === r) {
            var O = f.inst,
              j = O.destroy
            if (j !== void 0) {
              ;((O.destroy = void 0), (m = a))
              var K = l,
                pt = j
              try {
                pt()
              } catch (Ot) {
                Ke(m, K, Ot)
              }
            }
          }
          f = f.next
        } while (f !== b)
      }
    } catch (Ot) {
      Ke(a, a.return, Ot)
    }
  }
  function Oy(r) {
    var a = r.updateQueue
    if (a !== null) {
      var l = r.stateNode
      try {
        y0(a, l)
      } catch (f) {
        Ke(r, r.return, f)
      }
    }
  }
  function Ly(r, a, l) {
    ;((l.props = Ys(r.type, r.memoizedProps)), (l.state = r.memoizedState))
    try {
      l.componentWillUnmount()
    } catch (f) {
      Ke(r, a, f)
    }
  }
  function nu(r, a) {
    try {
      var l = r.ref
      if (l !== null) {
        switch (r.tag) {
          case 26:
          case 27:
          case 5:
            var f = r.stateNode
            break
          case 30:
            f = r.stateNode
            break
          default:
            f = r.stateNode
        }
        typeof l == 'function' ? (r.refCleanup = l(f)) : (l.current = f)
      }
    } catch (m) {
      Ke(r, a, m)
    }
  }
  function Zr(r, a) {
    var l = r.ref,
      f = r.refCleanup
    if (l !== null)
      if (typeof f == 'function')
        try {
          f()
        } catch (m) {
          Ke(r, a, m)
        } finally {
          ;((r.refCleanup = null), (r = r.alternate), r != null && (r.refCleanup = null))
        }
      else if (typeof l == 'function')
        try {
          l(null)
        } catch (m) {
          Ke(r, a, m)
        }
      else l.current = null
  }
  function zy(r) {
    var a = r.type,
      l = r.memoizedProps,
      f = r.stateNode
    try {
      t: switch (a) {
        case 'button':
        case 'input':
        case 'select':
        case 'textarea':
          l.autoFocus && f.focus()
          break t
        case 'img':
          l.src ? (f.src = l.src) : l.srcSet && (f.srcset = l.srcSet)
      }
    } catch (m) {
      Ke(r, r.return, m)
    }
  }
  function Wd(r, a, l) {
    try {
      var f = r.stateNode
      ;(DN(f, r.type, l, a), (f[gn] = a))
    } catch (m) {
      Ke(r, r.return, m)
    }
  }
  function Ry(r) {
    return r.tag === 5 || r.tag === 3 || r.tag === 26 || (r.tag === 27 && Ka(r.type)) || r.tag === 4
  }
  function Fd(r) {
    t: for (;;) {
      for (; r.sibling === null; ) {
        if (r.return === null || Ry(r.return)) return null
        r = r.return
      }
      for (
        r.sibling.return = r.return, r = r.sibling;
        r.tag !== 5 && r.tag !== 6 && r.tag !== 18;

      ) {
        if ((r.tag === 27 && Ka(r.type)) || r.flags & 2 || r.child === null || r.tag === 4)
          continue t
        ;((r.child.return = r), (r = r.child))
      }
      if (!(r.flags & 2)) return r.stateNode
    }
  }
  function Jd(r, a, l) {
    var f = r.tag
    if (f === 5 || f === 6)
      ((r = r.stateNode),
        a
          ? (l.nodeType === 9
              ? l.body
              : l.nodeName === 'HTML'
                ? l.ownerDocument.body
                : l
            ).insertBefore(r, a)
          : ((a = l.nodeType === 9 ? l.body : l.nodeName === 'HTML' ? l.ownerDocument.body : l),
            a.appendChild(r),
            (l = l._reactRootContainer),
            l != null || a.onclick !== null || (a.onclick = lf)))
    else if (
      f !== 4 &&
      (f === 27 && Ka(r.type) && ((l = r.stateNode), (a = null)), (r = r.child), r !== null)
    )
      for (Jd(r, a, l), r = r.sibling; r !== null; ) (Jd(r, a, l), (r = r.sibling))
  }
  function qc(r, a, l) {
    var f = r.tag
    if (f === 5 || f === 6) ((r = r.stateNode), a ? l.insertBefore(r, a) : l.appendChild(r))
    else if (f !== 4 && (f === 27 && Ka(r.type) && (l = r.stateNode), (r = r.child), r !== null))
      for (qc(r, a, l), r = r.sibling; r !== null; ) (qc(r, a, l), (r = r.sibling))
  }
  function ky(r) {
    var a = r.stateNode,
      l = r.memoizedProps
    try {
      for (var f = r.type, m = a.attributes; m.length; ) a.removeAttributeNode(m[0])
      ;(Vn(a, f, l), (a[sn] = r), (a[gn] = l))
    } catch (b) {
      Ke(r, r.return, b)
    }
  }
  var da = !1,
    yn = !1,
    qd = !1,
    _y = typeof WeakSet == 'function' ? WeakSet : Set,
    Pn = null
  function cN(r, a) {
    if (((r = r.containerInfo), (bg = pf), (r = _l(r)), V(r))) {
      if ('selectionStart' in r) var l = { start: r.selectionStart, end: r.selectionEnd }
      else
        t: {
          l = ((l = r.ownerDocument) && l.defaultView) || window
          var f = l.getSelection && l.getSelection()
          if (f && f.rangeCount !== 0) {
            l = f.anchorNode
            var m = f.anchorOffset,
              b = f.focusNode
            f = f.focusOffset
            try {
              ;(l.nodeType, b.nodeType)
            } catch {
              l = null
              break t
            }
            var O = 0,
              j = -1,
              K = -1,
              pt = 0,
              Ot = 0,
              zt = r,
              mt = null
            e: for (;;) {
              for (
                var It;
                zt !== l || (m !== 0 && zt.nodeType !== 3) || (j = O + m),
                  zt !== b || (f !== 0 && zt.nodeType !== 3) || (K = O + f),
                  zt.nodeType === 3 && (O += zt.nodeValue.length),
                  (It = zt.firstChild) !== null;

              )
                ((mt = zt), (zt = It))
              for (;;) {
                if (zt === r) break e
                if (
                  (mt === l && ++pt === m && (j = O),
                  mt === b && ++Ot === f && (K = O),
                  (It = zt.nextSibling) !== null)
                )
                  break
                ;((zt = mt), (mt = zt.parentNode))
              }
              zt = It
            }
            l = j === -1 || K === -1 ? null : { start: j, end: K }
          } else l = null
        }
      l = l || { start: 0, end: 0 }
    } else l = null
    for (Ig = { focusedElem: r, selectionRange: l }, pf = !1, Pn = a; Pn !== null; )
      if (((a = Pn), (r = a.child), (a.subtreeFlags & 1024) !== 0 && r !== null))
        ((r.return = a), (Pn = r))
      else
        for (; Pn !== null; ) {
          switch (((a = Pn), (b = a.alternate), (r = a.flags), a.tag)) {
            case 0:
              break
            case 11:
            case 15:
              break
            case 1:
              if ((r & 1024) !== 0 && b !== null) {
                ;((r = void 0),
                  (l = a),
                  (m = b.memoizedProps),
                  (b = b.memoizedState),
                  (f = l.stateNode))
                try {
                  var le = Ys(l.type, m, l.elementType === l.type)
                  ;((r = f.getSnapshotBeforeUpdate(le, b)),
                    (f.__reactInternalSnapshotBeforeUpdate = r))
                } catch (ie) {
                  Ke(l, l.return, ie)
                }
              }
              break
            case 3:
              if ((r & 1024) !== 0) {
                if (((r = a.stateNode.containerInfo), (l = r.nodeType), l === 9)) xg(r)
                else if (l === 1)
                  switch (r.nodeName) {
                    case 'HEAD':
                    case 'HTML':
                    case 'BODY':
                      xg(r)
                      break
                    default:
                      r.textContent = ''
                  }
              }
              break
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break
            default:
              if ((r & 1024) !== 0) throw Error(i(163))
          }
          if (((r = a.sibling), r !== null)) {
            ;((r.return = a.return), (Pn = r))
            break
          }
          Pn = a.return
        }
  }
  function By(r, a, l) {
    var f = l.flags
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        ;(Va(r, l), f & 4 && eu(5, l))
        break
      case 1:
        if ((Va(r, l), f & 4))
          if (((r = l.stateNode), a === null))
            try {
              r.componentDidMount()
            } catch (O) {
              Ke(l, l.return, O)
            }
          else {
            var m = Ys(l.type, a.memoizedProps)
            a = a.memoizedState
            try {
              r.componentDidUpdate(m, a, r.__reactInternalSnapshotBeforeUpdate)
            } catch (O) {
              Ke(l, l.return, O)
            }
          }
        ;(f & 64 && Oy(l), f & 512 && nu(l, l.return))
        break
      case 3:
        if ((Va(r, l), f & 64 && ((r = l.updateQueue), r !== null))) {
          if (((a = null), l.child !== null))
            switch (l.child.tag) {
              case 27:
              case 5:
                a = l.child.stateNode
                break
              case 1:
                a = l.child.stateNode
            }
          try {
            y0(r, a)
          } catch (O) {
            Ke(l, l.return, O)
          }
        }
        break
      case 27:
        a === null && f & 4 && ky(l)
      case 26:
      case 5:
        ;(Va(r, l), a === null && f & 4 && zy(l), f & 512 && nu(l, l.return))
        break
      case 12:
        Va(r, l)
        break
      case 13:
        ;(Va(r, l),
          f & 4 && Gy(r, l),
          f & 64 &&
            ((r = l.memoizedState),
            r !== null && ((r = r.dehydrated), r !== null && ((l = AN.bind(null, l)), BN(r, l)))))
        break
      case 22:
        if (((f = l.memoizedState !== null || da), !f)) {
          ;((a = (a !== null && a.memoizedState !== null) || yn), (m = da))
          var b = yn
          ;((da = f),
            (yn = a) && !b ? Xa(r, l, (l.subtreeFlags & 8772) !== 0) : Va(r, l),
            (da = m),
            (yn = b))
        }
        break
      case 30:
        break
      default:
        Va(r, l)
    }
  }
  function jy(r) {
    var a = r.alternate
    ;(a !== null && ((r.alternate = null), jy(a)),
      (r.child = null),
      (r.deletions = null),
      (r.sibling = null),
      r.tag === 5 && ((a = r.stateNode), a !== null && Il(a)),
      (r.stateNode = null),
      (r.return = null),
      (r.dependencies = null),
      (r.memoizedProps = null),
      (r.memoizedState = null),
      (r.pendingProps = null),
      (r.stateNode = null),
      (r.updateQueue = null))
  }
  var rn = null,
    pi = !1
  function ga(r, a, l) {
    for (l = l.child; l !== null; ) (Py(r, a, l), (l = l.sibling))
  }
  function Py(r, a, l) {
    if (fe && typeof fe.onCommitFiberUnmount == 'function')
      try {
        fe.onCommitFiberUnmount(ae, l)
      } catch {}
    switch (l.tag) {
      case 26:
        ;(yn || Zr(l, a),
          ga(r, a, l),
          l.memoizedState
            ? l.memoizedState.count--
            : l.stateNode && ((l = l.stateNode), l.parentNode.removeChild(l)))
        break
      case 27:
        yn || Zr(l, a)
        var f = rn,
          m = pi
        ;(Ka(l.type) && ((rn = l.stateNode), (pi = !1)),
          ga(r, a, l),
          fu(l.stateNode),
          (rn = f),
          (pi = m))
        break
      case 5:
        yn || Zr(l, a)
      case 6:
        if (((f = rn), (m = pi), (rn = null), ga(r, a, l), (rn = f), (pi = m), rn !== null))
          if (pi)
            try {
              ;(rn.nodeType === 9
                ? rn.body
                : rn.nodeName === 'HTML'
                  ? rn.ownerDocument.body
                  : rn
              ).removeChild(l.stateNode)
            } catch (b) {
              Ke(l, a, b)
            }
          else
            try {
              rn.removeChild(l.stateNode)
            } catch (b) {
              Ke(l, a, b)
            }
        break
      case 18:
        rn !== null &&
          (pi
            ? ((r = rn),
              TA(
                r.nodeType === 9 ? r.body : r.nodeName === 'HTML' ? r.ownerDocument.body : r,
                l.stateNode
              ),
              Au(r))
            : TA(rn, l.stateNode))
        break
      case 4:
        ;((f = rn),
          (m = pi),
          (rn = l.stateNode.containerInfo),
          (pi = !0),
          ga(r, a, l),
          (rn = f),
          (pi = m))
        break
      case 0:
      case 11:
      case 14:
      case 15:
        ;(yn || Ha(2, l, a), yn || Ha(4, l, a), ga(r, a, l))
        break
      case 1:
        ;(yn ||
          (Zr(l, a), (f = l.stateNode), typeof f.componentWillUnmount == 'function' && Ly(l, a, f)),
          ga(r, a, l))
        break
      case 21:
        ga(r, a, l)
        break
      case 22:
        ;((yn = (f = yn) || l.memoizedState !== null), ga(r, a, l), (yn = f))
        break
      default:
        ga(r, a, l)
    }
  }
  function Gy(r, a) {
    if (
      a.memoizedState === null &&
      ((r = a.alternate),
      r !== null && ((r = r.memoizedState), r !== null && ((r = r.dehydrated), r !== null)))
    )
      try {
        Au(r)
      } catch (l) {
        Ke(a, a.return, l)
      }
  }
  function fN(r) {
    switch (r.tag) {
      case 13:
      case 19:
        var a = r.stateNode
        return (a === null && (a = r.stateNode = new _y()), a)
      case 22:
        return (
          (r = r.stateNode),
          (a = r._retryCache),
          a === null && (a = r._retryCache = new _y()),
          a
        )
      default:
        throw Error(i(435, r.tag))
    }
  }
  function Qd(r, a) {
    var l = fN(r)
    a.forEach(function (f) {
      var m = bN.bind(null, r, f)
      l.has(f) || (l.add(f), f.then(m, m))
    })
  }
  function Oi(r, a) {
    var l = a.deletions
    if (l !== null)
      for (var f = 0; f < l.length; f++) {
        var m = l[f],
          b = r,
          O = a,
          j = O
        t: for (; j !== null; ) {
          switch (j.tag) {
            case 27:
              if (Ka(j.type)) {
                ;((rn = j.stateNode), (pi = !1))
                break t
              }
              break
            case 5:
              ;((rn = j.stateNode), (pi = !1))
              break t
            case 3:
            case 4:
              ;((rn = j.stateNode.containerInfo), (pi = !0))
              break t
          }
          j = j.return
        }
        if (rn === null) throw Error(i(160))
        ;(Py(b, O, m),
          (rn = null),
          (pi = !1),
          (b = m.alternate),
          b !== null && (b.return = null),
          (m.return = null))
      }
    if (a.subtreeFlags & 13878) for (a = a.child; a !== null; ) (Zy(a, r), (a = a.sibling))
  }
  var Sr = null
  function Zy(r, a) {
    var l = r.alternate,
      f = r.flags
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ;(Oi(a, r), Li(r), f & 4 && (Ha(3, r, r.return), eu(3, r), Ha(5, r, r.return)))
        break
      case 1:
        ;(Oi(a, r),
          Li(r),
          f & 512 && (yn || l === null || Zr(l, l.return)),
          f & 64 &&
            da &&
            ((r = r.updateQueue),
            r !== null &&
              ((f = r.callbacks),
              f !== null &&
                ((l = r.shared.hiddenCallbacks),
                (r.shared.hiddenCallbacks = l === null ? f : l.concat(f))))))
        break
      case 26:
        var m = Sr
        if ((Oi(a, r), Li(r), f & 512 && (yn || l === null || Zr(l, l.return)), f & 4)) {
          var b = l !== null ? l.memoizedState : null
          if (((f = r.memoizedState), l === null))
            if (f === null)
              if (r.stateNode === null) {
                t: {
                  ;((f = r.type), (l = r.memoizedProps), (m = m.ownerDocument || m))
                  e: switch (f) {
                    case 'title':
                      ;((b = m.getElementsByTagName('title')[0]),
                        (!b ||
                          b[Ta] ||
                          b[sn] ||
                          b.namespaceURI === 'http://www.w3.org/2000/svg' ||
                          b.hasAttribute('itemprop')) &&
                          ((b = m.createElement(f)),
                          m.head.insertBefore(b, m.querySelector('head > title'))),
                        Vn(b, f, l),
                        (b[sn] = r),
                        pn(b),
                        (f = b))
                      break t
                    case 'link':
                      var O = kA('link', 'href', m).get(f + (l.href || ''))
                      if (O) {
                        for (var j = 0; j < O.length; j++)
                          if (
                            ((b = O[j]),
                            b.getAttribute('href') ===
                              (l.href == null || l.href === '' ? null : l.href) &&
                              b.getAttribute('rel') === (l.rel == null ? null : l.rel) &&
                              b.getAttribute('title') === (l.title == null ? null : l.title) &&
                              b.getAttribute('crossorigin') ===
                                (l.crossOrigin == null ? null : l.crossOrigin))
                          ) {
                            O.splice(j, 1)
                            break e
                          }
                      }
                      ;((b = m.createElement(f)), Vn(b, f, l), m.head.appendChild(b))
                      break
                    case 'meta':
                      if ((O = kA('meta', 'content', m).get(f + (l.content || '')))) {
                        for (j = 0; j < O.length; j++)
                          if (
                            ((b = O[j]),
                            b.getAttribute('content') ===
                              (l.content == null ? null : '' + l.content) &&
                              b.getAttribute('name') === (l.name == null ? null : l.name) &&
                              b.getAttribute('property') ===
                                (l.property == null ? null : l.property) &&
                              b.getAttribute('http-equiv') ===
                                (l.httpEquiv == null ? null : l.httpEquiv) &&
                              b.getAttribute('charset') === (l.charSet == null ? null : l.charSet))
                          ) {
                            O.splice(j, 1)
                            break e
                          }
                      }
                      ;((b = m.createElement(f)), Vn(b, f, l), m.head.appendChild(b))
                      break
                    default:
                      throw Error(i(468, f))
                  }
                  ;((b[sn] = r), pn(b), (f = b))
                }
                r.stateNode = f
              } else _A(m, r.type, r.stateNode)
            else r.stateNode = RA(m, f, r.memoizedProps)
          else
            b !== f
              ? (b === null
                  ? l.stateNode !== null && ((l = l.stateNode), l.parentNode.removeChild(l))
                  : b.count--,
                f === null ? _A(m, r.type, r.stateNode) : RA(m, f, r.memoizedProps))
              : f === null && r.stateNode !== null && Wd(r, r.memoizedProps, l.memoizedProps)
        }
        break
      case 27:
        ;(Oi(a, r),
          Li(r),
          f & 512 && (yn || l === null || Zr(l, l.return)),
          l !== null && f & 4 && Wd(r, r.memoizedProps, l.memoizedProps))
        break
      case 5:
        if ((Oi(a, r), Li(r), f & 512 && (yn || l === null || Zr(l, l.return)), r.flags & 32)) {
          m = r.stateNode
          try {
            za(m, '')
          } catch (It) {
            Ke(r, r.return, It)
          }
        }
        ;(f & 4 &&
          r.stateNode != null &&
          ((m = r.memoizedProps), Wd(r, m, l !== null ? l.memoizedProps : m)),
          f & 1024 && (qd = !0))
        break
      case 6:
        if ((Oi(a, r), Li(r), f & 4)) {
          if (r.stateNode === null) throw Error(i(162))
          ;((f = r.memoizedProps), (l = r.stateNode))
          try {
            l.nodeValue = f
          } catch (It) {
            Ke(r, r.return, It)
          }
        }
        break
      case 3:
        if (
          ((hf = null),
          (m = Sr),
          (Sr = cf(a.containerInfo)),
          Oi(a, r),
          (Sr = m),
          Li(r),
          f & 4 && l !== null && l.memoizedState.isDehydrated)
        )
          try {
            Au(a.containerInfo)
          } catch (It) {
            Ke(r, r.return, It)
          }
        qd && ((qd = !1), Uy(r))
        break
      case 4:
        ;((f = Sr), (Sr = cf(r.stateNode.containerInfo)), Oi(a, r), Li(r), (Sr = f))
        break
      case 12:
        ;(Oi(a, r), Li(r))
        break
      case 13:
        ;(Oi(a, r),
          Li(r),
          r.child.flags & 8192 &&
            (r.memoizedState !== null) != (l !== null && l.memoizedState !== null) &&
            (ig = J()),
          f & 4 && ((f = r.updateQueue), f !== null && ((r.updateQueue = null), Qd(r, f))))
        break
      case 22:
        m = r.memoizedState !== null
        var K = l !== null && l.memoizedState !== null,
          pt = da,
          Ot = yn
        if (((da = pt || m), (yn = Ot || K), Oi(a, r), (yn = Ot), (da = pt), Li(r), f & 8192))
          t: for (
            a = r.stateNode,
              a._visibility = m ? a._visibility & -2 : a._visibility | 1,
              m && (l === null || K || da || yn || Hs(r)),
              l = null,
              a = r;
            ;

          ) {
            if (a.tag === 5 || a.tag === 26) {
              if (l === null) {
                K = l = a
                try {
                  if (((b = K.stateNode), m))
                    ((O = b.style),
                      typeof O.setProperty == 'function'
                        ? O.setProperty('display', 'none', 'important')
                        : (O.display = 'none'))
                  else {
                    j = K.stateNode
                    var zt = K.memoizedProps.style,
                      mt = zt != null && zt.hasOwnProperty('display') ? zt.display : null
                    j.style.display = mt == null || typeof mt == 'boolean' ? '' : ('' + mt).trim()
                  }
                } catch (It) {
                  Ke(K, K.return, It)
                }
              }
            } else if (a.tag === 6) {
              if (l === null) {
                K = a
                try {
                  K.stateNode.nodeValue = m ? '' : K.memoizedProps
                } catch (It) {
                  Ke(K, K.return, It)
                }
              }
            } else if (
              ((a.tag !== 22 && a.tag !== 23) || a.memoizedState === null || a === r) &&
              a.child !== null
            ) {
              ;((a.child.return = a), (a = a.child))
              continue
            }
            if (a === r) break t
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === r) break t
              ;(l === a && (l = null), (a = a.return))
            }
            ;(l === a && (l = null), (a.sibling.return = a.return), (a = a.sibling))
          }
        f & 4 &&
          ((f = r.updateQueue),
          f !== null && ((l = f.retryQueue), l !== null && ((f.retryQueue = null), Qd(r, l))))
        break
      case 19:
        ;(Oi(a, r),
          Li(r),
          f & 4 && ((f = r.updateQueue), f !== null && ((r.updateQueue = null), Qd(r, f))))
        break
      case 30:
        break
      case 21:
        break
      default:
        ;(Oi(a, r), Li(r))
    }
  }
  function Li(r) {
    var a = r.flags
    if (a & 2) {
      try {
        for (var l, f = r.return; f !== null; ) {
          if (Ry(f)) {
            l = f
            break
          }
          f = f.return
        }
        if (l == null) throw Error(i(160))
        switch (l.tag) {
          case 27:
            var m = l.stateNode,
              b = Fd(r)
            qc(r, b, m)
            break
          case 5:
            var O = l.stateNode
            l.flags & 32 && (za(O, ''), (l.flags &= -33))
            var j = Fd(r)
            qc(r, j, O)
            break
          case 3:
          case 4:
            var K = l.stateNode.containerInfo,
              pt = Fd(r)
            Jd(r, pt, K)
            break
          default:
            throw Error(i(161))
        }
      } catch (Ot) {
        Ke(r, r.return, Ot)
      }
      r.flags &= -3
    }
    a & 4096 && (r.flags &= -4097)
  }
  function Uy(r) {
    if (r.subtreeFlags & 1024)
      for (r = r.child; r !== null; ) {
        var a = r
        ;(Uy(a), a.tag === 5 && a.flags & 1024 && a.stateNode.reset(), (r = r.sibling))
      }
  }
  function Va(r, a) {
    if (a.subtreeFlags & 8772)
      for (a = a.child; a !== null; ) (By(r, a.alternate, a), (a = a.sibling))
  }
  function Hs(r) {
    for (r = r.child; r !== null; ) {
      var a = r
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ;(Ha(4, a, a.return), Hs(a))
          break
        case 1:
          Zr(a, a.return)
          var l = a.stateNode
          ;(typeof l.componentWillUnmount == 'function' && Ly(a, a.return, l), Hs(a))
          break
        case 27:
          fu(a.stateNode)
        case 26:
        case 5:
          ;(Zr(a, a.return), Hs(a))
          break
        case 22:
          a.memoizedState === null && Hs(a)
          break
        case 30:
          Hs(a)
          break
        default:
          Hs(a)
      }
      r = r.sibling
    }
  }
  function Xa(r, a, l) {
    for (l = l && (a.subtreeFlags & 8772) !== 0, a = a.child; a !== null; ) {
      var f = a.alternate,
        m = r,
        b = a,
        O = b.flags
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          ;(Xa(m, b, l), eu(4, b))
          break
        case 1:
          if ((Xa(m, b, l), (f = b), (m = f.stateNode), typeof m.componentDidMount == 'function'))
            try {
              m.componentDidMount()
            } catch (pt) {
              Ke(f, f.return, pt)
            }
          if (((f = b), (m = f.updateQueue), m !== null)) {
            var j = f.stateNode
            try {
              var K = m.shared.hiddenCallbacks
              if (K !== null)
                for (m.shared.hiddenCallbacks = null, m = 0; m < K.length; m++) m0(K[m], j)
            } catch (pt) {
              Ke(f, f.return, pt)
            }
          }
          ;(l && O & 64 && Oy(b), nu(b, b.return))
          break
        case 27:
          ky(b)
        case 26:
        case 5:
          ;(Xa(m, b, l), l && f === null && O & 4 && zy(b), nu(b, b.return))
          break
        case 12:
          Xa(m, b, l)
          break
        case 13:
          ;(Xa(m, b, l), l && O & 4 && Gy(m, b))
          break
        case 22:
          ;(b.memoizedState === null && Xa(m, b, l), nu(b, b.return))
          break
        case 30:
          break
        default:
          Xa(m, b, l)
      }
      a = a.sibling
    }
  }
  function Kd(r, a) {
    var l = null
    ;(r !== null &&
      r.memoizedState !== null &&
      r.memoizedState.cachePool !== null &&
      (l = r.memoizedState.cachePool.pool),
      (r = null),
      a.memoizedState !== null &&
        a.memoizedState.cachePool !== null &&
        (r = a.memoizedState.cachePool.pool),
      r !== l && (r != null && r.refCount++, l != null && Zl(l)))
  }
  function $d(r, a) {
    ;((r = null),
      a.alternate !== null && (r = a.alternate.memoizedState.cache),
      (a = a.memoizedState.cache),
      a !== r && (a.refCount++, r != null && Zl(r)))
  }
  function Ur(r, a, l, f) {
    if (a.subtreeFlags & 10256) for (a = a.child; a !== null; ) (Yy(r, a, l, f), (a = a.sibling))
  }
  function Yy(r, a, l, f) {
    var m = a.flags
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        ;(Ur(r, a, l, f), m & 2048 && eu(9, a))
        break
      case 1:
        Ur(r, a, l, f)
        break
      case 3:
        ;(Ur(r, a, l, f),
          m & 2048 &&
            ((r = null),
            a.alternate !== null && (r = a.alternate.memoizedState.cache),
            (a = a.memoizedState.cache),
            a !== r && (a.refCount++, r != null && Zl(r))))
        break
      case 12:
        if (m & 2048) {
          ;(Ur(r, a, l, f), (r = a.stateNode))
          try {
            var b = a.memoizedProps,
              O = b.id,
              j = b.onPostCommit
            typeof j == 'function' &&
              j(O, a.alternate === null ? 'mount' : 'update', r.passiveEffectDuration, -0)
          } catch (K) {
            Ke(a, a.return, K)
          }
        } else Ur(r, a, l, f)
        break
      case 13:
        Ur(r, a, l, f)
        break
      case 23:
        break
      case 22:
        ;((b = a.stateNode),
          (O = a.alternate),
          a.memoizedState !== null
            ? b._visibility & 2
              ? Ur(r, a, l, f)
              : iu(r, a)
            : b._visibility & 2
              ? Ur(r, a, l, f)
              : ((b._visibility |= 2), Po(r, a, l, f, (a.subtreeFlags & 10256) !== 0)),
          m & 2048 && Kd(O, a))
        break
      case 24:
        ;(Ur(r, a, l, f), m & 2048 && $d(a.alternate, a))
        break
      default:
        Ur(r, a, l, f)
    }
  }
  function Po(r, a, l, f, m) {
    for (m = m && (a.subtreeFlags & 10256) !== 0, a = a.child; a !== null; ) {
      var b = r,
        O = a,
        j = l,
        K = f,
        pt = O.flags
      switch (O.tag) {
        case 0:
        case 11:
        case 15:
          ;(Po(b, O, j, K, m), eu(8, O))
          break
        case 23:
          break
        case 22:
          var Ot = O.stateNode
          ;(O.memoizedState !== null
            ? Ot._visibility & 2
              ? Po(b, O, j, K, m)
              : iu(b, O)
            : ((Ot._visibility |= 2), Po(b, O, j, K, m)),
            m && pt & 2048 && Kd(O.alternate, O))
          break
        case 24:
          ;(Po(b, O, j, K, m), m && pt & 2048 && $d(O.alternate, O))
          break
        default:
          Po(b, O, j, K, m)
      }
      a = a.sibling
    }
  }
  function iu(r, a) {
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; ) {
        var l = r,
          f = a,
          m = f.flags
        switch (f.tag) {
          case 22:
            ;(iu(l, f), m & 2048 && Kd(f.alternate, f))
            break
          case 24:
            ;(iu(l, f), m & 2048 && $d(f.alternate, f))
            break
          default:
            iu(l, f)
        }
        a = a.sibling
      }
  }
  var ru = 8192
  function Go(r) {
    if (r.subtreeFlags & ru) for (r = r.child; r !== null; ) (Hy(r), (r = r.sibling))
  }
  function Hy(r) {
    switch (r.tag) {
      case 26:
        ;(Go(r),
          r.flags & ru && r.memoizedState !== null && qN(Sr, r.memoizedState, r.memoizedProps))
        break
      case 5:
        Go(r)
        break
      case 3:
      case 4:
        var a = Sr
        ;((Sr = cf(r.stateNode.containerInfo)), Go(r), (Sr = a))
        break
      case 22:
        r.memoizedState === null &&
          ((a = r.alternate),
          a !== null && a.memoizedState !== null
            ? ((a = ru), (ru = 16777216), Go(r), (ru = a))
            : Go(r))
        break
      default:
        Go(r)
    }
  }
  function Vy(r) {
    var a = r.alternate
    if (a !== null && ((r = a.child), r !== null)) {
      a.child = null
      do ((a = r.sibling), (r.sibling = null), (r = a))
      while (r !== null)
    }
  }
  function au(r) {
    var a = r.deletions
    if ((r.flags & 16) !== 0) {
      if (a !== null)
        for (var l = 0; l < a.length; l++) {
          var f = a[l]
          ;((Pn = f), Wy(f, r))
        }
      Vy(r)
    }
    if (r.subtreeFlags & 10256) for (r = r.child; r !== null; ) (Xy(r), (r = r.sibling))
  }
  function Xy(r) {
    switch (r.tag) {
      case 0:
      case 11:
      case 15:
        ;(au(r), r.flags & 2048 && Ha(9, r, r.return))
        break
      case 3:
        au(r)
        break
      case 12:
        au(r)
        break
      case 22:
        var a = r.stateNode
        r.memoizedState !== null && a._visibility & 2 && (r.return === null || r.return.tag !== 13)
          ? ((a._visibility &= -3), Qc(r))
          : au(r)
        break
      default:
        au(r)
    }
  }
  function Qc(r) {
    var a = r.deletions
    if ((r.flags & 16) !== 0) {
      if (a !== null)
        for (var l = 0; l < a.length; l++) {
          var f = a[l]
          ;((Pn = f), Wy(f, r))
        }
      Vy(r)
    }
    for (r = r.child; r !== null; ) {
      switch (((a = r), a.tag)) {
        case 0:
        case 11:
        case 15:
          ;(Ha(8, a, a.return), Qc(a))
          break
        case 22:
          ;((l = a.stateNode), l._visibility & 2 && ((l._visibility &= -3), Qc(a)))
          break
        default:
          Qc(a)
      }
      r = r.sibling
    }
  }
  function Wy(r, a) {
    for (; Pn !== null; ) {
      var l = Pn
      switch (l.tag) {
        case 0:
        case 11:
        case 15:
          Ha(8, l, a)
          break
        case 23:
        case 22:
          if (l.memoizedState !== null && l.memoizedState.cachePool !== null) {
            var f = l.memoizedState.cachePool.pool
            f != null && f.refCount++
          }
          break
        case 24:
          Zl(l.memoizedState.cache)
      }
      if (((f = l.child), f !== null)) ((f.return = l), (Pn = f))
      else
        t: for (l = r; Pn !== null; ) {
          f = Pn
          var m = f.sibling,
            b = f.return
          if ((jy(f), f === l)) {
            Pn = null
            break t
          }
          if (m !== null) {
            ;((m.return = b), (Pn = m))
            break t
          }
          Pn = b
        }
    }
  }
  var hN = {
      getCacheForType: function (r) {
        var a = Qn(Tn),
          l = a.data.get(r)
        return (l === void 0 && ((l = r()), a.data.set(r, l)), l)
      },
    },
    dN = typeof WeakMap == 'function' ? WeakMap : Map,
    Ve = 0,
    tn = null,
    Me = null,
    Re = 0,
    Xe = 0,
    zi = null,
    Wa = !1,
    Zo = !1,
    tg = !1,
    pa = 0,
    cn = 0,
    Fa = 0,
    Vs = 0,
    eg = 0,
    er = 0,
    Uo = 0,
    su = null,
    vi = null,
    ng = !1,
    ig = 0,
    Kc = 1 / 0,
    $c = null,
    Ja = null,
    Hn = 0,
    qa = null,
    Yo = null,
    Ho = 0,
    rg = 0,
    ag = null,
    Fy = null,
    ou = 0,
    sg = null
  function Ri() {
    if ((Ve & 2) !== 0 && Re !== 0) return Re & -Re
    if (G.T !== null) {
      var r = Oo
      return r !== 0 ? r : dg()
    }
    return oc()
  }
  function Jy() {
    er === 0 && (er = (Re & 536870912) === 0 || je ? Sa() : 536870912)
    var r = tr.current
    return (r !== null && (r.flags |= 32), er)
  }
  function ki(r, a, l) {
    ;(((r === tn && (Xe === 2 || Xe === 9)) || r.cancelPendingCommit !== null) &&
      (Vo(r, 0), Qa(r, Re, er, !1)),
      hi(r, l),
      ((Ve & 2) === 0 || r !== tn) &&
        (r === tn && ((Ve & 2) === 0 && (Vs |= l), cn === 4 && Qa(r, Re, er, !1)), Yr(r)))
  }
  function qy(r, a, l) {
    if ((Ve & 6) !== 0) throw Error(i(327))
    var f = (!l && (a & 124) === 0 && (a & r.expiredLanes) === 0) || xi(r, a),
      m = f ? vN(r, a) : ug(r, a, !0),
      b = f
    do {
      if (m === 0) {
        Zo && !f && Qa(r, a, 0, !1)
        break
      } else {
        if (((l = r.current.alternate), b && !gN(l))) {
          ;((m = ug(r, a, !1)), (b = !1))
          continue
        }
        if (m === 2) {
          if (((b = a), r.errorRecoveryDisabledLanes & b)) var O = 0
          else
            ((O = r.pendingLanes & -536870913), (O = O !== 0 ? O : O & 536870912 ? 536870912 : 0))
          if (O !== 0) {
            a = O
            t: {
              var j = r
              m = su
              var K = j.current.memoizedState.isDehydrated
              if ((K && (Vo(j, O).flags |= 256), (O = ug(j, O, !1)), O !== 2)) {
                if (tg && !K) {
                  ;((j.errorRecoveryDisabledLanes |= b), (Vs |= b), (m = 4))
                  break t
                }
                ;((b = vi), (vi = m), b !== null && (vi === null ? (vi = b) : vi.push.apply(vi, b)))
              }
              m = O
            }
            if (((b = !1), m !== 2)) continue
          }
        }
        if (m === 1) {
          ;(Vo(r, 0), Qa(r, a, 0, !0))
          break
        }
        t: {
          switch (((f = r), (b = m), b)) {
            case 0:
            case 1:
              throw Error(i(345))
            case 4:
              if ((a & 4194048) !== a) break
            case 6:
              Qa(f, a, er, !Wa)
              break t
            case 2:
              vi = null
              break
            case 3:
            case 5:
              break
            default:
              throw Error(i(329))
          }
          if ((a & 62914560) === a && ((m = ig + 300 - J()), 10 < m)) {
            if ((Qa(f, a, er, !Wa), fr(f, 0, !0) !== 0)) break t
            f.timeoutHandle = SA(Qy.bind(null, f, l, vi, $c, ng, a, er, Vs, Uo, Wa, b, 2, -0, 0), m)
            break t
          }
          Qy(f, l, vi, $c, ng, a, er, Vs, Uo, Wa, b, 0, -0, 0)
        }
      }
      break
    } while (!0)
    Yr(r)
  }
  function Qy(r, a, l, f, m, b, O, j, K, pt, Ot, zt, mt, It) {
    if (
      ((r.timeoutHandle = -1),
      (zt = a.subtreeFlags),
      (zt & 8192 || (zt & 16785408) === 16785408) &&
        ((gu = { stylesheets: null, count: 0, unsuspend: JN }), Hy(a), (zt = QN()), zt !== null))
    ) {
      ;((r.cancelPendingCommit = zt(rA.bind(null, r, a, b, l, f, m, O, j, K, Ot, 1, mt, It))),
        Qa(r, b, O, !pt))
      return
    }
    rA(r, a, b, l, f, m, O, j, K)
  }
  function gN(r) {
    for (var a = r; ; ) {
      var l = a.tag
      if (
        (l === 0 || l === 11 || l === 15) &&
        a.flags & 16384 &&
        ((l = a.updateQueue), l !== null && ((l = l.stores), l !== null))
      )
        for (var f = 0; f < l.length; f++) {
          var m = l[f],
            b = m.getSnapshot
          m = m.value
          try {
            if (!_n(b(), m)) return !1
          } catch {
            return !1
          }
        }
      if (((l = a.child), a.subtreeFlags & 16384 && l !== null)) ((l.return = a), (a = l))
      else {
        if (a === r) break
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === r) return !0
          a = a.return
        }
        ;((a.sibling.return = a.return), (a = a.sibling))
      }
    }
    return !0
  }
  function Qa(r, a, l, f) {
    ;((a &= ~eg),
      (a &= ~Vs),
      (r.suspendedLanes |= a),
      (r.pingedLanes &= ~a),
      f && (r.warmLanes |= a),
      (f = r.expirationTimes))
    for (var m = a; 0 < m; ) {
      var b = 31 - Ne(m),
        O = 1 << b
      ;((f[b] = -1), (m &= ~O))
    }
    l !== 0 && As(r, l, a)
  }
  function tf() {
    return (Ve & 6) === 0 ? (lu(0), !1) : !0
  }
  function og() {
    if (Me !== null) {
      if (Xe === 0) var r = Me.return
      else ((r = Me), (oa = Ps = null), xd(r), (Bo = null), (Kl = 0), (r = Me))
      for (; r !== null; ) (Dy(r.alternate, r), (r = r.return))
      Me = null
    }
  }
  function Vo(r, a) {
    var l = r.timeoutHandle
    ;(l !== -1 && ((r.timeoutHandle = -1), LN(l)),
      (l = r.cancelPendingCommit),
      l !== null && ((r.cancelPendingCommit = null), l()),
      og(),
      (tn = r),
      (Me = l = ra(r.current, null)),
      (Re = a),
      (Xe = 0),
      (zi = null),
      (Wa = !1),
      (Zo = xi(r, a)),
      (tg = !1),
      (Uo = er = eg = Vs = Fa = cn = 0),
      (vi = su = null),
      (ng = !1),
      (a & 8) !== 0 && (a |= a & 32))
    var f = r.entangledLanes
    if (f !== 0)
      for (r = r.entanglements, f &= a; 0 < f; ) {
        var m = 31 - Ne(f),
          b = 1 << m
        ;((a |= r[m]), (f &= ~b))
      }
    return ((pa = a), Cc(), l)
  }
  function Ky(r, a) {
    ;((be = null),
      (G.H = Zc),
      a === Yl || a === Oc
        ? ((a = p0()), (Xe = 3))
        : a === h0
          ? ((a = p0()), (Xe = 4))
          : (Xe =
              a === vy
                ? 8
                : a !== null && typeof a == 'object' && typeof a.then == 'function'
                  ? 6
                  : 1),
      (zi = a),
      Me === null && ((cn = 1), Xc(r, qi(a, r.current))))
  }
  function $y() {
    var r = G.H
    return ((G.H = Zc), r === null ? Zc : r)
  }
  function tA() {
    var r = G.A
    return ((G.A = hN), r)
  }
  function lg() {
    ;((cn = 4),
      Wa || ((Re & 4194048) !== Re && tr.current !== null) || (Zo = !0),
      ((Fa & 134217727) === 0 && (Vs & 134217727) === 0) || tn === null || Qa(tn, Re, er, !1))
  }
  function ug(r, a, l) {
    var f = Ve
    Ve |= 2
    var m = $y(),
      b = tA()
    ;((tn !== r || Re !== a) && (($c = null), Vo(r, a)), (a = !1))
    var O = cn
    t: do
      try {
        if (Xe !== 0 && Me !== null) {
          var j = Me,
            K = zi
          switch (Xe) {
            case 8:
              ;(og(), (O = 6))
              break t
            case 3:
            case 2:
            case 9:
            case 6:
              tr.current === null && (a = !0)
              var pt = Xe
              if (((Xe = 0), (zi = null), Xo(r, j, K, pt), l && Zo)) {
                O = 0
                break t
              }
              break
            default:
              ;((pt = Xe), (Xe = 0), (zi = null), Xo(r, j, K, pt))
          }
        }
        ;(pN(), (O = cn))
        break
      } catch (Ot) {
        Ky(r, Ot)
      }
    while (!0)
    return (
      a && r.shellSuspendCounter++,
      (oa = Ps = null),
      (Ve = f),
      (G.H = m),
      (G.A = b),
      Me === null && ((tn = null), (Re = 0), Cc()),
      O
    )
  }
  function pN() {
    for (; Me !== null; ) eA(Me)
  }
  function vN(r, a) {
    var l = Ve
    Ve |= 2
    var f = $y(),
      m = tA()
    tn !== r || Re !== a ? (($c = null), (Kc = J() + 500), Vo(r, a)) : (Zo = xi(r, a))
    t: do
      try {
        if (Xe !== 0 && Me !== null) {
          a = Me
          var b = zi
          e: switch (Xe) {
            case 1:
              ;((Xe = 0), (zi = null), Xo(r, a, b, 1))
              break
            case 2:
            case 9:
              if (d0(b)) {
                ;((Xe = 0), (zi = null), nA(a))
                break
              }
              ;((a = function () {
                ;((Xe !== 2 && Xe !== 9) || tn !== r || (Xe = 7), Yr(r))
              }),
                b.then(a, a))
              break t
            case 3:
              Xe = 7
              break t
            case 4:
              Xe = 5
              break t
            case 7:
              d0(b) ? ((Xe = 0), (zi = null), nA(a)) : ((Xe = 0), (zi = null), Xo(r, a, b, 7))
              break
            case 5:
              var O = null
              switch (Me.tag) {
                case 26:
                  O = Me.memoizedState
                case 5:
                case 27:
                  var j = Me
                  if (!O || BA(O)) {
                    ;((Xe = 0), (zi = null))
                    var K = j.sibling
                    if (K !== null) Me = K
                    else {
                      var pt = j.return
                      pt !== null ? ((Me = pt), ef(pt)) : (Me = null)
                    }
                    break e
                  }
              }
              ;((Xe = 0), (zi = null), Xo(r, a, b, 5))
              break
            case 6:
              ;((Xe = 0), (zi = null), Xo(r, a, b, 6))
              break
            case 8:
              ;(og(), (cn = 6))
              break t
            default:
              throw Error(i(462))
          }
        }
        mN()
        break
      } catch (Ot) {
        Ky(r, Ot)
      }
    while (!0)
    return (
      (oa = Ps = null),
      (G.H = f),
      (G.A = m),
      (Ve = l),
      Me !== null ? 0 : ((tn = null), (Re = 0), Cc(), cn)
    )
  }
  function mN() {
    for (; Me !== null && !P(); ) eA(Me)
  }
  function eA(r) {
    var a = My(r.alternate, r, pa)
    ;((r.memoizedProps = r.pendingProps), a === null ? ef(r) : (Me = a))
  }
  function nA(r) {
    var a = r,
      l = a.alternate
    switch (a.tag) {
      case 15:
      case 0:
        a = Cy(l, a, a.pendingProps, a.type, void 0, Re)
        break
      case 11:
        a = Cy(l, a, a.pendingProps, a.type.render, a.ref, Re)
        break
      case 5:
        xd(a)
      default:
        ;(Dy(l, a), (a = Me = i0(a, pa)), (a = My(l, a, pa)))
    }
    ;((r.memoizedProps = r.pendingProps), a === null ? ef(r) : (Me = a))
  }
  function Xo(r, a, l, f) {
    ;((oa = Ps = null), xd(a), (Bo = null), (Kl = 0))
    var m = a.return
    try {
      if (sN(r, m, a, l, Re)) {
        ;((cn = 1), Xc(r, qi(l, r.current)), (Me = null))
        return
      }
    } catch (b) {
      if (m !== null) throw ((Me = m), b)
      ;((cn = 1), Xc(r, qi(l, r.current)), (Me = null))
      return
    }
    a.flags & 32768
      ? (je || f === 1
          ? (r = !0)
          : Zo || (Re & 536870912) !== 0
            ? (r = !1)
            : ((Wa = r = !0),
              (f === 2 || f === 9 || f === 3 || f === 6) &&
                ((f = tr.current), f !== null && f.tag === 13 && (f.flags |= 16384))),
        iA(a, r))
      : ef(a)
  }
  function ef(r) {
    var a = r
    do {
      if ((a.flags & 32768) !== 0) {
        iA(a, Wa)
        return
      }
      r = a.return
      var l = lN(a.alternate, a, pa)
      if (l !== null) {
        Me = l
        return
      }
      if (((a = a.sibling), a !== null)) {
        Me = a
        return
      }
      Me = a = r
    } while (a !== null)
    cn === 0 && (cn = 5)
  }
  function iA(r, a) {
    do {
      var l = uN(r.alternate, r)
      if (l !== null) {
        ;((l.flags &= 32767), (Me = l))
        return
      }
      if (
        ((l = r.return),
        l !== null && ((l.flags |= 32768), (l.subtreeFlags = 0), (l.deletions = null)),
        !a && ((r = r.sibling), r !== null))
      ) {
        Me = r
        return
      }
      Me = r = l
    } while (r !== null)
    ;((cn = 6), (Me = null))
  }
  function rA(r, a, l, f, m, b, O, j, K) {
    r.cancelPendingCommit = null
    do nf()
    while (Hn !== 0)
    if ((Ve & 6) !== 0) throw Error(i(327))
    if (a !== null) {
      if (a === r.current) throw Error(i(177))
      if (
        ((b = a.lanes | a.childLanes),
        (b |= $h),
        ys(r, l, b, O, j, K),
        r === tn && ((Me = tn = null), (Re = 0)),
        (Yo = a),
        (qa = r),
        (Ho = l),
        (rg = b),
        (ag = m),
        (Fy = f),
        (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0
          ? ((r.callbackNode = null),
            (r.callbackPriority = 0),
            IN(se, function () {
              return (uA(), null)
            }))
          : ((r.callbackNode = null), (r.callbackPriority = 0)),
        (f = (a.flags & 13878) !== 0),
        (a.subtreeFlags & 13878) !== 0 || f)
      ) {
        ;((f = G.T), (G.T = null), (m = Q.p), (Q.p = 2), (O = Ve), (Ve |= 4))
        try {
          cN(r, a, l)
        } finally {
          ;((Ve = O), (Q.p = m), (G.T = f))
        }
      }
      ;((Hn = 1), aA(), sA(), oA())
    }
  }
  function aA() {
    if (Hn === 1) {
      Hn = 0
      var r = qa,
        a = Yo,
        l = (a.flags & 13878) !== 0
      if ((a.subtreeFlags & 13878) !== 0 || l) {
        ;((l = G.T), (G.T = null))
        var f = Q.p
        Q.p = 2
        var m = Ve
        Ve |= 4
        try {
          Zy(a, r)
          var b = Ig,
            O = _l(r.containerInfo),
            j = b.focusedElem,
            K = b.selectionRange
          if (O !== j && j && j.ownerDocument && So(j.ownerDocument.documentElement, j)) {
            if (K !== null && V(j)) {
              var pt = K.start,
                Ot = K.end
              if ((Ot === void 0 && (Ot = pt), 'selectionStart' in j))
                ((j.selectionStart = pt), (j.selectionEnd = Math.min(Ot, j.value.length)))
              else {
                var zt = j.ownerDocument || document,
                  mt = (zt && zt.defaultView) || window
                if (mt.getSelection) {
                  var It = mt.getSelection(),
                    le = j.textContent.length,
                    ie = Math.min(K.start, le),
                    Je = K.end === void 0 ? ie : Math.min(K.end, le)
                  !It.extend && ie > Je && ((O = Je), (Je = ie), (ie = O))
                  var ut = Ic(j, ie),
                    at = Ic(j, Je)
                  if (
                    ut &&
                    at &&
                    (It.rangeCount !== 1 ||
                      It.anchorNode !== ut.node ||
                      It.anchorOffset !== ut.offset ||
                      It.focusNode !== at.node ||
                      It.focusOffset !== at.offset)
                  ) {
                    var ft = zt.createRange()
                    ;(ft.setStart(ut.node, ut.offset),
                      It.removeAllRanges(),
                      ie > Je
                        ? (It.addRange(ft), It.extend(at.node, at.offset))
                        : (ft.setEnd(at.node, at.offset), It.addRange(ft)))
                  }
                }
              }
            }
            for (zt = [], It = j; (It = It.parentNode); )
              It.nodeType === 1 && zt.push({ element: It, left: It.scrollLeft, top: It.scrollTop })
            for (typeof j.focus == 'function' && j.focus(), j = 0; j < zt.length; j++) {
              var Lt = zt[j]
              ;((Lt.element.scrollLeft = Lt.left), (Lt.element.scrollTop = Lt.top))
            }
          }
          ;((pf = !!bg), (Ig = bg = null))
        } finally {
          ;((Ve = m), (Q.p = f), (G.T = l))
        }
      }
      ;((r.current = a), (Hn = 2))
    }
  }
  function sA() {
    if (Hn === 2) {
      Hn = 0
      var r = qa,
        a = Yo,
        l = (a.flags & 8772) !== 0
      if ((a.subtreeFlags & 8772) !== 0 || l) {
        ;((l = G.T), (G.T = null))
        var f = Q.p
        Q.p = 2
        var m = Ve
        Ve |= 4
        try {
          By(r, a.alternate, a)
        } finally {
          ;((Ve = m), (Q.p = f), (G.T = l))
        }
      }
      Hn = 3
    }
  }
  function oA() {
    if (Hn === 4 || Hn === 3) {
      ;((Hn = 0), Y())
      var r = qa,
        a = Yo,
        l = Ho,
        f = Fy
      ;(a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0
        ? (Hn = 5)
        : ((Hn = 0), (Yo = qa = null), lA(r, r.pendingLanes))
      var m = r.pendingLanes
      if (
        (m === 0 && (Ja = null),
        bs(l),
        (a = a.stateNode),
        fe && typeof fe.onCommitFiberRoot == 'function')
      )
        try {
          fe.onCommitFiberRoot(ae, a, void 0, (a.current.flags & 128) === 128)
        } catch {}
      if (f !== null) {
        ;((a = G.T), (m = Q.p), (Q.p = 2), (G.T = null))
        try {
          for (var b = r.onRecoverableError, O = 0; O < f.length; O++) {
            var j = f[O]
            b(j.value, { componentStack: j.stack })
          }
        } finally {
          ;((G.T = a), (Q.p = m))
        }
      }
      ;((Ho & 3) !== 0 && nf(),
        Yr(r),
        (m = r.pendingLanes),
        (l & 4194090) !== 0 && (m & 42) !== 0 ? (r === sg ? ou++ : ((ou = 0), (sg = r))) : (ou = 0),
        lu(0))
    }
  }
  function lA(r, a) {
    ;(r.pooledCacheLanes &= a) === 0 &&
      ((a = r.pooledCache), a != null && ((r.pooledCache = null), Zl(a)))
  }
  function nf(r) {
    return (aA(), sA(), oA(), uA())
  }
  function uA() {
    if (Hn !== 5) return !1
    var r = qa,
      a = rg
    rg = 0
    var l = bs(Ho),
      f = G.T,
      m = Q.p
    try {
      ;((Q.p = 32 > l ? 32 : l), (G.T = null), (l = ag), (ag = null))
      var b = qa,
        O = Ho
      if (((Hn = 0), (Yo = qa = null), (Ho = 0), (Ve & 6) !== 0)) throw Error(i(331))
      var j = Ve
      if (
        ((Ve |= 4),
        Xy(b.current),
        Yy(b, b.current, O, l),
        (Ve = j),
        lu(0, !1),
        fe && typeof fe.onPostCommitFiberRoot == 'function')
      )
        try {
          fe.onPostCommitFiberRoot(ae, b)
        } catch {}
      return !0
    } finally {
      ;((Q.p = m), (G.T = f), lA(r, a))
    }
  }
  function cA(r, a, l) {
    ;((a = qi(l, a)),
      (a = jd(r.stateNode, a, 2)),
      (r = Ga(r, a, 2)),
      r !== null && (hi(r, 2), Yr(r)))
  }
  function Ke(r, a, l) {
    if (r.tag === 3) cA(r, r, l)
    else
      for (; a !== null; ) {
        if (a.tag === 3) {
          cA(a, r, l)
          break
        } else if (a.tag === 1) {
          var f = a.stateNode
          if (
            typeof a.type.getDerivedStateFromError == 'function' ||
            (typeof f.componentDidCatch == 'function' && (Ja === null || !Ja.has(f)))
          ) {
            ;((r = qi(l, r)),
              (l = gy(2)),
              (f = Ga(a, l, 2)),
              f !== null && (py(l, f, a, r), hi(f, 2), Yr(f)))
            break
          }
        }
        a = a.return
      }
  }
  function cg(r, a, l) {
    var f = r.pingCache
    if (f === null) {
      f = r.pingCache = new dN()
      var m = new Set()
      f.set(a, m)
    } else ((m = f.get(a)), m === void 0 && ((m = new Set()), f.set(a, m)))
    m.has(l) || ((tg = !0), m.add(l), (r = yN.bind(null, r, a, l)), a.then(r, r))
  }
  function yN(r, a, l) {
    var f = r.pingCache
    ;(f !== null && f.delete(a),
      (r.pingedLanes |= r.suspendedLanes & l),
      (r.warmLanes &= ~l),
      tn === r &&
        (Re & l) === l &&
        (cn === 4 || (cn === 3 && (Re & 62914560) === Re && 300 > J() - ig)
          ? (Ve & 2) === 0 && Vo(r, 0)
          : (eg |= l),
        Uo === Re && (Uo = 0)),
      Yr(r))
  }
  function fA(r, a) {
    ;(a === 0 && (a = hr()), (r = To(r, a)), r !== null && (hi(r, a), Yr(r)))
  }
  function AN(r) {
    var a = r.memoizedState,
      l = 0
    ;(a !== null && (l = a.retryLane), fA(r, l))
  }
  function bN(r, a) {
    var l = 0
    switch (r.tag) {
      case 13:
        var f = r.stateNode,
          m = r.memoizedState
        m !== null && (l = m.retryLane)
        break
      case 19:
        f = r.stateNode
        break
      case 22:
        f = r.stateNode._retryCache
        break
      default:
        throw Error(i(314))
    }
    ;(f !== null && f.delete(a), fA(r, l))
  }
  function IN(r, a) {
    return Xt(r, a)
  }
  var rf = null,
    Wo = null,
    fg = !1,
    af = !1,
    hg = !1,
    Xs = 0
  function Yr(r) {
    ;(r !== Wo && r.next === null && (Wo === null ? (rf = Wo = r) : (Wo = Wo.next = r)),
      (af = !0),
      fg || ((fg = !0), wN()))
  }
  function lu(r, a) {
    if (!hg && af) {
      hg = !0
      do
        for (var l = !1, f = rf; f !== null; ) {
          if (r !== 0) {
            var m = f.pendingLanes
            if (m === 0) var b = 0
            else {
              var O = f.suspendedLanes,
                j = f.pingedLanes
              ;((b = (1 << (31 - Ne(42 | r) + 1)) - 1),
                (b &= m & ~(O & ~j)),
                (b = b & 201326741 ? (b & 201326741) | 1 : b ? b | 2 : 0))
            }
            b !== 0 && ((l = !0), pA(f, b))
          } else
            ((b = Re),
              (b = fr(
                f,
                f === tn ? b : 0,
                f.cancelPendingCommit !== null || f.timeoutHandle !== -1
              )),
              (b & 3) === 0 || xi(f, b) || ((l = !0), pA(f, b)))
          f = f.next
        }
      while (l)
      hg = !1
    }
  }
  function CN() {
    hA()
  }
  function hA() {
    af = fg = !1
    var r = 0
    Xs !== 0 && (ON() && (r = Xs), (Xs = 0))
    for (var a = J(), l = null, f = rf; f !== null; ) {
      var m = f.next,
        b = dA(f, a)
      ;(b === 0
        ? ((f.next = null), l === null ? (rf = m) : (l.next = m), m === null && (Wo = l))
        : ((l = f), (r !== 0 || (b & 3) !== 0) && (af = !0)),
        (f = m))
    }
    lu(r)
  }
  function dA(r, a) {
    for (
      var l = r.suspendedLanes,
        f = r.pingedLanes,
        m = r.expirationTimes,
        b = r.pendingLanes & -62914561;
      0 < b;

    ) {
      var O = 31 - Ne(b),
        j = 1 << O,
        K = m[O]
      ;(K === -1
        ? ((j & l) === 0 || (j & f) !== 0) && (m[O] = ms(j, a))
        : K <= a && (r.expiredLanes |= j),
        (b &= ~j))
    }
    if (
      ((a = tn),
      (l = Re),
      (l = fr(r, r === a ? l : 0, r.cancelPendingCommit !== null || r.timeoutHandle !== -1)),
      (f = r.callbackNode),
      l === 0 || (r === a && (Xe === 2 || Xe === 9)) || r.cancelPendingCommit !== null)
    )
      return (f !== null && f !== null && E(f), (r.callbackNode = null), (r.callbackPriority = 0))
    if ((l & 3) === 0 || xi(r, l)) {
      if (((a = l & -l), a === r.callbackPriority)) return a
      switch ((f !== null && E(f), bs(l))) {
        case 2:
        case 8:
          l = Yt
          break
        case 32:
          l = se
          break
        case 268435456:
          l = $e
          break
        default:
          l = se
      }
      return (
        (f = gA.bind(null, r)),
        (l = Xt(l, f)),
        (r.callbackPriority = a),
        (r.callbackNode = l),
        a
      )
    }
    return (f !== null && f !== null && E(f), (r.callbackPriority = 2), (r.callbackNode = null), 2)
  }
  function gA(r, a) {
    if (Hn !== 0 && Hn !== 5) return ((r.callbackNode = null), (r.callbackPriority = 0), null)
    var l = r.callbackNode
    if (nf() && r.callbackNode !== l) return null
    var f = Re
    return (
      (f = fr(r, r === tn ? f : 0, r.cancelPendingCommit !== null || r.timeoutHandle !== -1)),
      f === 0
        ? null
        : (qy(r, f, a),
          dA(r, J()),
          r.callbackNode != null && r.callbackNode === l ? gA.bind(null, r) : null)
    )
  }
  function pA(r, a) {
    if (nf()) return null
    qy(r, a, !0)
  }
  function wN() {
    zN(function () {
      ;(Ve & 6) !== 0 ? Xt(Nt, CN) : hA()
    })
  }
  function dg() {
    return (Xs === 0 && (Xs = Sa()), Xs)
  }
  function vA(r) {
    return r == null || typeof r == 'symbol' || typeof r == 'boolean'
      ? null
      : typeof r == 'function'
        ? r
        : Ts('' + r)
  }
  function mA(r, a) {
    var l = a.ownerDocument.createElement('input')
    return (
      (l.name = a.name),
      (l.value = a.value),
      r.id && l.setAttribute('form', r.id),
      a.parentNode.insertBefore(l, a),
      (r = new FormData(r)),
      l.parentNode.removeChild(l),
      r
    )
  }
  function xN(r, a, l, f, m) {
    if (a === 'submit' && l && l.stateNode === m) {
      var b = vA((m[gn] || null).action),
        O = f.submitter
      O &&
        ((a = (a = O[gn] || null) ? vA(a.formAction) : O.getAttribute('formAction')),
        a !== null && ((b = a), (O = null)))
      var j = new Os('action', 'action', null, f, m)
      r.push({
        event: j,
        listeners: [
          {
            instance: null,
            listener: function () {
              if (f.defaultPrevented) {
                if (Xs !== 0) {
                  var K = O ? mA(m, O) : new FormData(m)
                  zd(l, { pending: !0, data: K, method: m.method, action: b }, null, K)
                }
              } else
                typeof b == 'function' &&
                  (j.preventDefault(),
                  (K = O ? mA(m, O) : new FormData(m)),
                  zd(l, { pending: !0, data: K, method: m.method, action: b }, b, K))
            },
            currentTarget: m,
          },
        ],
      })
    }
  }
  for (var gg = 0; gg < Nn.length; gg++) {
    var pg = Nn[gg],
      SN = pg.toLowerCase(),
      NN = pg[0].toUpperCase() + pg.slice(1)
    xr(SN, 'on' + NN)
  }
  ;(xr(ye, 'onAnimationEnd'),
    xr(te, 'onAnimationIteration'),
    xr(He, 'onAnimationStart'),
    xr('dblclick', 'onDoubleClick'),
    xr('focusin', 'onFocus'),
    xr('focusout', 'onBlur'),
    xr(qn, 'onTransitionRun'),
    xr(Bn, 'onTransitionStart'),
    xr(di, 'onTransitionCancel'),
    xr(Ei, 'onTransitionEnd'),
    Fr('onMouseEnter', ['mouseout', 'mouseover']),
    Fr('onMouseLeave', ['mouseout', 'mouseover']),
    Fr('onPointerEnter', ['pointerout', 'pointerover']),
    Fr('onPointerLeave', ['pointerout', 'pointerover']),
    Xi('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' ')),
    Xi(
      'onSelect',
      'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
        ' '
      )
    ),
    Xi('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']),
    Xi('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' ')),
    Xi(
      'onCompositionStart',
      'compositionstart focusout keydown keypress keyup mousedown'.split(' ')
    ),
    Xi(
      'onCompositionUpdate',
      'compositionupdate focusout keydown keypress keyup mousedown'.split(' ')
    ))
  var uu =
      'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
        ' '
      ),
    TN = new Set(
      'beforetoggle cancel close invalid load scroll scrollend toggle'.split(' ').concat(uu)
    )
  function yA(r, a) {
    a = (a & 4) !== 0
    for (var l = 0; l < r.length; l++) {
      var f = r[l],
        m = f.event
      f = f.listeners
      t: {
        var b = void 0
        if (a)
          for (var O = f.length - 1; 0 <= O; O--) {
            var j = f[O],
              K = j.instance,
              pt = j.currentTarget
            if (((j = j.listener), K !== b && m.isPropagationStopped())) break t
            ;((b = j), (m.currentTarget = pt))
            try {
              b(m)
            } catch (Ot) {
              Vc(Ot)
            }
            ;((m.currentTarget = null), (b = K))
          }
        else
          for (O = 0; O < f.length; O++) {
            if (
              ((j = f[O]),
              (K = j.instance),
              (pt = j.currentTarget),
              (j = j.listener),
              K !== b && m.isPropagationStopped())
            )
              break t
            ;((b = j), (m.currentTarget = pt))
            try {
              b(m)
            } catch (Ot) {
              Vc(Ot)
            }
            ;((m.currentTarget = null), (b = K))
          }
      }
    }
  }
  function Ee(r, a) {
    var l = a[Na]
    l === void 0 && (l = a[Na] = new Set())
    var f = r + '__bubble'
    l.has(f) || (AA(a, r, 2, !1), l.add(f))
  }
  function vg(r, a, l) {
    var f = 0
    ;(a && (f |= 4), AA(l, r, f, a))
  }
  var sf = '_reactListening' + Math.random().toString(36).slice(2)
  function mg(r) {
    if (!r[sf]) {
      ;((r[sf] = !0),
        uo.forEach(function (l) {
          l !== 'selectionchange' && (TN.has(l) || vg(l, !1, r), vg(l, !0, r))
        }))
      var a = r.nodeType === 9 ? r : r.ownerDocument
      a === null || a[sf] || ((a[sf] = !0), vg('selectionchange', !1, a))
    }
  }
  function AA(r, a, l, f) {
    switch (YA(a)) {
      case 2:
        var m = tT
        break
      case 8:
        m = eT
        break
      default:
        m = Og
    }
    ;((l = m.bind(null, a, l, r)),
      (m = void 0),
      !El || (a !== 'touchstart' && a !== 'touchmove' && a !== 'wheel') || (m = !0),
      f
        ? m !== void 0
          ? r.addEventListener(a, l, { capture: !0, passive: m })
          : r.addEventListener(a, l, !0)
        : m !== void 0
          ? r.addEventListener(a, l, { passive: m })
          : r.addEventListener(a, l, !1))
  }
  function yg(r, a, l, f, m) {
    var b = f
    if ((a & 1) === 0 && (a & 2) === 0 && f !== null)
      t: for (;;) {
        if (f === null) return
        var O = f.tag
        if (O === 3 || O === 4) {
          var j = f.stateNode.containerInfo
          if (j === m) break
          if (O === 4)
            for (O = f.return; O !== null; ) {
              var K = O.tag
              if ((K === 3 || K === 4) && O.stateNode.containerInfo === m) return
              O = O.return
            }
          for (; j !== null; ) {
            if (((O = Ma(j)), O === null)) return
            if (((K = O.tag), K === 5 || K === 6 || K === 26 || K === 27)) {
              f = b = O
              continue t
            }
            j = j.parentNode
          }
        }
        f = f.return
      }
    pc(function () {
      var pt = b,
        Ot = mo(l),
        zt = []
      t: {
        var mt = ia.get(r)
        if (mt !== void 0) {
          var It = Os,
            le = r
          switch (r) {
            case 'keypress':
              if (Ds(l) === 0) break t
            case 'keydown':
            case 'keyup':
              It = _t
              break
            case 'focusin':
              ;((le = 'focus'), (It = d))
              break
            case 'focusout':
              ;((le = 'blur'), (It = d))
              break
            case 'beforeblur':
            case 'afterblur':
              It = d
              break
            case 'click':
              if (l.button === 2) break t
            case 'auxclick':
            case 'dblclick':
            case 'mousedown':
            case 'mousemove':
            case 'mouseup':
            case 'mouseout':
            case 'mouseover':
            case 'contextmenu':
              It = Ao
              break
            case 'drag':
            case 'dragend':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'dragstart':
            case 'drop':
              It = Jh
              break
            case 'touchcancel':
            case 'touchend':
            case 'touchmove':
            case 'touchstart':
              It = Sn
              break
            case ye:
            case te:
            case He:
              It = I
              break
            case Ei:
              It = Wi
              break
            case 'scroll':
            case 'scrollend':
              It = Wh
              break
            case 'wheel':
              It = Ce
              break
            case 'copy':
            case 'cut':
            case 'paste':
              It = D
              break
            case 'gotpointercapture':
            case 'lostpointercapture':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'pointerup':
              It = Te
              break
            case 'toggle':
            case 'beforetoggle':
              It = Oe
          }
          var ie = (a & 4) !== 0,
            Je = !ie && (r === 'scroll' || r === 'scrollend'),
            ut = ie ? (mt !== null ? mt + 'Capture' : null) : mt
          ie = []
          for (var at = pt, ft; at !== null; ) {
            var Lt = at
            if (
              ((ft = Lt.stateNode),
              (Lt = Lt.tag),
              (Lt !== 5 && Lt !== 26 && Lt !== 27) ||
                ft === null ||
                ut === null ||
                ((Lt = Qr(at, ut)), Lt != null && ie.push(cu(at, Lt, ft))),
              Je)
            )
              break
            at = at.return
          }
          0 < ie.length &&
            ((mt = new It(mt, le, null, l, Ot)), zt.push({ event: mt, listeners: ie }))
        }
      }
      if ((a & 7) === 0) {
        t: {
          if (
            ((mt = r === 'mouseover' || r === 'pointerover'),
            (It = r === 'mouseout' || r === 'pointerout'),
            mt && l !== Ms && (le = l.relatedTarget || l.fromElement) && (Ma(le) || le[Lr]))
          )
            break t
          if (
            (It || mt) &&
            ((mt =
              Ot.window === Ot
                ? Ot
                : (mt = Ot.ownerDocument)
                  ? mt.defaultView || mt.parentWindow
                  : window),
            It
              ? ((le = l.relatedTarget || l.toElement),
                (It = pt),
                (le = le ? Ma(le) : null),
                le !== null &&
                  ((Je = o(le)), (ie = le.tag), le !== Je || (ie !== 5 && ie !== 27 && ie !== 6)) &&
                  (le = null))
              : ((It = null), (le = pt)),
            It !== le)
          ) {
            if (
              ((ie = Ao),
              (Lt = 'onMouseLeave'),
              (ut = 'onMouseEnter'),
              (at = 'mouse'),
              (r === 'pointerout' || r === 'pointerover') &&
                ((ie = Te), (Lt = 'onPointerLeave'), (ut = 'onPointerEnter'), (at = 'pointer')),
              (Je = It == null ? mt : Is(It)),
              (ft = le == null ? mt : Is(le)),
              (mt = new ie(Lt, at + 'leave', It, l, Ot)),
              (mt.target = Je),
              (mt.relatedTarget = ft),
              (Lt = null),
              Ma(Ot) === pt &&
                ((ie = new ie(ut, at + 'enter', le, l, Ot)),
                (ie.target = ft),
                (ie.relatedTarget = Je),
                (Lt = ie)),
              (Je = Lt),
              It && le)
            )
              e: {
                for (ie = It, ut = le, at = 0, ft = ie; ft; ft = Fo(ft)) at++
                for (ft = 0, Lt = ut; Lt; Lt = Fo(Lt)) ft++
                for (; 0 < at - ft; ) ((ie = Fo(ie)), at--)
                for (; 0 < ft - at; ) ((ut = Fo(ut)), ft--)
                for (; at--; ) {
                  if (ie === ut || (ut !== null && ie === ut.alternate)) break e
                  ;((ie = Fo(ie)), (ut = Fo(ut)))
                }
                ie = null
              }
            else ie = null
            ;(It !== null && bA(zt, mt, It, ie, !1),
              le !== null && Je !== null && bA(zt, Je, le, ie, !0))
          }
        }
        t: {
          if (
            ((mt = pt ? Is(pt) : window),
            (It = mt.nodeName && mt.nodeName.toLowerCase()),
            It === 'select' || (It === 'input' && mt.type === 'file'))
          )
            var Wt = Ac
          else if (mc(mt))
            if (bc) Wt = kl
            else {
              Wt = Co
              var we = zs
            }
          else
            ((It = mt.nodeName),
              !It || It.toLowerCase() !== 'input' || (mt.type !== 'checkbox' && mt.type !== 'radio')
                ? pt && Ss(pt.elementType) && (Wt = Ac)
                : (Wt = wo))
          if (Wt && (Wt = Wt(r, pt))) {
            yc(zt, Wt, l, Ot)
            break t
          }
          ;(we && we(r, mt, pt),
            r === 'focusout' &&
              pt &&
              mt.type === 'number' &&
              pt.memoizedProps.value != null &&
              Sl(mt, 'number', mt.value))
        }
        switch (((we = pt ? Is(pt) : window), r)) {
          case 'focusin':
            ;(mc(we) || we.contentEditable === 'true') && ((dt = we), (wt = pt), (Mt = null))
            break
          case 'focusout':
            Mt = wt = dt = null
            break
          case 'mousedown':
            jt = !0
            break
          case 'contextmenu':
          case 'mouseup':
          case 'dragend':
            ;((jt = !1), Ht(zt, l, Ot))
            break
          case 'selectionchange':
            if (rt) break
          case 'keydown':
          case 'keyup':
            Ht(zt, l, Ot)
        }
        var $t
        if (ta)
          t: {
            switch (r) {
              case 'compositionstart':
                var re = 'onCompositionStart'
                break t
              case 'compositionend':
                re = 'onCompositionEnd'
                break t
              case 'compositionupdate':
                re = 'onCompositionUpdate'
                break t
            }
            re = void 0
          }
        else
          Br
            ? yr(r, l) && (re = 'onCompositionEnd')
            : r === 'keydown' && l.keyCode === 229 && (re = 'onCompositionStart')
        ;(re &&
          (_a &&
            l.locale !== 'ko' &&
            (Br || re !== 'onCompositionStart'
              ? re === 'onCompositionEnd' && Br && ($t = vc())
              : ((kr = Ot), (Dl = 'value' in kr ? kr.value : kr.textContent), (Br = !0))),
          (we = of(pt, re)),
          0 < we.length &&
            ((re = new k(re, r, null, l, Ot)),
            zt.push({ event: re, listeners: we }),
            $t ? (re.data = $t) : (($t = ii(l)), $t !== null && (re.data = $t)))),
          ($t = Ji ? Ar(r, l) : br(r, l)) &&
            ((re = of(pt, 'onBeforeInput')),
            0 < re.length &&
              ((we = new k('onBeforeInput', 'beforeinput', null, l, Ot)),
              zt.push({ event: we, listeners: re }),
              (we.data = $t))),
          xN(zt, r, pt, l, Ot))
      }
      yA(zt, a)
    })
  }
  function cu(r, a, l) {
    return { instance: r, listener: a, currentTarget: l }
  }
  function of(r, a) {
    for (var l = a + 'Capture', f = []; r !== null; ) {
      var m = r,
        b = m.stateNode
      if (
        ((m = m.tag),
        (m !== 5 && m !== 26 && m !== 27) ||
          b === null ||
          ((m = Qr(r, l)),
          m != null && f.unshift(cu(r, m, b)),
          (m = Qr(r, a)),
          m != null && f.push(cu(r, m, b))),
        r.tag === 3)
      )
        return f
      r = r.return
    }
    return []
  }
  function Fo(r) {
    if (r === null) return null
    do r = r.return
    while (r && r.tag !== 5 && r.tag !== 27)
    return r || null
  }
  function bA(r, a, l, f, m) {
    for (var b = a._reactName, O = []; l !== null && l !== f; ) {
      var j = l,
        K = j.alternate,
        pt = j.stateNode
      if (((j = j.tag), K !== null && K === f)) break
      ;((j !== 5 && j !== 26 && j !== 27) ||
        pt === null ||
        ((K = pt),
        m
          ? ((pt = Qr(l, b)), pt != null && O.unshift(cu(l, pt, K)))
          : m || ((pt = Qr(l, b)), pt != null && O.push(cu(l, pt, K)))),
        (l = l.return))
    }
    O.length !== 0 && r.push({ event: a, listeners: O })
  }
  var MN = /\r\n?/g,
    EN = /\u0000|\uFFFD/g
  function IA(r) {
    return (typeof r == 'string' ? r : '' + r)
      .replace(
        MN,
        `
`
      )
      .replace(EN, '')
  }
  function CA(r, a) {
    return ((a = IA(a)), IA(r) === a)
  }
  function lf() {}
  function Fe(r, a, l, f, m, b) {
    switch (l) {
      case 'children':
        typeof f == 'string'
          ? a === 'body' || (a === 'textarea' && f === '') || za(r, f)
          : (typeof f == 'number' || typeof f == 'bigint') && a !== 'body' && za(r, '' + f)
        break
      case 'className':
        ws(r, 'class', f)
        break
      case 'tabIndex':
        ws(r, 'tabindex', f)
        break
      case 'dir':
      case 'role':
      case 'viewBox':
      case 'width':
      case 'height':
        ws(r, l, f)
        break
      case 'style':
        Rr(r, f, b)
        break
      case 'data':
        if (a !== 'object') {
          ws(r, 'data', f)
          break
        }
      case 'src':
      case 'href':
        if (f === '' && (a !== 'a' || l !== 'href')) {
          r.removeAttribute(l)
          break
        }
        if (f == null || typeof f == 'function' || typeof f == 'symbol' || typeof f == 'boolean') {
          r.removeAttribute(l)
          break
        }
        ;((f = Ts('' + f)), r.setAttribute(l, f))
        break
      case 'action':
      case 'formAction':
        if (typeof f == 'function') {
          r.setAttribute(
            l,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          )
          break
        } else
          typeof b == 'function' &&
            (l === 'formAction'
              ? (a !== 'input' && Fe(r, a, 'name', m.name, m, null),
                Fe(r, a, 'formEncType', m.formEncType, m, null),
                Fe(r, a, 'formMethod', m.formMethod, m, null),
                Fe(r, a, 'formTarget', m.formTarget, m, null))
              : (Fe(r, a, 'encType', m.encType, m, null),
                Fe(r, a, 'method', m.method, m, null),
                Fe(r, a, 'target', m.target, m, null)))
        if (f == null || typeof f == 'symbol' || typeof f == 'boolean') {
          r.removeAttribute(l)
          break
        }
        ;((f = Ts('' + f)), r.setAttribute(l, f))
        break
      case 'onClick':
        f != null && (r.onclick = lf)
        break
      case 'onScroll':
        f != null && Ee('scroll', r)
        break
      case 'onScrollEnd':
        f != null && Ee('scrollend', r)
        break
      case 'dangerouslySetInnerHTML':
        if (f != null) {
          if (typeof f != 'object' || !('__html' in f)) throw Error(i(61))
          if (((l = f.__html), l != null)) {
            if (m.children != null) throw Error(i(60))
            r.innerHTML = l
          }
        }
        break
      case 'multiple':
        r.multiple = f && typeof f != 'function' && typeof f != 'symbol'
        break
      case 'muted':
        r.muted = f && typeof f != 'function' && typeof f != 'symbol'
        break
      case 'suppressContentEditableWarning':
      case 'suppressHydrationWarning':
      case 'defaultValue':
      case 'defaultChecked':
      case 'innerHTML':
      case 'ref':
        break
      case 'autoFocus':
        break
      case 'xlinkHref':
        if (f == null || typeof f == 'function' || typeof f == 'boolean' || typeof f == 'symbol') {
          r.removeAttribute('xlink:href')
          break
        }
        ;((l = Ts('' + f)), r.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', l))
        break
      case 'contentEditable':
      case 'spellCheck':
      case 'draggable':
      case 'value':
      case 'autoReverse':
      case 'externalResourcesRequired':
      case 'focusable':
      case 'preserveAlpha':
        f != null && typeof f != 'function' && typeof f != 'symbol'
          ? r.setAttribute(l, '' + f)
          : r.removeAttribute(l)
        break
      case 'inert':
      case 'allowFullScreen':
      case 'async':
      case 'autoPlay':
      case 'controls':
      case 'default':
      case 'defer':
      case 'disabled':
      case 'disablePictureInPicture':
      case 'disableRemotePlayback':
      case 'formNoValidate':
      case 'hidden':
      case 'loop':
      case 'noModule':
      case 'noValidate':
      case 'open':
      case 'playsInline':
      case 'readOnly':
      case 'required':
      case 'reversed':
      case 'scoped':
      case 'seamless':
      case 'itemScope':
        f && typeof f != 'function' && typeof f != 'symbol'
          ? r.setAttribute(l, '')
          : r.removeAttribute(l)
        break
      case 'capture':
      case 'download':
        f === !0
          ? r.setAttribute(l, '')
          : f !== !1 && f != null && typeof f != 'function' && typeof f != 'symbol'
            ? r.setAttribute(l, f)
            : r.removeAttribute(l)
        break
      case 'cols':
      case 'rows':
      case 'size':
      case 'span':
        f != null && typeof f != 'function' && typeof f != 'symbol' && !isNaN(f) && 1 <= f
          ? r.setAttribute(l, f)
          : r.removeAttribute(l)
        break
      case 'rowSpan':
      case 'start':
        f == null || typeof f == 'function' || typeof f == 'symbol' || isNaN(f)
          ? r.removeAttribute(l)
          : r.setAttribute(l, f)
        break
      case 'popover':
        ;(Ee('beforetoggle', r), Ee('toggle', r), Cs(r, 'popover', f))
        break
      case 'xlinkActuate':
        gr(r, 'http://www.w3.org/1999/xlink', 'xlink:actuate', f)
        break
      case 'xlinkArcrole':
        gr(r, 'http://www.w3.org/1999/xlink', 'xlink:arcrole', f)
        break
      case 'xlinkRole':
        gr(r, 'http://www.w3.org/1999/xlink', 'xlink:role', f)
        break
      case 'xlinkShow':
        gr(r, 'http://www.w3.org/1999/xlink', 'xlink:show', f)
        break
      case 'xlinkTitle':
        gr(r, 'http://www.w3.org/1999/xlink', 'xlink:title', f)
        break
      case 'xlinkType':
        gr(r, 'http://www.w3.org/1999/xlink', 'xlink:type', f)
        break
      case 'xmlBase':
        gr(r, 'http://www.w3.org/XML/1998/namespace', 'xml:base', f)
        break
      case 'xmlLang':
        gr(r, 'http://www.w3.org/XML/1998/namespace', 'xml:lang', f)
        break
      case 'xmlSpace':
        gr(r, 'http://www.w3.org/XML/1998/namespace', 'xml:space', f)
        break
      case 'is':
        Cs(r, 'is', f)
        break
      case 'innerText':
      case 'textContent':
        break
      default:
        ;(!(2 < l.length) || (l[0] !== 'o' && l[0] !== 'O') || (l[1] !== 'n' && l[1] !== 'N')) &&
          ((l = Xh.get(l) || l), Cs(r, l, f))
    }
  }
  function Ag(r, a, l, f, m, b) {
    switch (l) {
      case 'style':
        Rr(r, f, b)
        break
      case 'dangerouslySetInnerHTML':
        if (f != null) {
          if (typeof f != 'object' || !('__html' in f)) throw Error(i(61))
          if (((l = f.__html), l != null)) {
            if (m.children != null) throw Error(i(60))
            r.innerHTML = l
          }
        }
        break
      case 'children':
        typeof f == 'string'
          ? za(r, f)
          : (typeof f == 'number' || typeof f == 'bigint') && za(r, '' + f)
        break
      case 'onScroll':
        f != null && Ee('scroll', r)
        break
      case 'onScrollEnd':
        f != null && Ee('scrollend', r)
        break
      case 'onClick':
        f != null && (r.onclick = lf)
        break
      case 'suppressContentEditableWarning':
      case 'suppressHydrationWarning':
      case 'innerHTML':
      case 'ref':
        break
      case 'innerText':
      case 'textContent':
        break
      default:
        if (!co.hasOwnProperty(l))
          t: {
            if (
              l[0] === 'o' &&
              l[1] === 'n' &&
              ((m = l.endsWith('Capture')),
              (a = l.slice(2, m ? l.length - 7 : void 0)),
              (b = r[gn] || null),
              (b = b != null ? b[l] : null),
              typeof b == 'function' && r.removeEventListener(a, b, m),
              typeof f == 'function')
            ) {
              ;(typeof b != 'function' &&
                b !== null &&
                (l in r ? (r[l] = null) : r.hasAttribute(l) && r.removeAttribute(l)),
                r.addEventListener(a, f, m))
              break t
            }
            l in r ? (r[l] = f) : f === !0 ? r.setAttribute(l, '') : Cs(r, l, f)
          }
    }
  }
  function Vn(r, a, l) {
    switch (a) {
      case 'div':
      case 'span':
      case 'svg':
      case 'path':
      case 'a':
      case 'g':
      case 'p':
      case 'li':
        break
      case 'img':
        ;(Ee('error', r), Ee('load', r))
        var f = !1,
          m = !1,
          b
        for (b in l)
          if (l.hasOwnProperty(b)) {
            var O = l[b]
            if (O != null)
              switch (b) {
                case 'src':
                  f = !0
                  break
                case 'srcSet':
                  m = !0
                  break
                case 'children':
                case 'dangerouslySetInnerHTML':
                  throw Error(i(137, a))
                default:
                  Fe(r, a, b, O, l, null)
              }
          }
        ;(m && Fe(r, a, 'srcSet', l.srcSet, l, null), f && Fe(r, a, 'src', l.src, l, null))
        return
      case 'input':
        Ee('invalid', r)
        var j = (b = O = m = null),
          K = null,
          pt = null
        for (f in l)
          if (l.hasOwnProperty(f)) {
            var Ot = l[f]
            if (Ot != null)
              switch (f) {
                case 'name':
                  m = Ot
                  break
                case 'type':
                  O = Ot
                  break
                case 'checked':
                  K = Ot
                  break
                case 'defaultChecked':
                  pt = Ot
                  break
                case 'value':
                  b = Ot
                  break
                case 'defaultValue':
                  j = Ot
                  break
                case 'children':
                case 'dangerouslySetInnerHTML':
                  if (Ot != null) throw Error(i(137, a))
                  break
                default:
                  Fe(r, a, f, Ot, l, null)
              }
          }
        ;(gc(r, b, j, K, pt, O, m, !1), po(r))
        return
      case 'select':
        ;(Ee('invalid', r), (f = O = b = null))
        for (m in l)
          if (l.hasOwnProperty(m) && ((j = l[m]), j != null))
            switch (m) {
              case 'value':
                b = j
                break
              case 'defaultValue':
                O = j
                break
              case 'multiple':
                f = j
              default:
                Fe(r, a, m, j, l, null)
            }
        ;((a = b),
          (l = O),
          (r.multiple = !!f),
          a != null ? Rn(r, !!f, a, !1) : l != null && Rn(r, !!f, l, !0))
        return
      case 'textarea':
        ;(Ee('invalid', r), (b = m = f = null))
        for (O in l)
          if (l.hasOwnProperty(O) && ((j = l[O]), j != null))
            switch (O) {
              case 'value':
                f = j
                break
              case 'defaultValue':
                m = j
                break
              case 'children':
                b = j
                break
              case 'dangerouslySetInnerHTML':
                if (j != null) throw Error(i(91))
                break
              default:
                Fe(r, a, O, j, l, null)
            }
        ;(La(r, f, m, b), po(r))
        return
      case 'option':
        for (K in l)
          if (l.hasOwnProperty(K) && ((f = l[K]), f != null))
            switch (K) {
              case 'selected':
                r.selected = f && typeof f != 'function' && typeof f != 'symbol'
                break
              default:
                Fe(r, a, K, f, l, null)
            }
        return
      case 'dialog':
        ;(Ee('beforetoggle', r), Ee('toggle', r), Ee('cancel', r), Ee('close', r))
        break
      case 'iframe':
      case 'object':
        Ee('load', r)
        break
      case 'video':
      case 'audio':
        for (f = 0; f < uu.length; f++) Ee(uu[f], r)
        break
      case 'image':
        ;(Ee('error', r), Ee('load', r))
        break
      case 'details':
        Ee('toggle', r)
        break
      case 'embed':
      case 'source':
      case 'link':
        ;(Ee('error', r), Ee('load', r))
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'hr':
      case 'keygen':
      case 'meta':
      case 'param':
      case 'track':
      case 'wbr':
      case 'menuitem':
        for (pt in l)
          if (l.hasOwnProperty(pt) && ((f = l[pt]), f != null))
            switch (pt) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw Error(i(137, a))
              default:
                Fe(r, a, pt, f, l, null)
            }
        return
      default:
        if (Ss(a)) {
          for (Ot in l)
            l.hasOwnProperty(Ot) && ((f = l[Ot]), f !== void 0 && Ag(r, a, Ot, f, l, void 0))
          return
        }
    }
    for (j in l) l.hasOwnProperty(j) && ((f = l[j]), f != null && Fe(r, a, j, f, l, null))
  }
  function DN(r, a, l, f) {
    switch (a) {
      case 'div':
      case 'span':
      case 'svg':
      case 'path':
      case 'a':
      case 'g':
      case 'p':
      case 'li':
        break
      case 'input':
        var m = null,
          b = null,
          O = null,
          j = null,
          K = null,
          pt = null,
          Ot = null
        for (It in l) {
          var zt = l[It]
          if (l.hasOwnProperty(It) && zt != null)
            switch (It) {
              case 'checked':
                break
              case 'value':
                break
              case 'defaultValue':
                K = zt
              default:
                f.hasOwnProperty(It) || Fe(r, a, It, null, f, zt)
            }
        }
        for (var mt in f) {
          var It = f[mt]
          if (((zt = l[mt]), f.hasOwnProperty(mt) && (It != null || zt != null)))
            switch (mt) {
              case 'type':
                b = It
                break
              case 'name':
                m = It
                break
              case 'checked':
                pt = It
                break
              case 'defaultChecked':
                Ot = It
                break
              case 'value':
                O = It
                break
              case 'defaultValue':
                j = It
                break
              case 'children':
              case 'dangerouslySetInnerHTML':
                if (It != null) throw Error(i(137, a))
                break
              default:
                It !== zt && Fe(r, a, mt, It, f, zt)
            }
        }
        vo(r, O, j, K, pt, Ot, b, m)
        return
      case 'select':
        It = O = j = mt = null
        for (b in l)
          if (((K = l[b]), l.hasOwnProperty(b) && K != null))
            switch (b) {
              case 'value':
                break
              case 'multiple':
                It = K
              default:
                f.hasOwnProperty(b) || Fe(r, a, b, null, f, K)
            }
        for (m in f)
          if (((b = f[m]), (K = l[m]), f.hasOwnProperty(m) && (b != null || K != null)))
            switch (m) {
              case 'value':
                mt = b
                break
              case 'defaultValue':
                j = b
                break
              case 'multiple':
                O = b
              default:
                b !== K && Fe(r, a, m, b, f, K)
            }
        ;((a = j),
          (l = O),
          (f = It),
          mt != null
            ? Rn(r, !!l, mt, !1)
            : !!f != !!l && (a != null ? Rn(r, !!l, a, !0) : Rn(r, !!l, l ? [] : '', !1)))
        return
      case 'textarea':
        It = mt = null
        for (j in l)
          if (((m = l[j]), l.hasOwnProperty(j) && m != null && !f.hasOwnProperty(j)))
            switch (j) {
              case 'value':
                break
              case 'children':
                break
              default:
                Fe(r, a, j, null, f, m)
            }
        for (O in f)
          if (((m = f[O]), (b = l[O]), f.hasOwnProperty(O) && (m != null || b != null)))
            switch (O) {
              case 'value':
                mt = m
                break
              case 'defaultValue':
                It = m
                break
              case 'children':
                break
              case 'dangerouslySetInnerHTML':
                if (m != null) throw Error(i(91))
                break
              default:
                m !== b && Fe(r, a, O, m, f, b)
            }
        Nl(r, mt, It)
        return
      case 'option':
        for (var le in l)
          if (((mt = l[le]), l.hasOwnProperty(le) && mt != null && !f.hasOwnProperty(le)))
            switch (le) {
              case 'selected':
                r.selected = !1
                break
              default:
                Fe(r, a, le, null, f, mt)
            }
        for (K in f)
          if (
            ((mt = f[K]),
            (It = l[K]),
            f.hasOwnProperty(K) && mt !== It && (mt != null || It != null))
          )
            switch (K) {
              case 'selected':
                r.selected = mt && typeof mt != 'function' && typeof mt != 'symbol'
                break
              default:
                Fe(r, a, K, mt, f, It)
            }
        return
      case 'img':
      case 'link':
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'embed':
      case 'hr':
      case 'keygen':
      case 'meta':
      case 'param':
      case 'source':
      case 'track':
      case 'wbr':
      case 'menuitem':
        for (var ie in l)
          ((mt = l[ie]),
            l.hasOwnProperty(ie) &&
              mt != null &&
              !f.hasOwnProperty(ie) &&
              Fe(r, a, ie, null, f, mt))
        for (pt in f)
          if (
            ((mt = f[pt]),
            (It = l[pt]),
            f.hasOwnProperty(pt) && mt !== It && (mt != null || It != null))
          )
            switch (pt) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                if (mt != null) throw Error(i(137, a))
                break
              default:
                Fe(r, a, pt, mt, f, It)
            }
        return
      default:
        if (Ss(a)) {
          for (var Je in l)
            ((mt = l[Je]),
              l.hasOwnProperty(Je) &&
                mt !== void 0 &&
                !f.hasOwnProperty(Je) &&
                Ag(r, a, Je, void 0, f, mt))
          for (Ot in f)
            ((mt = f[Ot]),
              (It = l[Ot]),
              !f.hasOwnProperty(Ot) ||
                mt === It ||
                (mt === void 0 && It === void 0) ||
                Ag(r, a, Ot, mt, f, It))
          return
        }
    }
    for (var ut in l)
      ((mt = l[ut]),
        l.hasOwnProperty(ut) && mt != null && !f.hasOwnProperty(ut) && Fe(r, a, ut, null, f, mt))
    for (zt in f)
      ((mt = f[zt]),
        (It = l[zt]),
        !f.hasOwnProperty(zt) || mt === It || (mt == null && It == null) || Fe(r, a, zt, mt, f, It))
  }
  var bg = null,
    Ig = null
  function uf(r) {
    return r.nodeType === 9 ? r : r.ownerDocument
  }
  function wA(r) {
    switch (r) {
      case 'http://www.w3.org/2000/svg':
        return 1
      case 'http://www.w3.org/1998/Math/MathML':
        return 2
      default:
        return 0
    }
  }
  function xA(r, a) {
    if (r === 0)
      switch (a) {
        case 'svg':
          return 1
        case 'math':
          return 2
        default:
          return 0
      }
    return r === 1 && a === 'foreignObject' ? 0 : r
  }
  function Cg(r, a) {
    return (
      r === 'textarea' ||
      r === 'noscript' ||
      typeof a.children == 'string' ||
      typeof a.children == 'number' ||
      typeof a.children == 'bigint' ||
      (typeof a.dangerouslySetInnerHTML == 'object' &&
        a.dangerouslySetInnerHTML !== null &&
        a.dangerouslySetInnerHTML.__html != null)
    )
  }
  var wg = null
  function ON() {
    var r = window.event
    return r && r.type === 'popstate' ? (r === wg ? !1 : ((wg = r), !0)) : ((wg = null), !1)
  }
  var SA = typeof setTimeout == 'function' ? setTimeout : void 0,
    LN = typeof clearTimeout == 'function' ? clearTimeout : void 0,
    NA = typeof Promise == 'function' ? Promise : void 0,
    zN =
      typeof queueMicrotask == 'function'
        ? queueMicrotask
        : typeof NA < 'u'
          ? function (r) {
              return NA.resolve(null).then(r).catch(RN)
            }
          : SA
  function RN(r) {
    setTimeout(function () {
      throw r
    })
  }
  function Ka(r) {
    return r === 'head'
  }
  function TA(r, a) {
    var l = a,
      f = 0,
      m = 0
    do {
      var b = l.nextSibling
      if ((r.removeChild(l), b && b.nodeType === 8))
        if (((l = b.data), l === '/$')) {
          if (0 < f && 8 > f) {
            l = f
            var O = r.ownerDocument
            if ((l & 1 && fu(O.documentElement), l & 2 && fu(O.body), l & 4))
              for (l = O.head, fu(l), O = l.firstChild; O; ) {
                var j = O.nextSibling,
                  K = O.nodeName
                ;(O[Ta] ||
                  K === 'SCRIPT' ||
                  K === 'STYLE' ||
                  (K === 'LINK' && O.rel.toLowerCase() === 'stylesheet') ||
                  l.removeChild(O),
                  (O = j))
              }
          }
          if (m === 0) {
            ;(r.removeChild(b), Au(a))
            return
          }
          m--
        } else l === '$' || l === '$?' || l === '$!' ? m++ : (f = l.charCodeAt(0) - 48)
      else f = 0
      l = b
    } while (l)
    Au(a)
  }
  function xg(r) {
    var a = r.firstChild
    for (a && a.nodeType === 10 && (a = a.nextSibling); a; ) {
      var l = a
      switch (((a = a.nextSibling), l.nodeName)) {
        case 'HTML':
        case 'HEAD':
        case 'BODY':
          ;(xg(l), Il(l))
          continue
        case 'SCRIPT':
        case 'STYLE':
          continue
        case 'LINK':
          if (l.rel.toLowerCase() === 'stylesheet') continue
      }
      r.removeChild(l)
    }
  }
  function kN(r, a, l, f) {
    for (; r.nodeType === 1; ) {
      var m = l
      if (r.nodeName.toLowerCase() !== a.toLowerCase()) {
        if (!f && (r.nodeName !== 'INPUT' || r.type !== 'hidden')) break
      } else if (f) {
        if (!r[Ta])
          switch (a) {
            case 'meta':
              if (!r.hasAttribute('itemprop')) break
              return r
            case 'link':
              if (
                ((b = r.getAttribute('rel')),
                b === 'stylesheet' && r.hasAttribute('data-precedence'))
              )
                break
              if (
                b !== m.rel ||
                r.getAttribute('href') !== (m.href == null || m.href === '' ? null : m.href) ||
                r.getAttribute('crossorigin') !== (m.crossOrigin == null ? null : m.crossOrigin) ||
                r.getAttribute('title') !== (m.title == null ? null : m.title)
              )
                break
              return r
            case 'style':
              if (r.hasAttribute('data-precedence')) break
              return r
            case 'script':
              if (
                ((b = r.getAttribute('src')),
                (b !== (m.src == null ? null : m.src) ||
                  r.getAttribute('type') !== (m.type == null ? null : m.type) ||
                  r.getAttribute('crossorigin') !==
                    (m.crossOrigin == null ? null : m.crossOrigin)) &&
                  b &&
                  r.hasAttribute('async') &&
                  !r.hasAttribute('itemprop'))
              )
                break
              return r
            default:
              return r
          }
      } else if (a === 'input' && r.type === 'hidden') {
        var b = m.name == null ? null : '' + m.name
        if (m.type === 'hidden' && r.getAttribute('name') === b) return r
      } else return r
      if (((r = Nr(r.nextSibling)), r === null)) break
    }
    return null
  }
  function _N(r, a, l) {
    if (a === '') return null
    for (; r.nodeType !== 3; )
      if (
        ((r.nodeType !== 1 || r.nodeName !== 'INPUT' || r.type !== 'hidden') && !l) ||
        ((r = Nr(r.nextSibling)), r === null)
      )
        return null
    return r
  }
  function Sg(r) {
    return r.data === '$!' || (r.data === '$?' && r.ownerDocument.readyState === 'complete')
  }
  function BN(r, a) {
    var l = r.ownerDocument
    if (r.data !== '$?' || l.readyState === 'complete') a()
    else {
      var f = function () {
        ;(a(), l.removeEventListener('DOMContentLoaded', f))
      }
      ;(l.addEventListener('DOMContentLoaded', f), (r._reactRetry = f))
    }
  }
  function Nr(r) {
    for (; r != null; r = r.nextSibling) {
      var a = r.nodeType
      if (a === 1 || a === 3) break
      if (a === 8) {
        if (((a = r.data), a === '$' || a === '$!' || a === '$?' || a === 'F!' || a === 'F')) break
        if (a === '/$') return null
      }
    }
    return r
  }
  var Ng = null
  function MA(r) {
    r = r.previousSibling
    for (var a = 0; r; ) {
      if (r.nodeType === 8) {
        var l = r.data
        if (l === '$' || l === '$!' || l === '$?') {
          if (a === 0) return r
          a--
        } else l === '/$' && a++
      }
      r = r.previousSibling
    }
    return null
  }
  function EA(r, a, l) {
    switch (((a = uf(l)), r)) {
      case 'html':
        if (((r = a.documentElement), !r)) throw Error(i(452))
        return r
      case 'head':
        if (((r = a.head), !r)) throw Error(i(453))
        return r
      case 'body':
        if (((r = a.body), !r)) throw Error(i(454))
        return r
      default:
        throw Error(i(451))
    }
  }
  function fu(r) {
    for (var a = r.attributes; a.length; ) r.removeAttributeNode(a[0])
    Il(r)
  }
  var nr = new Map(),
    DA = new Set()
  function cf(r) {
    return typeof r.getRootNode == 'function'
      ? r.getRootNode()
      : r.nodeType === 9
        ? r
        : r.ownerDocument
  }
  var va = Q.d
  Q.d = { f: jN, r: PN, D: GN, C: ZN, L: UN, m: YN, X: VN, S: HN, M: XN }
  function jN() {
    var r = va.f(),
      a = tf()
    return r || a
  }
  function PN(r) {
    var a = Wr(r)
    a !== null && a.tag === 5 && a.type === 'form' ? q0(a) : va.r(r)
  }
  var Jo = typeof document > 'u' ? null : document
  function OA(r, a, l) {
    var f = Jo
    if (f && typeof a == 'string' && a) {
      var m = Un(a)
      ;((m = 'link[rel="' + r + '"][href="' + m + '"]'),
        typeof l == 'string' && (m += '[crossorigin="' + l + '"]'),
        DA.has(m) ||
          (DA.add(m),
          (r = { rel: r, crossOrigin: l, href: a }),
          f.querySelector(m) === null &&
            ((a = f.createElement('link')), Vn(a, 'link', r), pn(a), f.head.appendChild(a))))
    }
  }
  function GN(r) {
    ;(va.D(r), OA('dns-prefetch', r, null))
  }
  function ZN(r, a) {
    ;(va.C(r, a), OA('preconnect', r, a))
  }
  function UN(r, a, l) {
    va.L(r, a, l)
    var f = Jo
    if (f && r && a) {
      var m = 'link[rel="preload"][as="' + Un(a) + '"]'
      a === 'image' && l && l.imageSrcSet
        ? ((m += '[imagesrcset="' + Un(l.imageSrcSet) + '"]'),
          typeof l.imageSizes == 'string' && (m += '[imagesizes="' + Un(l.imageSizes) + '"]'))
        : (m += '[href="' + Un(r) + '"]')
      var b = m
      switch (a) {
        case 'style':
          b = qo(r)
          break
        case 'script':
          b = Qo(r)
      }
      nr.has(b) ||
        ((r = y(
          { rel: 'preload', href: a === 'image' && l && l.imageSrcSet ? void 0 : r, as: a },
          l
        )),
        nr.set(b, r),
        f.querySelector(m) !== null ||
          (a === 'style' && f.querySelector(hu(b))) ||
          (a === 'script' && f.querySelector(du(b))) ||
          ((a = f.createElement('link')), Vn(a, 'link', r), pn(a), f.head.appendChild(a)))
    }
  }
  function YN(r, a) {
    va.m(r, a)
    var l = Jo
    if (l && r) {
      var f = a && typeof a.as == 'string' ? a.as : 'script',
        m = 'link[rel="modulepreload"][as="' + Un(f) + '"][href="' + Un(r) + '"]',
        b = m
      switch (f) {
        case 'audioworklet':
        case 'paintworklet':
        case 'serviceworker':
        case 'sharedworker':
        case 'worker':
        case 'script':
          b = Qo(r)
      }
      if (
        !nr.has(b) &&
        ((r = y({ rel: 'modulepreload', href: r }, a)), nr.set(b, r), l.querySelector(m) === null)
      ) {
        switch (f) {
          case 'audioworklet':
          case 'paintworklet':
          case 'serviceworker':
          case 'sharedworker':
          case 'worker':
          case 'script':
            if (l.querySelector(du(b))) return
        }
        ;((f = l.createElement('link')), Vn(f, 'link', r), pn(f), l.head.appendChild(f))
      }
    }
  }
  function HN(r, a, l) {
    va.S(r, a, l)
    var f = Jo
    if (f && r) {
      var m = Ni(f).hoistableStyles,
        b = qo(r)
      a = a || 'default'
      var O = m.get(b)
      if (!O) {
        var j = { loading: 0, preload: null }
        if ((O = f.querySelector(hu(b)))) j.loading = 5
        else {
          ;((r = y({ rel: 'stylesheet', href: r, 'data-precedence': a }, l)),
            (l = nr.get(b)) && Tg(r, l))
          var K = (O = f.createElement('link'))
          ;(pn(K),
            Vn(K, 'link', r),
            (K._p = new Promise(function (pt, Ot) {
              ;((K.onload = pt), (K.onerror = Ot))
            })),
            K.addEventListener('load', function () {
              j.loading |= 1
            }),
            K.addEventListener('error', function () {
              j.loading |= 2
            }),
            (j.loading |= 4),
            ff(O, a, f))
        }
        ;((O = { type: 'stylesheet', instance: O, count: 1, state: j }), m.set(b, O))
      }
    }
  }
  function VN(r, a) {
    va.X(r, a)
    var l = Jo
    if (l && r) {
      var f = Ni(l).hoistableScripts,
        m = Qo(r),
        b = f.get(m)
      b ||
        ((b = l.querySelector(du(m))),
        b ||
          ((r = y({ src: r, async: !0 }, a)),
          (a = nr.get(m)) && Mg(r, a),
          (b = l.createElement('script')),
          pn(b),
          Vn(b, 'link', r),
          l.head.appendChild(b)),
        (b = { type: 'script', instance: b, count: 1, state: null }),
        f.set(m, b))
    }
  }
  function XN(r, a) {
    va.M(r, a)
    var l = Jo
    if (l && r) {
      var f = Ni(l).hoistableScripts,
        m = Qo(r),
        b = f.get(m)
      b ||
        ((b = l.querySelector(du(m))),
        b ||
          ((r = y({ src: r, async: !0, type: 'module' }, a)),
          (a = nr.get(m)) && Mg(r, a),
          (b = l.createElement('script')),
          pn(b),
          Vn(b, 'link', r),
          l.head.appendChild(b)),
        (b = { type: 'script', instance: b, count: 1, state: null }),
        f.set(m, b))
    }
  }
  function LA(r, a, l, f) {
    var m = (m = lt.current) ? cf(m) : null
    if (!m) throw Error(i(446))
    switch (r) {
      case 'meta':
      case 'title':
        return null
      case 'style':
        return typeof l.precedence == 'string' && typeof l.href == 'string'
          ? ((a = qo(l.href)),
            (l = Ni(m).hoistableStyles),
            (f = l.get(a)),
            f || ((f = { type: 'style', instance: null, count: 0, state: null }), l.set(a, f)),
            f)
          : { type: 'void', instance: null, count: 0, state: null }
      case 'link':
        if (
          l.rel === 'stylesheet' &&
          typeof l.href == 'string' &&
          typeof l.precedence == 'string'
        ) {
          r = qo(l.href)
          var b = Ni(m).hoistableStyles,
            O = b.get(r)
          if (
            (O ||
              ((m = m.ownerDocument || m),
              (O = {
                type: 'stylesheet',
                instance: null,
                count: 0,
                state: { loading: 0, preload: null },
              }),
              b.set(r, O),
              (b = m.querySelector(hu(r))) && !b._p && ((O.instance = b), (O.state.loading = 5)),
              nr.has(r) ||
                ((l = {
                  rel: 'preload',
                  as: 'style',
                  href: l.href,
                  crossOrigin: l.crossOrigin,
                  integrity: l.integrity,
                  media: l.media,
                  hrefLang: l.hrefLang,
                  referrerPolicy: l.referrerPolicy,
                }),
                nr.set(r, l),
                b || WN(m, r, l, O.state))),
            a && f === null)
          )
            throw Error(i(528, ''))
          return O
        }
        if (a && f !== null) throw Error(i(529, ''))
        return null
      case 'script':
        return (
          (a = l.async),
          (l = l.src),
          typeof l == 'string' && a && typeof a != 'function' && typeof a != 'symbol'
            ? ((a = Qo(l)),
              (l = Ni(m).hoistableScripts),
              (f = l.get(a)),
              f || ((f = { type: 'script', instance: null, count: 0, state: null }), l.set(a, f)),
              f)
            : { type: 'void', instance: null, count: 0, state: null }
        )
      default:
        throw Error(i(444, r))
    }
  }
  function qo(r) {
    return 'href="' + Un(r) + '"'
  }
  function hu(r) {
    return 'link[rel="stylesheet"][' + r + ']'
  }
  function zA(r) {
    return y({}, r, { 'data-precedence': r.precedence, precedence: null })
  }
  function WN(r, a, l, f) {
    r.querySelector('link[rel="preload"][as="style"][' + a + ']')
      ? (f.loading = 1)
      : ((a = r.createElement('link')),
        (f.preload = a),
        a.addEventListener('load', function () {
          return (f.loading |= 1)
        }),
        a.addEventListener('error', function () {
          return (f.loading |= 2)
        }),
        Vn(a, 'link', l),
        pn(a),
        r.head.appendChild(a))
  }
  function Qo(r) {
    return '[src="' + Un(r) + '"]'
  }
  function du(r) {
    return 'script[async]' + r
  }
  function RA(r, a, l) {
    if ((a.count++, a.instance === null))
      switch (a.type) {
        case 'style':
          var f = r.querySelector('style[data-href~="' + Un(l.href) + '"]')
          if (f) return ((a.instance = f), pn(f), f)
          var m = y({}, l, {
            'data-href': l.href,
            'data-precedence': l.precedence,
            href: null,
            precedence: null,
          })
          return (
            (f = (r.ownerDocument || r).createElement('style')),
            pn(f),
            Vn(f, 'style', m),
            ff(f, l.precedence, r),
            (a.instance = f)
          )
        case 'stylesheet':
          m = qo(l.href)
          var b = r.querySelector(hu(m))
          if (b) return ((a.state.loading |= 4), (a.instance = b), pn(b), b)
          ;((f = zA(l)),
            (m = nr.get(m)) && Tg(f, m),
            (b = (r.ownerDocument || r).createElement('link')),
            pn(b))
          var O = b
          return (
            (O._p = new Promise(function (j, K) {
              ;((O.onload = j), (O.onerror = K))
            })),
            Vn(b, 'link', f),
            (a.state.loading |= 4),
            ff(b, l.precedence, r),
            (a.instance = b)
          )
        case 'script':
          return (
            (b = Qo(l.src)),
            (m = r.querySelector(du(b)))
              ? ((a.instance = m), pn(m), m)
              : ((f = l),
                (m = nr.get(b)) && ((f = y({}, l)), Mg(f, m)),
                (r = r.ownerDocument || r),
                (m = r.createElement('script')),
                pn(m),
                Vn(m, 'link', f),
                r.head.appendChild(m),
                (a.instance = m))
          )
        case 'void':
          return null
        default:
          throw Error(i(443, a.type))
      }
    else
      a.type === 'stylesheet' &&
        (a.state.loading & 4) === 0 &&
        ((f = a.instance), (a.state.loading |= 4), ff(f, l.precedence, r))
    return a.instance
  }
  function ff(r, a, l) {
    for (
      var f = l.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),
        m = f.length ? f[f.length - 1] : null,
        b = m,
        O = 0;
      O < f.length;
      O++
    ) {
      var j = f[O]
      if (j.dataset.precedence === a) b = j
      else if (b !== m) break
    }
    b
      ? b.parentNode.insertBefore(r, b.nextSibling)
      : ((a = l.nodeType === 9 ? l.head : l), a.insertBefore(r, a.firstChild))
  }
  function Tg(r, a) {
    ;(r.crossOrigin == null && (r.crossOrigin = a.crossOrigin),
      r.referrerPolicy == null && (r.referrerPolicy = a.referrerPolicy),
      r.title == null && (r.title = a.title))
  }
  function Mg(r, a) {
    ;(r.crossOrigin == null && (r.crossOrigin = a.crossOrigin),
      r.referrerPolicy == null && (r.referrerPolicy = a.referrerPolicy),
      r.integrity == null && (r.integrity = a.integrity))
  }
  var hf = null
  function kA(r, a, l) {
    if (hf === null) {
      var f = new Map(),
        m = (hf = new Map())
      m.set(l, f)
    } else ((m = hf), (f = m.get(l)), f || ((f = new Map()), m.set(l, f)))
    if (f.has(r)) return f
    for (f.set(r, null), l = l.getElementsByTagName(r), m = 0; m < l.length; m++) {
      var b = l[m]
      if (
        !(b[Ta] || b[sn] || (r === 'link' && b.getAttribute('rel') === 'stylesheet')) &&
        b.namespaceURI !== 'http://www.w3.org/2000/svg'
      ) {
        var O = b.getAttribute(a) || ''
        O = r + O
        var j = f.get(O)
        j ? j.push(b) : f.set(O, [b])
      }
    }
    return f
  }
  function _A(r, a, l) {
    ;((r = r.ownerDocument || r),
      r.head.insertBefore(l, a === 'title' ? r.querySelector('head > title') : null))
  }
  function FN(r, a, l) {
    if (l === 1 || a.itemProp != null) return !1
    switch (r) {
      case 'meta':
      case 'title':
        return !0
      case 'style':
        if (typeof a.precedence != 'string' || typeof a.href != 'string' || a.href === '') break
        return !0
      case 'link':
        if (
          typeof a.rel != 'string' ||
          typeof a.href != 'string' ||
          a.href === '' ||
          a.onLoad ||
          a.onError
        )
          break
        switch (a.rel) {
          case 'stylesheet':
            return ((r = a.disabled), typeof a.precedence == 'string' && r == null)
          default:
            return !0
        }
      case 'script':
        if (
          a.async &&
          typeof a.async != 'function' &&
          typeof a.async != 'symbol' &&
          !a.onLoad &&
          !a.onError &&
          a.src &&
          typeof a.src == 'string'
        )
          return !0
    }
    return !1
  }
  function BA(r) {
    return !(r.type === 'stylesheet' && (r.state.loading & 3) === 0)
  }
  var gu = null
  function JN() {}
  function qN(r, a, l) {
    if (gu === null) throw Error(i(475))
    var f = gu
    if (
      a.type === 'stylesheet' &&
      (typeof l.media != 'string' || matchMedia(l.media).matches !== !1) &&
      (a.state.loading & 4) === 0
    ) {
      if (a.instance === null) {
        var m = qo(l.href),
          b = r.querySelector(hu(m))
        if (b) {
          ;((r = b._p),
            r !== null &&
              typeof r == 'object' &&
              typeof r.then == 'function' &&
              (f.count++, (f = df.bind(f)), r.then(f, f)),
            (a.state.loading |= 4),
            (a.instance = b),
            pn(b))
          return
        }
        ;((b = r.ownerDocument || r),
          (l = zA(l)),
          (m = nr.get(m)) && Tg(l, m),
          (b = b.createElement('link')),
          pn(b))
        var O = b
        ;((O._p = new Promise(function (j, K) {
          ;((O.onload = j), (O.onerror = K))
        })),
          Vn(b, 'link', l),
          (a.instance = b))
      }
      ;(f.stylesheets === null && (f.stylesheets = new Map()),
        f.stylesheets.set(a, r),
        (r = a.state.preload) &&
          (a.state.loading & 3) === 0 &&
          (f.count++,
          (a = df.bind(f)),
          r.addEventListener('load', a),
          r.addEventListener('error', a)))
    }
  }
  function QN() {
    if (gu === null) throw Error(i(475))
    var r = gu
    return (
      r.stylesheets && r.count === 0 && Eg(r, r.stylesheets),
      0 < r.count
        ? function (a) {
            var l = setTimeout(function () {
              if ((r.stylesheets && Eg(r, r.stylesheets), r.unsuspend)) {
                var f = r.unsuspend
                ;((r.unsuspend = null), f())
              }
            }, 6e4)
            return (
              (r.unsuspend = a),
              function () {
                ;((r.unsuspend = null), clearTimeout(l))
              }
            )
          }
        : null
    )
  }
  function df() {
    if ((this.count--, this.count === 0)) {
      if (this.stylesheets) Eg(this, this.stylesheets)
      else if (this.unsuspend) {
        var r = this.unsuspend
        ;((this.unsuspend = null), r())
      }
    }
  }
  var gf = null
  function Eg(r, a) {
    ;((r.stylesheets = null),
      r.unsuspend !== null &&
        (r.count++, (gf = new Map()), a.forEach(KN, r), (gf = null), df.call(r)))
  }
  function KN(r, a) {
    if (!(a.state.loading & 4)) {
      var l = gf.get(r)
      if (l) var f = l.get(null)
      else {
        ;((l = new Map()), gf.set(r, l))
        for (
          var m = r.querySelectorAll('link[data-precedence],style[data-precedence]'), b = 0;
          b < m.length;
          b++
        ) {
          var O = m[b]
          ;(O.nodeName === 'LINK' || O.getAttribute('media') !== 'not all') &&
            (l.set(O.dataset.precedence, O), (f = O))
        }
        f && l.set(null, f)
      }
      ;((m = a.instance),
        (O = m.getAttribute('data-precedence')),
        (b = l.get(O) || f),
        b === f && l.set(null, m),
        l.set(O, m),
        this.count++,
        (f = df.bind(this)),
        m.addEventListener('load', f),
        m.addEventListener('error', f),
        b
          ? b.parentNode.insertBefore(m, b.nextSibling)
          : ((r = r.nodeType === 9 ? r.head : r), r.insertBefore(m, r.firstChild)),
        (a.state.loading |= 4))
    }
  }
  var pu = {
    $$typeof: H,
    Provider: null,
    Consumer: null,
    _currentValue: it,
    _currentValue2: it,
    _threadCount: 0,
  }
  function $N(r, a, l, f, m, b, O, j) {
    ;((this.tag = 1),
      (this.containerInfo = r),
      (this.pingCache = this.current = this.pendingChildren = null),
      (this.timeoutHandle = -1),
      (this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null),
      (this.callbackPriority = 0),
      (this.expirationTimes = Si(-1)),
      (this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Si(0)),
      (this.hiddenUpdates = Si(null)),
      (this.identifierPrefix = f),
      (this.onUncaughtError = m),
      (this.onCaughtError = b),
      (this.onRecoverableError = O),
      (this.pooledCache = null),
      (this.pooledCacheLanes = 0),
      (this.formState = j),
      (this.incompleteTransitions = new Map()))
  }
  function jA(r, a, l, f, m, b, O, j, K, pt, Ot, zt) {
    return (
      (r = new $N(r, a, l, O, j, K, pt, zt)),
      (a = 1),
      b === !0 && (a |= 24),
      (b = Di(3, null, null, a)),
      (r.current = b),
      (b.stateNode = r),
      (a = cd()),
      a.refCount++,
      (r.pooledCache = a),
      a.refCount++,
      (b.memoizedState = { element: f, isDehydrated: l, cache: a }),
      gd(b),
      r
    )
  }
  function PA(r) {
    return r ? ((r = Mo), r) : Mo
  }
  function GA(r, a, l, f, m, b) {
    ;((m = PA(m)),
      f.context === null ? (f.context = m) : (f.pendingContext = m),
      (f = Pa(a)),
      (f.payload = { element: l }),
      (b = b === void 0 ? null : b),
      b !== null && (f.callback = b),
      (l = Ga(r, f, a)),
      l !== null && (ki(l, r, a), Vl(l, r, a)))
  }
  function ZA(r, a) {
    if (((r = r.memoizedState), r !== null && r.dehydrated !== null)) {
      var l = r.retryLane
      r.retryLane = l !== 0 && l < a ? l : a
    }
  }
  function Dg(r, a) {
    ;(ZA(r, a), (r = r.alternate) && ZA(r, a))
  }
  function UA(r) {
    if (r.tag === 13) {
      var a = To(r, 67108864)
      ;(a !== null && ki(a, r, 67108864), Dg(r, 67108864))
    }
  }
  var pf = !0
  function tT(r, a, l, f) {
    var m = G.T
    G.T = null
    var b = Q.p
    try {
      ;((Q.p = 2), Og(r, a, l, f))
    } finally {
      ;((Q.p = b), (G.T = m))
    }
  }
  function eT(r, a, l, f) {
    var m = G.T
    G.T = null
    var b = Q.p
    try {
      ;((Q.p = 8), Og(r, a, l, f))
    } finally {
      ;((Q.p = b), (G.T = m))
    }
  }
  function Og(r, a, l, f) {
    if (pf) {
      var m = Lg(f)
      if (m === null) (yg(r, a, f, vf, l), HA(r, f))
      else if (iT(m, r, a, l, f)) f.stopPropagation()
      else if ((HA(r, f), a & 4 && -1 < nT.indexOf(r))) {
        for (; m !== null; ) {
          var b = Wr(m)
          if (b !== null)
            switch (b.tag) {
              case 3:
                if (((b = b.stateNode), b.current.memoizedState.isDehydrated)) {
                  var O = Ln(b.pendingLanes)
                  if (O !== 0) {
                    var j = b
                    for (j.pendingLanes |= 2, j.entangledLanes |= 2; O; ) {
                      var K = 1 << (31 - Ne(O))
                      ;((j.entanglements[1] |= K), (O &= ~K))
                    }
                    ;(Yr(b), (Ve & 6) === 0 && ((Kc = J() + 500), lu(0)))
                  }
                }
                break
              case 13:
                ;((j = To(b, 2)), j !== null && ki(j, b, 2), tf(), Dg(b, 2))
            }
          if (((b = Lg(f)), b === null && yg(r, a, f, vf, l), b === m)) break
          m = b
        }
        m !== null && f.stopPropagation()
      } else yg(r, a, f, null, l)
    }
  }
  function Lg(r) {
    return ((r = mo(r)), zg(r))
  }
  var vf = null
  function zg(r) {
    if (((vf = null), (r = Ma(r)), r !== null)) {
      var a = o(r)
      if (a === null) r = null
      else {
        var l = a.tag
        if (l === 13) {
          if (((r = u(a)), r !== null)) return r
          r = null
        } else if (l === 3) {
          if (a.stateNode.current.memoizedState.isDehydrated)
            return a.tag === 3 ? a.stateNode.containerInfo : null
          r = null
        } else a !== r && (r = null)
      }
    }
    return ((vf = r), null)
  }
  function YA(r) {
    switch (r) {
      case 'beforetoggle':
      case 'cancel':
      case 'click':
      case 'close':
      case 'contextmenu':
      case 'copy':
      case 'cut':
      case 'auxclick':
      case 'dblclick':
      case 'dragend':
      case 'dragstart':
      case 'drop':
      case 'focusin':
      case 'focusout':
      case 'input':
      case 'invalid':
      case 'keydown':
      case 'keypress':
      case 'keyup':
      case 'mousedown':
      case 'mouseup':
      case 'paste':
      case 'pause':
      case 'play':
      case 'pointercancel':
      case 'pointerdown':
      case 'pointerup':
      case 'ratechange':
      case 'reset':
      case 'resize':
      case 'seeked':
      case 'submit':
      case 'toggle':
      case 'touchcancel':
      case 'touchend':
      case 'touchstart':
      case 'volumechange':
      case 'change':
      case 'selectionchange':
      case 'textInput':
      case 'compositionstart':
      case 'compositionend':
      case 'compositionupdate':
      case 'beforeblur':
      case 'afterblur':
      case 'beforeinput':
      case 'blur':
      case 'fullscreenchange':
      case 'focus':
      case 'hashchange':
      case 'popstate':
      case 'select':
      case 'selectstart':
        return 2
      case 'drag':
      case 'dragenter':
      case 'dragexit':
      case 'dragleave':
      case 'dragover':
      case 'mousemove':
      case 'mouseout':
      case 'mouseover':
      case 'pointermove':
      case 'pointerout':
      case 'pointerover':
      case 'scroll':
      case 'touchmove':
      case 'wheel':
      case 'mouseenter':
      case 'mouseleave':
      case 'pointerenter':
      case 'pointerleave':
        return 8
      case 'message':
        switch (At()) {
          case Nt:
            return 2
          case Yt:
            return 8
          case se:
          case Se:
            return 32
          case $e:
            return 268435456
          default:
            return 32
        }
      default:
        return 32
    }
  }
  var Rg = !1,
    $a = null,
    ts = null,
    es = null,
    vu = new Map(),
    mu = new Map(),
    ns = [],
    nT =
      'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset'.split(
        ' '
      )
  function HA(r, a) {
    switch (r) {
      case 'focusin':
      case 'focusout':
        $a = null
        break
      case 'dragenter':
      case 'dragleave':
        ts = null
        break
      case 'mouseover':
      case 'mouseout':
        es = null
        break
      case 'pointerover':
      case 'pointerout':
        vu.delete(a.pointerId)
        break
      case 'gotpointercapture':
      case 'lostpointercapture':
        mu.delete(a.pointerId)
    }
  }
  function yu(r, a, l, f, m, b) {
    return r === null || r.nativeEvent !== b
      ? ((r = {
          blockedOn: a,
          domEventName: l,
          eventSystemFlags: f,
          nativeEvent: b,
          targetContainers: [m],
        }),
        a !== null && ((a = Wr(a)), a !== null && UA(a)),
        r)
      : ((r.eventSystemFlags |= f),
        (a = r.targetContainers),
        m !== null && a.indexOf(m) === -1 && a.push(m),
        r)
  }
  function iT(r, a, l, f, m) {
    switch (a) {
      case 'focusin':
        return (($a = yu($a, r, a, l, f, m)), !0)
      case 'dragenter':
        return ((ts = yu(ts, r, a, l, f, m)), !0)
      case 'mouseover':
        return ((es = yu(es, r, a, l, f, m)), !0)
      case 'pointerover':
        var b = m.pointerId
        return (vu.set(b, yu(vu.get(b) || null, r, a, l, f, m)), !0)
      case 'gotpointercapture':
        return ((b = m.pointerId), mu.set(b, yu(mu.get(b) || null, r, a, l, f, m)), !0)
    }
    return !1
  }
  function VA(r) {
    var a = Ma(r.target)
    if (a !== null) {
      var l = o(a)
      if (l !== null) {
        if (((a = l.tag), a === 13)) {
          if (((a = u(l)), a !== null)) {
            ;((r.blockedOn = a),
              lc(r.priority, function () {
                if (l.tag === 13) {
                  var f = Ri()
                  f = zn(f)
                  var m = To(l, f)
                  ;(m !== null && ki(m, l, f), Dg(l, f))
                }
              }))
            return
          }
        } else if (a === 3 && l.stateNode.current.memoizedState.isDehydrated) {
          r.blockedOn = l.tag === 3 ? l.stateNode.containerInfo : null
          return
        }
      }
    }
    r.blockedOn = null
  }
  function mf(r) {
    if (r.blockedOn !== null) return !1
    for (var a = r.targetContainers; 0 < a.length; ) {
      var l = Lg(r.nativeEvent)
      if (l === null) {
        l = r.nativeEvent
        var f = new l.constructor(l.type, l)
        ;((Ms = f), l.target.dispatchEvent(f), (Ms = null))
      } else return ((a = Wr(l)), a !== null && UA(a), (r.blockedOn = l), !1)
      a.shift()
    }
    return !0
  }
  function XA(r, a, l) {
    mf(r) && l.delete(a)
  }
  function rT() {
    ;((Rg = !1),
      $a !== null && mf($a) && ($a = null),
      ts !== null && mf(ts) && (ts = null),
      es !== null && mf(es) && (es = null),
      vu.forEach(XA),
      mu.forEach(XA))
  }
  function yf(r, a) {
    r.blockedOn === a &&
      ((r.blockedOn = null),
      Rg || ((Rg = !0), t.unstable_scheduleCallback(t.unstable_NormalPriority, rT)))
  }
  var Af = null
  function WA(r) {
    Af !== r &&
      ((Af = r),
      t.unstable_scheduleCallback(t.unstable_NormalPriority, function () {
        Af === r && (Af = null)
        for (var a = 0; a < r.length; a += 3) {
          var l = r[a],
            f = r[a + 1],
            m = r[a + 2]
          if (typeof f != 'function') {
            if (zg(f || l) === null) continue
            break
          }
          var b = Wr(l)
          b !== null &&
            (r.splice(a, 3),
            (a -= 3),
            zd(b, { pending: !0, data: m, method: l.method, action: f }, f, m))
        }
      }))
  }
  function Au(r) {
    function a(K) {
      return yf(K, r)
    }
    ;($a !== null && yf($a, r),
      ts !== null && yf(ts, r),
      es !== null && yf(es, r),
      vu.forEach(a),
      mu.forEach(a))
    for (var l = 0; l < ns.length; l++) {
      var f = ns[l]
      f.blockedOn === r && (f.blockedOn = null)
    }
    for (; 0 < ns.length && ((l = ns[0]), l.blockedOn === null); )
      (VA(l), l.blockedOn === null && ns.shift())
    if (((l = (r.ownerDocument || r).$$reactFormReplay), l != null))
      for (f = 0; f < l.length; f += 3) {
        var m = l[f],
          b = l[f + 1],
          O = m[gn] || null
        if (typeof b == 'function') O || WA(l)
        else if (O) {
          var j = null
          if (b && b.hasAttribute('formAction')) {
            if (((m = b), (O = b[gn] || null))) j = O.formAction
            else if (zg(m) !== null) continue
          } else j = O.action
          ;(typeof j == 'function' ? (l[f + 1] = j) : (l.splice(f, 3), (f -= 3)), WA(l))
        }
      }
  }
  function kg(r) {
    this._internalRoot = r
  }
  ;((bf.prototype.render = kg.prototype.render =
    function (r) {
      var a = this._internalRoot
      if (a === null) throw Error(i(409))
      var l = a.current,
        f = Ri()
      GA(l, f, r, a, null, null)
    }),
    (bf.prototype.unmount = kg.prototype.unmount =
      function () {
        var r = this._internalRoot
        if (r !== null) {
          this._internalRoot = null
          var a = r.containerInfo
          ;(GA(r.current, 2, null, r, null, null), tf(), (a[Lr] = null))
        }
      }))
  function bf(r) {
    this._internalRoot = r
  }
  bf.prototype.unstable_scheduleHydration = function (r) {
    if (r) {
      var a = oc()
      r = { blockedOn: null, target: r, priority: a }
      for (var l = 0; l < ns.length && a !== 0 && a < ns[l].priority; l++);
      ;(ns.splice(l, 0, r), l === 0 && VA(r))
    }
  }
  var FA = e.version
  if (FA !== '19.1.1') throw Error(i(527, FA, '19.1.1'))
  Q.findDOMNode = function (r) {
    var a = r._reactInternals
    if (a === void 0)
      throw typeof r.render == 'function'
        ? Error(i(188))
        : ((r = Object.keys(r).join(',')), Error(i(268, r)))
    return ((r = h(a)), (r = r !== null ? p(r) : null), (r = r === null ? null : r.stateNode), r)
  }
  var aT = {
    bundleType: 0,
    version: '19.1.1',
    rendererPackageName: 'react-dom',
    currentDispatcherRef: G,
    reconcilerVersion: '19.1.1',
  }
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
    var If = __REACT_DEVTOOLS_GLOBAL_HOOK__
    if (!If.isDisabled && If.supportsFiber)
      try {
        ;((ae = If.inject(aT)), (fe = If))
      } catch {}
  }
  return (
    (Iu.createRoot = function (r, a) {
      if (!s(r)) throw Error(i(299))
      var l = !1,
        f = '',
        m = cy,
        b = fy,
        O = hy,
        j = null
      return (
        a != null &&
          (a.unstable_strictMode === !0 && (l = !0),
          a.identifierPrefix !== void 0 && (f = a.identifierPrefix),
          a.onUncaughtError !== void 0 && (m = a.onUncaughtError),
          a.onCaughtError !== void 0 && (b = a.onCaughtError),
          a.onRecoverableError !== void 0 && (O = a.onRecoverableError),
          a.unstable_transitionCallbacks !== void 0 && (j = a.unstable_transitionCallbacks)),
        (a = jA(r, 1, !1, null, null, l, f, m, b, O, j, null)),
        (r[Lr] = a.current),
        mg(r),
        new kg(a)
      )
    }),
    (Iu.hydrateRoot = function (r, a, l) {
      if (!s(r)) throw Error(i(299))
      var f = !1,
        m = '',
        b = cy,
        O = fy,
        j = hy,
        K = null,
        pt = null
      return (
        l != null &&
          (l.unstable_strictMode === !0 && (f = !0),
          l.identifierPrefix !== void 0 && (m = l.identifierPrefix),
          l.onUncaughtError !== void 0 && (b = l.onUncaughtError),
          l.onCaughtError !== void 0 && (O = l.onCaughtError),
          l.onRecoverableError !== void 0 && (j = l.onRecoverableError),
          l.unstable_transitionCallbacks !== void 0 && (K = l.unstable_transitionCallbacks),
          l.formState !== void 0 && (pt = l.formState)),
        (a = jA(r, 1, !0, a, l ?? null, f, m, b, O, j, K, pt)),
        (a.context = PA(null)),
        (l = a.current),
        (f = Ri()),
        (f = zn(f)),
        (m = Pa(f)),
        (m.callback = null),
        Ga(l, m, f),
        (l = f),
        (a.current.lanes = l),
        hi(a, l),
        Yr(a),
        (r[Lr] = a.current),
        mg(r),
        new bf(a)
      )
    }),
    (Iu.version = '19.1.1'),
    Iu
  )
}
var rb
function mT() {
  if (rb) return jg.exports
  rb = 1
  function t() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)
      } catch (e) {
        console.error(e)
      }
  }
  return (t(), (jg.exports = vT()), jg.exports)
}
var yT = mT()
const AT = Hu(yT)
function bT({
  onNew: t,
  onImport: e,
  onExport: n,
  onShare: i,
  onGenerateDocAi: s,
  docLoading: o,
  docDisabled: u,
  onGenerateCode: c,
  genLoading: h = !1,
  genDisabled: p = !1,
  onAiDiagramOpen: y,
  aiLoading: v,
}) {
  const C = ce.useRef(null),
    w = () => C.current?.click(),
    N = T => {
      const z = T.target.files?.[0]
      ;(z && e(z), (T.target.value = ''))
    }
  return Gt.jsxs('header', {
    className: 'navbar',
    children: [
      Gt.jsxs('div', {
        className: 'brand',
        children: ['Diagramador ', Gt.jsx('span', { className: 'tag' })],
      }),
      Gt.jsxs('div', {
        className: 'actions',
        children: [
          Gt.jsx('button', { onClick: t, title: 'Nuevo proyecto', children: 'Nuevo' }),
          Gt.jsx('button', { onClick: w, title: 'Importar JSON', children: 'Importar' }),
          Gt.jsx('button', { onClick: n, title: 'Exportar JSON', children: 'Exportar' }),
          Gt.jsx('button', {
            onClick: i,
            title: 'Compartir enlace de snapshot',
            children: 'Compartir',
          }),
          Gt.jsx('button', {
            onClick: c,
            title: 'Generar backend Spring Boot (ZIP)',
            disabled: h || p,
            children: h ? 'Generando…' : 'Generar Código',
          }),
          Gt.jsx('button', {
            onClick: s,
            disabled: u || o,
            title: 'Generar documentación (IA) en PDF',
            children: o ? 'Creando PDF…' : 'Generar PDF',
          }),
          Gt.jsx('button', {
            onClick: y,
            title: 'Generar diagrama con IA',
            disabled: v,
            children: v ? 'IA...' : 'Diagrama con IA',
          }),
          Gt.jsx('input', {
            ref: C,
            type: 'file',
            accept: 'application/json',
            onChange: N,
            hidden: !0,
          }),
        ],
      }),
    ],
  })
}
function IT({
  onAddClass: t,
  onSetRelation: e,
  onAddAttribute: n,
  onRenameSelected: i,
  onUpdateAttribute: s,
  onRemoveAttribute: o,
  onDeleteSelected: u,
  onUpdateMultiplicity: c,
  selectedMeta: h,
}) {
  const [p, y] = ce.useState(''),
    [v, C] = ce.useState([]),
    [w, N] = ce.useState('1'),
    [T, z] = ce.useState('0..*')
  ce.useEffect(() => {
    h &&
      (h.isLink
        ? (N(h.multSource ?? '1'), z(h.multTarget ?? '0..*'))
        : (y(h.name || ''), C(h.attributes || [])))
  }, [h])
  const R = !h || h.type !== 'uml.Class'
  return Gt.jsxs('aside', {
    className: 'sidebar',
    children: [
      Gt.jsxs('div', {
        className: 'section',
        children: [
          Gt.jsx('h3', { children: 'Elementos' }),
          Gt.jsx('button', { onClick: t, children: '+ Clase' }),
        ],
      }),
      Gt.jsx('div', {
        style: { marginTop: -10 },
        children: Gt.jsx('button', { onClick: u, disabled: R, children: 'Eliminar clase' }),
      }),
      Gt.jsxs('div', {
        className: 'section',
        children: [
          Gt.jsx('h3', { children: 'Relaciones' }),
          Gt.jsxs('div', {
            className: 'relation-grid',
            children: [
              Gt.jsx('button', { onClick: () => e('association'), children: 'Asociación' }),
              Gt.jsx('button', { onClick: () => e('aggregation'), children: 'Agregación' }),
              Gt.jsx('button', { onClick: () => e('composition'), children: 'Composición' }),
              Gt.jsx('button', { onClick: () => e('generalization'), children: 'Generalización' }),
            ],
          }),
          Gt.jsx('small', { children: 'Selecciona tipo y luego clic en origen → destino' }),
        ],
      }),
      Gt.jsxs('div', {
        className: 'section',
        children: [
          Gt.jsx('h3', { children: 'Inspector' }),
          Gt.jsx('label', { children: 'Nombre de clase' }),
          Gt.jsx('input', {
            type: 'text',
            value: p,
            onChange: B => y(B.target.value),
            onBlur: () => p && i(p),
            placeholder: 'NombreClase',
            disabled: R,
          }),
          Gt.jsx('div', {
            style: { marginTop: 8 },
            children: Gt.jsx('button', { onClick: n, disabled: R, children: '+ Atributo' }),
          }),
          !R &&
            v?.length > 0 &&
            Gt.jsx('div', {
              style: { marginTop: 10, display: 'grid', gap: 6 },
              children: v.map((B, H) =>
                Gt.jsxs(
                  'div',
                  {
                    style: { display: 'grid', gridTemplateColumns: '1fr auto', gap: 6 },
                    children: [
                      Gt.jsx('input', {
                        type: 'text',
                        value: B,
                        onChange: Z => {
                          const U = Z.target.value,
                            nt = [...v]
                          ;((nt[H] = U), C(nt))
                        },
                        onBlur: Z => s(H, Z.target.value),
                        placeholder: '+ campo: Tipo',
                      }),
                      Gt.jsx('button', {
                        onClick: () => o(H),
                        title: 'Eliminar atributo',
                        children: '✕',
                      }),
                    ],
                  },
                  H
                )
              ),
            }),
          h?.isLink &&
            h?.type === 'uml.Association' &&
            Gt.jsxs('div', {
              className: 'section',
              style: { marginTop: 16 },
              children: [
                Gt.jsx('h3', { children: 'Relación seleccionada' }),
                Gt.jsx('label', { children: 'Multiplicidad (origen)' }),
                Gt.jsx('input', {
                  type: 'text',
                  value: w,
                  onChange: B => N(B.target.value),
                  onBlur: B => c?.(0, B.target.value),
                  placeholder: '1 | 0..1 | * | 0..* | 1..*',
                }),
                Gt.jsx('label', { style: { marginTop: 8 }, children: 'Multiplicidad (destino)' }),
                Gt.jsx('input', {
                  type: 'text',
                  value: T,
                  onChange: B => z(B.target.value),
                  onBlur: B => c?.(1, B.target.value),
                  placeholder: '1 | 0..1 | * | 0..* | 1..*',
                }),
                Gt.jsx('small', { children: 'Consejo: multiplicidades solo para asociaciones.' }),
              ],
            }),
          R && Gt.jsx('small', { children: 'Selecciona una clase para editar.' }),
        ],
      }),
    ],
  })
}
const CT = 'modulepreload',
  wT = function (t) {
    return '/diagramador-frontend/' + t
  },
  ab = {},
  xT = function (e, n, i) {
    let s = Promise.resolve()
    if (n && n.length > 0) {
      let h = function (p) {
        return Promise.all(
          p.map(y =>
            Promise.resolve(y).then(
              v => ({ status: 'fulfilled', value: v }),
              v => ({ status: 'rejected', reason: v })
            )
          )
        )
      }
      document.getElementsByTagName('link')
      const u = document.querySelector('meta[property=csp-nonce]'),
        c = u?.nonce || u?.getAttribute('nonce')
      s = h(
        n.map(p => {
          if (((p = wT(p)), p in ab)) return
          ab[p] = !0
          const y = p.endsWith('.css'),
            v = y ? '[rel="stylesheet"]' : ''
          if (document.querySelector(`link[href="${p}"]${v}`)) return
          const C = document.createElement('link')
          if (
            ((C.rel = y ? 'stylesheet' : CT),
            y || (C.as = 'script'),
            (C.crossOrigin = ''),
            (C.href = p),
            c && C.setAttribute('nonce', c),
            document.head.appendChild(C),
            y)
          )
            return new Promise((w, N) => {
              ;(C.addEventListener('load', w),
                C.addEventListener('error', () => N(new Error(`Unable to preload CSS for ${p}`))))
            })
        })
      )
    }
    function o(u) {
      const c = new Event('vite:preloadError', { cancelable: !0 })
      if (((c.payload = u), window.dispatchEvent(c), !c.defaultPrevented)) throw u
    }
    return s.then(u => {
      for (const c of u || []) c.status === 'rejected' && o(c.reason)
      return e().catch(o)
    })
  },
  ma = { x: 'x', y: 'y', width: 'w', height: 'h', minimum: 's', maximum: 'l', diagonal: 'd' },
  ST = Object.keys(ma)
    .map(t => ma[t])
    .join(''),
  Ug = '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?',
  NT = /\s/g,
  sb = new RegExp(`^(${Ug}\\*)?([${ST}])(/${Ug})?([-+]{1,2}${Ug})?$`, 'g')
function NC(t) {
  throw new Error(`Invalid calc() expression: ${t}`)
}
function TT(t, e) {
  const n = sb.exec(t.replace(NT, ''))
  ;(n || NC(t), (sb.lastIndex = 0))
  const [, i, s, o, u] = n,
    { x: c, y: h, width: p, height: y } = e
  let v = 0
  switch (s) {
    case ma.width: {
      v = p
      break
    }
    case ma.height: {
      v = y
      break
    }
    case ma.x: {
      v = c
      break
    }
    case ma.y: {
      v = h
      break
    }
    case ma.minimum: {
      v = Math.min(y, p)
      break
    }
    case ma.maximum: {
      v = Math.max(y, p)
      break
    }
    case ma.diagonal: {
      v = Math.sqrt(y * y + p * p)
      break
    }
  }
  return (i && (v *= parseFloat(i)), o && (v /= parseFloat(o.slice(1))), u && (v += MT(u)), v)
}
function MT(t) {
  if (!t) return 0
  const [e] = t
  switch (e) {
    case '+':
      return parseFloat(t.substr(1))
    case '-':
      return -parseFloat(t.substr(1))
  }
  return parseFloat(t)
}
function Gi(t) {
  return typeof t == 'string' && t.includes('calc')
}
const TC = 'calc(',
  ob = TC.length
function Zi(t, e) {
  let n = t,
    i = 0
  do {
    let s = n.indexOf(TC, i)
    if (s === -1) return n
    let o = s + ob,
      u = 1
    t: do {
      switch (n[o]) {
        case '(': {
          u++
          break
        }
        case ')': {
          if ((u--, u === 0)) break t
          break
        }
        case void 0:
          NC(n)
      }
      o++
    } while (!0)
    let c = n.slice(s + ob, o)
    Gi(c) && (c = Zi(c, e))
    const h = String(TT(c, e))
    ;((n = n.slice(0, s) + h + n.slice(o + 1)), (i = s + h.length))
  } while (!0)
}
const { round: ET, floor: DT, PI: MC } = Math,
  OT = {
    linear: function (t, e, n) {
      var i = t[1] - t[0],
        s = e[1] - e[0]
      return ((n - t[0]) / i) * s + e[0] || 0
    },
  },
  Dr = function (t) {
    return (t % 360) + (t < 0 ? 360 : 0)
  },
  to = function (t, e) {
    return e * ET(t / e)
  },
  dh = function (t) {
    return ((180 * t) / MC) % 360
  },
  Ai = function (t, e) {
    return ((e = e || !1), (t = e ? t : t % 360), (t * MC) / 180)
  },
  ov = function (t, e) {
    if (e === void 0) ((e = t === void 0 ? 1 : t), (t = 0))
    else if (e < t) {
      const n = t
      ;((t = e), (e = n))
    }
    return DT(Math.random() * (e - t + 1) + t)
  },
  { cos: Cf, sin: Yg, atan2: LT } = Math,
  EC = function (t, e) {
    var n = Ai(t.y),
      i = Ai(e.y),
      s = t.x,
      o = e.x,
      u = Ai(o - s),
      c = Yg(u) * Cf(i),
      h = Cf(n) * Yg(i) - Yg(n) * Cf(i) * Cf(u),
      p = dh(LT(c, h)),
      y = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'],
      v = p - 22.5
    return (v < 0 && (v += 360), (v = parseInt(v / 45)), y[v])
  },
  Sv = function (t, e) {
    var n = t.x,
      i = t.y,
      s = e.x,
      o = e.y
    return (n -= s) * n + (i -= o) * i
  },
  DC = function (t, e) {
    return Math.sqrt(Sv(t, e))
  },
  me = { Point: 1, Line: 2, Ellipse: 3, Rect: 4, Polyline: 5, Polygon: 6, Curve: 7, Path: 8 },
  {
    abs: Wf,
    cos: lv,
    sin: uv,
    sqrt: lb,
    min: ub,
    max: cb,
    atan2: zT,
    round: fb,
    pow: RT,
    PI: hb,
  } = Math,
  et = function (t, e) {
    if (!(this instanceof et)) return new et(t, e)
    if (typeof t == 'string') {
      var n = t.split(t.indexOf('@') === -1 ? ' ' : '@')
      ;((t = parseFloat(n[0])), (e = parseFloat(n[1])))
    } else Object(t) === t && ((e = t.y), (t = t.x))
    ;((this.x = t === void 0 ? 0 : t), (this.y = e === void 0 ? 0 : e))
  }
et.fromPolar = function (t, e, n) {
  n = new et(n)
  var i = Wf(t * lv(e)),
    s = Wf(t * uv(e)),
    o = Dr(dh(e))
  return (
    o < 90 ? (s = -s) : o < 180 ? ((i = -i), (s = -s)) : o < 270 && (i = -i),
    new et(n.x + i, n.y + s)
  )
}
et.random = function (t, e, n, i) {
  return new et(ov(t, e), ov(n, i))
}
et.prototype = {
  type: me.Point,
  chooseClosest: function (t) {
    var e = t.length
    if (e === 1) return new et(t[0])
    for (var n = null, i = 1 / 0, s = 0; s < e; s++) {
      var o = new et(t[s]),
        u = this.squaredDistance(o)
      u < i && ((n = o), (i = u))
    }
    return n
  },
  adhereToRect: function (t) {
    return t.containsPoint(this)
      ? this
      : ((this.x = ub(cb(this.x, t.x), t.x + t.width)),
        (this.y = ub(cb(this.y, t.y), t.y + t.height)),
        this)
  },
  angleBetween: function (t, e) {
    var n = this.equals(t) || this.equals(e) ? NaN : this.theta(e) - this.theta(t)
    return (n < 0 && (n += 360), n)
  },
  bearing: function (t) {
    return EC(this, t)
  },
  changeInAngle: function (t, e, n) {
    return this.clone().offset(-t, -e).theta(n) - this.theta(n)
  },
  clone: function () {
    return new et(this)
  },
  cross: function (t, e) {
    return t && e ? (e.x - this.x) * (t.y - this.y) - (e.y - this.y) * (t.x - this.x) : NaN
  },
  difference: function (t, e) {
    return (Object(t) === t && ((e = t.y), (t = t.x)), new et(this.x - (t || 0), this.y - (e || 0)))
  },
  distance: function (t) {
    return DC(this, t)
  },
  dot: function (t) {
    return t ? this.x * t.x + this.y * t.y : NaN
  },
  equals: function (t) {
    return !!t && this.x === t.x && this.y === t.y
  },
  lerp: function (t, e) {
    var n = this.x,
      i = this.y
    return new et((1 - e) * n + e * t.x, (1 - e) * i + e * t.y)
  },
  magnitude: function () {
    return lb(this.x * this.x + this.y * this.y) || 0.01
  },
  manhattanDistance: function (t) {
    return Wf(t.x - this.x) + Wf(t.y - this.y)
  },
  move: function (t, e) {
    var n = Ai(new et(t).theta(this)),
      i = this.offset(lv(n) * e, -uv(n) * e)
    return i
  },
  normalize: function (t) {
    var e = (t || 1) / this.magnitude()
    return this.scale(e, e)
  },
  offset: function (t, e) {
    return (Object(t) === t && ((e = t.y), (t = t.x)), (this.x += t || 0), (this.y += e || 0), this)
  },
  reflection: function (t) {
    return new et(t).move(this, this.distance(t))
  },
  rotate: function (t, e) {
    if (e === 0) return this
    ;((t = t || new et(0, 0)), (e = Ai(Dr(-e))))
    var n = lv(e),
      i = uv(e),
      s = n * (this.x - t.x) - i * (this.y - t.y) + t.x,
      o = i * (this.x - t.x) + n * (this.y - t.y) + t.y
    return ((this.x = s), (this.y = o), this)
  },
  round: function (t) {
    let e = 1
    if (t)
      switch (t) {
        case 1:
          e = 10
          break
        case 2:
          e = 100
          break
        case 3:
          e = 1e3
          break
        default:
          e = RT(10, t)
          break
      }
    return ((this.x = fb(this.x * e) / e), (this.y = fb(this.y * e) / e), this)
  },
  scale: function (t, e, n) {
    return (
      (n = (n && new et(n)) || new et(0, 0)),
      (this.x = n.x + t * (this.x - n.x)),
      (this.y = n.y + e * (this.y - n.y)),
      this
    )
  },
  snapToGrid: function (t, e) {
    return ((this.x = to(this.x, t)), (this.y = to(this.y, e || t)), this)
  },
  squaredDistance: function (t) {
    return Sv(this, t)
  },
  theta: function (t) {
    t = new et(t)
    var e = -(t.y - this.y),
      n = t.x - this.x,
      i = zT(e, n)
    return (i < 0 && (i = 2 * hb + i), (180 * i) / hb)
  },
  toJSON: function () {
    return { x: this.x, y: this.y }
  },
  toPolar: function (t) {
    t = (t && new et(t)) || new et(0, 0)
    var e = this.x,
      n = this.y
    return (
      (this.x = lb((e - t.x) * (e - t.x) + (n - t.y) * (n - t.y))),
      (this.y = Ai(t.theta(new et(e, n)))),
      this
    )
  },
  toString: function () {
    return this.x + '@' + this.y
  },
  serialize: function () {
    return this.x + ',' + this.y
  },
  update: function (t, e) {
    return (Object(t) === t && ((e = t.y), (t = t.x)), (this.x = t || 0), (this.y = e || 0), this)
  },
  vectorAngle: function (t) {
    var e = new et(0, 0)
    return e.angleBetween(this, t)
  },
}
et.prototype.translate = et.prototype.offset
const Ff = et,
  { max: Hg, min: Vg } = Math,
  Ut = function (t, e) {
    if (!(this instanceof Ut)) return new Ut(t, e)
    if (t instanceof Ut) return new Ut(t.start, t.end)
    ;((this.start = new et(t)), (this.end = new et(e)))
  }
Ut.prototype = {
  type: me.Line,
  angle: function () {
    var t = new et(this.start.x + 1, this.start.y)
    return this.start.angleBetween(this.end, t)
  },
  bbox: function () {
    var t = Vg(this.start.x, this.end.x),
      e = Vg(this.start.y, this.end.y),
      n = Hg(this.start.x, this.end.x),
      i = Hg(this.start.y, this.end.y)
    return new Pt(t, e, n - t, i - e)
  },
  bearing: function () {
    return EC(this.start, this.end)
  },
  clone: function () {
    return new Ut(this.start, this.end)
  },
  closestPoint: function (t) {
    return this.pointAt(this.closestPointNormalizedLength(t))
  },
  closestPointLength: function (t) {
    return this.closestPointNormalizedLength(t) * this.length()
  },
  closestPointNormalizedLength: function (t) {
    var e = this.vector().dot(new Ut(this.start, t).vector()),
      n = Vg(1, Hg(0, e / this.squaredLength()))
    return n !== n ? 0 : n
  },
  closestPointTangent: function (t) {
    return this.tangentAt(this.closestPointNormalizedLength(t))
  },
  containsPoint: function (t) {
    var e = this.start,
      n = this.end
    if (e.cross(t, n) !== 0) return !1
    var i = this.length()
    return !(new Ut(e, t).length() > i || new Ut(t, n).length() > i)
  },
  divideAt: function (t) {
    var e = this.pointAt(t)
    return [new Ut(this.start, e), new Ut(e, this.end)]
  },
  divideAtLength: function (t) {
    var e = this.pointAtLength(t)
    return [new Ut(this.start, e), new Ut(e, this.end)]
  },
  equals: function (t) {
    return (
      !!t &&
      this.start.x === t.start.x &&
      this.start.y === t.start.y &&
      this.end.x === t.end.x &&
      this.end.y === t.end.y
    )
  },
  intersect: function (t, e) {
    if (t && t.intersectionWithLine) {
      var n = t.intersectionWithLine(this, e)
      return (n && t instanceof Ut && (n = n[0]), n)
    }
    return null
  },
  intersectionWithLine: function (t) {
    var e = new et(this.end.x - this.start.x, this.end.y - this.start.y),
      n = new et(t.end.x - t.start.x, t.end.y - t.start.y),
      i = e.x * n.y - e.y * n.x,
      s = new et(t.start.x - this.start.x, t.start.y - this.start.y),
      o = s.x * n.y - s.y * n.x,
      u = s.x * e.y - s.y * e.x
    if (i === 0 || o * i < 0 || u * i < 0) return null
    if (i > 0) {
      if (o > i || u > i) return null
    } else if (o < i || u < i) return null
    return [new et(this.start.x + (o * e.x) / i, this.start.y + (o * e.y) / i)]
  },
  isDifferentiable: function () {
    return !this.start.equals(this.end)
  },
  length: function () {
    return DC(this.start, this.end)
  },
  midpoint: function () {
    return new et((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2)
  },
  parallel: function (t) {
    const e = this.clone()
    if (!this.isDifferentiable()) return e
    const { start: n, end: i } = e,
      s = n.clone().rotate(i, 270),
      o = i.clone().rotate(n, 90)
    return (n.move(o, t), i.move(s, t), e)
  },
  pointAt: function (t) {
    var e = this.start,
      n = this.end
    return t <= 0 ? e.clone() : t >= 1 ? n.clone() : e.lerp(n, t)
  },
  pointAtLength: function (t) {
    var e = this.start,
      n = this.end,
      i = !0
    t < 0 && ((i = !1), (t = -t))
    var s = this.length()
    return t >= s ? (i ? n.clone() : e.clone()) : this.pointAt((i ? t : s - t) / s)
  },
  pointOffset: function (t) {
    t = new et(t)
    var e = this.start,
      n = this.end,
      i = (n.x - e.x) * (t.y - e.y) - (n.y - e.y) * (t.x - e.x)
    return i / this.length()
  },
  rotate: function (t, e) {
    return (this.start.rotate(t, e), this.end.rotate(t, e), this)
  },
  round: function (t) {
    return (this.start.round(t), this.end.round(t), this)
  },
  scale: function (t, e, n) {
    return (this.start.scale(t, e, n), this.end.scale(t, e, n), this)
  },
  setLength: function (t) {
    var e = this.length()
    if (!e) return this
    var n = t / e
    return this.scale(n, n, this.start)
  },
  squaredLength: function () {
    return Sv(this.start, this.end)
  },
  tangentAt: function (t) {
    if (!this.isDifferentiable()) return null
    var e = this.start,
      n = this.end,
      i = this.pointAt(t),
      s = new Ut(e, n)
    return (s.translate(i.x - e.x, i.y - e.y), s)
  },
  tangentAtLength: function (t) {
    if (!this.isDifferentiable()) return null
    var e = this.start,
      n = this.end,
      i = this.pointAtLength(t),
      s = new Ut(e, n)
    return (s.translate(i.x - e.x, i.y - e.y), s)
  },
  toString: function () {
    return this.start.toString() + ' ' + this.end.toString()
  },
  serialize: function () {
    return this.start.serialize() + ' ' + this.end.serialize()
  },
  translate: function (t, e) {
    return (this.start.translate(t, e), this.end.translate(t, e), this)
  },
  vector: function () {
    return new et(this.end.x - this.start.x, this.end.y - this.start.y)
  },
}
Ut.prototype.intersection = Ut.prototype.intersect
const Ks = Ut,
  { sqrt: db, round: wf, pow: kT } = Math,
  li = function (t, e, n) {
    if (!(this instanceof li)) return new li(t, e, n)
    if (t instanceof li) return new li(new et(t.x, t.y), t.a, t.b)
    ;((t = new et(t)), (this.x = t.x), (this.y = t.y), (this.a = e), (this.b = n))
  }
li.fromRect = function (t) {
  return ((t = new Pt(t)), new li(t.center(), t.width / 2, t.height / 2))
}
li.prototype = {
  type: me.Ellipse,
  bbox: function () {
    return new Pt(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b)
  },
  center: function () {
    return new et(this.x, this.y)
  },
  clone: function () {
    return new li(this)
  },
  containsPoint: function (t) {
    return this.normalizedDistance(t) <= 1
  },
  equals: function (t) {
    return !!t && t.x === this.x && t.y === this.y && t.a === this.a && t.b === this.b
  },
  inflate: function (t, e) {
    return (
      t === void 0 && (t = 0),
      e === void 0 && (e = t),
      (this.a += 2 * t),
      (this.b += 2 * e),
      this
    )
  },
  intersectionWithLine: function (t) {
    var e = [],
      n = t.start,
      i = t.end,
      s = this.a,
      o = this.b,
      u = t.vector(),
      c = n.difference(new et(this)),
      h = new et(u.x / (s * s), u.y / (o * o)),
      p = new et(c.x / (s * s), c.y / (o * o)),
      y = u.dot(h),
      v = u.dot(p),
      C = c.dot(p) - 1,
      w = v * v - y * C
    if (w < 0) return null
    if (w > 0) {
      var N = db(w),
        T = (-v - N) / y,
        z = (-v + N) / y
      if ((T < 0 || 1 < T) && (z < 0 || 1 < z)) return null
      ;(0 <= T && T <= 1 && e.push(n.lerp(i, T)), 0 <= z && z <= 1 && e.push(n.lerp(i, z)))
    } else {
      var R = -v / y
      if (0 <= R && R <= 1) e.push(n.lerp(i, R))
      else return null
    }
    return e
  },
  intersectionWithLineFromCenterToPoint: function (t, e) {
    ;((t = new et(t)), e && t.rotate(new et(this.x, this.y), e))
    var n = t.x - this.x,
      i = t.y - this.y,
      s
    if (n === 0)
      return (
        (s = this.bbox().pointNearestToPoint(t)),
        e ? s.rotate(new et(this.x, this.y), -e) : s
      )
    var o = i / n,
      u = o * o,
      c = this.a * this.a,
      h = this.b * this.b,
      p = db(1 / (1 / c + u / h))
    p = n < 0 ? -p : p
    var y = o * p
    return ((s = new et(this.x + p, this.y + y)), e ? s.rotate(new et(this.x, this.y), -e) : s)
  },
  normalizedDistance: function (t) {
    var e = t.x,
      n = t.y,
      i = this.a,
      s = this.b,
      o = this.x,
      u = this.y
    return ((e - o) * (e - o)) / (i * i) + ((n - u) * (n - u)) / (s * s)
  },
  round: function (t) {
    let e = 1
    if (t)
      switch (t) {
        case 1:
          e = 10
          break
        case 2:
          e = 100
          break
        case 3:
          e = 1e3
          break
        default:
          e = kT(10, t)
          break
      }
    return (
      (this.x = wf(this.x * e) / e),
      (this.y = wf(this.y * e) / e),
      (this.a = wf(this.a * e) / e),
      (this.b = wf(this.b * e) / e),
      this
    )
  },
  tangentTheta: function (t) {
    var e = 30,
      n = t.x,
      i = t.y,
      s = this.a,
      o = this.b,
      u = this.bbox().center(),
      c = u.x,
      h = u.y,
      p = n > u.x + s / 2,
      y = n < u.x - s / 2,
      v,
      C
    return (
      p || y
        ? ((v = n > u.x ? i - e : i + e),
          (C = (s * s) / (n - c) - (s * s * (i - h) * (v - h)) / (o * o * (n - c)) + c))
        : ((C = i > u.y ? n + e : n - e),
          (v = (o * o) / (i - h) - (o * o * (n - c) * (C - c)) / (s * s * (i - h)) + h)),
      new et(C, v).theta(t)
    )
  },
  toString: function () {
    return new et(this.x, this.y).toString() + ' ' + this.a + ' ' + this.b
  },
}
const _T = li,
  { abs: gb, cos: BT, sin: jT, min: Cu, max: pb, round: xf, pow: PT } = Math,
  Pt = function (t, e, n, i) {
    if (!(this instanceof Pt)) return new Pt(t, e, n, i)
    ;(Object(t) === t && ((e = t.y), (n = t.width), (i = t.height), (t = t.x)),
      (this.x = t === void 0 ? 0 : t),
      (this.y = e === void 0 ? 0 : e),
      (this.width = n === void 0 ? 0 : n),
      (this.height = i === void 0 ? 0 : i))
  }
Pt.fromEllipse = function (t) {
  return ((t = new li(t)), new Pt(t.x - t.a, t.y - t.b, 2 * t.a, 2 * t.b))
}
Pt.fromPointUnion = function (...t) {
  if (t.length === 0) return null
  const e = new et()
  let n, i, s, o
  ;((n = i = 1 / 0), (s = o = -1 / 0))
  for (let u = 0; u < t.length; u++) {
    e.update(t[u])
    const c = e.x,
      h = e.y
    ;(c < n && (n = c), c > s && (s = c), h < i && (i = h), h > o && (o = h))
  }
  return new Pt(n, i, s - n, o - i)
}
Pt.fromRectUnion = function (...t) {
  if (t.length === 0) return null
  const e = new Pt()
  let n, i, s, o
  ;((n = i = 1 / 0), (s = o = -1 / 0))
  for (let u = 0; u < t.length; u++) {
    e.update(t[u])
    const c = e.x,
      h = e.y,
      p = c + e.width,
      y = h + e.height
    ;(c < n && (n = c), p > s && (s = p), h < i && (i = h), y > o && (o = y))
  }
  return new Pt(n, i, s - n, o - i)
}
Pt.prototype = {
  type: me.Rect,
  bbox: function (t) {
    return this.clone().rotateAroundCenter(t)
  },
  rotateAroundCenter: function (t) {
    if (!t) return this
    const { width: e, height: n } = this,
      i = Ai(t),
      s = gb(jT(i)),
      o = gb(BT(i)),
      u = e * o + n * s,
      c = e * s + n * o
    return (
      (this.x += (e - u) / 2),
      (this.y += (n - c) / 2),
      (this.width = u),
      (this.height = c),
      this
    )
  },
  bottomLeft: function () {
    return new et(this.x, this.y + this.height)
  },
  bottomLine: function () {
    return new Ut(this.bottomLeft(), this.bottomRight())
  },
  bottomMiddle: function () {
    return new et(this.x + this.width / 2, this.y + this.height)
  },
  center: function () {
    return new et(this.x + this.width / 2, this.y + this.height / 2)
  },
  clone: function () {
    return new Pt(this)
  },
  containsPoint: function (t) {
    return (
      t instanceof et || (t = new et(t)),
      t.x >= this.x && t.x <= this.x + this.width && t.y >= this.y && t.y <= this.y + this.height
    )
  },
  containsRect: function (t) {
    var e = new Pt(this).normalize(),
      n = new Pt(t).normalize(),
      i = e.width,
      s = e.height,
      o = n.width,
      u = n.height
    if (!i || !s || !o || !u) return !1
    var c = e.x,
      h = e.y,
      p = n.x,
      y = n.y
    return ((o += p), (i += c), (u += y), (s += h), c <= p && o <= i && h <= y && u <= s)
  },
  corner: function () {
    return new et(this.x + this.width, this.y + this.height)
  },
  equals: function (t) {
    var e = new Pt(this).normalize(),
      n = new Pt(t).normalize()
    return e.x === n.x && e.y === n.y && e.width === n.width && e.height === n.height
  },
  inflate: function (t, e) {
    return (
      t === void 0 && (t = 0),
      e === void 0 && (e = t),
      (this.x -= t),
      (this.y -= e),
      (this.width += 2 * t),
      (this.height += 2 * e),
      this
    )
  },
  intersect: function (t) {
    var e = this.origin(),
      n = this.corner(),
      i = t.origin(),
      s = t.corner()
    if (s.x <= e.x || s.y <= e.y || i.x >= n.x || i.y >= n.y) return null
    var o = pb(e.x, i.x),
      u = pb(e.y, i.y)
    return new Pt(o, u, Cu(n.x, s.x) - o, Cu(n.y, s.y) - u)
  },
  intersectionWithLine: function (t) {
    var e = this,
      n = [e.topLine(), e.rightLine(), e.bottomLine(), e.leftLine()],
      i = [],
      s = [],
      o,
      u,
      c = n.length
    for (u = 0; u < c; u++)
      ((o = t.intersect(n[u])),
        o !== null && s.indexOf(o.toString()) < 0 && (i.push(o), s.push(o.toString())))
    return i.length > 0 ? i : null
  },
  intersectionWithLineFromCenterToPoint: function (t, e) {
    t = new et(t)
    var n = new et(this.x + this.width / 2, this.y + this.height / 2),
      i
    e && t.rotate(n, e)
    for (
      var s = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()],
        o = new Ut(n, t),
        u = s.length - 1;
      u >= 0;
      --u
    ) {
      var c = s[u].intersection(o)
      if (c !== null) {
        i = c
        break
      }
    }
    return (i && e && i.rotate(n, -e), i)
  },
  leftLine: function () {
    return new Ut(this.topLeft(), this.bottomLeft())
  },
  leftMiddle: function () {
    return new et(this.x, this.y + this.height / 2)
  },
  maxRectScaleToFit: function (t, e) {
    ;((t = new Pt(t)), e || (e = t.center()))
    var n,
      i,
      s,
      o,
      u,
      c,
      h,
      p,
      y = e.x,
      v = e.y
    n = i = s = o = u = c = h = p = 1 / 0
    var C = t.topLeft()
    ;(C.x < y && (n = (this.x - y) / (C.x - y)), C.y < v && (u = (this.y - v) / (C.y - v)))
    var w = t.bottomRight()
    ;(w.x > y && (i = (this.x + this.width - y) / (w.x - y)),
      w.y > v && (c = (this.y + this.height - v) / (w.y - v)))
    var N = t.topRight()
    ;(N.x > y && (s = (this.x + this.width - y) / (N.x - y)),
      N.y < v && (h = (this.y - v) / (N.y - v)))
    var T = t.bottomLeft()
    return (
      T.x < y && (o = (this.x - y) / (T.x - y)),
      T.y > v && (p = (this.y + this.height - v) / (T.y - v)),
      { sx: Cu(n, i, s, o), sy: Cu(u, c, h, p) }
    )
  },
  maxRectUniformScaleToFit: function (t, e) {
    var n = this.maxRectScaleToFit(t, e)
    return Cu(n.sx, n.sy)
  },
  moveAndExpand: function (t) {
    return (
      (this.x += t.x || 0),
      (this.y += t.y || 0),
      (this.width += t.width || 0),
      (this.height += t.height || 0),
      this
    )
  },
  normalize: function () {
    var t = this.x,
      e = this.y,
      n = this.width,
      i = this.height
    return (
      this.width < 0 && ((t = this.x + this.width), (n = -this.width)),
      this.height < 0 && ((e = this.y + this.height), (i = -this.height)),
      (this.x = t),
      (this.y = e),
      (this.width = n),
      (this.height = i),
      this
    )
  },
  offset: function (t, e) {
    return et.prototype.offset.call(this, t, e)
  },
  origin: function () {
    return new et(this.x, this.y)
  },
  pointNearestToPoint: function (t) {
    if (((t = new et(t)), this.containsPoint(t))) {
      var e = this.sideNearestToPoint(t)
      switch (e) {
        case 'right':
          return new et(this.x + this.width, t.y)
        case 'left':
          return new et(this.x, t.y)
        case 'bottom':
          return new et(t.x, this.y + this.height)
        case 'top':
          return new et(t.x, this.y)
      }
    }
    return t.adhereToRect(this)
  },
  rightLine: function () {
    return new Ut(this.topRight(), this.bottomRight())
  },
  rightMiddle: function () {
    return new et(this.x + this.width, this.y + this.height / 2)
  },
  round: function (t) {
    let e = 1
    if (t)
      switch (t) {
        case 1:
          e = 10
          break
        case 2:
          e = 100
          break
        case 3:
          e = 1e3
          break
        default:
          e = PT(10, t)
          break
      }
    return (
      (this.x = xf(this.x * e) / e),
      (this.y = xf(this.y * e) / e),
      (this.width = xf(this.width * e) / e),
      (this.height = xf(this.height * e) / e),
      this
    )
  },
  scale: function (t, e, n) {
    return (
      (n = this.origin().scale(t, e, n)),
      (this.x = n.x),
      (this.y = n.y),
      (this.width *= t),
      (this.height *= e),
      this
    )
  },
  sideNearestToPoint: function (t) {
    t = new et(t)
    var e = t.x - this.x,
      n = this.x + this.width - t.x,
      i = t.y - this.y,
      s = this.y + this.height - t.y,
      o = e,
      u = 'left'
    return (
      n < o && ((o = n), (u = 'right')),
      i < o && ((o = i), (u = 'top')),
      s < o && (u = 'bottom'),
      u
    )
  },
  snapToGrid: function (t, e) {
    var n = this.origin().snapToGrid(t, e),
      i = this.corner().snapToGrid(t, e)
    return (
      (this.x = n.x),
      (this.y = n.y),
      (this.width = i.x - n.x),
      (this.height = i.y - n.y),
      this
    )
  },
  toJSON: function () {
    return { x: this.x, y: this.y, width: this.width, height: this.height }
  },
  topLine: function () {
    return new Ut(this.topLeft(), this.topRight())
  },
  topMiddle: function () {
    return new et(this.x + this.width / 2, this.y)
  },
  topRight: function () {
    return new et(this.x + this.width, this.y)
  },
  toString: function () {
    return this.origin().toString() + ' ' + this.corner().toString()
  },
  union: function (t) {
    return Pt.fromRectUnion(this, t)
  },
  update: function (t, e, n, i) {
    return (
      Object(t) === t && ((e = t.y), (n = t.width), (i = t.height), (t = t.x)),
      (this.x = t || 0),
      (this.y = e || 0),
      (this.width = n || 0),
      (this.height = i || 0),
      this
    )
  },
}
Pt.prototype.bottomRight = Pt.prototype.corner
Pt.prototype.topLeft = Pt.prototype.origin
Pt.prototype.translate = Pt.prototype.offset
const GT = Pt
function OC(t) {
  const e = t.trim()
  if (e === '') return []
  const n = [],
    i = e.split(/\b\s*,\s*|,\s*|\s+/),
    s = i.length
  for (let o = 0; o < s; o += 2) n.push({ x: +i[o], y: +i[o + 1] })
  return n
}
function LC(t) {
  const e = t.length
  if (e === 0) return []
  const n = []
  for (let i = 0; i < e; i++) {
    const s = t[i].clone()
    n.push(s)
  }
  return n
}
function zC(t) {
  const { abs: e } = Math
  var n,
    i,
    s = t.length
  if (s === 0) return []
  var o
  for (n = 0; n < s; n++)
    (o === void 0 || t[n].y < o.y || (t[n].y === o.y && t[n].x > o.x)) && (o = t[n])
  var u = []
  for (n = 0; n < s; n++) {
    var c = o.theta(t[n])
    c === 0 && (c = 360)
    var h = [t[n], n, c]
    u.push(h)
  }
  if (
    (u.sort(function (X, Ct) {
      var Tt = X[2] - Ct[2]
      return (Tt === 0 && (Tt = Ct[1] - X[1]), Tt)
    }),
    u.length > 2)
  ) {
    var p = u[u.length - 1]
    u.unshift(p)
  }
  for (var y = {}, v = [], C, w, N, T, z, R; u.length !== 0; )
    if (((C = u.pop()), (w = C[0]), !y.hasOwnProperty(C[0] + '@@' + C[1])))
      for (var B = !1; !B; )
        if (v.length < 2) (v.push(C), (B = !0))
        else {
          ;((N = v.pop()), (T = N[0]), (z = v.pop()), (R = z[0]))
          var H = R.cross(T, w)
          if (H < 0) (v.push(z), v.push(N), v.push(C), (B = !0))
          else if (H === 0) {
            var Z = 1e-10,
              U = T.angleBetween(R, w)
            e(U - 180) < Z || T.equals(w) || R.equals(T)
              ? ((y[N[0] + '@@' + N[1]] = T), v.push(z))
              : e(((U + 1) % 360) - 1) < Z && (v.push(z), u.push(N))
          } else ((y[N[0] + '@@' + N[1]] = T), v.push(z))
        }
  v.length > 2 && v.pop()
  var nt,
    g = -1
  for (i = v.length, n = 0; n < i; n++) {
    var S = v[n][1]
    ;(nt === void 0 || S < nt) && ((nt = S), (g = n))
  }
  var M = []
  if (g > 0) {
    var _ = v.slice(g),
      W = v.slice(0, g)
    M = _.concat(W)
  } else M = v
  var $ = []
  for (i = M.length, n = 0; n < i; n++) $.push(M[n][0])
  return $
}
const qe = function (t) {
  if (!(this instanceof qe)) return new qe(t)
  if (typeof t == 'string') return new qe.parse(t)
  this.points = Array.isArray(t) ? t.map(et) : []
}
qe.parse = function (t) {
  return new qe(OC(t))
}
qe.fromRect = function (t) {
  return new qe([t.topLeft(), t.topRight(), t.bottomRight(), t.bottomLeft(), t.topLeft()])
}
qe.prototype = {
  type: me.Polyline,
  bbox: function () {
    var t = 1 / 0,
      e = -1 / 0,
      n = 1 / 0,
      i = -1 / 0,
      s = this.points,
      o = s.length
    if (o === 0) return null
    for (var u = 0; u < o; u++) {
      var c = s[u],
        h = c.x,
        p = c.y
      ;(h < t && (t = h), h > e && (e = h), p < n && (n = p), p > i && (i = p))
    }
    return new Pt(t, n, e - t, i - n)
  },
  clone: function () {
    return new qe(LC(this.points))
  },
  closestPoint: function (t) {
    var e = this.closestPointLength(t)
    return this.pointAtLength(e)
  },
  closestPointLength: function (t) {
    var e = this.lengthPoints(),
      n = e.length
    if (n === 0 || n === 1) return 0
    for (var i, s = 1 / 0, o = 0, u = n - 1, c = 0; c < u; c++) {
      var h = new Ut(e[c], e[c + 1]),
        p = h.length(),
        y = h.closestPointNormalizedLength(t),
        v = h.pointAt(y),
        C = v.squaredDistance(t)
      ;(C < s && ((s = C), (i = o + y * p)), (o += p))
    }
    return i
  },
  closestPointNormalizedLength: function (t) {
    var e = this.closestPointLength(t)
    if (e === 0) return 0
    var n = this.length()
    return n === 0 ? 0 : e / n
  },
  closestPointTangent: function (t) {
    var e = this.closestPointLength(t)
    return this.tangentAtLength(e)
  },
  containsPoint: function (t) {
    var e = this.points,
      n = e.length
    if (n === 0) return !1
    for (
      var i = t.x, s = t.y, o = n - 1, u = 0, c = 0, h = new Ut(), p = new Ut(), y = new et();
      u < n;
      u++
    ) {
      var v = e[o],
        C = e[u]
      if (t.equals(v) || ((h.start = v), (h.end = C), h.containsPoint(t))) return !0
      if ((s <= v.y && s > C.y) || (s > v.y && s <= C.y)) {
        var w = v.x - i > C.x - i ? v.x - i : C.x - i
        w >= 0 && ((y.x = i + w), (y.y = s), (p.start = t), (p.end = y), h.intersect(p) && c++)
      }
      o = u
    }
    return c % 2 === 1
  },
  close: function () {
    const { start: t, end: e, points: n } = this
    return (t && e && !t.equals(e) && n.push(t.clone()), this)
  },
  lengthPoints: function () {
    return this.points
  },
  convexHull: function () {
    return new qe(zC(this.points))
  },
  equals: function (t) {
    if (!t) return !1
    var e = this.points,
      n = t.points,
      i = e.length
    if (n.length !== i) return !1
    for (var s = 0; s < i; s++) {
      var o = e[s],
        u = t.points[s]
      if (!o.equals(u)) return !1
    }
    return !0
  },
  intersectionWithLine: function (t) {
    for (
      var e = new Ut(t), n = [], i = this.lengthPoints(), s = new Ut(), o = 0, u = i.length - 1;
      o < u;
      o++
    ) {
      ;((s.start = i[o]), (s.end = i[o + 1]))
      var c = e.intersectionWithLine(s)
      c && n.push(c[0])
    }
    return n.length > 0 ? n : null
  },
  isDifferentiable: function () {
    var t = this.points,
      e = t.length
    if (e === 0) return !1
    for (var n = new Ut(), i = e - 1, s = 0; s < i; s++)
      if (((n.start = t[s]), (n.end = t[s + 1]), n.isDifferentiable())) return !0
    return !1
  },
  length: function () {
    var t = this.lengthPoints(),
      e = t.length
    if (e === 0) return 0
    for (var n = 0, i = e - 1, s = 0; s < i; s++) n += t[s].distance(t[s + 1])
    return n
  },
  pointAt: function (t) {
    var e = this.lengthPoints(),
      n = e.length
    if (n === 0) return null
    if (n === 1 || t <= 0) return e[0].clone()
    if (t >= 1) return e[n - 1].clone()
    var i = this.length(),
      s = i * t
    return this.pointAtLength(s)
  },
  pointAtLength: function (t) {
    var e = this.lengthPoints(),
      n = e.length
    if (n === 0) return null
    if (n === 1) return e[0].clone()
    var i = !0
    t < 0 && ((i = !1), (t = -t))
    for (var s = 0, o = n - 1, u = 0; u < o; u++) {
      var c = i ? u : o - 1 - u,
        h = e[c],
        p = e[c + 1],
        y = new Ut(h, p),
        v = h.distance(p)
      if (t <= s + v) return y.pointAtLength((i ? 1 : -1) * (t - s))
      s += v
    }
    var C = i ? e[n - 1] : e[0]
    return C.clone()
  },
  round: function (t) {
    for (var e = this.points, n = e.length, i = 0; i < n; i++) e[i].round(t)
    return this
  },
  scale: function (t, e, n) {
    for (var i = this.points, s = i.length, o = 0; o < s; o++) i[o].scale(t, e, n)
    return this
  },
  simplify: function (t = {}) {
    const e = this.points
    if (e.length < 3) return this
    const n = t.threshold || 1e-10
    let i = 0
    for (; e[i + 2]; ) {
      const s = i,
        o = i + 1,
        u = i + 2,
        c = e[s],
        h = e[o],
        p = e[u]
      new Ut(c, p).closestPoint(h).distance(h) <= n ? e.splice(o, 1) : (i += 1)
    }
    return this
  },
  tangentAt: function (t) {
    var e = this.lengthPoints(),
      n = e.length
    if (n === 0 || n === 1) return null
    ;(t < 0 && (t = 0), t > 1 && (t = 1))
    var i = this.length(),
      s = i * t
    return this.tangentAtLength(s)
  },
  tangentAtLength: function (t) {
    var e = this.lengthPoints(),
      n = e.length
    if (n === 0 || n === 1) return null
    var i = !0
    t < 0 && ((i = !1), (t = -t))
    for (var s, o = 0, u = n - 1, c = 0; c < u; c++) {
      var h = i ? c : u - 1 - c,
        p = e[h],
        y = e[h + 1],
        v = new Ut(p, y),
        C = p.distance(y)
      if (v.isDifferentiable()) {
        if (t <= o + C) return v.tangentAtLength((i ? 1 : -1) * (t - o))
        s = v
      }
      o += C
    }
    if (s) {
      var w = i ? 1 : 0
      return s.tangentAt(w)
    }
    return null
  },
  toString: function () {
    return this.points + ''
  },
  translate: function (t, e) {
    for (var n = this.points, i = n.length, s = 0; s < i; s++) n[s].translate(t, e)
    return this
  },
  serialize: function () {
    var t = this.points,
      e = t.length
    if (e === 0) return ''
    for (var n = '', i = 0; i < e; i++) {
      var s = t[i]
      n += s.x + ',' + s.y + ' '
    }
    return n.trim()
  },
}
Object.defineProperty(qe.prototype, 'start', {
  configurable: !0,
  enumerable: !0,
  get: function () {
    var t = this.points,
      e = t.length
    return e === 0 ? null : this.points[0]
  },
})
Object.defineProperty(qe.prototype, 'end', {
  configurable: !0,
  enumerable: !0,
  get: function () {
    var t = this.points,
      e = t.length
    return e === 0 ? null : this.points[e - 1]
  },
})
const { abs: Sf, sqrt: ZT, min: vb, max: mb, pow: Xg } = Math,
  Be = function (t, e, n, i) {
    if (!(this instanceof Be)) return new Be(t, e, n, i)
    if (t instanceof Be) return new Be(t.start, t.controlPoint1, t.controlPoint2, t.end)
    ;((this.start = new et(t)),
      (this.controlPoint1 = new et(e)),
      (this.controlPoint2 = new et(n)),
      (this.end = new et(i)))
  }
Be.throughPoints = (function () {
  function t(n) {
    var i = [],
      s = [],
      o = n.length - 1,
      u
    if (o == 1)
      return (
        (i[0] = new et((2 * n[0].x + n[1].x) / 3, (2 * n[0].y + n[1].y) / 3)),
        (s[0] = new et(2 * i[0].x - n[0].x, 2 * i[0].y - n[0].y)),
        [i, s]
      )
    var c = []
    for (u = 1; u < o - 1; u++) c[u] = 4 * n[u].x + 2 * n[u + 1].x
    ;((c[0] = n[0].x + 2 * n[1].x), (c[o - 1] = (8 * n[o - 1].x + n[o].x) / 2))
    var h = e(c)
    for (u = 1; u < o - 1; ++u) c[u] = 4 * n[u].y + 2 * n[u + 1].y
    ;((c[0] = n[0].y + 2 * n[1].y), (c[o - 1] = (8 * n[o - 1].y + n[o].y) / 2))
    var p = e(c)
    for (u = 0; u < o; u++)
      (i.push(new et(h[u], p[u])),
        u < o - 1
          ? s.push(new et(2 * n[u + 1].x - h[u + 1], 2 * n[u + 1].y - p[u + 1]))
          : s.push(new et((n[o].x + h[o - 1]) / 2, (n[o].y + p[o - 1]) / 2)))
    return [i, s]
  }
  function e(n) {
    var i = n.length,
      s = [],
      o = [],
      u = 2
    s[0] = n[0] / u
    for (var c = 1; c < i; c++)
      ((o[c] = 1 / u), (u = (c < i - 1 ? 4 : 3.5) - o[c]), (s[c] = (n[c] - s[c - 1]) / u))
    for (c = 1; c < i; c++) s[i - c - 1] -= o[i - c] * s[i - c]
    return s
  }
  return function (n) {
    if (!n || (Array.isArray(n) && n.length < 2)) throw new Error('At least 2 points are required')
    for (var i = t(n), s = [], o = i[0].length, u = 0; u < o; u++) {
      var c = new et(i[0][u].x, i[0][u].y),
        h = new et(i[1][u].x, i[1][u].y)
      s.push(new Be(n[u], c, h, n[u + 1]))
    }
    return s
  }
})()
Be.prototype = {
  type: me.Curve,
  bbox: function () {
    for (
      var t = this.start,
        e = this.controlPoint1,
        n = this.controlPoint2,
        i = this.end,
        s = t.x,
        o = t.y,
        u = e.x,
        c = e.y,
        h = n.x,
        p = n.y,
        y = i.x,
        v = i.y,
        C = new Array(),
        w = new Array(),
        N = [new Array(), new Array()],
        T,
        z,
        R,
        B,
        H,
        Z,
        U,
        nt,
        g = 0;
      g < 2;
      ++g
    ) {
      if (
        (g === 0
          ? ((z = 6 * s - 12 * u + 6 * h),
            (T = -3 * s + 9 * u - 9 * h + 3 * y),
            (R = 3 * u - 3 * s))
          : ((z = 6 * o - 12 * c + 6 * p),
            (T = -3 * o + 9 * c - 9 * p + 3 * v),
            (R = 3 * c - 3 * o)),
        Sf(T) < 1e-12)
      ) {
        if (Sf(z) < 1e-12) continue
        ;((B = -R / z), 0 < B && B < 1 && w.push(B))
        continue
      }
      ;((U = z * z - 4 * R * T),
        (nt = ZT(U)),
        !(U < 0) &&
          ((H = (-z + nt) / (2 * T)),
          0 < H && H < 1 && w.push(H),
          (Z = (-z - nt) / (2 * T)),
          0 < Z && Z < 1 && w.push(Z)))
    }
    for (var S = w.length, M = S, _, W, $; S--; )
      ((B = w[S]),
        (_ = 1 - B),
        (W = _ * _ * _ * s + 3 * _ * _ * B * u + 3 * _ * B * B * h + B * B * B * y),
        (N[0][S] = W),
        ($ = _ * _ * _ * o + 3 * _ * _ * B * c + 3 * _ * B * B * p + B * B * B * v),
        (N[1][S] = $),
        (C[S] = { X: W, Y: $ }))
    ;((w[M] = 0),
      (w[M + 1] = 1),
      (C[M] = { X: s, Y: o }),
      (C[M + 1] = { X: y, Y: v }),
      (N[0][M] = s),
      (N[1][M] = o),
      (N[0][M + 1] = y),
      (N[1][M + 1] = v),
      (w.length = M + 2),
      (N[0].length = M + 2),
      (N[1].length = M + 2),
      (C.length = M + 2))
    var X = vb.apply(null, N[0]),
      Ct = vb.apply(null, N[1]),
      Tt = mb.apply(null, N[0]),
      G = mb.apply(null, N[1])
    return new Pt(X, Ct, Tt - X, G - Ct)
  },
  clone: function () {
    return new Be(this.start, this.controlPoint1, this.controlPoint2, this.end)
  },
  closestPoint: function (t, e) {
    return this.pointAtT(this.closestPointT(t, e))
  },
  closestPointLength: function (t, e) {
    e = e || {}
    var n = e.precision === void 0 ? this.PRECISION : e.precision,
      i = e.subdivisions === void 0 ? this.getSubdivisions({ precision: n }) : e.subdivisions,
      s = { precision: n, subdivisions: i }
    return this.lengthAtT(this.closestPointT(t, s), s)
  },
  closestPointNormalizedLength: function (t, e) {
    e = e || {}
    var n = e.precision === void 0 ? this.PRECISION : e.precision,
      i = e.subdivisions === void 0 ? this.getSubdivisions({ precision: n }) : e.subdivisions,
      s = { precision: n, subdivisions: i },
      o = this.closestPointLength(t, s)
    if (!o) return 0
    var u = this.length(s)
    return u === 0 ? 0 : o / u
  },
  closestPointT: function (t, e) {
    e = e || {}
    for (
      var n = e.precision === void 0 ? this.PRECISION : e.precision,
        i = e.subdivisions === void 0 ? this.getSubdivisions({ precision: n }) : e.subdivisions,
        s,
        o,
        u,
        c,
        h,
        p,
        y,
        v = i.length,
        C = v ? 1 / v : 0,
        w = 0;
      w < v;
      w++
    ) {
      var N = i[w],
        T = N.start.distance(t),
        z = N.end.distance(t),
        R = T + z
      ;(!y || R < y) &&
        ((s = N),
        (o = w * C),
        (u = (w + 1) * C),
        (c = T),
        (h = z),
        (p = N.start.distance(N.end)),
        (y = R))
    }
    for (var B = Xg(10, -n); ; ) {
      var H = c ? Sf(c - h) / c : 0,
        Z = h ? Sf(c - h) / h : 0,
        U = H < B || Z < B,
        nt = c ? c < p * B : !0,
        g = h ? h < p * B : !0,
        S = nt || g
      if (U || S) return c <= h ? o : u
      var M = s.divide(0.5)
      C /= 2
      var _ = M[0].start.distance(t),
        W = M[0].end.distance(t),
        $ = _ + W,
        X = M[1].start.distance(t),
        Ct = M[1].end.distance(t),
        Tt = X + Ct
      $ <= Tt ? ((s = M[0]), (u -= C), (c = _), (h = W)) : ((s = M[1]), (o += C), (c = X), (h = Ct))
    }
  },
  closestPointTangent: function (t, e) {
    return this.tangentAtT(this.closestPointT(t, e))
  },
  containsPoint: function (t, e) {
    var n = this.toPolyline(e)
    return n.containsPoint(t)
  },
  divideAt: function (t, e) {
    if (t <= 0) return this.divideAtT(0)
    if (t >= 1) return this.divideAtT(1)
    var n = this.tAt(t, e)
    return this.divideAtT(n)
  },
  divideAtLength: function (t, e) {
    var n = this.tAtLength(t, e)
    return this.divideAtT(n)
  },
  divideAtT: function (t) {
    var e = this.start,
      n = this.controlPoint1,
      i = this.controlPoint2,
      s = this.end
    if (t <= 0) return [new Be(e, e, e, e), new Be(e, n, i, s)]
    if (t >= 1) return [new Be(e, n, i, s), new Be(s, s, s, s)]
    var o = this.getSkeletonPoints(t),
      u = o.startControlPoint1,
      c = o.startControlPoint2,
      h = o.divider,
      p = o.dividerControlPoint1,
      y = o.dividerControlPoint2
    return [new Be(e, u, c, h), new Be(h, p, y, s)]
  },
  endpointDistance: function () {
    return this.start.distance(this.end)
  },
  equals: function (t) {
    return (
      !!t &&
      this.start.x === t.start.x &&
      this.start.y === t.start.y &&
      this.controlPoint1.x === t.controlPoint1.x &&
      this.controlPoint1.y === t.controlPoint1.y &&
      this.controlPoint2.x === t.controlPoint2.x &&
      this.controlPoint2.y === t.controlPoint2.y &&
      this.end.x === t.end.x &&
      this.end.y === t.end.y
    )
  },
  getSkeletonPoints: function (t) {
    var e = this.start,
      n = this.controlPoint1,
      i = this.controlPoint2,
      s = this.end
    if (t <= 0)
      return {
        startControlPoint1: e.clone(),
        startControlPoint2: e.clone(),
        divider: e.clone(),
        dividerControlPoint1: n.clone(),
        dividerControlPoint2: i.clone(),
      }
    if (t >= 1)
      return {
        startControlPoint1: n.clone(),
        startControlPoint2: i.clone(),
        divider: s.clone(),
        dividerControlPoint1: s.clone(),
        dividerControlPoint2: s.clone(),
      }
    var o = new Ut(e, n).pointAt(t),
      u = new Ut(n, i).pointAt(t),
      c = new Ut(i, s).pointAt(t),
      h = new Ut(o, u).pointAt(t),
      p = new Ut(u, c).pointAt(t),
      y = new Ut(h, p).pointAt(t),
      v = {
        startControlPoint1: o,
        startControlPoint2: h,
        divider: y,
        dividerControlPoint1: p,
        dividerControlPoint2: c,
      }
    return v
  },
  getSubdivisions: function (t) {
    t = t || {}
    var e = t.precision === void 0 ? this.PRECISION : t.precision,
      n = this.start,
      i = this.controlPoint1,
      s = this.controlPoint2,
      o = this.end,
      u = [new Be(n, i, s, o)]
    if (e === 0) return u
    var c = !this.isDifferentiable()
    if (c) return u
    var h = this.endpointDistance(),
      p = Xg(10, -e),
      y = 2,
      v = i.cross(n, o) === 0 && s.cross(n, o) === 0
    v && (y = 2 * e)
    for (var C = 0; ; ) {
      C += 1
      for (var w = [], N = u.length, T = 0; T < N; T++) {
        var z = u[T],
          R = z.divide(0.5)
        w.push(R[0], R[1])
      }
      for (var B = 0, H = w.length, Z = 0; Z < H; Z++) {
        var U = w[Z]
        B += U.endpointDistance()
      }
      if (C >= y) {
        var nt = B !== 0 ? (B - h) / B : 0
        if (nt < p) return w
      }
      ;((u = w), (h = B))
    }
  },
  isDifferentiable: function () {
    var t = this.start,
      e = this.controlPoint1,
      n = this.controlPoint2,
      i = this.end
    return !(t.equals(e) && e.equals(n) && n.equals(i))
  },
  length: function (t) {
    t = t || {}
    for (
      var e = t.precision === void 0 ? this.PRECISION : t.precision,
        n = t.subdivisions === void 0 ? this.getSubdivisions({ precision: e }) : t.subdivisions,
        i = 0,
        s = n.length,
        o = 0;
      o < s;
      o++
    ) {
      var u = n[o]
      i += u.endpointDistance()
    }
    return i
  },
  lengthAtT: function (t, e) {
    if (t <= 0) return 0
    e = e || {}
    var n = e.precision === void 0 ? this.PRECISION : e.precision,
      i = this.divide(t)[0],
      s = i.length({ precision: n })
    return s
  },
  pointAt: function (t, e) {
    if (t <= 0) return this.start.clone()
    if (t >= 1) return this.end.clone()
    var n = this.tAt(t, e)
    return this.pointAtT(n)
  },
  pointAtLength: function (t, e) {
    var n = this.tAtLength(t, e)
    return this.pointAtT(n)
  },
  pointAtT: function (t) {
    return t <= 0
      ? this.start.clone()
      : t >= 1
        ? this.end.clone()
        : this.getSkeletonPoints(t).divider
  },
  PRECISION: 3,
  round: function (t) {
    return (
      this.start.round(t),
      this.controlPoint1.round(t),
      this.controlPoint2.round(t),
      this.end.round(t),
      this
    )
  },
  scale: function (t, e, n) {
    return (
      this.start.scale(t, e, n),
      this.controlPoint1.scale(t, e, n),
      this.controlPoint2.scale(t, e, n),
      this.end.scale(t, e, n),
      this
    )
  },
  tangentAt: function (t, e) {
    if (!this.isDifferentiable()) return null
    t < 0 ? (t = 0) : t > 1 && (t = 1)
    var n = this.tAt(t, e)
    return this.tangentAtT(n)
  },
  tangentAtLength: function (t, e) {
    if (!this.isDifferentiable()) return null
    var n = this.tAtLength(t, e)
    return this.tangentAtT(n)
  },
  tangentAtT: function (t) {
    if (!this.isDifferentiable()) return null
    t < 0 ? (t = 0) : t > 1 && (t = 1)
    var e = this.getSkeletonPoints(t),
      n = e.startControlPoint2,
      i = e.dividerControlPoint1,
      s = e.divider,
      o = new Ut(n, i)
    return (o.translate(s.x - n.x, s.y - n.y), o)
  },
  tAt: function (t, e) {
    if (t <= 0) return 0
    if (t >= 1) return 1
    e = e || {}
    var n = e.precision === void 0 ? this.PRECISION : e.precision,
      i = e.subdivisions === void 0 ? this.getSubdivisions({ precision: n }) : e.subdivisions,
      s = { precision: n, subdivisions: i },
      o = this.length(s),
      u = o * t
    return this.tAtLength(u, s)
  },
  tAtLength: function (t, e) {
    var n = !0
    ;(t < 0 && ((n = !1), (t = -t)), (e = e || {}))
    for (
      var i = e.precision === void 0 ? this.PRECISION : e.precision,
        s = e.subdivisions === void 0 ? this.getSubdivisions({ precision: i }) : e.subdivisions,
        o = { precision: i, subdivisions: s },
        u,
        c,
        h,
        p,
        y,
        v = 0,
        C = s.length,
        w = 1 / C,
        N = 0;
      N < C;
      N++
    ) {
      var T = n ? N : C - 1 - N,
        z = s[N],
        R = z.endpointDistance()
      if (t <= v + R) {
        ;((u = z),
          (c = T * w),
          (h = (T + 1) * w),
          (p = n ? t - v : R + v - t),
          (y = n ? R + v - t : t - v))
        break
      }
      v += R
    }
    if (!u) return n ? 1 : 0
    for (var B = this.length(o), H = Xg(10, -i); ; ) {
      var Z
      if (((Z = B !== 0 ? p / B : 0), Z < H)) return c
      if (((Z = B !== 0 ? y / B : 0), Z < H)) return h
      var U,
        nt,
        g = u.divide(0.5)
      w /= 2
      var S = g[0].endpointDistance(),
        M = g[1].endpointDistance()
      ;(p <= S
        ? ((u = g[0]), (h -= w), (U = p), (nt = S - U))
        : ((u = g[1]), (c += w), (U = p - S), (nt = M - U)),
        (p = U),
        (y = nt))
    }
  },
  toPoints: function (t) {
    t = t || {}
    for (
      var e = t.precision === void 0 ? this.PRECISION : t.precision,
        n = t.subdivisions === void 0 ? this.getSubdivisions({ precision: e }) : t.subdivisions,
        i = [n[0].start.clone()],
        s = n.length,
        o = 0;
      o < s;
      o++
    ) {
      var u = n[o]
      i.push(u.end.clone())
    }
    return i
  },
  toPolyline: function (t) {
    return new qe(this.toPoints(t))
  },
  toString: function () {
    return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end
  },
  translate: function (t, e) {
    return (
      this.start.translate(t, e),
      this.controlPoint1.translate(t, e),
      this.controlPoint2.translate(t, e),
      this.end.translate(t, e),
      this
    )
  },
}
Be.prototype.divide = Be.prototype.divideAtT
function Vu(t) {
  var e,
    n,
    i = []
  for (n = arguments.length, e = 1; e < n; e++) i.push(arguments[e])
  if (!t) throw new Error('Missing a parent object.')
  var s = Object.create(t)
  for (n = i.length, e = 0; e < n; e++) {
    var o = i[e],
      u,
      c
    for (c in o)
      o.hasOwnProperty(c) &&
        (delete s[c], (u = Object.getOwnPropertyDescriptor(o, c)), Object.defineProperty(s, c, u))
  }
  return s
}
const Jt = function (t) {
  if (!(this instanceof Jt)) return new Jt(t)
  if (typeof t == 'string') return new Jt.parse(t)
  this.segments = []
  var e, n
  if (t)
    if (Array.isArray(t) && t.length !== 0)
      if (
        ((t = t.reduce(function (c, h) {
          return c.concat(h)
        }, [])),
        (n = t.length),
        t[0].isSegment)
      )
        for (e = 0; e < n; e++) {
          var i = t[e]
          this.appendSegment(i)
        }
      else {
        var s = null
        for (e = 0; e < n; e++) {
          var o = t[e]
          if (!(o instanceof Ut || o instanceof Be))
            throw new Error('Cannot construct a path segment from the provided object.')
          ;(e === 0 && this.appendSegment(Jt.createSegment('M', o.start)),
            s && !s.end.equals(o.start) && this.appendSegment(Jt.createSegment('M', o.start)),
            o instanceof Ut
              ? this.appendSegment(Jt.createSegment('L', o.end))
              : o instanceof Be &&
                this.appendSegment(Jt.createSegment('C', o.controlPoint1, o.controlPoint2, o.end)),
            (s = o))
        }
      }
    else if (t.isSegment) this.appendSegment(t)
    else if (t instanceof Ut)
      (this.appendSegment(Jt.createSegment('M', t.start)),
        this.appendSegment(Jt.createSegment('L', t.end)))
    else if (t instanceof Be)
      (this.appendSegment(Jt.createSegment('M', t.start)),
        this.appendSegment(Jt.createSegment('C', t.controlPoint1, t.controlPoint2, t.end)))
    else if (t instanceof qe) {
      if (!(t.points && t.points.length !== 0)) return
      for (n = t.points.length, e = 0; e < n; e++) {
        var u = t.points[e]
        e === 0
          ? this.appendSegment(Jt.createSegment('M', u))
          : this.appendSegment(Jt.createSegment('L', u))
      }
    } else throw new Error('Cannot construct a path from the provided object.')
}
Jt.parse = function (t) {
  if (!t) return new Jt()
  for (
    var e = new Jt(),
      n =
        /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g,
      i = t.match(n),
      s = i.length,
      o = 0;
    o < s;
    o++
  ) {
    var u = i[o],
      c = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g,
      h = u.match(c),
      p = Jt.createSegment.apply(this, h)
    e.appendSegment(p)
  }
  return e
}
Jt.createSegment = function (t) {
  if (!t) throw new Error('Type must be provided.')
  var e = Jt.segmentTypes[t]
  if (!e) throw new Error(t + ' is not a recognized path segment type.')
  for (var n = [], i = arguments.length, s = 1; s < i; s++) n.push(arguments[s])
  return Xr(e, n)
}
Jt.prototype = {
  type: me.Path,
  appendSegment: function (t) {
    var e = this.segments,
      n = e.length,
      i,
      s = n !== 0 ? e[n - 1] : null,
      o = null
    if (Array.isArray(t)) {
      if (
        ((t = t.reduce(function (p, y) {
          return p.concat(y)
        }, [])),
        !t[0].isSegment)
      )
        throw new Error('Segments required.')
      for (var u = t.length, c = 0; c < u; c++) {
        var h = t[c]
        ;((i = this.prepareSegment(h, s, o)), e.push(i), (s = i))
      }
    } else {
      if (!t || !t.isSegment) throw new Error('Segment required.')
      ;((i = this.prepareSegment(t, s, o)), e.push(i))
    }
  },
  bbox: function () {
    var t = this.segments,
      e = t.length
    if (e === 0) return null
    for (var n, i = 0; i < e; i++) {
      var s = t[i]
      if (s.isVisible) {
        var o = s.bbox()
        n = n ? n.union(o) : o
      }
    }
    if (n) return n
    var u = t[e - 1]
    return new Pt(u.end.x, u.end.y, 0, 0)
  },
  clone: function () {
    for (var t = this.segments, e = t.length, n = new Jt(), i = 0; i < e; i++) {
      var s = t[i].clone()
      n.appendSegment(s)
    }
    return n
  },
  closestPoint: function (t, e) {
    var n = this.closestPointT(t, e)
    return n ? this.pointAtT(n) : null
  },
  closestPointLength: function (t, e) {
    e = e || {}
    var n = e.precision === void 0 ? this.PRECISION : e.precision,
      i =
        e.segmentSubdivisions === void 0
          ? this.getSegmentSubdivisions({ precision: n })
          : e.segmentSubdivisions,
      s = { precision: n, segmentSubdivisions: i },
      o = this.closestPointT(t, s)
    return o ? this.lengthAtT(o, s) : 0
  },
  closestPointNormalizedLength: function (t, e) {
    e = e || {}
    var n = e.precision === void 0 ? this.PRECISION : e.precision,
      i =
        e.segmentSubdivisions === void 0
          ? this.getSegmentSubdivisions({ precision: n })
          : e.segmentSubdivisions,
      s = { precision: n, segmentSubdivisions: i },
      o = this.closestPointLength(t, s)
    if (o === 0) return 0
    var u = this.length(s)
    return u === 0 ? 0 : o / u
  },
  closestPointT: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return null
    e = e || {}
    for (
      var s = e.precision === void 0 ? this.PRECISION : e.precision,
        o =
          e.segmentSubdivisions === void 0
            ? this.getSegmentSubdivisions({ precision: s })
            : e.segmentSubdivisions,
        u,
        c = 1 / 0,
        h = 0;
      h < i;
      h++
    ) {
      var p = n[h],
        y = o[h]
      if (p.isVisible) {
        var v = p.closestPointT(t, { precision: s, subdivisions: y }),
          C = p.pointAtT(v),
          w = new Ut(C, t).squaredLength()
        w < c && ((u = { segmentIndex: h, value: v }), (c = w))
      }
    }
    return u || { segmentIndex: i - 1, value: 1 }
  },
  closestPointTangent: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return null
    e = e || {}
    for (
      var s = e.precision === void 0 ? this.PRECISION : e.precision,
        o =
          e.segmentSubdivisions === void 0
            ? this.getSegmentSubdivisions({ precision: s })
            : e.segmentSubdivisions,
        u,
        c = 1 / 0,
        h = 0;
      h < i;
      h++
    ) {
      var p = n[h],
        y = o[h]
      if (p.isDifferentiable()) {
        var v = p.closestPointT(t, { precision: s, subdivisions: y }),
          C = p.pointAtT(v),
          w = new Ut(C, t).squaredLength()
        w < c && ((u = p.tangentAtT(v)), (c = w))
      }
    }
    return u || null
  },
  containsPoint: function (t, e) {
    var n = this.toPolylines(e)
    if (!n) return !1
    for (var i = n.length, s = 0, o = 0; o < i; o++) {
      var u = n[o]
      u.containsPoint(t) && s++
    }
    return s % 2 === 1
  },
  divideAt: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return null
    ;(t < 0 && (t = 0), t > 1 && (t = 1), (e = e || {}))
    var s = e.precision === void 0 ? this.PRECISION : e.precision,
      o =
        e.segmentSubdivisions === void 0
          ? this.getSegmentSubdivisions({ precision: s })
          : e.segmentSubdivisions,
      u = { precision: s, segmentSubdivisions: o },
      c = this.length(u),
      h = c * t
    return this.divideAtLength(h, u)
  },
  divideAtLength: function (t, e) {
    var n = this.segments.length
    if (n === 0) return null
    var i = !0
    ;(t < 0 && ((i = !1), (t = -t)), (e = e || {}))
    var s = e.precision === void 0 ? this.PRECISION : e.precision,
      o =
        e.segmentSubdivisions === void 0
          ? this.getSegmentSubdivisions({ precision: s })
          : e.segmentSubdivisions,
      u,
      c,
      h = 0,
      p,
      y,
      v,
      C,
      w
    for (u = 0; u < n; u++) {
      var N = i ? u : n - 1 - u
      c = this.getSegment(N)
      var T = o[N],
        z = c.length({ precision: s, subdivisions: T })
      if (c.isDifferentiable() && ((v = c), (C = N), t <= h + z)) {
        ;((y = N),
          (p = c.divideAtLength((i ? 1 : -1) * (t - h), { precision: s, subdivisions: T })))
        break
      }
      h += z
    }
    if (!v) return null
    p || ((y = C), (w = i ? 1 : 0), (p = v.divideAtT(w)))
    var R = this.clone()
    R.replaceSegment(y, p)
    var B = y,
      H = y + 1,
      Z = y + 2
    p[0].isDifferentiable() || (R.removeSegment(B), (H -= 1), (Z -= 1))
    var U = R.getSegment(H).start
    ;(R.insertSegment(H, Jt.createSegment('M', U)),
      (Z += 1),
      p[1].isDifferentiable() || (R.removeSegment(Z - 1), (Z -= 1)))
    var nt = Z - B - 1
    for (u = Z; u < R.segments.length; u++) {
      var g = this.getSegment(u - nt)
      if (
        ((c = R.getSegment(u)),
        c.type === 'Z' && !g.subpathStartSegment.end.equals(c.subpathStartSegment.end))
      ) {
        var S = Jt.createSegment('L', g.end)
        R.replaceSegment(u, S)
      }
    }
    var M = new Jt(R.segments.slice(0, H)),
      _ = new Jt(R.segments.slice(H))
    return [M, _]
  },
  equals: function (t) {
    if (!t) return !1
    var e = this.segments,
      n = t.segments,
      i = e.length
    if (n.length !== i) return !1
    for (var s = 0; s < i; s++) {
      var o = e[s],
        u = n[s]
      if (o.type !== u.type || !o.equals(u)) return !1
    }
    return !0
  },
  getSegment: function (t) {
    var e = this.segments,
      n = e.length
    if (n === 0) throw new Error('Path has no segments.')
    if ((t < 0 && (t = n + t), t >= n || t < 0)) throw new Error('Index out of range.')
    return e[t]
  },
  getSegmentSubdivisions: function (t) {
    var e = this.segments,
      n = e.length
    t = t || {}
    for (var i = t.precision === void 0 ? this.PRECISION : t.precision, s = [], o = 0; o < n; o++) {
      var u = e[o],
        c = u.getSubdivisions({ precision: i })
      s.push(c)
    }
    return s
  },
  getSubpaths: function () {
    const e = this.clone().validate().segments,
      n = e.length,
      i = []
    for (let s = 0; s < n; s++) {
      const o = e[s]
      o.isSubpathStart ? i.push(new Jt(o)) : i[i.length - 1].appendSegment(o)
    }
    return i
  },
  insertSegment: function (t, e) {
    var n = this.segments,
      i = n.length
    if ((t < 0 && (t = i + t + 1), t > i || t < 0)) throw new Error('Index out of range.')
    var s,
      o = null,
      u = null
    if (
      (i !== 0 && (t >= 1 ? ((o = n[t - 1]), (u = o.nextSegment)) : (u = n[0])), Array.isArray(e))
    ) {
      if (
        ((e = e.reduce(function (y, v) {
          return y.concat(v)
        }, [])),
        !e[0].isSegment)
      )
        throw new Error('Segments required.')
      for (var c = e.length, h = 0; h < c; h++) {
        var p = e[h]
        ;((s = this.prepareSegment(p, o, u)), n.splice(t + h, 0, s), (o = s))
      }
    } else {
      if (!e || !e.isSegment) throw new Error('Segment required.')
      ;((s = this.prepareSegment(e, o, u)), n.splice(t, 0, s))
    }
  },
  intersectionWithLine: function (t, e) {
    var n = null,
      i = this.toPolylines(e)
    if (!i) return null
    for (var s = 0, o = i.length; s < o; s++) {
      var u = i[s],
        c = t.intersect(u)
      c && (n || (n = []), Array.isArray(c) ? Array.prototype.push.apply(n, c) : n.push(c))
    }
    return n
  },
  isDifferentiable: function () {
    for (var t = this.segments, e = t.length, n = 0; n < e; n++) {
      var i = t[n]
      if (i.isDifferentiable()) return !0
    }
    return !1
  },
  isValid: function () {
    var t = this.segments,
      e = t.length === 0 || t[0].type === 'M'
    return e
  },
  length: function (t) {
    var e = this.segments,
      n = e.length
    if (n === 0) return 0
    t = t || {}
    for (
      var i = t.precision === void 0 ? this.PRECISION : t.precision,
        s =
          t.segmentSubdivisions === void 0
            ? this.getSegmentSubdivisions({ precision: i })
            : t.segmentSubdivisions,
        o = 0,
        u = 0;
      u < n;
      u++
    ) {
      var c = e[u],
        h = s[u]
      o += c.length({ subdivisions: h })
    }
    return o
  },
  lengthAtT: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return 0
    var s = t.segmentIndex
    if (s < 0) return 0
    var o = t.value
    ;(s >= i ? ((s = i - 1), (o = 1)) : o < 0 ? (o = 0) : o > 1 && (o = 1), (e = e || {}))
    for (
      var u = e.precision === void 0 ? this.PRECISION : e.precision,
        c =
          e.segmentSubdivisions === void 0
            ? this.getSegmentSubdivisions({ precision: u })
            : e.segmentSubdivisions,
        h,
        p = 0,
        y = 0;
      y < s;
      y++
    ) {
      var v = n[y]
      ;((h = c[y]), (p += v.length({ precisison: u, subdivisions: h })))
    }
    return ((v = n[s]), (h = c[s]), (p += v.lengthAtT(o, { precisison: u, subdivisions: h })), p)
  },
  pointAt: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return null
    if (t <= 0) return this.start.clone()
    if (t >= 1) return this.end.clone()
    e = e || {}
    var s = e.precision === void 0 ? this.PRECISION : e.precision,
      o =
        e.segmentSubdivisions === void 0
          ? this.getSegmentSubdivisions({ precision: s })
          : e.segmentSubdivisions,
      u = { precision: s, segmentSubdivisions: o },
      c = this.length(u),
      h = c * t
    return this.pointAtLength(h, u)
  },
  pointAtLength: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return null
    if (t === 0) return this.start.clone()
    var s = !0
    ;(t < 0 && ((s = !1), (t = -t)), (e = e || {}))
    for (
      var o = e.precision === void 0 ? this.PRECISION : e.precision,
        u =
          e.segmentSubdivisions === void 0
            ? this.getSegmentSubdivisions({ precision: o })
            : e.segmentSubdivisions,
        c,
        h = 0,
        p = 0;
      p < i;
      p++
    ) {
      var y = s ? p : i - 1 - p,
        v = n[y],
        C = u[y],
        w = v.length({ precision: o, subdivisions: C })
      if (v.isVisible) {
        if (t <= h + w)
          return v.pointAtLength((s ? 1 : -1) * (t - h), { precision: o, subdivisions: C })
        c = v
      }
      h += w
    }
    if (c) return s ? c.end : c.start
    var N = n[i - 1]
    return N.end.clone()
  },
  pointAtT: function (t) {
    var e = this.segments,
      n = e.length
    if (n === 0) return null
    var i = t.segmentIndex
    if (i < 0) return e[0].pointAtT(0)
    if (i >= n) return e[n - 1].pointAtT(1)
    var s = t.value
    return (s < 0 ? (s = 0) : s > 1 && (s = 1), e[i].pointAtT(s))
  },
  PRECISION: 3,
  prepareSegment: function (t, e, n) {
    ;((t.previousSegment = e),
      (t.nextSegment = n),
      e && (e.nextSegment = t),
      n && (n.previousSegment = t))
    var i = t
    return (
      t.isSubpathStart && ((t.subpathStartSegment = t), (i = n)),
      i && this.updateSubpathStartSegment(i),
      t
    )
  },
  removeSegment: function (t) {
    var e = this.segments,
      n = e.length
    if (n === 0) throw new Error('Path has no segments.')
    if ((t < 0 && (t = n + t), t >= n || t < 0)) throw new Error('Index out of range.')
    var i = e.splice(t, 1)[0],
      s = i.previousSegment,
      o = i.nextSegment
    ;(s && (s.nextSegment = o),
      o && (o.previousSegment = s),
      i.isSubpathStart && o && this.updateSubpathStartSegment(o))
  },
  replaceSegment: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) throw new Error('Path has no segments.')
    if ((t < 0 && (t = i + t), t >= i || t < 0)) throw new Error('Index out of range.')
    var s,
      o = n[t],
      u = o.previousSegment,
      c = o.nextSegment,
      h = o.isSubpathStart
    if (Array.isArray(e)) {
      if (
        ((e = e.reduce(function (C, w) {
          return C.concat(w)
        }, [])),
        !e[0].isSegment)
      )
        throw new Error('Segments required.')
      n.splice(t, 1)
      for (var p = e.length, y = 0; y < p; y++) {
        var v = e[y]
        ;((s = this.prepareSegment(v, u, c)),
          n.splice(t + y, 0, s),
          (u = s),
          h && s.isSubpathStart && (h = !1))
      }
    } else {
      if (!e || !e.isSegment) throw new Error('Segment required.')
      ;((s = this.prepareSegment(e, u, c)), n.splice(t, 1, s), h && s.isSubpathStart && (h = !1))
    }
    h && c && this.updateSubpathStartSegment(c)
  },
  round: function (t) {
    for (var e = this.segments, n = e.length, i = 0; i < n; i++) {
      var s = e[i]
      s.round(t)
    }
    return this
  },
  scale: function (t, e, n) {
    for (var i = this.segments, s = i.length, o = 0; o < s; o++) {
      var u = i[o]
      u.scale(t, e, n)
    }
    return this
  },
  segmentAt: function (t, e) {
    var n = this.segmentIndexAt(t, e)
    return n ? this.getSegment(n) : null
  },
  segmentAtLength: function (t, e) {
    var n = this.segmentIndexAtLength(t, e)
    return n ? this.getSegment(n) : null
  },
  segmentIndexAt: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return null
    ;(t < 0 && (t = 0), t > 1 && (t = 1), (e = e || {}))
    var s = e.precision === void 0 ? this.PRECISION : e.precision,
      o =
        e.segmentSubdivisions === void 0
          ? this.getSegmentSubdivisions({ precision: s })
          : e.segmentSubdivisions,
      u = { precision: s, segmentSubdivisions: o },
      c = this.length(u),
      h = c * t
    return this.segmentIndexAtLength(h, u)
  },
  segmentIndexAtLength: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return null
    var s = !0
    ;(t < 0 && ((s = !1), (t = -t)), (e = e || {}))
    for (
      var o = e.precision === void 0 ? this.PRECISION : e.precision,
        u =
          e.segmentSubdivisions === void 0
            ? this.getSegmentSubdivisions({ precision: o })
            : e.segmentSubdivisions,
        c = null,
        h = 0,
        p = 0;
      p < i;
      p++
    ) {
      var y = s ? p : i - 1 - p,
        v = n[y],
        C = u[y],
        w = v.length({ precision: o, subdivisions: C })
      if (v.isVisible) {
        if (t <= h + w) return y
        c = y
      }
      h += w
    }
    return c
  },
  serialize: function () {
    if (!this.isValid()) throw new Error('Invalid path segments.')
    return this.toString()
  },
  tangentAt: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return null
    ;(t < 0 && (t = 0), t > 1 && (t = 1), (e = e || {}))
    var s = e.precision === void 0 ? this.PRECISION : e.precision,
      o =
        e.segmentSubdivisions === void 0
          ? this.getSegmentSubdivisions({ precision: s })
          : e.segmentSubdivisions,
      u = { precision: s, segmentSubdivisions: o },
      c = this.length(u),
      h = c * t
    return this.tangentAtLength(h, u)
  },
  tangentAtLength: function (t, e) {
    var n = this.segments,
      i = n.length
    if (i === 0) return null
    var s = !0
    ;(t < 0 && ((s = !1), (t = -t)), (e = e || {}))
    for (
      var o = e.precision === void 0 ? this.PRECISION : e.precision,
        u =
          e.segmentSubdivisions === void 0
            ? this.getSegmentSubdivisions({ precision: o })
            : e.segmentSubdivisions,
        c,
        h = 0,
        p = 0;
      p < i;
      p++
    ) {
      var y = s ? p : i - 1 - p,
        v = n[y],
        C = u[y],
        w = v.length({ precision: o, subdivisions: C })
      if (v.isDifferentiable()) {
        if (t <= h + w)
          return v.tangentAtLength((s ? 1 : -1) * (t - h), { precision: o, subdivisions: C })
        c = v
      }
      h += w
    }
    if (c) {
      var N = s ? 1 : 0
      return c.tangentAtT(N)
    }
    return null
  },
  tangentAtT: function (t) {
    var e = this.segments,
      n = e.length
    if (n === 0) return null
    var i = t.segmentIndex
    if (i < 0) return e[0].tangentAtT(0)
    if (i >= n) return e[n - 1].tangentAtT(1)
    var s = t.value
    return (s < 0 ? (s = 0) : s > 1 && (s = 1), e[i].tangentAtT(s))
  },
  toPoints: function (t) {
    var e = this.segments,
      n = e.length
    if (n === 0) return null
    t = t || {}
    for (
      var i = t.precision === void 0 ? this.PRECISION : t.precision,
        s =
          t.segmentSubdivisions === void 0
            ? this.getSegmentSubdivisions({ precision: i })
            : t.segmentSubdivisions,
        o = [],
        u = [],
        c = 0;
      c < n;
      c++
    ) {
      var h = e[c]
      if (h.isVisible) {
        var p = s[c]
        if (p.length > 0) {
          var y = p.map(function (v) {
            return v.start
          })
          Array.prototype.push.apply(u, y)
        } else u.push(h.start)
      } else u.length > 0 && (u.push(e[c - 1].end), o.push(u), (u = []))
    }
    return (u.length > 0 && (u.push(this.end), o.push(u)), o)
  },
  toPolylines: function (t) {
    var e = [],
      n = this.toPoints(t)
    if (!n) return null
    for (var i = 0, s = n.length; i < s; i++) e.push(new qe(n[i]))
    return e
  },
  toString: function () {
    for (var t = this.segments, e = t.length, n = '', i = 0; i < e; i++) {
      var s = t[i]
      n += s.serialize() + ' '
    }
    return n.trim()
  },
  translate: function (t, e) {
    for (var n = this.segments, i = n.length, s = 0; s < i; s++) {
      var o = n[s]
      o.translate(t, e)
    }
    return this
  },
  updateSubpathStartSegment: function (t) {
    for (var e = t.previousSegment; t && !t.isSubpathStart; )
      (e ? (t.subpathStartSegment = e.subpathStartSegment) : (t.subpathStartSegment = null),
        (e = t),
        (t = t.nextSegment))
  },
  validate: function () {
    return (this.isValid() || this.insertSegment(0, Jt.createSegment('M', 0, 0)), this)
  },
}
Object.defineProperty(Jt.prototype, 'start', {
  configurable: !0,
  enumerable: !0,
  get: function () {
    var t = this.segments,
      e = t.length
    if (e === 0) return null
    for (var n = 0; n < e; n++) {
      var i = t[n]
      if (i.isVisible) return i.start
    }
    return t[e - 1].end
  },
})
Object.defineProperty(Jt.prototype, 'end', {
  configurable: !0,
  enumerable: !0,
  get: function () {
    var t = this.segments,
      e = t.length
    if (e === 0) return null
    for (var n = e - 1; n >= 0; n--) {
      var i = t[n]
      if (i.isVisible) return i.end
    }
    return t[e - 1].end
  },
})
function Xr(t, e) {
  return (e.unshift(null), new (Function.prototype.bind.apply(t, e))())
}
var no = {
  bbox: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  clone: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  closestPoint: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  closestPointLength: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  closestPointNormalizedLength: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  closestPointT: function (t) {
    if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(t)
    throw new Error(
      'Neither closestPointT() nor closestPointNormalizedLength() function is implemented.'
    )
  },
  closestPointTangent: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  divideAt: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  divideAtLength: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  divideAtT: function (t) {
    if (this.divideAt) return this.divideAt(t)
    throw new Error('Neither divideAtT() nor divideAt() function is implemented.')
  },
  equals: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  getSubdivisions: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  isDifferentiable: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  isSegment: !0,
  isSubpathStart: !1,
  isVisible: !0,
  length: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  lengthAtT: function (t) {
    if (t <= 0) return 0
    var e = this.length()
    return t >= 1 ? e : e * t
  },
  nextSegment: null,
  pointAt: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  pointAtLength: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  pointAtT: function (t) {
    if (this.pointAt) return this.pointAt(t)
    throw new Error('Neither pointAtT() nor pointAt() function is implemented.')
  },
  previousSegment: null,
  round: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  subpathStartSegment: null,
  scale: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  serialize: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  tangentAt: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  tangentAtLength: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  tangentAtT: function (t) {
    if (this.tangentAt) return this.tangentAt(t)
    throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.')
  },
  toString: function () {
    throw new Error('Declaration missing for virtual function.')
  },
  translate: function () {
    throw new Error('Declaration missing for virtual function.')
  },
}
Object.defineProperty(no, 'end', { configurable: !0, enumerable: !0, writable: !0 })
Object.defineProperty(no, 'start', {
  configurable: !0,
  enumerable: !0,
  get: function () {
    if (!this.previousSegment)
      throw new Error(
        'Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)'
      )
    return this.previousSegment.end
  },
})
Object.defineProperty(no, 'type', {
  configurable: !0,
  enumerable: !0,
  get: function () {
    throw new Error('Bad segment declaration. No type specified.')
  },
})
var Xn = function () {
    for (var t = [], e = arguments.length, n = 0; n < e; n++) t.push(arguments[n])
    if (!(this instanceof Xn)) return Xr(Xn, t)
    if (e === 0)
      throw new Error(
        'Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).'
      )
    var i
    if (t[0] instanceof Ut) {
      if (e === 1) return ((this.end = t[0].end.clone()), this)
      throw new Error(
        'Lineto constructor expects a line, 1 point, or 2 coordinates (' + e + ' lines provided).'
      )
    } else if (typeof t[0] == 'string' || typeof t[0] == 'number') {
      if (e === 2) return ((this.end = new et(+t[0], +t[1])), this)
      if (e < 2)
        throw new Error(
          'Lineto constructor expects a line, 1 point, or 2 coordinates (' +
            e +
            ' coordinates provided).'
        )
      var s
      for (i = [], n = 0; n < e; n += 2) ((s = t.slice(n, n + 2)), i.push(Xr(Xn, s)))
      return i
    } else {
      if (e === 1) return ((this.end = new et(t[0])), this)
      var o
      for (i = [], n = 0; n < e; n += 1) ((o = t[n]), i.push(new Xn(o)))
      return i
    }
  },
  RC = {
    clone: function () {
      return new Xn(this.end)
    },
    divideAt: function (t) {
      var e = new Ut(this.start, this.end),
        n = e.divideAt(t)
      return [new Xn(n[0]), new Xn(n[1])]
    },
    divideAtLength: function (t) {
      var e = new Ut(this.start, this.end),
        n = e.divideAtLength(t)
      return [new Xn(n[0]), new Xn(n[1])]
    },
    getSubdivisions: function () {
      return []
    },
    isDifferentiable: function () {
      return this.previousSegment ? !this.start.equals(this.end) : !1
    },
    round: function (t) {
      return (this.end.round(t), this)
    },
    scale: function (t, e, n) {
      return (this.end.scale(t, e, n), this)
    },
    serialize: function () {
      var t = this.end
      return this.type + ' ' + t.x + ' ' + t.y
    },
    toString: function () {
      return this.type + ' ' + this.start + ' ' + this.end
    },
    translate: function (t, e) {
      return (this.end.translate(t, e), this)
    },
  }
Object.defineProperty(RC, 'type', { configurable: !0, enumerable: !0, value: 'L' })
Xn.prototype = Vu(no, Ut.prototype, RC)
var ji = function () {
    for (var t = [], e = arguments.length, n = 0; n < e; n++) t.push(arguments[n])
    if (!(this instanceof ji)) return Xr(ji, t)
    if (e === 0)
      throw new Error(
        'Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).'
      )
    var i
    if (t[0] instanceof Be) {
      if (e === 1)
        return (
          (this.controlPoint1 = t[0].controlPoint1.clone()),
          (this.controlPoint2 = t[0].controlPoint2.clone()),
          (this.end = t[0].end.clone()),
          this
        )
      throw new Error(
        'Curveto constructor expects a curve, 3 points, or 6 coordinates (' +
          e +
          ' curves provided).'
      )
    } else if (typeof t[0] == 'string' || typeof t[0] == 'number') {
      if (e === 6)
        return (
          (this.controlPoint1 = new et(+t[0], +t[1])),
          (this.controlPoint2 = new et(+t[2], +t[3])),
          (this.end = new et(+t[4], +t[5])),
          this
        )
      if (e < 6)
        throw new Error(
          'Curveto constructor expects a curve, 3 points, or 6 coordinates (' +
            e +
            ' coordinates provided).'
        )
      var s
      for (i = [], n = 0; n < e; n += 6) ((s = t.slice(n, n + 6)), i.push(Xr(ji, s)))
      return i
    } else {
      if (e === 3)
        return (
          (this.controlPoint1 = new et(t[0])),
          (this.controlPoint2 = new et(t[1])),
          (this.end = new et(t[2])),
          this
        )
      if (e < 3)
        throw new Error(
          'Curveto constructor expects a curve, 3 points, or 6 coordinates (' +
            e +
            ' points provided).'
        )
      var o
      for (i = [], n = 0; n < e; n += 3) ((o = t.slice(n, n + 3)), i.push(Xr(ji, o)))
      return i
    }
  },
  kC = {
    clone: function () {
      return new ji(this.controlPoint1, this.controlPoint2, this.end)
    },
    divideAt: function (t, e) {
      var n = new Be(this.start, this.controlPoint1, this.controlPoint2, this.end),
        i = n.divideAt(t, e)
      return [new ji(i[0]), new ji(i[1])]
    },
    divideAtLength: function (t, e) {
      var n = new Be(this.start, this.controlPoint1, this.controlPoint2, this.end),
        i = n.divideAtLength(t, e)
      return [new ji(i[0]), new ji(i[1])]
    },
    divideAtT: function (t) {
      var e = new Be(this.start, this.controlPoint1, this.controlPoint2, this.end),
        n = e.divideAtT(t)
      return [new ji(n[0]), new ji(n[1])]
    },
    isDifferentiable: function () {
      if (!this.previousSegment) return !1
      var t = this.start,
        e = this.controlPoint1,
        n = this.controlPoint2,
        i = this.end
      return !(t.equals(e) && e.equals(n) && n.equals(i))
    },
    round: function (t) {
      return (this.controlPoint1.round(t), this.controlPoint2.round(t), this.end.round(t), this)
    },
    scale: function (t, e, n) {
      return (
        this.controlPoint1.scale(t, e, n),
        this.controlPoint2.scale(t, e, n),
        this.end.scale(t, e, n),
        this
      )
    },
    serialize: function () {
      var t = this.controlPoint1,
        e = this.controlPoint2,
        n = this.end
      return this.type + ' ' + t.x + ' ' + t.y + ' ' + e.x + ' ' + e.y + ' ' + n.x + ' ' + n.y
    },
    toString: function () {
      return (
        this.type +
        ' ' +
        this.start +
        ' ' +
        this.controlPoint1 +
        ' ' +
        this.controlPoint2 +
        ' ' +
        this.end
      )
    },
    translate: function (t, e) {
      return (
        this.controlPoint1.translate(t, e),
        this.controlPoint2.translate(t, e),
        this.end.translate(t, e),
        this
      )
    },
  }
Object.defineProperty(kC, 'type', { configurable: !0, enumerable: !0, value: 'C' })
ji.prototype = Vu(no, Be.prototype, kC)
var Fs = function () {
    for (var t = [], e = arguments.length, n = 0; n < e; n++) t.push(arguments[n])
    if (!(this instanceof Fs)) return Xr(Fs, t)
    if (e === 0)
      throw new Error(
        'Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).'
      )
    var i
    if (t[0] instanceof Ut) {
      if (e === 1) return ((this.end = t[0].end.clone()), this)
      throw new Error(
        'Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' +
          e +
          ' lines provided).'
      )
    } else if (t[0] instanceof Be) {
      if (e === 1) return ((this.end = t[0].end.clone()), this)
      throw new Error(
        'Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' +
          e +
          ' curves provided).'
      )
    } else if (typeof t[0] == 'string' || typeof t[0] == 'number') {
      if (e === 2) return ((this.end = new et(+t[0], +t[1])), this)
      if (e < 2)
        throw new Error(
          'Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' +
            e +
            ' coordinates provided).'
        )
      var s
      for (i = [], n = 0; n < e; n += 2)
        ((s = t.slice(n, n + 2)), n === 0 ? i.push(Xr(Fs, s)) : i.push(Xr(Xn, s)))
      return i
    } else {
      if (e === 1) return ((this.end = new et(t[0])), this)
      var o
      for (i = [], n = 0; n < e; n += 1)
        ((o = t[n]), n === 0 ? i.push(new Fs(o)) : i.push(new Xn(o)))
      return i
    }
  },
  Nv = {
    bbox: function () {
      return null
    },
    clone: function () {
      return new Fs(this.end)
    },
    closestPoint: function () {
      return this.end.clone()
    },
    closestPointNormalizedLength: function () {
      return 0
    },
    closestPointLength: function () {
      return 0
    },
    closestPointT: function () {
      return 1
    },
    closestPointTangent: function () {
      return null
    },
    divideAt: function () {
      return [this.clone(), this.clone()]
    },
    divideAtLength: function () {
      return [this.clone(), this.clone()]
    },
    equals: function (t) {
      return this.end.equals(t.end)
    },
    getSubdivisions: function () {
      return []
    },
    isDifferentiable: function () {
      return !1
    },
    isSubpathStart: !0,
    isVisible: !1,
    length: function () {
      return 0
    },
    lengthAtT: function () {
      return 0
    },
    pointAt: function () {
      return this.end.clone()
    },
    pointAtLength: function () {
      return this.end.clone()
    },
    pointAtT: function () {
      return this.end.clone()
    },
    round: function (t) {
      return (this.end.round(t), this)
    },
    scale: function (t, e, n) {
      return (this.end.scale(t, e, n), this)
    },
    serialize: function () {
      var t = this.end
      return this.type + ' ' + t.x + ' ' + t.y
    },
    tangentAt: function () {
      return null
    },
    tangentAtLength: function () {
      return null
    },
    tangentAtT: function () {
      return null
    },
    toString: function () {
      return this.type + ' ' + this.end
    },
    translate: function (t, e) {
      return (this.end.translate(t, e), this)
    },
  }
Object.defineProperty(Nv, 'start', {
  configurable: !0,
  enumerable: !0,
  get: function () {
    throw new Error('Illegal access. Moveto segments should not need a start property.')
  },
})
Object.defineProperty(Nv, 'type', { configurable: !0, enumerable: !0, value: 'M' })
Fs.prototype = Vu(no, Nv)
var fl = function () {
    for (var t = [], e = arguments.length, n = 0; n < e; n++) t.push(arguments[n])
    if (!(this instanceof fl)) return Xr(fl, t)
    if (e > 0) throw new Error('Closepath constructor expects no arguments.')
    return this
  },
  Tv = {
    clone: function () {
      return new fl()
    },
    divideAt: function (t) {
      var e = new Ut(this.start, this.end),
        n = e.divideAt(t)
      return [n[1].isDifferentiable() ? new Xn(n[0]) : this.clone(), new Xn(n[1])]
    },
    divideAtLength: function (t) {
      var e = new Ut(this.start, this.end),
        n = e.divideAtLength(t)
      return [n[1].isDifferentiable() ? new Xn(n[0]) : this.clone(), new Xn(n[1])]
    },
    getSubdivisions: function () {
      return []
    },
    isDifferentiable: function () {
      return !this.previousSegment || !this.subpathStartSegment ? !1 : !this.start.equals(this.end)
    },
    round: function () {
      return this
    },
    scale: function () {
      return this
    },
    serialize: function () {
      return this.type
    },
    toString: function () {
      return this.type + ' ' + this.start + ' ' + this.end
    },
    translate: function () {
      return this
    },
  }
Object.defineProperty(Tv, 'end', {
  configurable: !0,
  enumerable: !0,
  get: function () {
    if (!this.subpathStartSegment)
      throw new Error(
        'Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)'
      )
    return this.subpathStartSegment.end
  },
})
Object.defineProperty(Tv, 'type', { configurable: !0, enumerable: !0, value: 'Z' })
fl.prototype = Vu(no, Ut.prototype, Tv)
var UT = (Jt.segmentTypes = { L: Xn, C: ji, M: Fs, Z: fl, z: fl })
Jt.regexSupportedData = new RegExp('^[\\s\\d' + Object.keys(UT).join('') + ',.]*$')
Jt.isDataSupported = function (t) {
  return typeof t != 'string' ? !1 : this.regexSupportedData.test(t)
}
const YT = {
    curveThroughPoints: function (t) {
      return (console.warn('deprecated'), new Jt(Be.throughPoints(t)).serialize())
    },
    getCurveControlPoints: function (t) {
      console.warn('deprecated')
      var e = [],
        n = [],
        i = t.length - 1,
        s
      if (i == 1)
        return (
          (e[0] = new et((2 * t[0].x + t[1].x) / 3, (2 * t[0].y + t[1].y) / 3)),
          (n[0] = new et(2 * e[0].x - t[0].x, 2 * e[0].y - t[0].y)),
          [e, n]
        )
      var o = []
      for (s = 1; s < i - 1; s++) o[s] = 4 * t[s].x + 2 * t[s + 1].x
      ;((o[0] = t[0].x + 2 * t[1].x), (o[i - 1] = (8 * t[i - 1].x + t[i].x) / 2))
      var u = this.getFirstControlPoints(o)
      for (s = 1; s < i - 1; ++s) o[s] = 4 * t[s].y + 2 * t[s + 1].y
      ;((o[0] = t[0].y + 2 * t[1].y), (o[i - 1] = (8 * t[i - 1].y + t[i].y) / 2))
      var c = this.getFirstControlPoints(o)
      for (s = 0; s < i; s++)
        (e.push(new et(u[s], c[s])),
          s < i - 1
            ? n.push(new et(2 * t[s + 1].x - u[s + 1], 2 * t[s + 1].y - c[s + 1]))
            : n.push(new et((t[i].x + u[i - 1]) / 2, (t[i].y + c[i - 1]) / 2)))
      return [e, n]
    },
    getCurveDivider: function (t, e, n, i) {
      console.warn('deprecated')
      var s = new Be(t, e, n, i)
      return function (u) {
        var c = s.divide(u)
        return [
          { p0: c[0].start, p1: c[0].controlPoint1, p2: c[0].controlPoint2, p3: c[0].end },
          { p0: c[1].start, p1: c[1].controlPoint1, p2: c[1].controlPoint2, p3: c[1].end },
        ]
      }
    },
    getFirstControlPoints: function (t) {
      console.warn('deprecated')
      var e = t.length,
        n = [],
        i = [],
        s = 2
      n[0] = t[0] / s
      for (var o = 1; o < e; o++)
        ((i[o] = 1 / s), (s = (o < e - 1 ? 4 : 3.5) - i[o]), (n[o] = (t[o] - n[o - 1]) / s))
      for (o = 1; o < e; o++) n[e - o - 1] -= i[e - o] * n[e - o]
      return n
    },
    getInversionSolver: function (t, e, n, i) {
      console.warn('deprecated')
      var s = new Be(t, e, n, i)
      return function (u) {
        return s.closestPointT(u)
      }
    },
  },
  bi = function (t) {
    if (!(this instanceof bi)) return new bi(t)
    if (typeof t == 'string') return new bi.parse(t)
    this.points = Array.isArray(t) ? t.map(et) : []
  }
bi.parse = function (t) {
  return new bi(OC(t))
}
bi.fromRect = function (t) {
  return new bi([t.topLeft(), t.topRight(), t.bottomRight(), t.bottomLeft()])
}
bi.prototype = Vu(qe.prototype, {
  type: me.Polygon,
  clone: function () {
    return new bi(LC(this.points))
  },
  convexHull: function () {
    return new bi(zC(this.points))
  },
  lengthPoints: function () {
    const { start: t, end: e, points: n } = this
    return n.length <= 1 || t.equals(e) ? n : [...n, t.clone()]
  },
})
function _C(t, e, n, i) {
  switch (t.type) {
    case me.Line: {
      switch (e.type) {
        case me.Line:
          return Js(t, e)
      }
      break
    }
    case me.Ellipse: {
      switch (e.type) {
        case me.Line:
          return Mv(t, e)
        case me.Ellipse:
          return BC(t, e)
      }
      break
    }
    case me.Rect: {
      switch (e.type) {
        case me.Line:
          return jC(t, e)
        case me.Ellipse:
          return PC(t, e)
        case me.Rect:
          return Ev(t, e)
      }
      break
    }
    case me.Polyline: {
      switch (e.type) {
        case me.Line:
          return gh(t, e)
        case me.Ellipse:
          return Dv(t, e)
        case me.Rect:
          return GC(t, e)
        case me.Polyline:
          return ZC(t, e)
      }
      break
    }
    case me.Polygon: {
      switch (e.type) {
        case me.Line:
          return Ov(t, e)
        case me.Ellipse:
          return ph(t, e)
        case me.Rect:
          return UC(t, e)
        case me.Polyline:
          return YC(t, e)
        case me.Polygon:
          return HC(t, e)
      }
      break
    }
    case me.Path: {
      switch (e.type) {
        case me.Line:
          return VC(t, e, n)
        case me.Ellipse:
          return XC(t, e, n)
        case me.Rect:
          return WC(t, e, n)
        case me.Polyline:
          return Lv(t, e, n)
        case me.Polygon:
          return vh(t, e, n)
        case me.Path:
          return FC(t, e, n, i)
      }
      break
    }
  }
  switch (e.type) {
    case me.Ellipse:
    case me.Rect:
    case me.Polyline:
    case me.Polygon:
    case me.Path:
      return _C(e, t, i, n)
    default:
      throw Error(`The intersection for ${t} and ${e} could not be found.`)
  }
}
function Js(t, e) {
  const n = t.start.x,
    i = t.start.y,
    s = t.end.x,
    o = t.end.y,
    u = e.start.x,
    c = e.start.y,
    h = e.end.x,
    p = e.end.y,
    y = s - n,
    v = o - i,
    C = h - u,
    w = p - c,
    N = n - u,
    T = i - c,
    z = y * w - C * v,
    R = (y * T - v * N) / z,
    B = (C * T - w * N) / z
  return R >= 0 && R <= 1 && B >= 0 && B <= 1
}
function Mv(t, e) {
  const n = t.a,
    i = t.b,
    s = t.x,
    o = t.y,
    u = e.start.x - s,
    c = e.end.x - s,
    h = e.start.y - o,
    p = e.end.y - o,
    y = n * n,
    v = i * i,
    C = c - u,
    w = p - h,
    N = (C * C) / y + (w * w) / v,
    T = (2 * u * C) / y + (2 * h * w) / v,
    z = (u * u) / y + (h * h) / v - 1,
    R = T * T - 4 * N * z
  if (R === 0) {
    const B = -T / 2 / N
    return B >= 0 && B <= 1
  } else if (R > 0) {
    const B = Math.sqrt(R),
      H = (-T + B) / 2 / N,
      Z = (-T - B) / 2 / N
    return (H >= 0 && H <= 1) || (Z >= 0 && Z <= 1)
  }
  return !1
}
function BC(t, e) {
  return HT(t, 0, e, 0)
}
function jC(t, e) {
  const { start: n, end: i } = e,
    { x: s, y: o, width: u, height: c } = t
  return (n.x > s + u && i.x > s + u) ||
    (n.x < s && i.x < s) ||
    (n.y > o + c && i.y > o + c) ||
    (n.y < o && i.y < o)
    ? !1
    : t.containsPoint(e.start) || t.containsPoint(e.end)
      ? !0
      : Js(t.topLine(), e) || Js(t.rightLine(), e) || Js(t.bottomLine(), e) || Js(t.leftLine(), e)
}
function PC(t, e) {
  return Ev(t, Pt.fromEllipse(e)) ? ph(bi.fromRect(t), e) : !1
}
function Ev(t, e) {
  return t.x < e.x + e.width && t.x + t.width > e.x && t.y < e.y + e.height && t.y + t.height > e.y
}
function gh(t, e) {
  return JC(t, e, { interior: !1 })
}
function Dv(t, e) {
  return qC(t, e, { interior: !1 })
}
function GC(t, e) {
  return QC(t, e, { interior: !1 })
}
function ZC(t, e) {
  return mh(t, e, { interior: !1 })
}
function Ov(t, e) {
  return JC(t, e, { interior: !0 })
}
function ph(t, e) {
  return qC(t, e, { interior: !0 })
}
function UC(t, e) {
  return QC(t, e, { interior: !0 })
}
function YC(t, e) {
  return mh(t, e, { interior: !0 })
}
function HC(t, e) {
  return zv(t, e, { interior: !0 })
}
function VC(t, e, n) {
  return t.getSubpaths().some(i => {
    const [s] = i.toPolylines(n),
      { type: o } = i.getSegment(-1)
    return o === 'Z' ? Ov(s, e) : gh(s, e)
  })
}
function XC(t, e, n) {
  return t.getSubpaths().some(i => {
    const [s] = i.toPolylines(n),
      { type: o } = i.getSegment(-1)
    return o === 'Z' ? ph(s, e) : Dv(s, e)
  })
}
function WC(t, e, n) {
  return vh(t, bi.fromRect(e), n)
}
function Lv(t, e, n) {
  return KC(t, e, n, { interior: !1 })
}
function vh(t, e, n) {
  return KC(t, e, n, { interior: !0 })
}
function FC(t, e, n, i) {
  return t.getSubpaths().some(s => {
    const [o] = s.toPolylines(n),
      { type: u } = s.getSegment(-1)
    return u === 'Z' ? vh(e, o, i) : Lv(e, o, i)
  })
}
function JC(t, e, n = {}) {
  const { interior: i = !1 } = n
  let s
  if (i) {
    if (t.containsPoint(e.start)) return !0
    const { start: c, end: h, points: p } = t
    s = h.equals(c) ? p : [...p, c]
  } else s = t.points
  const { length: o } = s,
    u = new Ut()
  for (let c = 0; c < o - 1; c++) if (((u.start = s[c]), (u.end = s[c + 1]), Js(e, u))) return !0
  return !1
}
function qC(t, e, n = {}) {
  const { start: i, end: s, points: o } = t
  if (e.containsPoint(i)) return !0
  let u
  const { interior: c = !1 } = n
  if (c) {
    if (t.containsPoint(e.center())) return !0
    u = s.equals(i) ? o : [...o, i]
  } else u = o
  const { length: h } = u,
    p = new Ut()
  for (let y = 0; y < h - 1; y++) if (((p.start = u[y]), (p.end = u[y + 1]), Mv(e, p))) return !0
  return !1
}
function QC(t, e, n) {
  const i = bi.fromRect(e)
  return zv(t, i, n)
}
function KC(t, e, n, i) {
  return t.getSubpaths().some(s => {
    const [o] = s.toPolylines(n),
      { type: u } = s.getSegment(-1)
    return u === 'Z' ? zv(e, o, i) : mh(e, o, i)
  })
}
function mh(t, e, n = {}) {
  const { interior: i = !1 } = n
  let s
  if (i) {
    const { start: h } = e
    if (t.containsPoint(h)) return !0
    s = t.clone().close()
  } else s = t
  const o = e.points,
    { length: u } = o,
    c = new Ut()
  for (let h = 0; h < u - 1; h++) if (((c.start = o[h]), (c.end = o[h + 1]), gh(s, c))) return !0
  return !1
}
function zv(t, e, n) {
  return e.containsPoint(t.start) || mh(t, e.clone().close(), n)
}
function HT(t, e, n, i) {
  const { cos: s, sin: o } = Math,
    u = o(e),
    c = s(e),
    h = o(i),
    p = s(i),
    y = u * u,
    v = c * c,
    C = u * c,
    w = h * h,
    N = p * p,
    T = h * p,
    z = t.a * t.a,
    R = t.b * t.b,
    B = n.a * n.a,
    H = n.b * n.b,
    Z = z * y + R * v,
    U = B * w + H * N,
    nt = z * v + R * y,
    g = B * N + H * w
  let S = 2 * (R - z) * C,
    M = 2 * (H - B) * T,
    _ = -2 * Z * t.x - S * t.y,
    W = -2 * U * n.x - M * n.y,
    $ = -S * t.x - 2 * nt * t.y,
    X = -M * n.x - 2 * g * n.y
  const Ct = Z * t.x * t.x + nt * t.y * t.y + S * t.x * t.y - z * R,
    Tt = U * n.x * n.x + g * n.y * n.y + M * n.x * n.y - B * H
  ;((S = S / 2), (M = M / 2), (_ = _ / 2), (W = W / 2), ($ = $ / 2), (X = X / 2))
  const G = rs([
      [Z, S, _],
      [S, nt, $],
      [_, $, Ct],
    ]),
    Q = rs([
      [U, M, W],
      [M, g, X],
      [W, X, Tt],
    ]),
    it =
      0.33333333 *
      (rs([
        [U, S, _],
        [M, nt, $],
        [W, $, Ct],
      ]) +
        rs([
          [Z, M, _],
          [S, g, $],
          [_, X, Ct],
        ]) +
        rs([
          [Z, S, W],
          [S, nt, X],
          [_, $, Tt],
        ])),
    st =
      0.33333333 *
      (rs([
        [Z, M, W],
        [S, g, X],
        [_, X, Tt],
      ]) +
        rs([
          [U, S, W],
          [M, nt, X],
          [W, $, Tt],
        ]) +
        rs([
          [U, M, _],
          [M, g, $],
          [W, X, Ct],
        ])),
    F = Nf([
      [G, it],
      [it, st],
    ]),
    ht = Nf([
      [G, st],
      [it, Q],
    ]),
    ct = Nf([
      [it, st],
      [st, Q],
    ])
  return !(
    Nf([
      [2 * F, ht],
      [ht, 2 * ct],
    ]) > 0 &&
    (st > 0 || it > 0)
  )
}
function Nf(t) {
  return t[0][0] * t[1][1] - t[0][1] * t[1][0]
}
function rs(t) {
  return (
    t[0][0] * t[1][1] * t[2][2] -
    t[0][0] * t[1][2] * t[2][1] -
    t[0][1] * t[1][0] * t[2][2] +
    t[0][1] * t[1][2] * t[2][0] +
    t[0][2] * t[1][0] * t[2][1] -
    t[0][2] * t[1][1] * t[2][0]
  )
}
const VT = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        ellipseWithEllipse: BC,
        ellipseWithLine: Mv,
        exists: _C,
        lineWithLine: Js,
        pathWithEllipse: XC,
        pathWithLine: VC,
        pathWithPath: FC,
        pathWithPolygon: vh,
        pathWithPolyline: Lv,
        pathWithRect: WC,
        polygonWithEllipse: ph,
        polygonWithLine: Ov,
        polygonWithPolygon: HC,
        polygonWithPolyline: YC,
        polygonWithRect: UC,
        polylineWithEllipse: Dv,
        polylineWithLine: gh,
        polylineWithPolyline: ZC,
        polylineWithRect: GC,
        rectWithEllipse: PC,
        rectWithLine: jC,
        rectWithRect: Ev,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  XT = VT,
  $C = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Curve: Be,
        Ellipse: li,
        Line: Ut,
        Path: Jt,
        Point: et,
        Polygon: bi,
        Polyline: qe,
        Rect: Pt,
        bezier: YT,
        ellipse: _T,
        intersection: XT,
        line: Ks,
        normalizeAngle: Dr,
        point: Ff,
        random: ov,
        rect: GT,
        scale: OT,
        snapToGrid: to,
        toDeg: dh,
        toRad: Ai,
        types: me,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
var Wg = {},
  Rv = '1.13.7',
  yb =
    (typeof self == 'object' && self.self === self && self) ||
    (typeof window == 'object' && window.global === window && window) ||
    Function('return this')() ||
    {},
  yh = Array.prototype,
  kv = Object.prototype,
  Ab = typeof Symbol < 'u' ? Symbol.prototype : null,
  WT = yh.push,
  Xu = yh.slice,
  Lu = kv.toString,
  FT = kv.hasOwnProperty,
  t1 = typeof ArrayBuffer < 'u',
  JT = typeof DataView < 'u',
  qT = Array.isArray,
  bb = Object.keys,
  Ib = Object.create,
  Cb = t1 && ArrayBuffer.isView,
  QT = isNaN,
  KT = isFinite,
  e1 = !{ toString: null }.propertyIsEnumerable('toString'),
  wb = [
    'valueOf',
    'isPrototypeOf',
    'toString',
    'propertyIsEnumerable',
    'hasOwnProperty',
    'toLocaleString',
  ],
  $T = Math.pow(2, 53) - 1
function ci(t, e) {
  return (
    (e = e == null ? t.length - 1 : +e),
    function () {
      for (var n = Math.max(arguments.length - e, 0), i = Array(n), s = 0; s < n; s++)
        i[s] = arguments[s + e]
      switch (e) {
        case 0:
          return t.call(this, i)
        case 1:
          return t.call(this, arguments[0], i)
        case 2:
          return t.call(this, arguments[0], arguments[1], i)
      }
      var o = Array(e + 1)
      for (s = 0; s < e; s++) o[s] = arguments[s]
      return ((o[e] = i), t.apply(this, o))
    }
  )
}
function fs(t) {
  var e = typeof t
  return e === 'function' || (e === 'object' && !!t)
}
function n1(t) {
  return t === null
}
function _v(t) {
  return t === void 0
}
function Bv(t) {
  return t === !0 || t === !1 || Lu.call(t) === '[object Boolean]'
}
function i1(t) {
  return !!(t && t.nodeType === 1)
}
function ni(t) {
  var e = '[object ' + t + ']'
  return function (n) {
    return Lu.call(n) === e
  }
}
const Ah = ni('String'),
  jv = ni('Number'),
  r1 = ni('Date'),
  a1 = ni('RegExp'),
  s1 = ni('Error'),
  Pv = ni('Symbol'),
  Gv = ni('ArrayBuffer')
var o1 = ni('Function'),
  tM = yb.document && yb.document.childNodes
typeof /./ != 'function' &&
  typeof Int8Array != 'object' &&
  typeof tM != 'function' &&
  (o1 = function (t) {
    return typeof t == 'function' || !1
  })
const ei = o1,
  l1 = ni('Object')
var u1 = JT && (!/\[native code\]/.test(String(DataView)) || l1(new DataView(new ArrayBuffer(8)))),
  Zv = typeof Map < 'u' && l1(new Map()),
  eM = ni('DataView')
function nM(t) {
  return t != null && ei(t.getInt8) && Gv(t.buffer)
}
const zu = u1 ? nM : eM,
  hs = qT || ni('Array')
function ds(t, e) {
  return t != null && FT.call(t, e)
}
var cv = ni('Arguments')
;(function () {
  cv(arguments) ||
    (cv = function (t) {
      return ds(t, 'callee')
    })
})()
const bh = cv
function c1(t) {
  return !Pv(t) && KT(t) && !isNaN(parseFloat(t))
}
function Uv(t) {
  return jv(t) && QT(t)
}
function Yv(t) {
  return function () {
    return t
  }
}
function f1(t) {
  return function (e) {
    var n = t(e)
    return typeof n == 'number' && n >= 0 && n <= $T
  }
}
function h1(t) {
  return function (e) {
    return e?.[t]
  }
}
const Jf = h1('byteLength'),
  iM = f1(Jf)
var rM = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/
function aM(t) {
  return Cb ? Cb(t) && !zu(t) : iM(t) && rM.test(Lu.call(t))
}
const Hv = t1 ? aM : Yv(!1),
  Ii = h1('length')
function sM(t) {
  for (var e = {}, n = t.length, i = 0; i < n; ++i) e[t[i]] = !0
  return {
    contains: function (s) {
      return e[s] === !0
    },
    push: function (s) {
      return ((e[s] = !0), t.push(s))
    },
  }
}
function d1(t, e) {
  e = sM(e)
  var n = wb.length,
    i = t.constructor,
    s = (ei(i) && i.prototype) || kv,
    o = 'constructor'
  for (ds(t, o) && !e.contains(o) && e.push(o); n--; )
    ((o = wb[n]), o in t && t[o] !== s[o] && !e.contains(o) && e.push(o))
}
function On(t) {
  if (!fs(t)) return []
  if (bb) return bb(t)
  var e = []
  for (var n in t) ds(t, n) && e.push(n)
  return (e1 && d1(t, e), e)
}
function g1(t) {
  if (t == null) return !0
  var e = Ii(t)
  return typeof e == 'number' && (hs(t) || Ah(t) || bh(t)) ? e === 0 : Ii(On(t)) === 0
}
function Vv(t, e) {
  var n = On(e),
    i = n.length
  if (t == null) return !i
  for (var s = Object(t), o = 0; o < i; o++) {
    var u = n[o]
    if (e[u] !== s[u] || !(u in s)) return !1
  }
  return !0
}
function Ue(t) {
  if (t instanceof Ue) return t
  if (!(this instanceof Ue)) return new Ue(t)
  this._wrapped = t
}
Ue.VERSION = Rv
Ue.prototype.value = function () {
  return this._wrapped
}
Ue.prototype.valueOf = Ue.prototype.toJSON = Ue.prototype.value
Ue.prototype.toString = function () {
  return String(this._wrapped)
}
function xb(t) {
  return new Uint8Array(t.buffer || t, t.byteOffset || 0, Jf(t))
}
var Sb = '[object DataView]'
function fv(t, e, n, i) {
  if (t === e) return t !== 0 || 1 / t === 1 / e
  if (t == null || e == null) return !1
  if (t !== t) return e !== e
  var s = typeof t
  return s !== 'function' && s !== 'object' && typeof e != 'object' ? !1 : p1(t, e, n, i)
}
function p1(t, e, n, i) {
  ;(t instanceof Ue && (t = t._wrapped), e instanceof Ue && (e = e._wrapped))
  var s = Lu.call(t)
  if (s !== Lu.call(e)) return !1
  if (u1 && s == '[object Object]' && zu(t)) {
    if (!zu(e)) return !1
    s = Sb
  }
  switch (s) {
    case '[object RegExp]':
    case '[object String]':
      return '' + t == '' + e
    case '[object Number]':
      return +t != +t ? +e != +e : +t == 0 ? 1 / +t === 1 / e : +t == +e
    case '[object Date]':
    case '[object Boolean]':
      return +t == +e
    case '[object Symbol]':
      return Ab.valueOf.call(t) === Ab.valueOf.call(e)
    case '[object ArrayBuffer]':
    case Sb:
      return p1(xb(t), xb(e), n, i)
  }
  var o = s === '[object Array]'
  if (!o && Hv(t)) {
    var u = Jf(t)
    if (u !== Jf(e)) return !1
    if (t.buffer === e.buffer && t.byteOffset === e.byteOffset) return !0
    o = !0
  }
  if (!o) {
    if (typeof t != 'object' || typeof e != 'object') return !1
    var c = t.constructor,
      h = e.constructor
    if (
      c !== h &&
      !(ei(c) && c instanceof c && ei(h) && h instanceof h) &&
      'constructor' in t &&
      'constructor' in e
    )
      return !1
  }
  ;((n = n || []), (i = i || []))
  for (var p = n.length; p--; ) if (n[p] === t) return i[p] === e
  if ((n.push(t), i.push(e), o)) {
    if (((p = t.length), p !== e.length)) return !1
    for (; p--; ) if (!fv(t[p], e[p], n, i)) return !1
  } else {
    var y = On(t),
      v
    if (((p = y.length), On(e).length !== p)) return !1
    for (; p--; ) if (((v = y[p]), !(ds(e, v) && fv(t[v], e[v], n, i)))) return !1
  }
  return (n.pop(), i.pop(), !0)
}
function v1(t, e) {
  return fv(t, e)
}
function ml(t) {
  if (!fs(t)) return []
  var e = []
  for (var n in t) e.push(n)
  return (e1 && d1(t, e), e)
}
function Xv(t) {
  var e = Ii(t)
  return function (n) {
    if (n == null) return !1
    var i = ml(n)
    if (Ii(i)) return !1
    for (var s = 0; s < e; s++) if (!ei(n[t[s]])) return !1
    return t !== A1 || !ei(n[Wv])
  }
}
var Wv = 'forEach',
  m1 = 'has',
  Fv = ['clear', 'delete'],
  y1 = ['get', m1, 'set'],
  oM = Fv.concat(Wv, y1),
  A1 = Fv.concat(y1),
  lM = ['add'].concat(Fv, Wv, m1)
const b1 = Zv ? Xv(oM) : ni('Map'),
  I1 = Zv ? Xv(A1) : ni('WeakMap'),
  C1 = Zv ? Xv(lM) : ni('Set'),
  w1 = ni('WeakSet')
function io(t) {
  for (var e = On(t), n = e.length, i = Array(n), s = 0; s < n; s++) i[s] = t[e[s]]
  return i
}
function x1(t) {
  for (var e = On(t), n = e.length, i = Array(n), s = 0; s < n; s++) i[s] = [e[s], t[e[s]]]
  return i
}
function Jv(t) {
  for (var e = {}, n = On(t), i = 0, s = n.length; i < s; i++) e[t[n[i]]] = n[i]
  return e
}
function Ru(t) {
  var e = []
  for (var n in t) ei(t[n]) && e.push(n)
  return e.sort()
}
function qv(t, e) {
  return function (n) {
    var i = arguments.length
    if ((e && (n = Object(n)), i < 2 || n == null)) return n
    for (var s = 1; s < i; s++)
      for (var o = arguments[s], u = t(o), c = u.length, h = 0; h < c; h++) {
        var p = u[h]
        ;(!e || n[p] === void 0) && (n[p] = o[p])
      }
    return n
  }
}
const Qv = qv(ml),
  hl = qv(On),
  Kv = qv(ml, !0)
function uM() {
  return function () {}
}
function S1(t) {
  if (!fs(t)) return {}
  if (Ib) return Ib(t)
  var e = uM()
  e.prototype = t
  var n = new e()
  return ((e.prototype = null), n)
}
function N1(t, e) {
  var n = S1(t)
  return (e && hl(n, e), n)
}
function T1(t) {
  return fs(t) ? (hs(t) ? t.slice() : Qv({}, t)) : t
}
function M1(t, e) {
  return (e(t), t)
}
function $v(t) {
  return hs(t) ? t : [t]
}
Ue.toPath = $v
function Wu(t) {
  return Ue.toPath(t)
}
function tm(t, e) {
  for (var n = e.length, i = 0; i < n; i++) {
    if (t == null) return
    t = t[e[i]]
  }
  return n ? t : void 0
}
function em(t, e, n) {
  var i = tm(t, Wu(e))
  return _v(i) ? n : i
}
function E1(t, e) {
  e = Wu(e)
  for (var n = e.length, i = 0; i < n; i++) {
    var s = e[i]
    if (!ds(t, s)) return !1
    t = t[s]
  }
  return !!n
}
function Ih(t) {
  return t
}
function eo(t) {
  return (
    (t = hl({}, t)),
    function (e) {
      return Vv(e, t)
    }
  )
}
function Ch(t) {
  return (
    (t = Wu(t)),
    function (e) {
      return tm(e, t)
    }
  )
}
function Fu(t, e, n) {
  if (e === void 0) return t
  switch (n ?? 3) {
    case 1:
      return function (i) {
        return t.call(e, i)
      }
    case 3:
      return function (i, s, o) {
        return t.call(e, i, s, o)
      }
    case 4:
      return function (i, s, o, u) {
        return t.call(e, i, s, o, u)
      }
  }
  return function () {
    return t.apply(e, arguments)
  }
}
function D1(t, e, n) {
  return t == null ? Ih : ei(t) ? Fu(t, e, n) : fs(t) && !hs(t) ? eo(t) : Ch(t)
}
function wh(t, e) {
  return D1(t, e, 1 / 0)
}
Ue.iteratee = wh
function Ci(t, e, n) {
  return Ue.iteratee !== wh ? Ue.iteratee(t, e) : D1(t, e, n)
}
function O1(t, e, n) {
  e = Ci(e, n)
  for (var i = On(t), s = i.length, o = {}, u = 0; u < s; u++) {
    var c = i[u]
    o[c] = e(t[c], c, t)
  }
  return o
}
function nm() {}
function L1(t) {
  return t == null
    ? nm
    : function (e) {
        return em(t, e)
      }
}
function z1(t, e, n) {
  var i = Array(Math.max(0, t))
  e = Fu(e, n, 1)
  for (var s = 0; s < t; s++) i[s] = e(s)
  return i
}
function qf(t, e) {
  return (e == null && ((e = t), (t = 0)), t + Math.floor(Math.random() * (e - t + 1)))
}
const dl =
  Date.now ||
  function () {
    return new Date().getTime()
  }
function R1(t) {
  var e = function (o) {
      return t[o]
    },
    n = '(?:' + On(t).join('|') + ')',
    i = RegExp(n),
    s = RegExp(n, 'g')
  return function (o) {
    return ((o = o == null ? '' : '' + o), i.test(o) ? o.replace(s, e) : o)
  }
}
const k1 = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;' },
  _1 = R1(k1),
  cM = Jv(k1),
  B1 = R1(cM),
  j1 = (Ue.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g,
  })
var Fg = /(.)^/,
  fM = { "'": "'", '\\': '\\', '\r': 'r', '\n': 'n', '\u2028': 'u2028', '\u2029': 'u2029' },
  hM = /\\|'|\r|\n|\u2028|\u2029/g
function dM(t) {
  return '\\' + fM[t]
}
var gM = /^\s*(\w|\$)+\s*$/
function P1(t, e, n) {
  ;(!e && n && (e = n), (e = Kv({}, e, Ue.templateSettings)))
  var i = RegExp(
      [(e.escape || Fg).source, (e.interpolate || Fg).source, (e.evaluate || Fg).source].join('|') +
        '|$',
      'g'
    ),
    s = 0,
    o = "__p+='"
  ;(t.replace(i, function (p, y, v, C, w) {
    return (
      (o += t.slice(s, w).replace(hM, dM)),
      (s = w + p.length),
      y
        ? (o +=
            `'+
((__t=(` +
            y +
            `))==null?'':_.escape(__t))+
'`)
        : v
          ? (o +=
              `'+
((__t=(` +
              v +
              `))==null?'':__t)+
'`)
          : C &&
            (o +=
              `';
` +
              C +
              `
__p+='`),
      p
    )
  }),
    (o += `';
`))
  var u = e.variable
  if (u) {
    if (!gM.test(u)) throw new Error('variable is not a bare identifier: ' + u)
  } else
    ((o =
      `with(obj||{}){
` +
      o +
      `}
`),
      (u = 'obj'))
  o =
    `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` +
    o +
    `return __p;
`
  var c
  try {
    c = new Function(u, '_', o)
  } catch (p) {
    throw ((p.source = o), p)
  }
  var h = function (p) {
    return c.call(this, p, Ue)
  }
  return (
    (h.source =
      'function(' +
      u +
      `){
` +
      o +
      '}'),
    h
  )
}
function G1(t, e, n) {
  e = Wu(e)
  var i = e.length
  if (!i) return ei(n) ? n.call(t) : n
  for (var s = 0; s < i; s++) {
    var o = t?.[e[s]]
    ;(o === void 0 && ((o = n), (s = i)), (t = ei(o) ? o.call(t) : o))
  }
  return t
}
var pM = 0
function Z1(t) {
  var e = ++pM + ''
  return t ? t + e : e
}
function U1(t) {
  var e = Ue(t)
  return ((e._chain = !0), e)
}
function Y1(t, e, n, i, s) {
  if (!(i instanceof e)) return t.apply(n, s)
  var o = S1(t.prototype),
    u = t.apply(o, s)
  return fs(u) ? u : o
}
var ro = ci(function (t, e) {
  var n = ro.placeholder,
    i = function () {
      for (var s = 0, o = e.length, u = Array(o), c = 0; c < o; c++)
        u[c] = e[c] === n ? arguments[s++] : e[c]
      for (; s < arguments.length; ) u.push(arguments[s++])
      return Y1(t, i, this, this, u)
    }
  return i
})
ro.placeholder = Ue
const im = ci(function (t, e, n) {
    if (!ei(t)) throw new TypeError('Bind must be called on a function')
    var i = ci(function (s) {
      return Y1(t, i, e, this, n.concat(s))
    })
    return i
  }),
  Hi = f1(Ii)
function ao(t, e, n, i) {
  if (((i = i || []), !e && e !== 0)) e = 1 / 0
  else if (e <= 0) return i.concat(t)
  for (var s = i.length, o = 0, u = Ii(t); o < u; o++) {
    var c = t[o]
    if (Hi(c) && (hs(c) || bh(c)))
      if (e > 1) (ao(c, e - 1, n, i), (s = i.length))
      else for (var h = 0, p = c.length; h < p; ) i[s++] = c[h++]
    else n || (i[s++] = c)
  }
  return i
}
const H1 = ci(function (t, e) {
  e = ao(e, !1, !1)
  var n = e.length
  if (n < 1) throw new Error('bindAll must be passed function names')
  for (; n--; ) {
    var i = e[n]
    t[i] = im(t[i], t)
  }
  return t
})
function V1(t, e) {
  var n = function (i) {
    var s = n.cache,
      o = '' + (e ? e.apply(this, arguments) : i)
    return (ds(s, o) || (s[o] = t.apply(this, arguments)), s[o])
  }
  return ((n.cache = {}), n)
}
const rm = ci(function (t, e, n) {
    return setTimeout(function () {
      return t.apply(null, n)
    }, e)
  }),
  X1 = ro(rm, Ue, 1)
function W1(t, e, n) {
  var i,
    s,
    o,
    u,
    c = 0
  n || (n = {})
  var h = function () {
      ;((c = n.leading === !1 ? 0 : dl()), (i = null), (u = t.apply(s, o)), i || (s = o = null))
    },
    p = function () {
      var y = dl()
      !c && n.leading === !1 && (c = y)
      var v = e - (y - c)
      return (
        (s = this),
        (o = arguments),
        v <= 0 || v > e
          ? (i && (clearTimeout(i), (i = null)), (c = y), (u = t.apply(s, o)), i || (s = o = null))
          : !i && n.trailing !== !1 && (i = setTimeout(h, v)),
        u
      )
    }
  return (
    (p.cancel = function () {
      ;(clearTimeout(i), (c = 0), (i = s = o = null))
    }),
    p
  )
}
function F1(t, e, n) {
  var i,
    s,
    o,
    u,
    c,
    h = function () {
      var y = dl() - s
      e > y
        ? (i = setTimeout(h, e - y))
        : ((i = null), n || (u = t.apply(c, o)), i || (o = c = null))
    },
    p = ci(function (y) {
      return (
        (c = this),
        (o = y),
        (s = dl()),
        i || ((i = setTimeout(h, e)), n && (u = t.apply(c, o))),
        u
      )
    })
  return (
    (p.cancel = function () {
      ;(clearTimeout(i), (i = o = c = null))
    }),
    p
  )
}
function J1(t, e) {
  return ro(e, t)
}
function xh(t) {
  return function () {
    return !t.apply(this, arguments)
  }
}
function q1() {
  var t = arguments,
    e = t.length - 1
  return function () {
    for (var n = e, i = t[e].apply(this, arguments); n--; ) i = t[n].call(this, i)
    return i
  }
}
function Q1(t, e) {
  return function () {
    if (--t < 1) return e.apply(this, arguments)
  }
}
function am(t, e) {
  var n
  return function () {
    return (--t > 0 && (n = e.apply(this, arguments)), t <= 1 && (e = null), n)
  }
}
const K1 = ro(am, 2)
function sm(t, e, n) {
  e = Ci(e, n)
  for (var i = On(t), s, o = 0, u = i.length; o < u; o++) if (((s = i[o]), e(t[s], s, t))) return s
}
function $1(t) {
  return function (e, n, i) {
    n = Ci(n, i)
    for (var s = Ii(e), o = t > 0 ? 0 : s - 1; o >= 0 && o < s; o += t) if (n(e[o], o, e)) return o
    return -1
  }
}
const Sh = $1(1),
  om = $1(-1)
function lm(t, e, n, i) {
  n = Ci(n, i, 1)
  for (var s = n(e), o = 0, u = Ii(t); o < u; ) {
    var c = Math.floor((o + u) / 2)
    n(t[c]) < s ? (o = c + 1) : (u = c)
  }
  return o
}
function tw(t, e, n) {
  return function (i, s, o) {
    var u = 0,
      c = Ii(i)
    if (typeof o == 'number')
      t > 0 ? (u = o >= 0 ? o : Math.max(o + c, u)) : (c = o >= 0 ? Math.min(o + 1, c) : o + c + 1)
    else if (n && o && c) return ((o = n(i, s)), i[o] === s ? o : -1)
    if (s !== s) return ((o = e(Xu.call(i, u, c), Uv)), o >= 0 ? o + u : -1)
    for (o = t > 0 ? u : c - 1; o >= 0 && o < c; o += t) if (i[o] === s) return o
    return -1
  }
}
const um = tw(1, Sh, lm),
  ew = tw(-1, om)
function ku(t, e, n) {
  var i = Hi(t) ? Sh : sm,
    s = i(t, e, n)
  if (s !== void 0 && s !== -1) return t[s]
}
function nw(t, e) {
  return ku(t, eo(e))
}
function Or(t, e, n) {
  e = Fu(e, n)
  var i, s
  if (Hi(t)) for (i = 0, s = t.length; i < s; i++) e(t[i], i, t)
  else {
    var o = On(t)
    for (i = 0, s = o.length; i < s; i++) e(t[o[i]], o[i], t)
  }
  return t
}
function Aa(t, e, n) {
  e = Ci(e, n)
  for (var i = !Hi(t) && On(t), s = (i || t).length, o = Array(s), u = 0; u < s; u++) {
    var c = i ? i[u] : u
    o[u] = e(t[c], c, t)
  }
  return o
}
function iw(t) {
  var e = function (n, i, s, o) {
    var u = !Hi(n) && On(n),
      c = (u || n).length,
      h = t > 0 ? 0 : c - 1
    for (o || ((s = n[u ? u[h] : h]), (h += t)); h >= 0 && h < c; h += t) {
      var p = u ? u[h] : h
      s = i(s, n[p], p, n)
    }
    return s
  }
  return function (n, i, s, o) {
    var u = arguments.length >= 3
    return e(n, Fu(i, o, 4), s, u)
  }
}
const sl = iw(1),
  Qf = iw(-1)
function us(t, e, n) {
  var i = []
  return (
    (e = Ci(e, n)),
    Or(t, function (s, o, u) {
      e(s, o, u) && i.push(s)
    }),
    i
  )
}
function rw(t, e, n) {
  return us(t, xh(Ci(e)), n)
}
function Kf(t, e, n) {
  e = Ci(e, n)
  for (var i = !Hi(t) && On(t), s = (i || t).length, o = 0; o < s; o++) {
    var u = i ? i[o] : o
    if (!e(t[u], u, t)) return !1
  }
  return !0
}
function $f(t, e, n) {
  e = Ci(e, n)
  for (var i = !Hi(t) && On(t), s = (i || t).length, o = 0; o < s; o++) {
    var u = i ? i[o] : o
    if (e(t[u], u, t)) return !0
  }
  return !1
}
function sr(t, e, n, i) {
  return (Hi(t) || (t = io(t)), (typeof n != 'number' || i) && (n = 0), um(t, e, n) >= 0)
}
const aw = ci(function (t, e, n) {
  var i, s
  return (
    ei(e) ? (s = e) : ((e = Wu(e)), (i = e.slice(0, -1)), (e = e[e.length - 1])),
    Aa(t, function (o) {
      var u = s
      if (!u) {
        if ((i && i.length && (o = tm(o, i)), o == null)) return
        u = o[e]
      }
      return u == null ? u : u.apply(o, n)
    })
  )
})
function Nh(t, e) {
  return Aa(t, Ch(e))
}
function sw(t, e) {
  return us(t, eo(e))
}
function cm(t, e, n) {
  var i = -1 / 0,
    s = -1 / 0,
    o,
    u
  if (e == null || (typeof e == 'number' && typeof t[0] != 'object' && t != null)) {
    t = Hi(t) ? t : io(t)
    for (var c = 0, h = t.length; c < h; c++) ((o = t[c]), o != null && o > i && (i = o))
  } else
    ((e = Ci(e, n)),
      Or(t, function (p, y, v) {
        ;((u = e(p, y, v)), (u > s || (u === -1 / 0 && i === -1 / 0)) && ((i = p), (s = u)))
      }))
  return i
}
function ow(t, e, n) {
  var i = 1 / 0,
    s = 1 / 0,
    o,
    u
  if (e == null || (typeof e == 'number' && typeof t[0] != 'object' && t != null)) {
    t = Hi(t) ? t : io(t)
    for (var c = 0, h = t.length; c < h; c++) ((o = t[c]), o != null && o < i && (i = o))
  } else
    ((e = Ci(e, n)),
      Or(t, function (p, y, v) {
        ;((u = e(p, y, v)), (u < s || (u === 1 / 0 && i === 1 / 0)) && ((i = p), (s = u)))
      }))
  return i
}
var vM = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g
function fm(t) {
  return t ? (hs(t) ? Xu.call(t) : Ah(t) ? t.match(vM) : Hi(t) ? Aa(t, Ih) : io(t)) : []
}
function hm(t, e, n) {
  if (e == null || n) return (Hi(t) || (t = io(t)), t[qf(t.length - 1)])
  var i = fm(t),
    s = Ii(i)
  e = Math.max(Math.min(e, s), 0)
  for (var o = s - 1, u = 0; u < e; u++) {
    var c = qf(u, o),
      h = i[u]
    ;((i[u] = i[c]), (i[c] = h))
  }
  return i.slice(0, e)
}
function lw(t) {
  return hm(t, 1 / 0)
}
function uw(t, e, n) {
  var i = 0
  return (
    (e = Ci(e, n)),
    Nh(
      Aa(t, function (s, o, u) {
        return { value: s, index: i++, criteria: e(s, o, u) }
      }).sort(function (s, o) {
        var u = s.criteria,
          c = o.criteria
        if (u !== c) {
          if (u > c || u === void 0) return 1
          if (u < c || c === void 0) return -1
        }
        return s.index - o.index
      }),
      'value'
    )
  )
}
function Th(t, e) {
  return function (n, i, s) {
    var o = e ? [[], []] : {}
    return (
      (i = Ci(i, s)),
      Or(n, function (u, c) {
        var h = i(u, c, n)
        t(o, u, h)
      }),
      o
    )
  }
}
const cw = Th(function (t, e, n) {
    ds(t, n) ? t[n].push(e) : (t[n] = [e])
  }),
  fw = Th(function (t, e, n) {
    t[n] = e
  }),
  hw = Th(function (t, e, n) {
    ds(t, n) ? t[n]++ : (t[n] = 1)
  }),
  dw = Th(function (t, e, n) {
    t[n ? 0 : 1].push(e)
  }, !0)
function gw(t) {
  return t == null ? 0 : Hi(t) ? t.length : On(t).length
}
function mM(t, e, n) {
  return e in n
}
const dm = ci(function (t, e) {
    var n = {},
      i = e[0]
    if (t == null) return n
    ei(i)
      ? (e.length > 1 && (i = Fu(i, e[1])), (e = ml(t)))
      : ((i = mM), (e = ao(e, !1, !1)), (t = Object(t)))
    for (var s = 0, o = e.length; s < o; s++) {
      var u = e[s],
        c = t[u]
      i(c, u, t) && (n[u] = c)
    }
    return n
  }),
  pw = ci(function (t, e) {
    var n = e[0],
      i
    return (
      ei(n)
        ? ((n = xh(n)), e.length > 1 && (i = e[1]))
        : ((e = Aa(ao(e, !1, !1), String)),
          (n = function (s, o) {
            return !sr(e, o)
          })),
      dm(t, n, i)
    )
  })
function gm(t, e, n) {
  return Xu.call(t, 0, Math.max(0, t.length - (e == null || n ? 1 : e)))
}
function ol(t, e, n) {
  return t == null || t.length < 1
    ? e == null || n
      ? void 0
      : []
    : e == null || n
      ? t[0]
      : gm(t, t.length - e)
}
function $s(t, e, n) {
  return Xu.call(t, e == null || n ? 1 : e)
}
function vw(t, e, n) {
  return t == null || t.length < 1
    ? e == null || n
      ? void 0
      : []
    : e == null || n
      ? t[t.length - 1]
      : $s(t, Math.max(0, t.length - e))
}
function mw(t) {
  return us(t, Boolean)
}
function yw(t, e) {
  return ao(t, e, !1)
}
const pm = ci(function (t, e) {
    return (
      (e = ao(e, !0, !0)),
      us(t, function (n) {
        return !sr(e, n)
      })
    )
  }),
  Aw = ci(function (t, e) {
    return pm(t, e)
  })
function _u(t, e, n, i) {
  ;(Bv(e) || ((i = n), (n = e), (e = !1)), n != null && (n = Ci(n, i)))
  for (var s = [], o = [], u = 0, c = Ii(t); u < c; u++) {
    var h = t[u],
      p = n ? n(h, u, t) : h
    e && !n
      ? ((!u || o !== p) && s.push(h), (o = p))
      : n
        ? sr(o, p) || (o.push(p), s.push(h))
        : sr(s, h) || s.push(h)
  }
  return s
}
const bw = ci(function (t) {
  return _u(ao(t, !0, !0))
})
function Iw(t) {
  for (var e = [], n = arguments.length, i = 0, s = Ii(t); i < s; i++) {
    var o = t[i]
    if (!sr(e, o)) {
      var u
      for (u = 1; u < n && sr(arguments[u], o); u++);
      u === n && e.push(o)
    }
  }
  return e
}
function Bu(t) {
  for (var e = (t && cm(t, Ii).length) || 0, n = Array(e), i = 0; i < e; i++) n[i] = Nh(t, i)
  return n
}
const Cw = ci(Bu)
function ww(t, e) {
  for (var n = {}, i = 0, s = Ii(t); i < s; i++) e ? (n[t[i]] = e[i]) : (n[t[i][0]] = t[i][1])
  return n
}
function xw(t, e, n) {
  ;(e == null && ((e = t || 0), (t = 0)), n || (n = e < t ? -1 : 1))
  for (var i = Math.max(Math.ceil((e - t) / n), 0), s = Array(i), o = 0; o < i; o++, t += n)
    s[o] = t
  return s
}
function Sw(t, e) {
  if (e == null || e < 1) return []
  for (var n = [], i = 0, s = t.length; i < s; ) n.push(Xu.call(t, i, (i += e)))
  return n
}
function vm(t, e) {
  return t._chain ? Ue(e).chain() : e
}
function mm(t) {
  return (
    Or(Ru(t), function (e) {
      var n = (Ue[e] = t[e])
      Ue.prototype[e] = function () {
        var i = [this._wrapped]
        return (WT.apply(i, arguments), vm(this, n.apply(Ue, i)))
      }
    }),
    Ue
  )
}
Or(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (t) {
  var e = yh[t]
  Ue.prototype[t] = function () {
    var n = this._wrapped
    return (
      n != null &&
        (e.apply(n, arguments), (t === 'shift' || t === 'splice') && n.length === 0 && delete n[0]),
      vm(this, n)
    )
  }
})
Or(['concat', 'join', 'slice'], function (t) {
  var e = yh[t]
  Ue.prototype[t] = function () {
    var n = this._wrapped
    return (n != null && (n = e.apply(n, arguments)), vm(this, n))
  }
})
const yM = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      VERSION: Rv,
      after: Q1,
      all: Kf,
      allKeys: ml,
      any: $f,
      assign: hl,
      before: am,
      bind: im,
      bindAll: H1,
      chain: U1,
      chunk: Sw,
      clone: T1,
      collect: Aa,
      compact: mw,
      compose: q1,
      constant: Yv,
      contains: sr,
      countBy: hw,
      create: N1,
      debounce: F1,
      default: Ue,
      defaults: Kv,
      defer: X1,
      delay: rm,
      detect: ku,
      difference: pm,
      drop: $s,
      each: Or,
      escape: _1,
      every: Kf,
      extend: Qv,
      extendOwn: hl,
      filter: us,
      find: ku,
      findIndex: Sh,
      findKey: sm,
      findLastIndex: om,
      findWhere: nw,
      first: ol,
      flatten: yw,
      foldl: sl,
      foldr: Qf,
      forEach: Or,
      functions: Ru,
      get: em,
      groupBy: cw,
      has: E1,
      head: ol,
      identity: Ih,
      include: sr,
      includes: sr,
      indexBy: fw,
      indexOf: um,
      initial: gm,
      inject: sl,
      intersection: Iw,
      invert: Jv,
      invoke: aw,
      isArguments: bh,
      isArray: hs,
      isArrayBuffer: Gv,
      isBoolean: Bv,
      isDataView: zu,
      isDate: r1,
      isElement: i1,
      isEmpty: g1,
      isEqual: v1,
      isError: s1,
      isFinite: c1,
      isFunction: ei,
      isMap: b1,
      isMatch: Vv,
      isNaN: Uv,
      isNull: n1,
      isNumber: jv,
      isObject: fs,
      isRegExp: a1,
      isSet: C1,
      isString: Ah,
      isSymbol: Pv,
      isTypedArray: Hv,
      isUndefined: _v,
      isWeakMap: I1,
      isWeakSet: w1,
      iteratee: wh,
      keys: On,
      last: vw,
      lastIndexOf: ew,
      map: Aa,
      mapObject: O1,
      matcher: eo,
      matches: eo,
      max: cm,
      memoize: V1,
      methods: Ru,
      min: ow,
      mixin: mm,
      negate: xh,
      noop: nm,
      now: dl,
      object: ww,
      omit: pw,
      once: K1,
      pairs: x1,
      partial: ro,
      partition: dw,
      pick: dm,
      pluck: Nh,
      property: Ch,
      propertyOf: L1,
      random: qf,
      range: xw,
      reduce: sl,
      reduceRight: Qf,
      reject: rw,
      rest: $s,
      restArguments: ci,
      result: G1,
      sample: hm,
      select: us,
      shuffle: lw,
      size: gw,
      some: $f,
      sortBy: uw,
      sortedIndex: lm,
      tail: $s,
      take: ol,
      tap: M1,
      template: P1,
      templateSettings: j1,
      throttle: W1,
      times: z1,
      toArray: fm,
      toPath: $v,
      transpose: Bu,
      unescape: B1,
      union: bw,
      uniq: _u,
      unique: _u,
      uniqueId: Z1,
      unzip: Bu,
      values: io,
      where: sw,
      without: Aw,
      wrap: J1,
      zip: Cw,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
var hv = mm(yM)
hv._ = hv
const AM = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        VERSION: Rv,
        after: Q1,
        all: Kf,
        allKeys: ml,
        any: $f,
        assign: hl,
        before: am,
        bind: im,
        bindAll: H1,
        chain: U1,
        chunk: Sw,
        clone: T1,
        collect: Aa,
        compact: mw,
        compose: q1,
        constant: Yv,
        contains: sr,
        countBy: hw,
        create: N1,
        debounce: F1,
        default: hv,
        defaults: Kv,
        defer: X1,
        delay: rm,
        detect: ku,
        difference: pm,
        drop: $s,
        each: Or,
        escape: _1,
        every: Kf,
        extend: Qv,
        extendOwn: hl,
        filter: us,
        find: ku,
        findIndex: Sh,
        findKey: sm,
        findLastIndex: om,
        findWhere: nw,
        first: ol,
        flatten: yw,
        foldl: sl,
        foldr: Qf,
        forEach: Or,
        functions: Ru,
        get: em,
        groupBy: cw,
        has: E1,
        head: ol,
        identity: Ih,
        include: sr,
        includes: sr,
        indexBy: fw,
        indexOf: um,
        initial: gm,
        inject: sl,
        intersection: Iw,
        invert: Jv,
        invoke: aw,
        isArguments: bh,
        isArray: hs,
        isArrayBuffer: Gv,
        isBoolean: Bv,
        isDataView: zu,
        isDate: r1,
        isElement: i1,
        isEmpty: g1,
        isEqual: v1,
        isError: s1,
        isFinite: c1,
        isFunction: ei,
        isMap: b1,
        isMatch: Vv,
        isNaN: Uv,
        isNull: n1,
        isNumber: jv,
        isObject: fs,
        isRegExp: a1,
        isSet: C1,
        isString: Ah,
        isSymbol: Pv,
        isTypedArray: Hv,
        isUndefined: _v,
        isWeakMap: I1,
        isWeakSet: w1,
        iteratee: wh,
        keys: On,
        last: vw,
        lastIndexOf: ew,
        map: Aa,
        mapObject: O1,
        matcher: eo,
        matches: eo,
        max: cm,
        memoize: V1,
        methods: Ru,
        min: ow,
        mixin: mm,
        negate: xh,
        noop: nm,
        now: dl,
        object: ww,
        omit: pw,
        once: K1,
        pairs: x1,
        partial: ro,
        partition: dw,
        pick: dm,
        pluck: Nh,
        property: Ch,
        propertyOf: L1,
        random: qf,
        range: xw,
        reduce: sl,
        reduceRight: Qf,
        reject: rw,
        rest: $s,
        restArguments: ci,
        result: G1,
        sample: hm,
        select: us,
        shuffle: lw,
        size: gw,
        some: $f,
        sortBy: uw,
        sortedIndex: lm,
        tail: $s,
        take: ol,
        tap: M1,
        template: P1,
        templateSettings: j1,
        throttle: W1,
        times: z1,
        toArray: fm,
        toPath: $v,
        transpose: Bu,
        unescape: B1,
        union: bw,
        uniq: _u,
        unique: _u,
        uniqueId: Z1,
        unzip: Bu,
        values: io,
        where: sw,
        without: Aw,
        wrap: J1,
        zip: Cw,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  bM = oT(AM)
var Yf = { exports: {} }
/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */ var IM = Yf.exports,
  Nb
function Nw() {
  return (
    Nb ||
      ((Nb = 1),
      (function (t) {
        ;(function (e, n) {
          t.exports = e.document
            ? n(e, !0)
            : function (i) {
                if (!i.document) throw new Error('jQuery requires a window with a document')
                return n(i)
              }
        })(typeof window < 'u' ? window : IM, function (e, n) {
          var i = [],
            s = Object.getPrototypeOf,
            o = i.slice,
            u = i.flat
              ? function (d) {
                  return i.flat.call(d)
                }
              : function (d) {
                  return i.concat.apply([], d)
                },
            c = i.push,
            h = i.indexOf,
            p = {},
            y = p.toString,
            v = p.hasOwnProperty,
            C = v.toString,
            w = C.call(Object),
            N = {},
            T = function (A) {
              return (
                typeof A == 'function' &&
                typeof A.nodeType != 'number' &&
                typeof A.item != 'function'
              )
            },
            z = function (A) {
              return A != null && A === A.window
            },
            R = e.document,
            B = { type: !0, src: !0, nonce: !0, noModule: !0 }
          function H(d, A, I) {
            I = I || R
            var x,
              D,
              L = I.createElement('script')
            if (((L.text = d), A))
              for (x in B)
                ((D = A[x] || (A.getAttribute && A.getAttribute(x))), D && L.setAttribute(x, D))
            I.head.appendChild(L).parentNode.removeChild(L)
          }
          function Z(d) {
            return d == null
              ? d + ''
              : typeof d == 'object' || typeof d == 'function'
                ? p[y.call(d)] || 'object'
                : typeof d
          }
          var U = '3.7.1',
            nt = /HTML$/i,
            g = function (d, A) {
              return new g.fn.init(d, A)
            }
          ;((g.fn = g.prototype =
            {
              jquery: U,
              constructor: g,
              length: 0,
              toArray: function () {
                return o.call(this)
              },
              get: function (d) {
                return d == null ? o.call(this) : d < 0 ? this[d + this.length] : this[d]
              },
              pushStack: function (d) {
                var A = g.merge(this.constructor(), d)
                return ((A.prevObject = this), A)
              },
              each: function (d) {
                return g.each(this, d)
              },
              map: function (d) {
                return this.pushStack(
                  g.map(this, function (A, I) {
                    return d.call(A, I, A)
                  })
                )
              },
              slice: function () {
                return this.pushStack(o.apply(this, arguments))
              },
              first: function () {
                return this.eq(0)
              },
              last: function () {
                return this.eq(-1)
              },
              even: function () {
                return this.pushStack(
                  g.grep(this, function (d, A) {
                    return (A + 1) % 2
                  })
                )
              },
              odd: function () {
                return this.pushStack(
                  g.grep(this, function (d, A) {
                    return A % 2
                  })
                )
              },
              eq: function (d) {
                var A = this.length,
                  I = +d + (d < 0 ? A : 0)
                return this.pushStack(I >= 0 && I < A ? [this[I]] : [])
              },
              end: function () {
                return this.prevObject || this.constructor()
              },
              push: c,
              sort: i.sort,
              splice: i.splice,
            }),
            (g.extend = g.fn.extend =
              function () {
                var d,
                  A,
                  I,
                  x,
                  D,
                  L,
                  k = arguments[0] || {},
                  tt = 1,
                  q = arguments.length,
                  ot = !1
                for (
                  typeof k == 'boolean' && ((ot = k), (k = arguments[tt] || {}), tt++),
                    typeof k != 'object' && !T(k) && (k = {}),
                    tt === q && ((k = this), tt--);
                  tt < q;
                  tt++
                )
                  if ((d = arguments[tt]) != null)
                    for (A in d)
                      ((x = d[A]),
                        !(A === '__proto__' || k === x) &&
                          (ot && x && (g.isPlainObject(x) || (D = Array.isArray(x)))
                            ? ((I = k[A]),
                              D && !Array.isArray(I)
                                ? (L = [])
                                : !D && !g.isPlainObject(I)
                                  ? (L = {})
                                  : (L = I),
                              (D = !1),
                              (k[A] = g.extend(ot, L, x)))
                            : x !== void 0 && (k[A] = x)))
                return k
              }),
            g.extend({
              expando: 'jQuery' + (U + Math.random()).replace(/\D/g, ''),
              isReady: !0,
              error: function (d) {
                throw new Error(d)
              },
              noop: function () {},
              isPlainObject: function (d) {
                var A, I
                return !d || y.call(d) !== '[object Object]'
                  ? !1
                  : ((A = s(d)),
                    A
                      ? ((I = v.call(A, 'constructor') && A.constructor),
                        typeof I == 'function' && C.call(I) === w)
                      : !0)
              },
              isEmptyObject: function (d) {
                var A
                for (A in d) return !1
                return !0
              },
              globalEval: function (d, A, I) {
                H(d, { nonce: A && A.nonce }, I)
              },
              each: function (d, A) {
                var I,
                  x = 0
                if (S(d)) for (I = d.length; x < I && A.call(d[x], x, d[x]) !== !1; x++);
                else for (x in d) if (A.call(d[x], x, d[x]) === !1) break
                return d
              },
              text: function (d) {
                var A,
                  I = '',
                  x = 0,
                  D = d.nodeType
                if (!D) for (; (A = d[x++]); ) I += g.text(A)
                return D === 1 || D === 11
                  ? d.textContent
                  : D === 9
                    ? d.documentElement.textContent
                    : D === 3 || D === 4
                      ? d.nodeValue
                      : I
              },
              makeArray: function (d, A) {
                var I = A || []
                return (
                  d != null &&
                    (S(Object(d)) ? g.merge(I, typeof d == 'string' ? [d] : d) : c.call(I, d)),
                  I
                )
              },
              inArray: function (d, A, I) {
                return A == null ? -1 : h.call(A, d, I)
              },
              isXMLDoc: function (d) {
                var A = d && d.namespaceURI,
                  I = d && (d.ownerDocument || d).documentElement
                return !nt.test(A || (I && I.nodeName) || 'HTML')
              },
              merge: function (d, A) {
                for (var I = +A.length, x = 0, D = d.length; x < I; x++) d[D++] = A[x]
                return ((d.length = D), d)
              },
              grep: function (d, A, I) {
                for (var x, D = [], L = 0, k = d.length, tt = !I; L < k; L++)
                  ((x = !A(d[L], L)), x !== tt && D.push(d[L]))
                return D
              },
              map: function (d, A, I) {
                var x,
                  D,
                  L = 0,
                  k = []
                if (S(d))
                  for (x = d.length; L < x; L++) ((D = A(d[L], L, I)), D != null && k.push(D))
                else for (L in d) ((D = A(d[L], L, I)), D != null && k.push(D))
                return u(k)
              },
              guid: 1,
              support: N,
            }),
            typeof Symbol == 'function' && (g.fn[Symbol.iterator] = i[Symbol.iterator]),
            g.each(
              'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '),
              function (d, A) {
                p['[object ' + A + ']'] = A.toLowerCase()
              }
            ))
          function S(d) {
            var A = !!d && 'length' in d && d.length,
              I = Z(d)
            return T(d) || z(d)
              ? !1
              : I === 'array' || A === 0 || (typeof A == 'number' && A > 0 && A - 1 in d)
          }
          function M(d, A) {
            return d.nodeName && d.nodeName.toLowerCase() === A.toLowerCase()
          }
          var _ = i.pop,
            W = i.sort,
            $ = i.splice,
            X = '[\\x20\\t\\r\\n\\f]',
            Ct = new RegExp('^' + X + '+|((?:^|[^\\\\])(?:\\\\.)*)' + X + '+$', 'g')
          g.contains = function (d, A) {
            var I = A && A.parentNode
            return (
              d === I ||
              !!(
                I &&
                I.nodeType === 1 &&
                (d.contains
                  ? d.contains(I)
                  : d.compareDocumentPosition && d.compareDocumentPosition(I) & 16)
              )
            )
          }
          var Tt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g
          function G(d, A) {
            return A
              ? d === '\0'
                ? '�'
                : d.slice(0, -1) + '\\' + d.charCodeAt(d.length - 1).toString(16) + ' '
              : '\\' + d
          }
          g.escapeSelector = function (d) {
            return (d + '').replace(Tt, G)
          }
          var Q = R,
            it = c
          ;(function () {
            var d,
              A,
              I,
              x,
              D,
              L = it,
              k,
              tt,
              q,
              ot,
              xt,
              Dt = g.expando,
              vt = 0,
              _t = 0,
              oe = jr(),
              Te = jr(),
              ge = jr(),
              Sn = jr(),
              vn = function (V, rt) {
                return (V === rt && (D = !0), 0)
              },
              Wi =
                'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',
              Fi = '(?:\\\\[\\da-fA-F]{1,6}' + X + '?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+',
              Ce =
                '\\[' +
                X +
                '*(' +
                Fi +
                ')(?:' +
                X +
                '*([*^$|!~]?=)' +
                X +
                `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` +
                Fi +
                '))|)' +
                X +
                '*\\]',
              $r =
                ':(' +
                Fi +
                `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` +
                Ce +
                ')*)|.*)\\)|)',
              Oe = new RegExp(X + '+', 'g'),
              nn = new RegExp('^' + X + '*,' + X + '*'),
              ta = new RegExp('^' + X + '*([>+~]|' + X + ')' + X + '*'),
              ea = new RegExp(X + '|>'),
              Ji = new RegExp($r),
              _a = new RegExp('^' + Fi + '$'),
              Ti = {
                ID: new RegExp('^#(' + Fi + ')'),
                CLASS: new RegExp('^\\.(' + Fi + ')'),
                TAG: new RegExp('^(' + Fi + '|[*])'),
                ATTR: new RegExp('^' + Ce),
                PSEUDO: new RegExp('^' + $r),
                CHILD: new RegExp(
                  '^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' +
                    X +
                    '*(even|odd|(([+-]|)(\\d*)n|)' +
                    X +
                    '*(?:([+-]|)' +
                    X +
                    '*(\\d+)|))' +
                    X +
                    '*\\)|)',
                  'i'
                ),
                bool: new RegExp('^(?:' + Wi + ')$', 'i'),
                needsContext: new RegExp(
                  '^' +
                    X +
                    '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' +
                    X +
                    '*((?:-\\d)?\\d*)' +
                    X +
                    '*\\)|)(?=[^-]|$)',
                  'i'
                ),
              },
              mr = /^(?:input|select|textarea|button)$/i,
              yr = /^h\d$/i,
              ii = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
              Br = /[+~]/,
              Ar = new RegExp('\\\\[\\da-fA-F]{1,6}' + X + '?|\\\\([^\\r\\n\\f])', 'g'),
              br = function (V, rt) {
                var dt = '0x' + V.slice(1) - 65536
                return (
                  rt ||
                  (dt < 0
                    ? String.fromCharCode(dt + 65536)
                    : String.fromCharCode((dt >> 10) | 55296, (dt & 1023) | 56320))
                )
              },
              Qh = function () {
                wr()
              },
              mc = wo(
                function (V) {
                  return V.disabled === !0 && M(V, 'fieldset')
                },
                { dir: 'parentNode', next: 'legend' }
              )
            function yc() {
              try {
                return k.activeElement
              } catch {}
            }
            try {
              ;(L.apply((i = o.call(Q.childNodes)), Q.childNodes), i[Q.childNodes.length].nodeType)
            } catch {
              L = {
                apply: function (rt, dt) {
                  it.apply(rt, o.call(dt))
                },
                call: function (rt) {
                  it.apply(rt, o.call(arguments, 1))
                },
              }
            }
            function Le(V, rt, dt, wt) {
              var Mt,
                jt,
                Ht,
                Vt,
                Zt,
                pe,
                ne,
                ee = rt && rt.ownerDocument,
                ye = rt ? rt.nodeType : 9
              if (
                ((dt = dt || []), typeof V != 'string' || !V || (ye !== 1 && ye !== 9 && ye !== 11))
              )
                return dt
              if (!wt && (wr(rt), (rt = rt || k), q)) {
                if (ye !== 11 && (Zt = ii.exec(V)))
                  if ((Mt = Zt[1])) {
                    if (ye === 9)
                      if ((Ht = rt.getElementById(Mt))) {
                        if (Ht.id === Mt) return (L.call(dt, Ht), dt)
                      } else return dt
                    else if (
                      ee &&
                      (Ht = ee.getElementById(Mt)) &&
                      Le.contains(rt, Ht) &&
                      Ht.id === Mt
                    )
                      return (L.call(dt, Ht), dt)
                  } else {
                    if (Zt[2]) return (L.apply(dt, rt.getElementsByTagName(V)), dt)
                    if ((Mt = Zt[3]) && rt.getElementsByClassName)
                      return (L.apply(dt, rt.getElementsByClassName(Mt)), dt)
                  }
                if (!Sn[V + ' '] && (!ot || !ot.test(V))) {
                  if (((ne = V), (ee = rt), ye === 1 && (ea.test(V) || ta.test(V)))) {
                    for (
                      ee = (Br.test(V) && Io(rt.parentNode)) || rt,
                        (ee != rt || !N.scope) &&
                          ((Vt = rt.getAttribute('id'))
                            ? (Vt = g.escapeSelector(Vt))
                            : rt.setAttribute('id', (Vt = Dt))),
                        pe = zs(V),
                        jt = pe.length;
                      jt--;

                    )
                      pe[jt] = (Vt ? '#' + Vt : ':scope') + ' ' + Co(pe[jt])
                    ne = pe.join(',')
                  }
                  try {
                    return (L.apply(dt, ee.querySelectorAll(ne)), dt)
                  } catch {
                    Sn(V, !0)
                  } finally {
                    Vt === Dt && rt.removeAttribute('id')
                  }
                }
              }
              return _l(V.replace(Ct, '$1'), rt, dt, wt)
            }
            function jr() {
              var V = []
              function rt(dt, wt) {
                return (
                  V.push(dt + ' ') > A.cacheLength && delete rt[V.shift()],
                  (rt[dt + ' '] = wt)
                )
              }
              return rt
            }
            function Mi(V) {
              return ((V[Dt] = !0), V)
            }
            function Ir(V) {
              var rt = k.createElement('fieldset')
              try {
                return !!V(rt)
              } catch {
                return !1
              } finally {
                ;(rt.parentNode && rt.parentNode.removeChild(rt), (rt = null))
              }
            }
            function Ac(V) {
              return function (rt) {
                return M(rt, 'input') && rt.type === V
              }
            }
            function bc(V) {
              return function (rt) {
                return (M(rt, 'input') || M(rt, 'button')) && rt.type === V
              }
            }
            function bo(V) {
              return function (rt) {
                return 'form' in rt
                  ? rt.parentNode && rt.disabled === !1
                    ? 'label' in rt
                      ? 'label' in rt.parentNode
                        ? rt.parentNode.disabled === V
                        : rt.disabled === V
                      : rt.isDisabled === V || (rt.isDisabled !== !V && mc(rt) === V)
                    : rt.disabled === V
                  : 'label' in rt
                    ? rt.disabled === V
                    : !1
              }
            }
            function Cr(V) {
              return Mi(function (rt) {
                return (
                  (rt = +rt),
                  Mi(function (dt, wt) {
                    for (var Mt, jt = V([], dt.length, rt), Ht = jt.length; Ht--; )
                      dt[(Mt = jt[Ht])] && (dt[Mt] = !(wt[Mt] = dt[Mt]))
                  })
                )
              })
            }
            function Io(V) {
              return V && typeof V.getElementsByTagName < 'u' && V
            }
            function wr(V) {
              var rt,
                dt = V ? V.ownerDocument || V : Q
              return (
                dt == k ||
                  dt.nodeType !== 9 ||
                  !dt.documentElement ||
                  ((k = dt),
                  (tt = k.documentElement),
                  (q = !g.isXMLDoc(k)),
                  (xt = tt.matches || tt.webkitMatchesSelector || tt.msMatchesSelector),
                  tt.msMatchesSelector &&
                    Q != k &&
                    (rt = k.defaultView) &&
                    rt.top !== rt &&
                    rt.addEventListener('unload', Qh),
                  (N.getById = Ir(function (wt) {
                    return (
                      (tt.appendChild(wt).id = g.expando),
                      !k.getElementsByName || !k.getElementsByName(g.expando).length
                    )
                  })),
                  (N.disconnectedMatch = Ir(function (wt) {
                    return xt.call(wt, '*')
                  })),
                  (N.scope = Ir(function () {
                    return k.querySelectorAll(':scope')
                  })),
                  (N.cssHas = Ir(function () {
                    try {
                      return (k.querySelector(':has(*,:jqfake)'), !1)
                    } catch {
                      return !0
                    }
                  })),
                  N.getById
                    ? ((A.filter.ID = function (wt) {
                        var Mt = wt.replace(Ar, br)
                        return function (jt) {
                          return jt.getAttribute('id') === Mt
                        }
                      }),
                      (A.find.ID = function (wt, Mt) {
                        if (typeof Mt.getElementById < 'u' && q) {
                          var jt = Mt.getElementById(wt)
                          return jt ? [jt] : []
                        }
                      }))
                    : ((A.filter.ID = function (wt) {
                        var Mt = wt.replace(Ar, br)
                        return function (jt) {
                          var Ht = typeof jt.getAttributeNode < 'u' && jt.getAttributeNode('id')
                          return Ht && Ht.value === Mt
                        }
                      }),
                      (A.find.ID = function (wt, Mt) {
                        if (typeof Mt.getElementById < 'u' && q) {
                          var jt,
                            Ht,
                            Vt,
                            Zt = Mt.getElementById(wt)
                          if (Zt) {
                            if (((jt = Zt.getAttributeNode('id')), jt && jt.value === wt))
                              return [Zt]
                            for (Vt = Mt.getElementsByName(wt), Ht = 0; (Zt = Vt[Ht++]); )
                              if (((jt = Zt.getAttributeNode('id')), jt && jt.value === wt))
                                return [Zt]
                          }
                          return []
                        }
                      })),
                  (A.find.TAG = function (wt, Mt) {
                    return typeof Mt.getElementsByTagName < 'u'
                      ? Mt.getElementsByTagName(wt)
                      : Mt.querySelectorAll(wt)
                  }),
                  (A.find.CLASS = function (wt, Mt) {
                    if (typeof Mt.getElementsByClassName < 'u' && q)
                      return Mt.getElementsByClassName(wt)
                  }),
                  (ot = []),
                  Ir(function (wt) {
                    var Mt
                    ;((tt.appendChild(wt).innerHTML =
                      "<a id='" +
                      Dt +
                      "' href='' disabled='disabled'></a><select id='" +
                      Dt +
                      "-\r\\' disabled='disabled'><option selected=''></option></select>"),
                      wt.querySelectorAll('[selected]').length ||
                        ot.push('\\[' + X + '*(?:value|' + Wi + ')'),
                      wt.querySelectorAll('[id~=' + Dt + '-]').length || ot.push('~='),
                      wt.querySelectorAll('a#' + Dt + '+*').length || ot.push('.#.+[+~]'),
                      wt.querySelectorAll(':checked').length || ot.push(':checked'),
                      (Mt = k.createElement('input')),
                      Mt.setAttribute('type', 'hidden'),
                      wt.appendChild(Mt).setAttribute('name', 'D'),
                      (tt.appendChild(wt).disabled = !0),
                      wt.querySelectorAll(':disabled').length !== 2 &&
                        ot.push(':enabled', ':disabled'),
                      (Mt = k.createElement('input')),
                      Mt.setAttribute('name', ''),
                      wt.appendChild(Mt),
                      wt.querySelectorAll("[name='']").length ||
                        ot.push('\\[' + X + '*name' + X + '*=' + X + `*(?:''|"")`))
                  }),
                  N.cssHas || ot.push(':has'),
                  (ot = ot.length && new RegExp(ot.join('|'))),
                  (vn = function (wt, Mt) {
                    if (wt === Mt) return ((D = !0), 0)
                    var jt = !wt.compareDocumentPosition - !Mt.compareDocumentPosition
                    return (
                      jt ||
                      ((jt =
                        (wt.ownerDocument || wt) == (Mt.ownerDocument || Mt)
                          ? wt.compareDocumentPosition(Mt)
                          : 1),
                      jt & 1 || (!N.sortDetached && Mt.compareDocumentPosition(wt) === jt)
                        ? wt === k || (wt.ownerDocument == Q && Le.contains(Q, wt))
                          ? -1
                          : Mt === k || (Mt.ownerDocument == Q && Le.contains(Q, Mt))
                            ? 1
                            : x
                              ? h.call(x, wt) - h.call(x, Mt)
                              : 0
                        : jt & 4
                          ? -1
                          : 1)
                    )
                  })),
                k
              )
            }
            ;((Le.matches = function (V, rt) {
              return Le(V, null, null, rt)
            }),
              (Le.matchesSelector = function (V, rt) {
                if ((wr(V), q && !Sn[rt + ' '] && (!ot || !ot.test(rt))))
                  try {
                    var dt = xt.call(V, rt)
                    if (dt || N.disconnectedMatch || (V.document && V.document.nodeType !== 11))
                      return dt
                  } catch {
                    Sn(rt, !0)
                  }
                return Le(rt, k, null, [V]).length > 0
              }),
              (Le.contains = function (V, rt) {
                return ((V.ownerDocument || V) != k && wr(V), g.contains(V, rt))
              }),
              (Le.attr = function (V, rt) {
                ;(V.ownerDocument || V) != k && wr(V)
                var dt = A.attrHandle[rt.toLowerCase()],
                  wt = dt && v.call(A.attrHandle, rt.toLowerCase()) ? dt(V, rt, !q) : void 0
                return wt !== void 0 ? wt : V.getAttribute(rt)
              }),
              (Le.error = function (V) {
                throw new Error('Syntax error, unrecognized expression: ' + V)
              }),
              (g.uniqueSort = function (V) {
                var rt,
                  dt = [],
                  wt = 0,
                  Mt = 0
                if (((D = !N.sortStable), (x = !N.sortStable && o.call(V, 0)), W.call(V, vn), D)) {
                  for (; (rt = V[Mt++]); ) rt === V[Mt] && (wt = dt.push(Mt))
                  for (; wt--; ) $.call(V, dt[wt], 1)
                }
                return ((x = null), V)
              }),
              (g.fn.uniqueSort = function () {
                return this.pushStack(g.uniqueSort(o.apply(this)))
              }),
              (A = g.expr =
                {
                  cacheLength: 50,
                  createPseudo: Mi,
                  match: Ti,
                  attrHandle: {},
                  find: {},
                  relative: {
                    '>': { dir: 'parentNode', first: !0 },
                    ' ': { dir: 'parentNode' },
                    '+': { dir: 'previousSibling', first: !0 },
                    '~': { dir: 'previousSibling' },
                  },
                  preFilter: {
                    ATTR: function (V) {
                      return (
                        (V[1] = V[1].replace(Ar, br)),
                        (V[3] = (V[3] || V[4] || V[5] || '').replace(Ar, br)),
                        V[2] === '~=' && (V[3] = ' ' + V[3] + ' '),
                        V.slice(0, 4)
                      )
                    },
                    CHILD: function (V) {
                      return (
                        (V[1] = V[1].toLowerCase()),
                        V[1].slice(0, 3) === 'nth'
                          ? (V[3] || Le.error(V[0]),
                            (V[4] = +(V[4]
                              ? V[5] + (V[6] || 1)
                              : 2 * (V[3] === 'even' || V[3] === 'odd'))),
                            (V[5] = +(V[7] + V[8] || V[3] === 'odd')))
                          : V[3] && Le.error(V[0]),
                        V
                      )
                    },
                    PSEUDO: function (V) {
                      var rt,
                        dt = !V[6] && V[2]
                      return Ti.CHILD.test(V[0])
                        ? null
                        : (V[3]
                            ? (V[2] = V[4] || V[5] || '')
                            : dt &&
                              Ji.test(dt) &&
                              (rt = zs(dt, !0)) &&
                              (rt = dt.indexOf(')', dt.length - rt) - dt.length) &&
                              ((V[0] = V[0].slice(0, rt)), (V[2] = dt.slice(0, rt))),
                          V.slice(0, 3))
                    },
                  },
                  filter: {
                    TAG: function (V) {
                      var rt = V.replace(Ar, br).toLowerCase()
                      return V === '*'
                        ? function () {
                            return !0
                          }
                        : function (dt) {
                            return M(dt, rt)
                          }
                    },
                    CLASS: function (V) {
                      var rt = oe[V + ' ']
                      return (
                        rt ||
                        ((rt = new RegExp('(^|' + X + ')' + V + '(' + X + '|$)')) &&
                          oe(V, function (dt) {
                            return rt.test(
                              (typeof dt.className == 'string' && dt.className) ||
                                (typeof dt.getAttribute < 'u' && dt.getAttribute('class')) ||
                                ''
                            )
                          }))
                      )
                    },
                    ATTR: function (V, rt, dt) {
                      return function (wt) {
                        var Mt = Le.attr(wt, V)
                        return Mt == null
                          ? rt === '!='
                          : rt
                            ? ((Mt += ''),
                              rt === '='
                                ? Mt === dt
                                : rt === '!='
                                  ? Mt !== dt
                                  : rt === '^='
                                    ? dt && Mt.indexOf(dt) === 0
                                    : rt === '*='
                                      ? dt && Mt.indexOf(dt) > -1
                                      : rt === '$='
                                        ? dt && Mt.slice(-dt.length) === dt
                                        : rt === '~='
                                          ? (' ' + Mt.replace(Oe, ' ') + ' ').indexOf(dt) > -1
                                          : rt === '|='
                                            ? Mt === dt || Mt.slice(0, dt.length + 1) === dt + '-'
                                            : !1)
                            : !0
                      }
                    },
                    CHILD: function (V, rt, dt, wt, Mt) {
                      var jt = V.slice(0, 3) !== 'nth',
                        Ht = V.slice(-4) !== 'last',
                        Vt = rt === 'of-type'
                      return wt === 1 && Mt === 0
                        ? function (Zt) {
                            return !!Zt.parentNode
                          }
                        : function (Zt, pe, ne) {
                            var ee,
                              ye,
                              te,
                              He,
                              qn,
                              Bn = jt !== Ht ? 'nextSibling' : 'previousSibling',
                              di = Zt.parentNode,
                              Ei = Vt && Zt.nodeName.toLowerCase(),
                              ia = !ne && !Vt,
                              Nn = !1
                            if (di) {
                              if (jt) {
                                for (; Bn; ) {
                                  for (te = Zt; (te = te[Bn]); )
                                    if (Vt ? M(te, Ei) : te.nodeType === 1) return !1
                                  qn = Bn = V === 'only' && !qn && 'nextSibling'
                                }
                                return !0
                              }
                              if (((qn = [Ht ? di.firstChild : di.lastChild]), Ht && ia)) {
                                for (
                                  ye = di[Dt] || (di[Dt] = {}),
                                    ee = ye[V] || [],
                                    He = ee[0] === vt && ee[1],
                                    Nn = He && ee[2],
                                    te = He && di.childNodes[He];
                                  (te = (++He && te && te[Bn]) || (Nn = He = 0) || qn.pop());

                                )
                                  if (te.nodeType === 1 && ++Nn && te === Zt) {
                                    ye[V] = [vt, He, Nn]
                                    break
                                  }
                              } else if (
                                (ia &&
                                  ((ye = Zt[Dt] || (Zt[Dt] = {})),
                                  (ee = ye[V] || []),
                                  (He = ee[0] === vt && ee[1]),
                                  (Nn = He)),
                                Nn === !1)
                              )
                                for (
                                  ;
                                  (te = (++He && te && te[Bn]) || (Nn = He = 0) || qn.pop()) &&
                                  !(
                                    (Vt ? M(te, Ei) : te.nodeType === 1) &&
                                    ++Nn &&
                                    (ia && ((ye = te[Dt] || (te[Dt] = {})), (ye[V] = [vt, Nn])),
                                    te === Zt)
                                  );

                                );
                              return ((Nn -= Mt), Nn === wt || (Nn % wt === 0 && Nn / wt >= 0))
                            }
                          }
                    },
                    PSEUDO: function (V, rt) {
                      var dt,
                        wt =
                          A.pseudos[V] ||
                          A.setFilters[V.toLowerCase()] ||
                          Le.error('unsupported pseudo: ' + V)
                      return wt[Dt]
                        ? wt(rt)
                        : wt.length > 1
                          ? ((dt = [V, V, '', rt]),
                            A.setFilters.hasOwnProperty(V.toLowerCase())
                              ? Mi(function (Mt, jt) {
                                  for (var Ht, Vt = wt(Mt, rt), Zt = Vt.length; Zt--; )
                                    ((Ht = h.call(Mt, Vt[Zt])), (Mt[Ht] = !(jt[Ht] = Vt[Zt])))
                                })
                              : function (Mt) {
                                  return wt(Mt, 0, dt)
                                })
                          : wt
                    },
                  },
                  pseudos: {
                    not: Mi(function (V) {
                      var rt = [],
                        dt = [],
                        wt = So(V.replace(Ct, '$1'))
                      return wt[Dt]
                        ? Mi(function (Mt, jt, Ht, Vt) {
                            for (var Zt, pe = wt(Mt, null, Vt, []), ne = Mt.length; ne--; )
                              (Zt = pe[ne]) && (Mt[ne] = !(jt[ne] = Zt))
                          })
                        : function (Mt, jt, Ht) {
                            return ((rt[0] = Mt), wt(rt, null, Ht, dt), (rt[0] = null), !dt.pop())
                          }
                    }),
                    has: Mi(function (V) {
                      return function (rt) {
                        return Le(V, rt).length > 0
                      }
                    }),
                    contains: Mi(function (V) {
                      return (
                        (V = V.replace(Ar, br)),
                        function (rt) {
                          return (rt.textContent || g.text(rt)).indexOf(V) > -1
                        }
                      )
                    }),
                    lang: Mi(function (V) {
                      return (
                        _a.test(V || '') || Le.error('unsupported lang: ' + V),
                        (V = V.replace(Ar, br).toLowerCase()),
                        function (rt) {
                          var dt
                          do
                            if (
                              (dt = q
                                ? rt.lang
                                : rt.getAttribute('xml:lang') || rt.getAttribute('lang'))
                            )
                              return (
                                (dt = dt.toLowerCase()),
                                dt === V || dt.indexOf(V + '-') === 0
                              )
                          while ((rt = rt.parentNode) && rt.nodeType === 1)
                          return !1
                        }
                      )
                    }),
                    target: function (V) {
                      var rt = e.location && e.location.hash
                      return rt && rt.slice(1) === V.id
                    },
                    root: function (V) {
                      return V === tt
                    },
                    focus: function (V) {
                      return V === yc() && k.hasFocus() && !!(V.type || V.href || ~V.tabIndex)
                    },
                    enabled: bo(!1),
                    disabled: bo(!0),
                    checked: function (V) {
                      return (M(V, 'input') && !!V.checked) || (M(V, 'option') && !!V.selected)
                    },
                    selected: function (V) {
                      return (V.parentNode && V.parentNode.selectedIndex, V.selected === !0)
                    },
                    empty: function (V) {
                      for (V = V.firstChild; V; V = V.nextSibling) if (V.nodeType < 6) return !1
                      return !0
                    },
                    parent: function (V) {
                      return !A.pseudos.empty(V)
                    },
                    header: function (V) {
                      return yr.test(V.nodeName)
                    },
                    input: function (V) {
                      return mr.test(V.nodeName)
                    },
                    button: function (V) {
                      return (M(V, 'input') && V.type === 'button') || M(V, 'button')
                    },
                    text: function (V) {
                      var rt
                      return (
                        M(V, 'input') &&
                        V.type === 'text' &&
                        ((rt = V.getAttribute('type')) == null || rt.toLowerCase() === 'text')
                      )
                    },
                    first: Cr(function () {
                      return [0]
                    }),
                    last: Cr(function (V, rt) {
                      return [rt - 1]
                    }),
                    eq: Cr(function (V, rt, dt) {
                      return [dt < 0 ? dt + rt : dt]
                    }),
                    even: Cr(function (V, rt) {
                      for (var dt = 0; dt < rt; dt += 2) V.push(dt)
                      return V
                    }),
                    odd: Cr(function (V, rt) {
                      for (var dt = 1; dt < rt; dt += 2) V.push(dt)
                      return V
                    }),
                    lt: Cr(function (V, rt, dt) {
                      var wt
                      for (dt < 0 ? (wt = dt + rt) : dt > rt ? (wt = rt) : (wt = dt); --wt >= 0; )
                        V.push(wt)
                      return V
                    }),
                    gt: Cr(function (V, rt, dt) {
                      for (var wt = dt < 0 ? dt + rt : dt; ++wt < rt; ) V.push(wt)
                      return V
                    }),
                  },
                }),
              (A.pseudos.nth = A.pseudos.eq))
            for (d in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 })
              A.pseudos[d] = Ac(d)
            for (d in { submit: !0, reset: !0 }) A.pseudos[d] = bc(d)
            function Rl() {}
            ;((Rl.prototype = A.filters = A.pseudos), (A.setFilters = new Rl()))
            function zs(V, rt) {
              var dt,
                wt,
                Mt,
                jt,
                Ht,
                Vt,
                Zt,
                pe = Te[V + ' ']
              if (pe) return rt ? 0 : pe.slice(0)
              for (Ht = V, Vt = [], Zt = A.preFilter; Ht; ) {
                ;((!dt || (wt = nn.exec(Ht))) &&
                  (wt && (Ht = Ht.slice(wt[0].length) || Ht), Vt.push((Mt = []))),
                  (dt = !1),
                  (wt = ta.exec(Ht)) &&
                    ((dt = wt.shift()),
                    Mt.push({ value: dt, type: wt[0].replace(Ct, ' ') }),
                    (Ht = Ht.slice(dt.length))))
                for (jt in A.filter)
                  (wt = Ti[jt].exec(Ht)) &&
                    (!Zt[jt] || (wt = Zt[jt](wt))) &&
                    ((dt = wt.shift()),
                    Mt.push({ value: dt, type: jt, matches: wt }),
                    (Ht = Ht.slice(dt.length)))
                if (!dt) break
              }
              return rt ? Ht.length : Ht ? Le.error(V) : Te(V, Vt).slice(0)
            }
            function Co(V) {
              for (var rt = 0, dt = V.length, wt = ''; rt < dt; rt++) wt += V[rt].value
              return wt
            }
            function wo(V, rt, dt) {
              var wt = rt.dir,
                Mt = rt.next,
                jt = Mt || wt,
                Ht = dt && jt === 'parentNode',
                Vt = _t++
              return rt.first
                ? function (Zt, pe, ne) {
                    for (; (Zt = Zt[wt]); ) if (Zt.nodeType === 1 || Ht) return V(Zt, pe, ne)
                    return !1
                  }
                : function (Zt, pe, ne) {
                    var ee,
                      ye,
                      te = [vt, Vt]
                    if (ne) {
                      for (; (Zt = Zt[wt]); )
                        if ((Zt.nodeType === 1 || Ht) && V(Zt, pe, ne)) return !0
                    } else
                      for (; (Zt = Zt[wt]); )
                        if (Zt.nodeType === 1 || Ht)
                          if (((ye = Zt[Dt] || (Zt[Dt] = {})), Mt && M(Zt, Mt))) Zt = Zt[wt] || Zt
                          else {
                            if ((ee = ye[jt]) && ee[0] === vt && ee[1] === Vt)
                              return (te[2] = ee[2])
                            if (((ye[jt] = te), (te[2] = V(Zt, pe, ne)))) return !0
                          }
                    return !1
                  }
            }
            function kl(V) {
              return V.length > 1
                ? function (rt, dt, wt) {
                    for (var Mt = V.length; Mt--; ) if (!V[Mt](rt, dt, wt)) return !1
                    return !0
                  }
                : V[0]
            }
            function Kh(V, rt, dt) {
              for (var wt = 0, Mt = rt.length; wt < Mt; wt++) Le(V, rt[wt], dt)
              return dt
            }
            function _n(V, rt, dt, wt, Mt) {
              for (var jt, Ht = [], Vt = 0, Zt = V.length, pe = rt != null; Vt < Zt; Vt++)
                (jt = V[Vt]) && (!dt || dt(jt, wt, Mt)) && (Ht.push(jt), pe && rt.push(Vt))
              return Ht
            }
            function na(V, rt, dt, wt, Mt, jt) {
              return (
                wt && !wt[Dt] && (wt = na(wt)),
                Mt && !Mt[Dt] && (Mt = na(Mt, jt)),
                Mi(function (Ht, Vt, Zt, pe) {
                  var ne,
                    ee,
                    ye,
                    te,
                    He = [],
                    qn = [],
                    Bn = Vt.length,
                    di = Ht || Kh(rt || '*', Zt.nodeType ? [Zt] : Zt, []),
                    Ei = V && (Ht || !rt) ? _n(di, He, V, Zt, pe) : di
                  if (
                    (dt
                      ? ((te = Mt || (Ht ? V : Bn || wt) ? [] : Vt), dt(Ei, te, Zt, pe))
                      : (te = Ei),
                    wt)
                  )
                    for (ne = _n(te, qn), wt(ne, [], Zt, pe), ee = ne.length; ee--; )
                      (ye = ne[ee]) && (te[qn[ee]] = !(Ei[qn[ee]] = ye))
                  if (Ht) {
                    if (Mt || V) {
                      if (Mt) {
                        for (ne = [], ee = te.length; ee--; )
                          (ye = te[ee]) && ne.push((Ei[ee] = ye))
                        Mt(null, (te = []), ne, pe)
                      }
                      for (ee = te.length; ee--; )
                        (ye = te[ee]) &&
                          (ne = Mt ? h.call(Ht, ye) : He[ee]) > -1 &&
                          (Ht[ne] = !(Vt[ne] = ye))
                    }
                  } else
                    ((te = _n(te === Vt ? te.splice(Bn, te.length) : te)),
                      Mt ? Mt(null, Vt, te, pe) : L.apply(Vt, te))
                })
              )
            }
            function xo(V) {
              for (
                var rt,
                  dt,
                  wt,
                  Mt = V.length,
                  jt = A.relative[V[0].type],
                  Ht = jt || A.relative[' '],
                  Vt = jt ? 1 : 0,
                  Zt = wo(
                    function (ee) {
                      return ee === rt
                    },
                    Ht,
                    !0
                  ),
                  pe = wo(
                    function (ee) {
                      return h.call(rt, ee) > -1
                    },
                    Ht,
                    !0
                  ),
                  ne = [
                    function (ee, ye, te) {
                      var He =
                        (!jt && (te || ye != I)) ||
                        ((rt = ye).nodeType ? Zt(ee, ye, te) : pe(ee, ye, te))
                      return ((rt = null), He)
                    },
                  ];
                Vt < Mt;
                Vt++
              )
                if ((dt = A.relative[V[Vt].type])) ne = [wo(kl(ne), dt)]
                else {
                  if (((dt = A.filter[V[Vt].type].apply(null, V[Vt].matches)), dt[Dt])) {
                    for (wt = ++Vt; wt < Mt && !A.relative[V[wt].type]; wt++);
                    return na(
                      Vt > 1 && kl(ne),
                      Vt > 1 &&
                        Co(
                          V.slice(0, Vt - 1).concat({ value: V[Vt - 2].type === ' ' ? '*' : '' })
                        ).replace(Ct, '$1'),
                      dt,
                      Vt < wt && xo(V.slice(Vt, wt)),
                      wt < Mt && xo((V = V.slice(wt))),
                      wt < Mt && Co(V)
                    )
                  }
                  ne.push(dt)
                }
              return kl(ne)
            }
            function Ic(V, rt) {
              var dt = rt.length > 0,
                wt = V.length > 0,
                Mt = function (jt, Ht, Vt, Zt, pe) {
                  var ne,
                    ee,
                    ye,
                    te = 0,
                    He = '0',
                    qn = jt && [],
                    Bn = [],
                    di = I,
                    Ei = jt || (wt && A.find.TAG('*', pe)),
                    ia = (vt += di == null ? 1 : Math.random() || 0.1),
                    Nn = Ei.length
                  for (pe && (I = Ht == k || Ht || pe); He !== Nn && (ne = Ei[He]) != null; He++) {
                    if (wt && ne) {
                      for (
                        ee = 0, !Ht && ne.ownerDocument != k && (wr(ne), (Vt = !q));
                        (ye = V[ee++]);

                      )
                        if (ye(ne, Ht || k, Vt)) {
                          L.call(Zt, ne)
                          break
                        }
                      pe && (vt = ia)
                    }
                    dt && ((ne = !ye && ne) && te--, jt && qn.push(ne))
                  }
                  if (((te += He), dt && He !== te)) {
                    for (ee = 0; (ye = rt[ee++]); ) ye(qn, Bn, Ht, Vt)
                    if (jt) {
                      if (te > 0) for (; He--; ) qn[He] || Bn[He] || (Bn[He] = _.call(Zt))
                      Bn = _n(Bn)
                    }
                    ;(L.apply(Zt, Bn),
                      pe && !jt && Bn.length > 0 && te + rt.length > 1 && g.uniqueSort(Zt))
                  }
                  return (pe && ((vt = ia), (I = di)), qn)
                }
              return dt ? Mi(Mt) : Mt
            }
            function So(V, rt) {
              var dt,
                wt = [],
                Mt = [],
                jt = ge[V + ' ']
              if (!jt) {
                for (rt || (rt = zs(V)), dt = rt.length; dt--; )
                  ((jt = xo(rt[dt])), jt[Dt] ? wt.push(jt) : Mt.push(jt))
                ;((jt = ge(V, Ic(Mt, wt))), (jt.selector = V))
              }
              return jt
            }
            function _l(V, rt, dt, wt) {
              var Mt,
                jt,
                Ht,
                Vt,
                Zt,
                pe = typeof V == 'function' && V,
                ne = !wt && zs((V = pe.selector || V))
              if (((dt = dt || []), ne.length === 1)) {
                if (
                  ((jt = ne[0] = ne[0].slice(0)),
                  jt.length > 2 &&
                    (Ht = jt[0]).type === 'ID' &&
                    rt.nodeType === 9 &&
                    q &&
                    A.relative[jt[1].type])
                ) {
                  if (((rt = (A.find.ID(Ht.matches[0].replace(Ar, br), rt) || [])[0]), rt))
                    pe && (rt = rt.parentNode)
                  else return dt
                  V = V.slice(jt.shift().value.length)
                }
                for (
                  Mt = Ti.needsContext.test(V) ? 0 : jt.length;
                  Mt-- && ((Ht = jt[Mt]), !A.relative[(Vt = Ht.type)]);

                )
                  if (
                    (Zt = A.find[Vt]) &&
                    (wt = Zt(
                      Ht.matches[0].replace(Ar, br),
                      (Br.test(jt[0].type) && Io(rt.parentNode)) || rt
                    ))
                  ) {
                    if ((jt.splice(Mt, 1), (V = wt.length && Co(jt)), !V))
                      return (L.apply(dt, wt), dt)
                    break
                  }
              }
              return (
                (pe || So(V, ne))(wt, rt, !q, dt, !rt || (Br.test(V) && Io(rt.parentNode)) || rt),
                dt
              )
            }
            ;((N.sortStable = Dt.split('').sort(vn).join('') === Dt),
              wr(),
              (N.sortDetached = Ir(function (V) {
                return V.compareDocumentPosition(k.createElement('fieldset')) & 1
              })),
              (g.find = Le),
              (g.expr[':'] = g.expr.pseudos),
              (g.unique = g.uniqueSort),
              (Le.compile = So),
              (Le.select = _l),
              (Le.setDocument = wr),
              (Le.tokenize = zs),
              (Le.escape = g.escapeSelector),
              (Le.getText = g.text),
              (Le.isXML = g.isXMLDoc),
              (Le.selectors = g.expr),
              (Le.support = g.support),
              (Le.uniqueSort = g.uniqueSort))
          })()
          var st = function (d, A, I) {
              for (var x = [], D = I !== void 0; (d = d[A]) && d.nodeType !== 9; )
                if (d.nodeType === 1) {
                  if (D && g(d).is(I)) break
                  x.push(d)
                }
              return x
            },
            F = function (d, A) {
              for (var I = []; d; d = d.nextSibling) d.nodeType === 1 && d !== A && I.push(d)
              return I
            },
            ht = g.expr.match.needsContext,
            ct = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i
          function St(d, A, I) {
            return T(A)
              ? g.grep(d, function (x, D) {
                  return !!A.call(x, D, x) !== I
                })
              : A.nodeType
                ? g.grep(d, function (x) {
                    return (x === A) !== I
                  })
                : typeof A != 'string'
                  ? g.grep(d, function (x) {
                      return h.call(A, x) > -1 !== I
                    })
                  : g.filter(A, d, I)
          }
          ;((g.filter = function (d, A, I) {
            var x = A[0]
            return (
              I && (d = ':not(' + d + ')'),
              A.length === 1 && x.nodeType === 1
                ? g.find.matchesSelector(x, d)
                  ? [x]
                  : []
                : g.find.matches(
                    d,
                    g.grep(A, function (D) {
                      return D.nodeType === 1
                    })
                  )
            )
          }),
            g.fn.extend({
              find: function (d) {
                var A,
                  I,
                  x = this.length,
                  D = this
                if (typeof d != 'string')
                  return this.pushStack(
                    g(d).filter(function () {
                      for (A = 0; A < x; A++) if (g.contains(D[A], this)) return !0
                    })
                  )
                for (I = this.pushStack([]), A = 0; A < x; A++) g.find(d, D[A], I)
                return x > 1 ? g.uniqueSort(I) : I
              },
              filter: function (d) {
                return this.pushStack(St(this, d || [], !1))
              },
              not: function (d) {
                return this.pushStack(St(this, d || [], !0))
              },
              is: function (d) {
                return !!St(this, typeof d == 'string' && ht.test(d) ? g(d) : d || [], !1).length
              },
            }))
          var bt,
            kt = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
            lt = (g.fn.init = function (d, A, I) {
              var x, D
              if (!d) return this
              if (((I = I || bt), typeof d == 'string'))
                if (
                  (d[0] === '<' && d[d.length - 1] === '>' && d.length >= 3
                    ? (x = [null, d, null])
                    : (x = kt.exec(d)),
                  x && (x[1] || !A))
                )
                  if (x[1]) {
                    if (
                      ((A = A instanceof g ? A[0] : A),
                      g.merge(
                        this,
                        g.parseHTML(x[1], A && A.nodeType ? A.ownerDocument || A : R, !0)
                      ),
                      ct.test(x[1]) && g.isPlainObject(A))
                    )
                      for (x in A) T(this[x]) ? this[x](A[x]) : this.attr(x, A[x])
                    return this
                  } else
                    return (
                      (D = R.getElementById(x[2])),
                      D && ((this[0] = D), (this.length = 1)),
                      this
                    )
                else return !A || A.jquery ? (A || I).find(d) : this.constructor(A).find(d)
              else {
                if (d.nodeType) return ((this[0] = d), (this.length = 1), this)
                if (T(d)) return I.ready !== void 0 ? I.ready(d) : d(g)
              }
              return g.makeArray(d, this)
            })
          ;((lt.prototype = g.fn), (bt = g(R)))
          var gt = /^(?:parents|prev(?:Until|All))/,
            Et = { children: !0, contents: !0, next: !0, prev: !0 }
          g.fn.extend({
            has: function (d) {
              var A = g(d, this),
                I = A.length
              return this.filter(function () {
                for (var x = 0; x < I; x++) if (g.contains(this, A[x])) return !0
              })
            },
            closest: function (d, A) {
              var I,
                x = 0,
                D = this.length,
                L = [],
                k = typeof d != 'string' && g(d)
              if (!ht.test(d)) {
                for (; x < D; x++)
                  for (I = this[x]; I && I !== A; I = I.parentNode)
                    if (
                      I.nodeType < 11 &&
                      (k ? k.index(I) > -1 : I.nodeType === 1 && g.find.matchesSelector(I, d))
                    ) {
                      L.push(I)
                      break
                    }
              }
              return this.pushStack(L.length > 1 ? g.uniqueSort(L) : L)
            },
            index: function (d) {
              return d
                ? typeof d == 'string'
                  ? h.call(g(d), this[0])
                  : h.call(this, d.jquery ? d[0] : d)
                : this[0] && this[0].parentNode
                  ? this.first().prevAll().length
                  : -1
            },
            add: function (d, A) {
              return this.pushStack(g.uniqueSort(g.merge(this.get(), g(d, A))))
            },
            addBack: function (d) {
              return this.add(d == null ? this.prevObject : this.prevObject.filter(d))
            },
          })
          function Ft(d, A) {
            for (; (d = d[A]) && d.nodeType !== 1; );
            return d
          }
          g.each(
            {
              parent: function (d) {
                var A = d.parentNode
                return A && A.nodeType !== 11 ? A : null
              },
              parents: function (d) {
                return st(d, 'parentNode')
              },
              parentsUntil: function (d, A, I) {
                return st(d, 'parentNode', I)
              },
              next: function (d) {
                return Ft(d, 'nextSibling')
              },
              prev: function (d) {
                return Ft(d, 'previousSibling')
              },
              nextAll: function (d) {
                return st(d, 'nextSibling')
              },
              prevAll: function (d) {
                return st(d, 'previousSibling')
              },
              nextUntil: function (d, A, I) {
                return st(d, 'nextSibling', I)
              },
              prevUntil: function (d, A, I) {
                return st(d, 'previousSibling', I)
              },
              siblings: function (d) {
                return F((d.parentNode || {}).firstChild, d)
              },
              children: function (d) {
                return F(d.firstChild)
              },
              contents: function (d) {
                return d.contentDocument != null && s(d.contentDocument)
                  ? d.contentDocument
                  : (M(d, 'template') && (d = d.content || d), g.merge([], d.childNodes))
              },
            },
            function (d, A) {
              g.fn[d] = function (I, x) {
                var D = g.map(this, A, I)
                return (
                  d.slice(-5) !== 'Until' && (x = I),
                  x && typeof x == 'string' && (D = g.filter(x, D)),
                  this.length > 1 && (Et[d] || g.uniqueSort(D), gt.test(d) && D.reverse()),
                  this.pushStack(D)
                )
              }
            }
          )
          var Qt = /[^\x20\t\r\n\f]+/g
          function qt(d) {
            var A = {}
            return (
              g.each(d.match(Qt) || [], function (I, x) {
                A[x] = !0
              }),
              A
            )
          }
          g.Callbacks = function (d) {
            d = typeof d == 'string' ? qt(d) : g.extend({}, d)
            var A,
              I,
              x,
              D,
              L = [],
              k = [],
              tt = -1,
              q = function () {
                for (D = D || d.once, x = A = !0; k.length; tt = -1)
                  for (I = k.shift(); ++tt < L.length; )
                    L[tt].apply(I[0], I[1]) === !1 && d.stopOnFalse && ((tt = L.length), (I = !1))
                ;(d.memory || (I = !1), (A = !1), D && (I ? (L = []) : (L = '')))
              },
              ot = {
                add: function () {
                  return (
                    L &&
                      (I && !A && ((tt = L.length - 1), k.push(I)),
                      (function xt(Dt) {
                        g.each(Dt, function (vt, _t) {
                          T(_t)
                            ? (!d.unique || !ot.has(_t)) && L.push(_t)
                            : _t && _t.length && Z(_t) !== 'string' && xt(_t)
                        })
                      })(arguments),
                      I && !A && q()),
                    this
                  )
                },
                remove: function () {
                  return (
                    g.each(arguments, function (xt, Dt) {
                      for (var vt; (vt = g.inArray(Dt, L, vt)) > -1; )
                        (L.splice(vt, 1), vt <= tt && tt--)
                    }),
                    this
                  )
                },
                has: function (xt) {
                  return xt ? g.inArray(xt, L) > -1 : L.length > 0
                },
                empty: function () {
                  return (L && (L = []), this)
                },
                disable: function () {
                  return ((D = k = []), (L = I = ''), this)
                },
                disabled: function () {
                  return !L
                },
                lock: function () {
                  return ((D = k = []), !I && !A && (L = I = ''), this)
                },
                locked: function () {
                  return !!D
                },
                fireWith: function (xt, Dt) {
                  return (
                    D ||
                      ((Dt = Dt || []),
                      (Dt = [xt, Dt.slice ? Dt.slice() : Dt]),
                      k.push(Dt),
                      A || q()),
                    this
                  )
                },
                fire: function () {
                  return (ot.fireWith(this, arguments), this)
                },
                fired: function () {
                  return !!x
                },
              }
            return ot
          }
          function de(d) {
            return d
          }
          function Xt(d) {
            throw d
          }
          function E(d, A, I, x) {
            var D
            try {
              d && T((D = d.promise))
                ? D.call(d).done(A).fail(I)
                : d && T((D = d.then))
                  ? D.call(d, A, I)
                  : A.apply(void 0, [d].slice(x))
            } catch (L) {
              I.apply(void 0, [L])
            }
          }
          g.extend({
            Deferred: function (d) {
              var A = [
                  ['notify', 'progress', g.Callbacks('memory'), g.Callbacks('memory'), 2],
                  [
                    'resolve',
                    'done',
                    g.Callbacks('once memory'),
                    g.Callbacks('once memory'),
                    0,
                    'resolved',
                  ],
                  [
                    'reject',
                    'fail',
                    g.Callbacks('once memory'),
                    g.Callbacks('once memory'),
                    1,
                    'rejected',
                  ],
                ],
                I = 'pending',
                x = {
                  state: function () {
                    return I
                  },
                  always: function () {
                    return (D.done(arguments).fail(arguments), this)
                  },
                  catch: function (L) {
                    return x.then(null, L)
                  },
                  pipe: function () {
                    var L = arguments
                    return g
                      .Deferred(function (k) {
                        ;(g.each(A, function (tt, q) {
                          var ot = T(L[q[4]]) && L[q[4]]
                          D[q[1]](function () {
                            var xt = ot && ot.apply(this, arguments)
                            xt && T(xt.promise)
                              ? xt.promise().progress(k.notify).done(k.resolve).fail(k.reject)
                              : k[q[0] + 'With'](this, ot ? [xt] : arguments)
                          })
                        }),
                          (L = null))
                      })
                      .promise()
                  },
                  then: function (L, k, tt) {
                    var q = 0
                    function ot(xt, Dt, vt, _t) {
                      return function () {
                        var oe = this,
                          Te = arguments,
                          ge = function () {
                            var vn, Wi
                            if (!(xt < q)) {
                              if (((vn = vt.apply(oe, Te)), vn === Dt.promise()))
                                throw new TypeError('Thenable self-resolution')
                              ;((Wi =
                                vn &&
                                (typeof vn == 'object' || typeof vn == 'function') &&
                                vn.then),
                                T(Wi)
                                  ? _t
                                    ? Wi.call(vn, ot(q, Dt, de, _t), ot(q, Dt, Xt, _t))
                                    : (q++,
                                      Wi.call(
                                        vn,
                                        ot(q, Dt, de, _t),
                                        ot(q, Dt, Xt, _t),
                                        ot(q, Dt, de, Dt.notifyWith)
                                      ))
                                  : (vt !== de && ((oe = void 0), (Te = [vn])),
                                    (_t || Dt.resolveWith)(oe, Te)))
                            }
                          },
                          Sn = _t
                            ? ge
                            : function () {
                                try {
                                  ge()
                                } catch (vn) {
                                  ;(g.Deferred.exceptionHook &&
                                    g.Deferred.exceptionHook(vn, Sn.error),
                                    xt + 1 >= q &&
                                      (vt !== Xt && ((oe = void 0), (Te = [vn])),
                                      Dt.rejectWith(oe, Te)))
                                }
                              }
                        xt
                          ? Sn()
                          : (g.Deferred.getErrorHook
                              ? (Sn.error = g.Deferred.getErrorHook())
                              : g.Deferred.getStackHook && (Sn.error = g.Deferred.getStackHook()),
                            e.setTimeout(Sn))
                      }
                    }
                    return g
                      .Deferred(function (xt) {
                        ;(A[0][3].add(ot(0, xt, T(tt) ? tt : de, xt.notifyWith)),
                          A[1][3].add(ot(0, xt, T(L) ? L : de)),
                          A[2][3].add(ot(0, xt, T(k) ? k : Xt)))
                      })
                      .promise()
                  },
                  promise: function (L) {
                    return L != null ? g.extend(L, x) : x
                  },
                },
                D = {}
              return (
                g.each(A, function (L, k) {
                  var tt = k[2],
                    q = k[5]
                  ;((x[k[1]] = tt.add),
                    q &&
                      tt.add(
                        function () {
                          I = q
                        },
                        A[3 - L][2].disable,
                        A[3 - L][3].disable,
                        A[0][2].lock,
                        A[0][3].lock
                      ),
                    tt.add(k[3].fire),
                    (D[k[0]] = function () {
                      return (D[k[0] + 'With'](this === D ? void 0 : this, arguments), this)
                    }),
                    (D[k[0] + 'With'] = tt.fireWith))
                }),
                x.promise(D),
                d && d.call(D, D),
                D
              )
            },
            when: function (d) {
              var A = arguments.length,
                I = A,
                x = Array(I),
                D = o.call(arguments),
                L = g.Deferred(),
                k = function (tt) {
                  return function (q) {
                    ;((x[tt] = this),
                      (D[tt] = arguments.length > 1 ? o.call(arguments) : q),
                      --A || L.resolveWith(x, D))
                  }
                }
              if (
                A <= 1 &&
                (E(d, L.done(k(I)).resolve, L.reject, !A),
                L.state() === 'pending' || T(D[I] && D[I].then))
              )
                return L.then()
              for (; I--; ) E(D[I], k(I), L.reject)
              return L.promise()
            },
          })
          var P = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/
          ;((g.Deferred.exceptionHook = function (d, A) {
            e.console &&
              e.console.warn &&
              d &&
              P.test(d.name) &&
              e.console.warn('jQuery.Deferred exception: ' + d.message, d.stack, A)
          }),
            (g.readyException = function (d) {
              e.setTimeout(function () {
                throw d
              })
            }))
          var Y = g.Deferred()
          ;((g.fn.ready = function (d) {
            return (
              Y.then(d).catch(function (A) {
                g.readyException(A)
              }),
              this
            )
          }),
            g.extend({
              isReady: !1,
              readyWait: 1,
              ready: function (d) {
                ;(d === !0 ? --g.readyWait : g.isReady) ||
                  ((g.isReady = !0), !(d !== !0 && --g.readyWait > 0) && Y.resolveWith(R, [g]))
              },
            }),
            (g.ready.then = Y.then))
          function J() {
            ;(R.removeEventListener('DOMContentLoaded', J),
              e.removeEventListener('load', J),
              g.ready())
          }
          R.readyState === 'complete' || (R.readyState !== 'loading' && !R.documentElement.doScroll)
            ? e.setTimeout(g.ready)
            : (R.addEventListener('DOMContentLoaded', J), e.addEventListener('load', J))
          var At = function (d, A, I, x, D, L, k) {
              var tt = 0,
                q = d.length,
                ot = I == null
              if (Z(I) === 'object') {
                D = !0
                for (tt in I) At(d, A, tt, I[tt], !0, L, k)
              } else if (
                x !== void 0 &&
                ((D = !0),
                T(x) || (k = !0),
                ot &&
                  (k
                    ? (A.call(d, x), (A = null))
                    : ((ot = A),
                      (A = function (xt, Dt, vt) {
                        return ot.call(g(xt), vt)
                      }))),
                A)
              )
                for (; tt < q; tt++) A(d[tt], I, k ? x : x.call(d[tt], tt, A(d[tt], I)))
              return D ? d : ot ? A.call(d) : q ? A(d[0], I) : L
            },
            Nt = /^-ms-/,
            Yt = /-([a-z])/g
          function se(d, A) {
            return A.toUpperCase()
          }
          function Se(d) {
            return d.replace(Nt, 'ms-').replace(Yt, se)
          }
          var $e = function (d) {
            return d.nodeType === 1 || d.nodeType === 9 || !+d.nodeType
          }
          function Ye() {
            this.expando = g.expando + Ye.uid++
          }
          ;((Ye.uid = 1),
            (Ye.prototype = {
              cache: function (d) {
                var A = d[this.expando]
                return (
                  A ||
                    ((A = {}),
                    $e(d) &&
                      (d.nodeType
                        ? (d[this.expando] = A)
                        : Object.defineProperty(d, this.expando, { value: A, configurable: !0 }))),
                  A
                )
              },
              set: function (d, A, I) {
                var x,
                  D = this.cache(d)
                if (typeof A == 'string') D[Se(A)] = I
                else for (x in A) D[Se(x)] = A[x]
                return D
              },
              get: function (d, A) {
                return A === void 0 ? this.cache(d) : d[this.expando] && d[this.expando][Se(A)]
              },
              access: function (d, A, I) {
                return A === void 0 || (A && typeof A == 'string' && I === void 0)
                  ? this.get(d, A)
                  : (this.set(d, A, I), I !== void 0 ? I : A)
              },
              remove: function (d, A) {
                var I,
                  x = d[this.expando]
                if (x !== void 0) {
                  if (A !== void 0)
                    for (
                      Array.isArray(A)
                        ? (A = A.map(Se))
                        : ((A = Se(A)), (A = (A in x) ? [A] : A.match(Qt) || [])),
                        I = A.length;
                      I--;

                    )
                      delete x[A[I]]
                  ;(A === void 0 || g.isEmptyObject(x)) &&
                    (d.nodeType ? (d[this.expando] = void 0) : delete d[this.expando])
                }
              },
              hasData: function (d) {
                var A = d[this.expando]
                return A !== void 0 && !g.isEmptyObject(A)
              },
            }))
          var Bt = new Ye(),
            ae = new Ye(),
            fe = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            Fn = /[A-Z]/g
          function Ne(d) {
            return d === 'true'
              ? !0
              : d === 'false'
                ? !1
                : d === 'null'
                  ? null
                  : d === +d + ''
                    ? +d
                    : fe.test(d)
                      ? JSON.parse(d)
                      : d
          }
          function ln(d, A, I) {
            var x
            if (I === void 0 && d.nodeType === 1)
              if (
                ((x = 'data-' + A.replace(Fn, '-$&').toLowerCase()),
                (I = d.getAttribute(x)),
                typeof I == 'string')
              ) {
                try {
                  I = Ne(I)
                } catch {}
                ae.set(d, A, I)
              } else I = void 0
            return I
          }
          ;(g.extend({
            hasData: function (d) {
              return ae.hasData(d) || Bt.hasData(d)
            },
            data: function (d, A, I) {
              return ae.access(d, A, I)
            },
            removeData: function (d, A) {
              ae.remove(d, A)
            },
            _data: function (d, A, I) {
              return Bt.access(d, A, I)
            },
            _removeData: function (d, A) {
              Bt.remove(d, A)
            },
          }),
            g.fn.extend({
              data: function (d, A) {
                var I,
                  x,
                  D,
                  L = this[0],
                  k = L && L.attributes
                if (d === void 0) {
                  if (
                    this.length &&
                    ((D = ae.get(L)), L.nodeType === 1 && !Bt.get(L, 'hasDataAttrs'))
                  ) {
                    for (I = k.length; I--; )
                      k[I] &&
                        ((x = k[I].name),
                        x.indexOf('data-') === 0 && ((x = Se(x.slice(5))), ln(L, x, D[x])))
                    Bt.set(L, 'hasDataAttrs', !0)
                  }
                  return D
                }
                return typeof d == 'object'
                  ? this.each(function () {
                      ae.set(this, d)
                    })
                  : At(
                      this,
                      function (tt) {
                        var q
                        if (L && tt === void 0)
                          return (
                            (q = ae.get(L, d)),
                            q !== void 0 || ((q = ln(L, d)), q !== void 0) ? q : void 0
                          )
                        this.each(function () {
                          ae.set(this, d, tt)
                        })
                      },
                      null,
                      A,
                      arguments.length > 1,
                      null,
                      !0
                    )
              },
              removeData: function (d) {
                return this.each(function () {
                  ae.remove(this, d)
                })
              },
            }),
            g.extend({
              queue: function (d, A, I) {
                var x
                if (d)
                  return (
                    (A = (A || 'fx') + 'queue'),
                    (x = Bt.get(d, A)),
                    I &&
                      (!x || Array.isArray(I) ? (x = Bt.access(d, A, g.makeArray(I))) : x.push(I)),
                    x || []
                  )
              },
              dequeue: function (d, A) {
                A = A || 'fx'
                var I = g.queue(d, A),
                  x = I.length,
                  D = I.shift(),
                  L = g._queueHooks(d, A),
                  k = function () {
                    g.dequeue(d, A)
                  }
                ;(D === 'inprogress' && ((D = I.shift()), x--),
                  D && (A === 'fx' && I.unshift('inprogress'), delete L.stop, D.call(d, k, L)),
                  !x && L && L.empty.fire())
              },
              _queueHooks: function (d, A) {
                var I = A + 'queueHooks'
                return (
                  Bt.get(d, I) ||
                  Bt.access(d, I, {
                    empty: g.Callbacks('once memory').add(function () {
                      Bt.remove(d, [A + 'queue', I])
                    }),
                  })
                )
              },
            }),
            g.fn.extend({
              queue: function (d, A) {
                var I = 2
                return (
                  typeof d != 'string' && ((A = d), (d = 'fx'), I--),
                  arguments.length < I
                    ? g.queue(this[0], d)
                    : A === void 0
                      ? this
                      : this.each(function () {
                          var x = g.queue(this, d, A)
                          ;(g._queueHooks(this, d),
                            d === 'fx' && x[0] !== 'inprogress' && g.dequeue(this, d))
                        })
                )
              },
              dequeue: function (d) {
                return this.each(function () {
                  g.dequeue(this, d)
                })
              },
              clearQueue: function (d) {
                return this.queue(d || 'fx', [])
              },
              promise: function (d, A) {
                var I,
                  x = 1,
                  D = g.Deferred(),
                  L = this,
                  k = this.length,
                  tt = function () {
                    --x || D.resolveWith(L, [L])
                  }
                for (typeof d != 'string' && ((A = d), (d = void 0)), d = d || 'fx'; k--; )
                  ((I = Bt.get(L[k], d + 'queueHooks')), I && I.empty && (x++, I.empty.add(tt)))
                return (tt(), D.promise(A))
              },
            }))
          var Zn = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            wi = new RegExp('^(?:([+-])=|)(' + Zn + ')([a-z%]*)$', 'i'),
            xn = ['Top', 'Right', 'Bottom', 'Left'],
            Jn = R.documentElement,
            Ln = function (d) {
              return g.contains(d.ownerDocument, d)
            },
            fr = { composed: !0 }
          Jn.getRootNode &&
            (Ln = function (d) {
              return g.contains(d.ownerDocument, d) || d.getRootNode(fr) === d.ownerDocument
            })
          var xi = function (d, A) {
            return (
              (d = A || d),
              d.style.display === 'none' ||
                (d.style.display === '' && Ln(d) && g.css(d, 'display') === 'none')
            )
          }
          function ms(d, A, I, x) {
            var D,
              L,
              k = 20,
              tt = x
                ? function () {
                    return x.cur()
                  }
                : function () {
                    return g.css(d, A, '')
                  },
              q = tt(),
              ot = (I && I[3]) || (g.cssNumber[A] ? '' : 'px'),
              xt = d.nodeType && (g.cssNumber[A] || (ot !== 'px' && +q)) && wi.exec(g.css(d, A))
            if (xt && xt[3] !== ot) {
              for (q = q / 2, ot = ot || xt[3], xt = +q || 1; k--; )
                (g.style(d, A, xt + ot),
                  (1 - L) * (1 - (L = tt() / q || 0.5)) <= 0 && (k = 0),
                  (xt = xt / L))
              ;((xt = xt * 2), g.style(d, A, xt + ot), (I = I || []))
            }
            return (
              I &&
                ((xt = +xt || +q || 0),
                (D = I[1] ? xt + (I[1] + 1) * I[2] : +I[2]),
                x && ((x.unit = ot), (x.start = xt), (x.end = D))),
              D
            )
          }
          var Sa = {}
          function hr(d) {
            var A,
              I = d.ownerDocument,
              x = d.nodeName,
              D = Sa[x]
            return (
              D ||
              ((A = I.body.appendChild(I.createElement(x))),
              (D = g.css(A, 'display')),
              A.parentNode.removeChild(A),
              D === 'none' && (D = 'block'),
              (Sa[x] = D),
              D)
            )
          }
          function Si(d, A) {
            for (var I, x, D = [], L = 0, k = d.length; L < k; L++)
              ((x = d[L]),
                x.style &&
                  ((I = x.style.display),
                  A
                    ? (I === 'none' &&
                        ((D[L] = Bt.get(x, 'display') || null), D[L] || (x.style.display = '')),
                      x.style.display === '' && xi(x) && (D[L] = hr(x)))
                    : I !== 'none' && ((D[L] = 'none'), Bt.set(x, 'display', I))))
            for (L = 0; L < k; L++) D[L] != null && (d[L].style.display = D[L])
            return d
          }
          g.fn.extend({
            show: function () {
              return Si(this, !0)
            },
            hide: function () {
              return Si(this)
            },
            toggle: function (d) {
              return typeof d == 'boolean'
                ? d
                  ? this.show()
                  : this.hide()
                : this.each(function () {
                    xi(this) ? g(this).show() : g(this).hide()
                  })
            },
          })
          var hi = /^(?:checkbox|radio)$/i,
            ys = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
            As = /^$|^module$|\/(?:java|ecma)script/i
          ;(function () {
            var d = R.createDocumentFragment(),
              A = d.appendChild(R.createElement('div')),
              I = R.createElement('input')
            ;(I.setAttribute('type', 'radio'),
              I.setAttribute('checked', 'checked'),
              I.setAttribute('name', 't'),
              A.appendChild(I),
              (N.checkClone = A.cloneNode(!0).cloneNode(!0).lastChild.checked),
              (A.innerHTML = '<textarea>x</textarea>'),
              (N.noCloneChecked = !!A.cloneNode(!0).lastChild.defaultValue),
              (A.innerHTML = '<option></option>'),
              (N.option = !!A.lastChild))
          })()
          var en = {
            thead: [1, '<table>', '</table>'],
            col: [2, '<table><colgroup>', '</colgroup></table>'],
            tr: [2, '<table><tbody>', '</tbody></table>'],
            td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],
            _default: [0, '', ''],
          }
          ;((en.tbody = en.tfoot = en.colgroup = en.caption = en.thead),
            (en.th = en.td),
            N.option ||
              (en.optgroup = en.option = [1, "<select multiple='multiple'>", '</select>']))
          function zn(d, A) {
            var I
            return (
              typeof d.getElementsByTagName < 'u'
                ? (I = d.getElementsByTagName(A || '*'))
                : typeof d.querySelectorAll < 'u'
                  ? (I = d.querySelectorAll(A || '*'))
                  : (I = []),
              A === void 0 || (A && M(d, A)) ? g.merge([d], I) : I
            )
          }
          function bs(d, A) {
            for (var I = 0, x = d.length; I < x; I++)
              Bt.set(d[I], 'globalEval', !A || Bt.get(A[I], 'globalEval'))
          }
          var oc = /<|&#?\w+;/
          function lc(d, A, I, x, D) {
            for (
              var L,
                k,
                tt,
                q,
                ot,
                xt,
                Dt = A.createDocumentFragment(),
                vt = [],
                _t = 0,
                oe = d.length;
              _t < oe;
              _t++
            )
              if (((L = d[_t]), L || L === 0))
                if (Z(L) === 'object') g.merge(vt, L.nodeType ? [L] : L)
                else if (!oc.test(L)) vt.push(A.createTextNode(L))
                else {
                  for (
                    k = k || Dt.appendChild(A.createElement('div')),
                      tt = (ys.exec(L) || ['', ''])[1].toLowerCase(),
                      q = en[tt] || en._default,
                      k.innerHTML = q[1] + g.htmlPrefilter(L) + q[2],
                      xt = q[0];
                    xt--;

                  )
                    k = k.lastChild
                  ;(g.merge(vt, k.childNodes), (k = Dt.firstChild), (k.textContent = ''))
                }
            for (Dt.textContent = '', _t = 0; (L = vt[_t++]); ) {
              if (x && g.inArray(L, x) > -1) {
                D && D.push(L)
                continue
              }
              if (((ot = Ln(L)), (k = zn(Dt.appendChild(L), 'script')), ot && bs(k), I))
                for (xt = 0; (L = k[xt++]); ) As.test(L.type || '') && I.push(L)
            }
            return Dt
          }
          var dr = /^([^.]*)(?:\.(.+)|)/
          function sn() {
            return !0
          }
          function gn() {
            return !1
          }
          function Lr(d, A, I, x, D, L) {
            var k, tt
            if (typeof A == 'object') {
              typeof I != 'string' && ((x = x || I), (I = void 0))
              for (tt in A) Lr(d, tt, I, x, A[tt], L)
              return d
            }
            if (
              (x == null && D == null
                ? ((D = I), (x = I = void 0))
                : D == null &&
                  (typeof I == 'string'
                    ? ((D = x), (x = void 0))
                    : ((D = x), (x = I), (I = void 0))),
              D === !1)
            )
              D = gn
            else if (!D) return d
            return (
              L === 1 &&
                ((k = D),
                (D = function (q) {
                  return (g().off(q), k.apply(this, arguments))
                }),
                (D.guid = k.guid || (k.guid = g.guid++))),
              d.each(function () {
                g.event.add(this, A, D, x, I)
              })
            )
          }
          g.event = {
            global: {},
            add: function (d, A, I, x, D) {
              var L,
                k,
                tt,
                q,
                ot,
                xt,
                Dt,
                vt,
                _t,
                oe,
                Te,
                ge = Bt.get(d)
              if ($e(d))
                for (
                  I.handler && ((L = I), (I = L.handler), (D = L.selector)),
                    D && g.find.matchesSelector(Jn, D),
                    I.guid || (I.guid = g.guid++),
                    (q = ge.events) || (q = ge.events = Object.create(null)),
                    (k = ge.handle) ||
                      (k = ge.handle =
                        function (Sn) {
                          return typeof g < 'u' && g.event.triggered !== Sn.type
                            ? g.event.dispatch.apply(d, arguments)
                            : void 0
                        }),
                    A = (A || '').match(Qt) || [''],
                    ot = A.length;
                  ot--;

                )
                  ((tt = dr.exec(A[ot]) || []),
                    (_t = Te = tt[1]),
                    (oe = (tt[2] || '').split('.').sort()),
                    _t &&
                      ((Dt = g.event.special[_t] || {}),
                      (_t = (D ? Dt.delegateType : Dt.bindType) || _t),
                      (Dt = g.event.special[_t] || {}),
                      (xt = g.extend(
                        {
                          type: _t,
                          origType: Te,
                          data: x,
                          handler: I,
                          guid: I.guid,
                          selector: D,
                          needsContext: D && g.expr.match.needsContext.test(D),
                          namespace: oe.join('.'),
                        },
                        L
                      )),
                      (vt = q[_t]) ||
                        ((vt = q[_t] = []),
                        (vt.delegateCount = 0),
                        (!Dt.setup || Dt.setup.call(d, x, oe, k) === !1) &&
                          d.addEventListener &&
                          d.addEventListener(_t, k)),
                      Dt.add && (Dt.add.call(d, xt), xt.handler.guid || (xt.handler.guid = I.guid)),
                      D ? vt.splice(vt.delegateCount++, 0, xt) : vt.push(xt),
                      (g.event.global[_t] = !0)))
            },
            remove: function (d, A, I, x, D) {
              var L,
                k,
                tt,
                q,
                ot,
                xt,
                Dt,
                vt,
                _t,
                oe,
                Te,
                ge = Bt.hasData(d) && Bt.get(d)
              if (!(!ge || !(q = ge.events))) {
                for (A = (A || '').match(Qt) || [''], ot = A.length; ot--; ) {
                  if (
                    ((tt = dr.exec(A[ot]) || []),
                    (_t = Te = tt[1]),
                    (oe = (tt[2] || '').split('.').sort()),
                    !_t)
                  ) {
                    for (_t in q) g.event.remove(d, _t + A[ot], I, x, !0)
                    continue
                  }
                  for (
                    Dt = g.event.special[_t] || {},
                      _t = (x ? Dt.delegateType : Dt.bindType) || _t,
                      vt = q[_t] || [],
                      tt = tt[2] && new RegExp('(^|\\.)' + oe.join('\\.(?:.*\\.|)') + '(\\.|$)'),
                      k = L = vt.length;
                    L--;

                  )
                    ((xt = vt[L]),
                      (D || Te === xt.origType) &&
                        (!I || I.guid === xt.guid) &&
                        (!tt || tt.test(xt.namespace)) &&
                        (!x || x === xt.selector || (x === '**' && xt.selector)) &&
                        (vt.splice(L, 1),
                        xt.selector && vt.delegateCount--,
                        Dt.remove && Dt.remove.call(d, xt)))
                  k &&
                    !vt.length &&
                    ((!Dt.teardown || Dt.teardown.call(d, oe, ge.handle) === !1) &&
                      g.removeEvent(d, _t, ge.handle),
                    delete q[_t])
                }
                g.isEmptyObject(q) && Bt.remove(d, 'handle events')
              }
            },
            dispatch: function (d) {
              var A,
                I,
                x,
                D,
                L,
                k,
                tt = new Array(arguments.length),
                q = g.event.fix(d),
                ot = (Bt.get(this, 'events') || Object.create(null))[q.type] || [],
                xt = g.event.special[q.type] || {}
              for (tt[0] = q, A = 1; A < arguments.length; A++) tt[A] = arguments[A]
              if (
                ((q.delegateTarget = this),
                !(xt.preDispatch && xt.preDispatch.call(this, q) === !1))
              ) {
                for (
                  k = g.event.handlers.call(this, q, ot), A = 0;
                  (D = k[A++]) && !q.isPropagationStopped();

                )
                  for (
                    q.currentTarget = D.elem, I = 0;
                    (L = D.handlers[I++]) && !q.isImmediatePropagationStopped();

                  )
                    (!q.rnamespace || L.namespace === !1 || q.rnamespace.test(L.namespace)) &&
                      ((q.handleObj = L),
                      (q.data = L.data),
                      (x = ((g.event.special[L.origType] || {}).handle || L.handler).apply(
                        D.elem,
                        tt
                      )),
                      x !== void 0 &&
                        (q.result = x) === !1 &&
                        (q.preventDefault(), q.stopPropagation()))
                return (xt.postDispatch && xt.postDispatch.call(this, q), q.result)
              }
            },
            handlers: function (d, A) {
              var I,
                x,
                D,
                L,
                k,
                tt = [],
                q = A.delegateCount,
                ot = d.target
              if (q && ot.nodeType && !(d.type === 'click' && d.button >= 1)) {
                for (; ot !== this; ot = ot.parentNode || this)
                  if (ot.nodeType === 1 && !(d.type === 'click' && ot.disabled === !0)) {
                    for (L = [], k = {}, I = 0; I < q; I++)
                      ((x = A[I]),
                        (D = x.selector + ' '),
                        k[D] === void 0 &&
                          (k[D] = x.needsContext
                            ? g(D, this).index(ot) > -1
                            : g.find(D, this, null, [ot]).length),
                        k[D] && L.push(x))
                    L.length && tt.push({ elem: ot, handlers: L })
                  }
              }
              return ((ot = this), q < A.length && tt.push({ elem: ot, handlers: A.slice(q) }), tt)
            },
            addProp: function (d, A) {
              Object.defineProperty(g.Event.prototype, d, {
                enumerable: !0,
                configurable: !0,
                get: T(A)
                  ? function () {
                      if (this.originalEvent) return A(this.originalEvent)
                    }
                  : function () {
                      if (this.originalEvent) return this.originalEvent[d]
                    },
                set: function (I) {
                  Object.defineProperty(this, d, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: I,
                  })
                },
              })
            },
            fix: function (d) {
              return d[g.expando] ? d : new g.Event(d)
            },
            special: {
              load: { noBubble: !0 },
              click: {
                setup: function (d) {
                  var A = this || d
                  return (hi.test(A.type) && A.click && M(A, 'input') && Na(A, 'click', !0), !1)
                },
                trigger: function (d) {
                  var A = this || d
                  return (hi.test(A.type) && A.click && M(A, 'input') && Na(A, 'click'), !0)
                },
                _default: function (d) {
                  var A = d.target
                  return (
                    (hi.test(A.type) && A.click && M(A, 'input') && Bt.get(A, 'click')) || M(A, 'a')
                  )
                },
              },
              beforeunload: {
                postDispatch: function (d) {
                  d.result !== void 0 && d.originalEvent && (d.originalEvent.returnValue = d.result)
                },
              },
            },
          }
          function Na(d, A, I) {
            if (!I) {
              Bt.get(d, A) === void 0 && g.event.add(d, A, sn)
              return
            }
            ;(Bt.set(d, A, !1),
              g.event.add(d, A, {
                namespace: !1,
                handler: function (x) {
                  var D,
                    L = Bt.get(this, A)
                  if (x.isTrigger & 1 && this[A]) {
                    if (L) (g.event.special[A] || {}).delegateType && x.stopPropagation()
                    else if (
                      ((L = o.call(arguments)),
                      Bt.set(this, A, L),
                      this[A](),
                      (D = Bt.get(this, A)),
                      Bt.set(this, A, !1),
                      L !== D)
                    )
                      return (x.stopImmediatePropagation(), x.preventDefault(), D)
                  } else
                    L &&
                      (Bt.set(this, A, g.event.trigger(L[0], L.slice(1), this)),
                      x.stopPropagation(),
                      (x.isImmediatePropagationStopped = sn))
                },
              }))
          }
          ;((g.removeEvent = function (d, A, I) {
            d.removeEventListener && d.removeEventListener(A, I)
          }),
            (g.Event = function (d, A) {
              if (!(this instanceof g.Event)) return new g.Event(d, A)
              ;(d && d.type
                ? ((this.originalEvent = d),
                  (this.type = d.type),
                  (this.isDefaultPrevented =
                    d.defaultPrevented || (d.defaultPrevented === void 0 && d.returnValue === !1)
                      ? sn
                      : gn),
                  (this.target =
                    d.target && d.target.nodeType === 3 ? d.target.parentNode : d.target),
                  (this.currentTarget = d.currentTarget),
                  (this.relatedTarget = d.relatedTarget))
                : (this.type = d),
                A && g.extend(this, A),
                (this.timeStamp = (d && d.timeStamp) || Date.now()),
                (this[g.expando] = !0))
            }),
            (g.Event.prototype = {
              constructor: g.Event,
              isDefaultPrevented: gn,
              isPropagationStopped: gn,
              isImmediatePropagationStopped: gn,
              isSimulated: !1,
              preventDefault: function () {
                var d = this.originalEvent
                ;((this.isDefaultPrevented = sn), d && !this.isSimulated && d.preventDefault())
              },
              stopPropagation: function () {
                var d = this.originalEvent
                ;((this.isPropagationStopped = sn), d && !this.isSimulated && d.stopPropagation())
              },
              stopImmediatePropagation: function () {
                var d = this.originalEvent
                ;((this.isImmediatePropagationStopped = sn),
                  d && !this.isSimulated && d.stopImmediatePropagation(),
                  this.stopPropagation())
              },
            }),
            g.each(
              {
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                char: !0,
                code: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: !0,
              },
              g.event.addProp
            ),
            g.each({ focus: 'focusin', blur: 'focusout' }, function (d, A) {
              function I(x) {
                if (R.documentMode) {
                  var D = Bt.get(this, 'handle'),
                    L = g.event.fix(x)
                  ;((L.type = x.type === 'focusin' ? 'focus' : 'blur'),
                    (L.isSimulated = !0),
                    D(x),
                    L.target === L.currentTarget && D(L))
                } else g.event.simulate(A, x.target, g.event.fix(x))
              }
              ;((g.event.special[d] = {
                setup: function () {
                  var x
                  if ((Na(this, d, !0), R.documentMode))
                    ((x = Bt.get(this, A)),
                      x || this.addEventListener(A, I),
                      Bt.set(this, A, (x || 0) + 1))
                  else return !1
                },
                trigger: function () {
                  return (Na(this, d), !0)
                },
                teardown: function () {
                  var x
                  if (R.documentMode)
                    ((x = Bt.get(this, A) - 1),
                      x ? Bt.set(this, A, x) : (this.removeEventListener(A, I), Bt.remove(this, A)))
                  else return !1
                },
                _default: function (x) {
                  return Bt.get(x.target, d)
                },
                delegateType: A,
              }),
                (g.event.special[A] = {
                  setup: function () {
                    var x = this.ownerDocument || this.document || this,
                      D = R.documentMode ? this : x,
                      L = Bt.get(D, A)
                    ;(L ||
                      (R.documentMode ? this.addEventListener(A, I) : x.addEventListener(d, I, !0)),
                      Bt.set(D, A, (L || 0) + 1))
                  },
                  teardown: function () {
                    var x = this.ownerDocument || this.document || this,
                      D = R.documentMode ? this : x,
                      L = Bt.get(D, A) - 1
                    L
                      ? Bt.set(D, A, L)
                      : (R.documentMode
                          ? this.removeEventListener(A, I)
                          : x.removeEventListener(d, I, !0),
                        Bt.remove(D, A))
                  },
                }))
            }),
            g.each(
              {
                mouseenter: 'mouseover',
                mouseleave: 'mouseout',
                pointerenter: 'pointerover',
                pointerleave: 'pointerout',
              },
              function (d, A) {
                g.event.special[d] = {
                  delegateType: A,
                  bindType: A,
                  handle: function (I) {
                    var x,
                      D = this,
                      L = I.relatedTarget,
                      k = I.handleObj
                    return (
                      (!L || (L !== D && !g.contains(D, L))) &&
                        ((I.type = k.origType),
                        (x = k.handler.apply(this, arguments)),
                        (I.type = A)),
                      x
                    )
                  },
                }
              }
            ),
            g.fn.extend({
              on: function (d, A, I, x) {
                return Lr(this, d, A, I, x)
              },
              one: function (d, A, I, x) {
                return Lr(this, d, A, I, x, 1)
              },
              off: function (d, A, I) {
                var x, D
                if (d && d.preventDefault && d.handleObj)
                  return (
                    (x = d.handleObj),
                    g(d.delegateTarget).off(
                      x.namespace ? x.origType + '.' + x.namespace : x.origType,
                      x.selector,
                      x.handler
                    ),
                    this
                  )
                if (typeof d == 'object') {
                  for (D in d) this.off(D, A, d[D])
                  return this
                }
                return (
                  (A === !1 || typeof A == 'function') && ((I = A), (A = void 0)),
                  I === !1 && (I = gn),
                  this.each(function () {
                    g.event.remove(this, d, I, A)
                  })
                )
              },
            }))
          var Uh = /<script|<style|<link/i,
            Yh = /checked\s*(?:[^=]|=\s*.checked.)/i,
            uc = /^\s*<!\[CDATA\[|\]\]>\s*$/g
          function Ta(d, A) {
            return (
              (M(d, 'table') &&
                M(A.nodeType !== 11 ? A : A.firstChild, 'tr') &&
                g(d).children('tbody')[0]) ||
              d
            )
          }
          function Il(d) {
            return ((d.type = (d.getAttribute('type') !== null) + '/' + d.type), d)
          }
          function Ma(d) {
            return (
              (d.type || '').slice(0, 5) === 'true/'
                ? (d.type = d.type.slice(5))
                : d.removeAttribute('type'),
              d
            )
          }
          function Wr(d, A) {
            var I, x, D, L, k, tt, q
            if (A.nodeType === 1) {
              if (Bt.hasData(d) && ((L = Bt.get(d)), (q = L.events), q)) {
                Bt.remove(A, 'handle events')
                for (D in q) for (I = 0, x = q[D].length; I < x; I++) g.event.add(A, D, q[D][I])
              }
              ae.hasData(d) && ((k = ae.access(d)), (tt = g.extend({}, k)), ae.set(A, tt))
            }
          }
          function Is(d, A) {
            var I = A.nodeName.toLowerCase()
            I === 'input' && hi.test(d.type)
              ? (A.checked = d.checked)
              : (I === 'input' || I === 'textarea') && (A.defaultValue = d.defaultValue)
          }
          function Ni(d, A, I, x) {
            A = u(A)
            var D,
              L,
              k,
              tt,
              q,
              ot,
              xt = 0,
              Dt = d.length,
              vt = Dt - 1,
              _t = A[0],
              oe = T(_t)
            if (oe || (Dt > 1 && typeof _t == 'string' && !N.checkClone && Yh.test(_t)))
              return d.each(function (Te) {
                var ge = d.eq(Te)
                ;(oe && (A[0] = _t.call(this, Te, ge.html())), Ni(ge, A, I, x))
              })
            if (
              Dt &&
              ((D = lc(A, d[0].ownerDocument, !1, d, x)),
              (L = D.firstChild),
              D.childNodes.length === 1 && (D = L),
              L || x)
            ) {
              for (k = g.map(zn(D, 'script'), Il), tt = k.length; xt < Dt; xt++)
                ((q = D),
                  xt !== vt && ((q = g.clone(q, !0, !0)), tt && g.merge(k, zn(q, 'script'))),
                  I.call(d[xt], q, xt))
              if (tt)
                for (ot = k[k.length - 1].ownerDocument, g.map(k, Ma), xt = 0; xt < tt; xt++)
                  ((q = k[xt]),
                    As.test(q.type || '') &&
                      !Bt.access(q, 'globalEval') &&
                      g.contains(ot, q) &&
                      (q.src && (q.type || '').toLowerCase() !== 'module'
                        ? g._evalUrl &&
                          !q.noModule &&
                          g._evalUrl(q.src, { nonce: q.nonce || q.getAttribute('nonce') }, ot)
                        : H(q.textContent.replace(uc, ''), q, ot)))
            }
            return d
          }
          function pn(d, A, I) {
            for (var x, D = A ? g.filter(A, d) : d, L = 0; (x = D[L]) != null; L++)
              (!I && x.nodeType === 1 && g.cleanData(zn(x)),
                x.parentNode && (I && Ln(x) && bs(zn(x, 'script')), x.parentNode.removeChild(x)))
            return d
          }
          ;(g.extend({
            htmlPrefilter: function (d) {
              return d
            },
            clone: function (d, A, I) {
              var x,
                D,
                L,
                k,
                tt = d.cloneNode(!0),
                q = Ln(d)
              if (!N.noCloneChecked && (d.nodeType === 1 || d.nodeType === 11) && !g.isXMLDoc(d))
                for (k = zn(tt), L = zn(d), x = 0, D = L.length; x < D; x++) Is(L[x], k[x])
              if (A)
                if (I)
                  for (L = L || zn(d), k = k || zn(tt), x = 0, D = L.length; x < D; x++)
                    Wr(L[x], k[x])
                else Wr(d, tt)
              return ((k = zn(tt, 'script')), k.length > 0 && bs(k, !q && zn(d, 'script')), tt)
            },
            cleanData: function (d) {
              for (var A, I, x, D = g.event.special, L = 0; (I = d[L]) !== void 0; L++)
                if ($e(I)) {
                  if ((A = I[Bt.expando])) {
                    if (A.events)
                      for (x in A.events)
                        D[x] ? g.event.remove(I, x) : g.removeEvent(I, x, A.handle)
                    I[Bt.expando] = void 0
                  }
                  I[ae.expando] && (I[ae.expando] = void 0)
                }
            },
          }),
            g.fn.extend({
              detach: function (d) {
                return pn(this, d, !0)
              },
              remove: function (d) {
                return pn(this, d)
              },
              text: function (d) {
                return At(
                  this,
                  function (A) {
                    return A === void 0
                      ? g.text(this)
                      : this.empty().each(function () {
                          ;(this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) &&
                            (this.textContent = A)
                        })
                  },
                  null,
                  d,
                  arguments.length
                )
              },
              append: function () {
                return Ni(this, arguments, function (d) {
                  if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var A = Ta(this, d)
                    A.appendChild(d)
                  }
                })
              },
              prepend: function () {
                return Ni(this, arguments, function (d) {
                  if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var A = Ta(this, d)
                    A.insertBefore(d, A.firstChild)
                  }
                })
              },
              before: function () {
                return Ni(this, arguments, function (d) {
                  this.parentNode && this.parentNode.insertBefore(d, this)
                })
              },
              after: function () {
                return Ni(this, arguments, function (d) {
                  this.parentNode && this.parentNode.insertBefore(d, this.nextSibling)
                })
              },
              empty: function () {
                for (var d, A = 0; (d = this[A]) != null; A++)
                  d.nodeType === 1 && (g.cleanData(zn(d, !1)), (d.textContent = ''))
                return this
              },
              clone: function (d, A) {
                return (
                  (d = d ?? !1),
                  (A = A ?? d),
                  this.map(function () {
                    return g.clone(this, d, A)
                  })
                )
              },
              html: function (d) {
                return At(
                  this,
                  function (A) {
                    var I = this[0] || {},
                      x = 0,
                      D = this.length
                    if (A === void 0 && I.nodeType === 1) return I.innerHTML
                    if (
                      typeof A == 'string' &&
                      !Uh.test(A) &&
                      !en[(ys.exec(A) || ['', ''])[1].toLowerCase()]
                    ) {
                      A = g.htmlPrefilter(A)
                      try {
                        for (; x < D; x++)
                          ((I = this[x] || {}),
                            I.nodeType === 1 && (g.cleanData(zn(I, !1)), (I.innerHTML = A)))
                        I = 0
                      } catch {}
                    }
                    I && this.empty().append(A)
                  },
                  null,
                  d,
                  arguments.length
                )
              },
              replaceWith: function () {
                var d = []
                return Ni(
                  this,
                  arguments,
                  function (A) {
                    var I = this.parentNode
                    g.inArray(this, d) < 0 && (g.cleanData(zn(this)), I && I.replaceChild(A, this))
                  },
                  d
                )
              },
            }),
            g.each(
              {
                appendTo: 'append',
                prependTo: 'prepend',
                insertBefore: 'before',
                insertAfter: 'after',
                replaceAll: 'replaceWith',
              },
              function (d, A) {
                g.fn[d] = function (I) {
                  for (var x, D = [], L = g(I), k = L.length - 1, tt = 0; tt <= k; tt++)
                    ((x = tt === k ? this : this.clone(!0)), g(L[tt])[A](x), c.apply(D, x.get()))
                  return this.pushStack(D)
                }
              }
            ))
          var uo = new RegExp('^(' + Zn + ')(?!px)[a-z%]+$', 'i'),
            co = /^--/,
            Xi = function (d) {
              var A = d.ownerDocument.defaultView
              return ((!A || !A.opener) && (A = e), A.getComputedStyle(d))
            },
            Fr = function (d, A, I) {
              var x,
                D,
                L = {}
              for (D in A) ((L[D] = d.style[D]), (d.style[D] = A[D]))
              x = I.call(d)
              for (D in A) d.style[D] = L[D]
              return x
            },
            Hh = new RegExp(xn.join('|'), 'i')
          ;(function () {
            function d() {
              if (ot) {
                ;((q.style.cssText =
                  'position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0'),
                  (ot.style.cssText =
                    'position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%'),
                  Jn.appendChild(q).appendChild(ot))
                var xt = e.getComputedStyle(ot)
                ;((I = xt.top !== '1%'),
                  (tt = A(xt.marginLeft) === 12),
                  (ot.style.right = '60%'),
                  (L = A(xt.right) === 36),
                  (x = A(xt.width) === 36),
                  (ot.style.position = 'absolute'),
                  (D = A(ot.offsetWidth / 3) === 12),
                  Jn.removeChild(q),
                  (ot = null))
              }
            }
            function A(xt) {
              return Math.round(parseFloat(xt))
            }
            var I,
              x,
              D,
              L,
              k,
              tt,
              q = R.createElement('div'),
              ot = R.createElement('div')
            ot.style &&
              ((ot.style.backgroundClip = 'content-box'),
              (ot.cloneNode(!0).style.backgroundClip = ''),
              (N.clearCloneStyle = ot.style.backgroundClip === 'content-box'),
              g.extend(N, {
                boxSizingReliable: function () {
                  return (d(), x)
                },
                pixelBoxStyles: function () {
                  return (d(), L)
                },
                pixelPosition: function () {
                  return (d(), I)
                },
                reliableMarginLeft: function () {
                  return (d(), tt)
                },
                scrollboxSize: function () {
                  return (d(), D)
                },
                reliableTrDimensions: function () {
                  var xt, Dt, vt, _t
                  return (
                    k == null &&
                      ((xt = R.createElement('table')),
                      (Dt = R.createElement('tr')),
                      (vt = R.createElement('div')),
                      (xt.style.cssText =
                        'position:absolute;left:-11111px;border-collapse:separate'),
                      (Dt.style.cssText = 'box-sizing:content-box;border:1px solid'),
                      (Dt.style.height = '1px'),
                      (vt.style.height = '9px'),
                      (vt.style.display = 'block'),
                      Jn.appendChild(xt).appendChild(Dt).appendChild(vt),
                      (_t = e.getComputedStyle(Dt)),
                      (k =
                        parseInt(_t.height, 10) +
                          parseInt(_t.borderTopWidth, 10) +
                          parseInt(_t.borderBottomWidth, 10) ===
                        Dt.offsetHeight),
                      Jn.removeChild(xt)),
                    k
                  )
                },
              }))
          })()
          function Ea(d, A, I) {
            var x,
              D,
              L,
              k,
              tt = co.test(A),
              q = d.style
            return (
              (I = I || Xi(d)),
              I &&
                ((k = I.getPropertyValue(A) || I[A]),
                tt && k && (k = k.replace(Ct, '$1') || void 0),
                k === '' && !Ln(d) && (k = g.style(d, A)),
                !N.pixelBoxStyles() &&
                  uo.test(k) &&
                  Hh.test(A) &&
                  ((x = q.width),
                  (D = q.minWidth),
                  (L = q.maxWidth),
                  (q.minWidth = q.maxWidth = q.width = k),
                  (k = I.width),
                  (q.width = x),
                  (q.minWidth = D),
                  (q.maxWidth = L))),
              k !== void 0 ? k + '' : k
            )
          }
          function Cl(d, A) {
            return {
              get: function () {
                if (d()) {
                  delete this.get
                  return
                }
                return (this.get = A).apply(this, arguments)
              },
            }
          }
          var cc = ['Webkit', 'Moz', 'ms'],
            Cs = R.createElement('div').style,
            ws = {}
          function gr(d) {
            for (var A = d[0].toUpperCase() + d.slice(1), I = cc.length; I--; )
              if (((d = cc[I] + A), d in Cs)) return d
          }
          function xs(d) {
            var A = g.cssProps[d] || ws[d]
            return A || (d in Cs ? d : (ws[d] = gr(d) || d))
          }
          var fc = /^(none|table(?!-c[ea]).+)/,
            Da = { position: 'absolute', visibility: 'hidden', display: 'block' },
            fo = { letterSpacing: '0', fontWeight: '400' }
          function ho(d, A, I) {
            var x = wi.exec(A)
            return x ? Math.max(0, x[2] - (I || 0)) + (x[3] || 'px') : A
          }
          function wl(d, A, I, x, D, L) {
            var k = A === 'width' ? 1 : 0,
              tt = 0,
              q = 0,
              ot = 0
            if (I === (x ? 'border' : 'content')) return 0
            for (; k < 4; k += 2)
              (I === 'margin' && (ot += g.css(d, I + xn[k], !0, D)),
                x
                  ? (I === 'content' && (q -= g.css(d, 'padding' + xn[k], !0, D)),
                    I !== 'margin' && (q -= g.css(d, 'border' + xn[k] + 'Width', !0, D)))
                  : ((q += g.css(d, 'padding' + xn[k], !0, D)),
                    I !== 'padding'
                      ? (q += g.css(d, 'border' + xn[k] + 'Width', !0, D))
                      : (tt += g.css(d, 'border' + xn[k] + 'Width', !0, D))))
            return (
              !x &&
                L >= 0 &&
                (q +=
                  Math.max(
                    0,
                    Math.ceil(d['offset' + A[0].toUpperCase() + A.slice(1)] - L - q - tt - 0.5)
                  ) || 0),
              q + ot
            )
          }
          function xl(d, A, I) {
            var x = Xi(d),
              D = !N.boxSizingReliable() || I,
              L = D && g.css(d, 'boxSizing', !1, x) === 'border-box',
              k = L,
              tt = Ea(d, A, x),
              q = 'offset' + A[0].toUpperCase() + A.slice(1)
            if (uo.test(tt)) {
              if (!I) return tt
              tt = 'auto'
            }
            return (
              ((!N.boxSizingReliable() && L) ||
                (!N.reliableTrDimensions() && M(d, 'tr')) ||
                tt === 'auto' ||
                (!parseFloat(tt) && g.css(d, 'display', !1, x) === 'inline')) &&
                d.getClientRects().length &&
                ((L = g.css(d, 'boxSizing', !1, x) === 'border-box'),
                (k = q in d),
                k && (tt = d[q])),
              (tt = parseFloat(tt) || 0),
              tt + wl(d, A, I || (L ? 'border' : 'content'), k, x, tt) + 'px'
            )
          }
          ;(g.extend({
            cssHooks: {
              opacity: {
                get: function (d, A) {
                  if (A) {
                    var I = Ea(d, 'opacity')
                    return I === '' ? '1' : I
                  }
                },
              },
            },
            cssNumber: {
              animationIterationCount: !0,
              aspectRatio: !0,
              borderImageSlice: !0,
              columnCount: !0,
              flexGrow: !0,
              flexShrink: !0,
              fontWeight: !0,
              gridArea: !0,
              gridColumn: !0,
              gridColumnEnd: !0,
              gridColumnStart: !0,
              gridRow: !0,
              gridRowEnd: !0,
              gridRowStart: !0,
              lineHeight: !0,
              opacity: !0,
              order: !0,
              orphans: !0,
              scale: !0,
              widows: !0,
              zIndex: !0,
              zoom: !0,
              fillOpacity: !0,
              floodOpacity: !0,
              stopOpacity: !0,
              strokeMiterlimit: !0,
              strokeOpacity: !0,
            },
            cssProps: {},
            style: function (d, A, I, x) {
              if (!(!d || d.nodeType === 3 || d.nodeType === 8 || !d.style)) {
                var D,
                  L,
                  k,
                  tt = Se(A),
                  q = co.test(A),
                  ot = d.style
                if ((q || (A = xs(tt)), (k = g.cssHooks[A] || g.cssHooks[tt]), I !== void 0)) {
                  if (
                    ((L = typeof I),
                    L === 'string' &&
                      (D = wi.exec(I)) &&
                      D[1] &&
                      ((I = ms(d, A, D)), (L = 'number')),
                    I == null || I !== I)
                  )
                    return
                  ;(L === 'number' && !q && (I += (D && D[3]) || (g.cssNumber[tt] ? '' : 'px')),
                    !N.clearCloneStyle &&
                      I === '' &&
                      A.indexOf('background') === 0 &&
                      (ot[A] = 'inherit'),
                    (!k || !('set' in k) || (I = k.set(d, I, x)) !== void 0) &&
                      (q ? ot.setProperty(A, I) : (ot[A] = I)))
                } else return k && 'get' in k && (D = k.get(d, !1, x)) !== void 0 ? D : ot[A]
              }
            },
            css: function (d, A, I, x) {
              var D,
                L,
                k,
                tt = Se(A),
                q = co.test(A)
              return (
                q || (A = xs(tt)),
                (k = g.cssHooks[A] || g.cssHooks[tt]),
                k && 'get' in k && (D = k.get(d, !0, I)),
                D === void 0 && (D = Ea(d, A, x)),
                D === 'normal' && A in fo && (D = fo[A]),
                I === '' || I ? ((L = parseFloat(D)), I === !0 || isFinite(L) ? L || 0 : D) : D
              )
            },
          }),
            g.each(['height', 'width'], function (d, A) {
              g.cssHooks[A] = {
                get: function (I, x, D) {
                  if (x)
                    return fc.test(g.css(I, 'display')) &&
                      (!I.getClientRects().length || !I.getBoundingClientRect().width)
                      ? Fr(I, Da, function () {
                          return xl(I, A, D)
                        })
                      : xl(I, A, D)
                },
                set: function (I, x, D) {
                  var L,
                    k = Xi(I),
                    tt = !N.scrollboxSize() && k.position === 'absolute',
                    q = tt || D,
                    ot = q && g.css(I, 'boxSizing', !1, k) === 'border-box',
                    xt = D ? wl(I, A, D, ot, k) : 0
                  return (
                    ot &&
                      tt &&
                      (xt -= Math.ceil(
                        I['offset' + A[0].toUpperCase() + A.slice(1)] -
                          parseFloat(k[A]) -
                          wl(I, A, 'border', !1, k) -
                          0.5
                      )),
                    xt &&
                      (L = wi.exec(x)) &&
                      (L[3] || 'px') !== 'px' &&
                      ((I.style[A] = x), (x = g.css(I, A))),
                    ho(I, x, xt)
                  )
                },
              }
            }),
            (g.cssHooks.marginLeft = Cl(N.reliableMarginLeft, function (d, A) {
              if (A)
                return (
                  (parseFloat(Ea(d, 'marginLeft')) ||
                    d.getBoundingClientRect().left -
                      Fr(d, { marginLeft: 0 }, function () {
                        return d.getBoundingClientRect().left
                      })) + 'px'
                )
            })),
            g.each({ margin: '', padding: '', border: 'Width' }, function (d, A) {
              ;((g.cssHooks[d + A] = {
                expand: function (I) {
                  for (var x = 0, D = {}, L = typeof I == 'string' ? I.split(' ') : [I]; x < 4; x++)
                    D[d + xn[x] + A] = L[x] || L[x - 2] || L[0]
                  return D
                },
              }),
                d !== 'margin' && (g.cssHooks[d + A].set = ho))
            }),
            g.fn.extend({
              css: function (d, A) {
                return At(
                  this,
                  function (I, x, D) {
                    var L,
                      k,
                      tt = {},
                      q = 0
                    if (Array.isArray(x)) {
                      for (L = Xi(I), k = x.length; q < k; q++) tt[x[q]] = g.css(I, x[q], !1, L)
                      return tt
                    }
                    return D !== void 0 ? g.style(I, x, D) : g.css(I, x)
                  },
                  d,
                  A,
                  arguments.length > 1
                )
              },
            }))
          function Qe(d, A, I, x, D) {
            return new Qe.prototype.init(d, A, I, x, D)
          }
          ;((g.Tween = Qe),
            (Qe.prototype = {
              constructor: Qe,
              init: function (d, A, I, x, D, L) {
                ;((this.elem = d),
                  (this.prop = I),
                  (this.easing = D || g.easing._default),
                  (this.options = A),
                  (this.start = this.now = this.cur()),
                  (this.end = x),
                  (this.unit = L || (g.cssNumber[I] ? '' : 'px')))
              },
              cur: function () {
                var d = Qe.propHooks[this.prop]
                return d && d.get ? d.get(this) : Qe.propHooks._default.get(this)
              },
              run: function (d) {
                var A,
                  I = Qe.propHooks[this.prop]
                return (
                  this.options.duration
                    ? (this.pos = A =
                        g.easing[this.easing](
                          d,
                          this.options.duration * d,
                          0,
                          1,
                          this.options.duration
                        ))
                    : (this.pos = A = d),
                  (this.now = (this.end - this.start) * A + this.start),
                  this.options.step && this.options.step.call(this.elem, this.now, this),
                  I && I.set ? I.set(this) : Qe.propHooks._default.set(this),
                  this
                )
              },
            }),
            (Qe.prototype.init.prototype = Qe.prototype),
            (Qe.propHooks = {
              _default: {
                get: function (d) {
                  var A
                  return d.elem.nodeType !== 1 ||
                    (d.elem[d.prop] != null && d.elem.style[d.prop] == null)
                    ? d.elem[d.prop]
                    : ((A = g.css(d.elem, d.prop, '')), !A || A === 'auto' ? 0 : A)
                },
                set: function (d) {
                  g.fx.step[d.prop]
                    ? g.fx.step[d.prop](d)
                    : d.elem.nodeType === 1 &&
                        (g.cssHooks[d.prop] || d.elem.style[xs(d.prop)] != null)
                      ? g.style(d.elem, d.prop, d.now + d.unit)
                      : (d.elem[d.prop] = d.now)
                },
              },
            }),
            (Qe.propHooks.scrollTop = Qe.propHooks.scrollLeft =
              {
                set: function (d) {
                  d.elem.nodeType && d.elem.parentNode && (d.elem[d.prop] = d.now)
                },
              }),
            (g.easing = {
              linear: function (d) {
                return d
              },
              swing: function (d) {
                return 0.5 - Math.cos(d * Math.PI) / 2
              },
              _default: 'swing',
            }),
            (g.fx = Qe.prototype.init),
            (g.fx.step = {}))
          var Jr,
            go,
            po = /^(?:toggle|show|hide)$/,
            hc = /queueHooks$/
          function Oa() {
            go &&
              (R.hidden === !1 && e.requestAnimationFrame
                ? e.requestAnimationFrame(Oa)
                : e.setTimeout(Oa, g.fx.interval),
              g.fx.tick())
          }
          function dc() {
            return (
              e.setTimeout(function () {
                Jr = void 0
              }),
              (Jr = Date.now())
            )
          }
          function Un(d, A) {
            var I,
              x = 0,
              D = { height: d }
            for (A = A ? 1 : 0; x < 4; x += 2 - A)
              ((I = xn[x]), (D['margin' + I] = D['padding' + I] = d))
            return (A && (D.opacity = D.width = d), D)
          }
          function vo(d, A, I) {
            for (
              var x, D = (Rn.tweeners[A] || []).concat(Rn.tweeners['*']), L = 0, k = D.length;
              L < k;
              L++
            )
              if ((x = D[L].call(I, A, d))) return x
          }
          function gc(d, A, I) {
            var x,
              D,
              L,
              k,
              tt,
              q,
              ot,
              xt,
              Dt = 'width' in A || 'height' in A,
              vt = this,
              _t = {},
              oe = d.style,
              Te = d.nodeType && xi(d),
              ge = Bt.get(d, 'fxshow')
            I.queue ||
              ((k = g._queueHooks(d, 'fx')),
              k.unqueued == null &&
                ((k.unqueued = 0),
                (tt = k.empty.fire),
                (k.empty.fire = function () {
                  k.unqueued || tt()
                })),
              k.unqueued++,
              vt.always(function () {
                vt.always(function () {
                  ;(k.unqueued--, g.queue(d, 'fx').length || k.empty.fire())
                })
              }))
            for (x in A)
              if (((D = A[x]), po.test(D))) {
                if ((delete A[x], (L = L || D === 'toggle'), D === (Te ? 'hide' : 'show')))
                  if (D === 'show' && ge && ge[x] !== void 0) Te = !0
                  else continue
                _t[x] = (ge && ge[x]) || g.style(d, x)
              }
            if (((q = !g.isEmptyObject(A)), !(!q && g.isEmptyObject(_t)))) {
              ;(Dt &&
                d.nodeType === 1 &&
                ((I.overflow = [oe.overflow, oe.overflowX, oe.overflowY]),
                (ot = ge && ge.display),
                ot == null && (ot = Bt.get(d, 'display')),
                (xt = g.css(d, 'display')),
                xt === 'none' &&
                  (ot
                    ? (xt = ot)
                    : (Si([d], !0),
                      (ot = d.style.display || ot),
                      (xt = g.css(d, 'display')),
                      Si([d]))),
                (xt === 'inline' || (xt === 'inline-block' && ot != null)) &&
                  g.css(d, 'float') === 'none' &&
                  (q ||
                    (vt.done(function () {
                      oe.display = ot
                    }),
                    ot == null && ((xt = oe.display), (ot = xt === 'none' ? '' : xt))),
                  (oe.display = 'inline-block'))),
                I.overflow &&
                  ((oe.overflow = 'hidden'),
                  vt.always(function () {
                    ;((oe.overflow = I.overflow[0]),
                      (oe.overflowX = I.overflow[1]),
                      (oe.overflowY = I.overflow[2]))
                  })),
                (q = !1))
              for (x in _t)
                (q ||
                  (ge
                    ? 'hidden' in ge && (Te = ge.hidden)
                    : (ge = Bt.access(d, 'fxshow', { display: ot })),
                  L && (ge.hidden = !Te),
                  Te && Si([d], !0),
                  vt.done(function () {
                    ;(Te || Si([d]), Bt.remove(d, 'fxshow'))
                    for (x in _t) g.style(d, x, _t[x])
                  })),
                  (q = vo(Te ? ge[x] : 0, x, vt)),
                  x in ge || ((ge[x] = q.start), Te && ((q.end = q.start), (q.start = 0))))
            }
          }
          function Sl(d, A) {
            var I, x, D, L, k
            for (I in d)
              if (
                ((x = Se(I)),
                (D = A[x]),
                (L = d[I]),
                Array.isArray(L) && ((D = L[1]), (L = d[I] = L[0])),
                I !== x && ((d[x] = L), delete d[I]),
                (k = g.cssHooks[x]),
                k && 'expand' in k)
              ) {
                ;((L = k.expand(L)), delete d[x])
                for (I in L) I in d || ((d[I] = L[I]), (A[I] = D))
              } else A[x] = D
          }
          function Rn(d, A, I) {
            var x,
              D,
              L = 0,
              k = Rn.prefilters.length,
              tt = g.Deferred().always(function () {
                delete q.elem
              }),
              q = function () {
                if (D) return !1
                for (
                  var Dt = Jr || dc(),
                    vt = Math.max(0, ot.startTime + ot.duration - Dt),
                    _t = vt / ot.duration || 0,
                    oe = 1 - _t,
                    Te = 0,
                    ge = ot.tweens.length;
                  Te < ge;
                  Te++
                )
                  ot.tweens[Te].run(oe)
                return (
                  tt.notifyWith(d, [ot, oe, vt]),
                  oe < 1 && ge
                    ? vt
                    : (ge || tt.notifyWith(d, [ot, 1, 0]), tt.resolveWith(d, [ot]), !1)
                )
              },
              ot = tt.promise({
                elem: d,
                props: g.extend({}, A),
                opts: g.extend(!0, { specialEasing: {}, easing: g.easing._default }, I),
                originalProperties: A,
                originalOptions: I,
                startTime: Jr || dc(),
                duration: I.duration,
                tweens: [],
                createTween: function (Dt, vt) {
                  var _t = g.Tween(d, ot.opts, Dt, vt, ot.opts.specialEasing[Dt] || ot.opts.easing)
                  return (ot.tweens.push(_t), _t)
                },
                stop: function (Dt) {
                  var vt = 0,
                    _t = Dt ? ot.tweens.length : 0
                  if (D) return this
                  for (D = !0; vt < _t; vt++) ot.tweens[vt].run(1)
                  return (
                    Dt
                      ? (tt.notifyWith(d, [ot, 1, 0]), tt.resolveWith(d, [ot, Dt]))
                      : tt.rejectWith(d, [ot, Dt]),
                    this
                  )
                },
              }),
              xt = ot.props
            for (Sl(xt, ot.opts.specialEasing); L < k; L++)
              if (((x = Rn.prefilters[L].call(ot, d, xt, ot.opts)), x))
                return (
                  T(x.stop) && (g._queueHooks(ot.elem, ot.opts.queue).stop = x.stop.bind(x)),
                  x
                )
            return (
              g.map(xt, vo, ot),
              T(ot.opts.start) && ot.opts.start.call(d, ot),
              ot
                .progress(ot.opts.progress)
                .done(ot.opts.done, ot.opts.complete)
                .fail(ot.opts.fail)
                .always(ot.opts.always),
              g.fx.timer(g.extend(q, { elem: d, anim: ot, queue: ot.opts.queue })),
              ot
            )
          }
          ;((g.Animation = g.extend(Rn, {
            tweeners: {
              '*': [
                function (d, A) {
                  var I = this.createTween(d, A)
                  return (ms(I.elem, d, wi.exec(A), I), I)
                },
              ],
            },
            tweener: function (d, A) {
              T(d) ? ((A = d), (d = ['*'])) : (d = d.match(Qt))
              for (var I, x = 0, D = d.length; x < D; x++)
                ((I = d[x]), (Rn.tweeners[I] = Rn.tweeners[I] || []), Rn.tweeners[I].unshift(A))
            },
            prefilters: [gc],
            prefilter: function (d, A) {
              A ? Rn.prefilters.unshift(d) : Rn.prefilters.push(d)
            },
          })),
            (g.speed = function (d, A, I) {
              var x =
                d && typeof d == 'object'
                  ? g.extend({}, d)
                  : {
                      complete: I || (!I && A) || (T(d) && d),
                      duration: d,
                      easing: (I && A) || (A && !T(A) && A),
                    }
              return (
                g.fx.off
                  ? (x.duration = 0)
                  : typeof x.duration != 'number' &&
                    (x.duration in g.fx.speeds
                      ? (x.duration = g.fx.speeds[x.duration])
                      : (x.duration = g.fx.speeds._default)),
                (x.queue == null || x.queue === !0) && (x.queue = 'fx'),
                (x.old = x.complete),
                (x.complete = function () {
                  ;(T(x.old) && x.old.call(this), x.queue && g.dequeue(this, x.queue))
                }),
                x
              )
            }),
            g.fn.extend({
              fadeTo: function (d, A, I, x) {
                return this.filter(xi)
                  .css('opacity', 0)
                  .show()
                  .end()
                  .animate({ opacity: A }, d, I, x)
              },
              animate: function (d, A, I, x) {
                var D = g.isEmptyObject(d),
                  L = g.speed(A, I, x),
                  k = function () {
                    var tt = Rn(this, g.extend({}, d), L)
                    ;(D || Bt.get(this, 'finish')) && tt.stop(!0)
                  }
                return ((k.finish = k), D || L.queue === !1 ? this.each(k) : this.queue(L.queue, k))
              },
              stop: function (d, A, I) {
                var x = function (D) {
                  var L = D.stop
                  ;(delete D.stop, L(I))
                }
                return (
                  typeof d != 'string' && ((I = A), (A = d), (d = void 0)),
                  A && this.queue(d || 'fx', []),
                  this.each(function () {
                    var D = !0,
                      L = d != null && d + 'queueHooks',
                      k = g.timers,
                      tt = Bt.get(this)
                    if (L) tt[L] && tt[L].stop && x(tt[L])
                    else for (L in tt) tt[L] && tt[L].stop && hc.test(L) && x(tt[L])
                    for (L = k.length; L--; )
                      k[L].elem === this &&
                        (d == null || k[L].queue === d) &&
                        (k[L].anim.stop(I), (D = !1), k.splice(L, 1))
                    ;(D || !I) && g.dequeue(this, d)
                  })
                )
              },
              finish: function (d) {
                return (
                  d !== !1 && (d = d || 'fx'),
                  this.each(function () {
                    var A,
                      I = Bt.get(this),
                      x = I[d + 'queue'],
                      D = I[d + 'queueHooks'],
                      L = g.timers,
                      k = x ? x.length : 0
                    for (
                      I.finish = !0,
                        g.queue(this, d, []),
                        D && D.stop && D.stop.call(this, !0),
                        A = L.length;
                      A--;

                    )
                      L[A].elem === this && L[A].queue === d && (L[A].anim.stop(!0), L.splice(A, 1))
                    for (A = 0; A < k; A++) x[A] && x[A].finish && x[A].finish.call(this)
                    delete I.finish
                  })
                )
              },
            }),
            g.each(['toggle', 'show', 'hide'], function (d, A) {
              var I = g.fn[A]
              g.fn[A] = function (x, D, L) {
                return x == null || typeof x == 'boolean'
                  ? I.apply(this, arguments)
                  : this.animate(Un(A, !0), x, D, L)
              }
            }),
            g.each(
              {
                slideDown: Un('show'),
                slideUp: Un('hide'),
                slideToggle: Un('toggle'),
                fadeIn: { opacity: 'show' },
                fadeOut: { opacity: 'hide' },
                fadeToggle: { opacity: 'toggle' },
              },
              function (d, A) {
                g.fn[d] = function (I, x, D) {
                  return this.animate(A, I, x, D)
                }
              }
            ),
            (g.timers = []),
            (g.fx.tick = function () {
              var d,
                A = 0,
                I = g.timers
              for (Jr = Date.now(); A < I.length; A++)
                ((d = I[A]), !d() && I[A] === d && I.splice(A--, 1))
              ;(I.length || g.fx.stop(), (Jr = void 0))
            }),
            (g.fx.timer = function (d) {
              ;(g.timers.push(d), g.fx.start())
            }),
            (g.fx.interval = 13),
            (g.fx.start = function () {
              go || ((go = !0), Oa())
            }),
            (g.fx.stop = function () {
              go = null
            }),
            (g.fx.speeds = { slow: 600, fast: 200, _default: 400 }),
            (g.fn.delay = function (d, A) {
              return (
                (d = (g.fx && g.fx.speeds[d]) || d),
                (A = A || 'fx'),
                this.queue(A, function (I, x) {
                  var D = e.setTimeout(I, d)
                  x.stop = function () {
                    e.clearTimeout(D)
                  }
                })
              )
            }),
            (function () {
              var d = R.createElement('input'),
                A = R.createElement('select'),
                I = A.appendChild(R.createElement('option'))
              ;((d.type = 'checkbox'),
                (N.checkOn = d.value !== ''),
                (N.optSelected = I.selected),
                (d = R.createElement('input')),
                (d.value = 't'),
                (d.type = 'radio'),
                (N.radioValue = d.value === 't'))
            })())
          var Nl,
            La = g.expr.attrHandle
          ;(g.fn.extend({
            attr: function (d, A) {
              return At(this, g.attr, d, A, arguments.length > 1)
            },
            removeAttr: function (d) {
              return this.each(function () {
                g.removeAttr(this, d)
              })
            },
          }),
            g.extend({
              attr: function (d, A, I) {
                var x,
                  D,
                  L = d.nodeType
                if (!(L === 3 || L === 8 || L === 2)) {
                  if (typeof d.getAttribute > 'u') return g.prop(d, A, I)
                  if (
                    ((L !== 1 || !g.isXMLDoc(d)) &&
                      (D =
                        g.attrHooks[A.toLowerCase()] || (g.expr.match.bool.test(A) ? Nl : void 0)),
                    I !== void 0)
                  ) {
                    if (I === null) {
                      g.removeAttr(d, A)
                      return
                    }
                    return D && 'set' in D && (x = D.set(d, I, A)) !== void 0
                      ? x
                      : (d.setAttribute(A, I + ''), I)
                  }
                  return D && 'get' in D && (x = D.get(d, A)) !== null
                    ? x
                    : ((x = g.find.attr(d, A)), x ?? void 0)
                }
              },
              attrHooks: {
                type: {
                  set: function (d, A) {
                    if (!N.radioValue && A === 'radio' && M(d, 'input')) {
                      var I = d.value
                      return (d.setAttribute('type', A), I && (d.value = I), A)
                    }
                  },
                },
              },
              removeAttr: function (d, A) {
                var I,
                  x = 0,
                  D = A && A.match(Qt)
                if (D && d.nodeType === 1) for (; (I = D[x++]); ) d.removeAttribute(I)
              },
            }),
            (Nl = {
              set: function (d, A, I) {
                return (A === !1 ? g.removeAttr(d, I) : d.setAttribute(I, I), I)
              },
            }),
            g.each(g.expr.match.bool.source.match(/\w+/g), function (d, A) {
              var I = La[A] || g.find.attr
              La[A] = function (x, D, L) {
                var k,
                  tt,
                  q = D.toLowerCase()
                return (
                  L ||
                    ((tt = La[q]), (La[q] = k), (k = I(x, D, L) != null ? q : null), (La[q] = tt)),
                  k
                )
              }
            }))
          var za = /^(?:input|select|textarea|button)$/i,
            Vh = /^(?:a|area)$/i
          ;(g.fn.extend({
            prop: function (d, A) {
              return At(this, g.prop, d, A, arguments.length > 1)
            },
            removeProp: function (d) {
              return this.each(function () {
                delete this[g.propFix[d] || d]
              })
            },
          }),
            g.extend({
              prop: function (d, A, I) {
                var x,
                  D,
                  L = d.nodeType
                if (!(L === 3 || L === 8 || L === 2))
                  return (
                    (L !== 1 || !g.isXMLDoc(d)) && ((A = g.propFix[A] || A), (D = g.propHooks[A])),
                    I !== void 0
                      ? D && 'set' in D && (x = D.set(d, I, A)) !== void 0
                        ? x
                        : (d[A] = I)
                      : D && 'get' in D && (x = D.get(d, A)) !== null
                        ? x
                        : d[A]
                  )
              },
              propHooks: {
                tabIndex: {
                  get: function (d) {
                    var A = g.find.attr(d, 'tabindex')
                    return A
                      ? parseInt(A, 10)
                      : za.test(d.nodeName) || (Vh.test(d.nodeName) && d.href)
                        ? 0
                        : -1
                  },
                },
              },
              propFix: { for: 'htmlFor', class: 'className' },
            }),
            N.optSelected ||
              (g.propHooks.selected = {
                get: function (d) {
                  var A = d.parentNode
                  return (A && A.parentNode && A.parentNode.selectedIndex, null)
                },
                set: function (d) {
                  var A = d.parentNode
                  A && (A.selectedIndex, A.parentNode && A.parentNode.selectedIndex)
                },
              }),
            g.each(
              [
                'tabIndex',
                'readOnly',
                'maxLength',
                'cellSpacing',
                'cellPadding',
                'rowSpan',
                'colSpan',
                'useMap',
                'frameBorder',
                'contentEditable',
              ],
              function () {
                g.propFix[this.toLowerCase()] = this
              }
            ))
          function zr(d) {
            var A = d.match(Qt) || []
            return A.join(' ')
          }
          function Rr(d) {
            return (d.getAttribute && d.getAttribute('class')) || ''
          }
          function Ss(d) {
            return Array.isArray(d) ? d : typeof d == 'string' ? d.match(Qt) || [] : []
          }
          g.fn.extend({
            addClass: function (d) {
              var A, I, x, D, L, k
              return T(d)
                ? this.each(function (tt) {
                    g(this).addClass(d.call(this, tt, Rr(this)))
                  })
                : ((A = Ss(d)),
                  A.length
                    ? this.each(function () {
                        if (((x = Rr(this)), (I = this.nodeType === 1 && ' ' + zr(x) + ' '), I)) {
                          for (L = 0; L < A.length; L++)
                            ((D = A[L]), I.indexOf(' ' + D + ' ') < 0 && (I += D + ' '))
                          ;((k = zr(I)), x !== k && this.setAttribute('class', k))
                        }
                      })
                    : this)
            },
            removeClass: function (d) {
              var A, I, x, D, L, k
              return T(d)
                ? this.each(function (tt) {
                    g(this).removeClass(d.call(this, tt, Rr(this)))
                  })
                : arguments.length
                  ? ((A = Ss(d)),
                    A.length
                      ? this.each(function () {
                          if (((x = Rr(this)), (I = this.nodeType === 1 && ' ' + zr(x) + ' '), I)) {
                            for (L = 0; L < A.length; L++)
                              for (D = A[L]; I.indexOf(' ' + D + ' ') > -1; )
                                I = I.replace(' ' + D + ' ', ' ')
                            ;((k = zr(I)), x !== k && this.setAttribute('class', k))
                          }
                        })
                      : this)
                  : this.attr('class', '')
            },
            toggleClass: function (d, A) {
              var I,
                x,
                D,
                L,
                k = typeof d,
                tt = k === 'string' || Array.isArray(d)
              return T(d)
                ? this.each(function (q) {
                    g(this).toggleClass(d.call(this, q, Rr(this), A), A)
                  })
                : typeof A == 'boolean' && tt
                  ? A
                    ? this.addClass(d)
                    : this.removeClass(d)
                  : ((I = Ss(d)),
                    this.each(function () {
                      if (tt)
                        for (L = g(this), D = 0; D < I.length; D++)
                          ((x = I[D]), L.hasClass(x) ? L.removeClass(x) : L.addClass(x))
                      else
                        (d === void 0 || k === 'boolean') &&
                          ((x = Rr(this)),
                          x && Bt.set(this, '__className__', x),
                          this.setAttribute &&
                            this.setAttribute(
                              'class',
                              x || d === !1 ? '' : Bt.get(this, '__className__') || ''
                            ))
                    }))
            },
            hasClass: function (d) {
              var A,
                I,
                x = 0
              for (A = ' ' + d + ' '; (I = this[x++]); )
                if (I.nodeType === 1 && (' ' + zr(Rr(I)) + ' ').indexOf(A) > -1) return !0
              return !1
            },
          })
          var Xh = /\r/g
          ;(g.fn.extend({
            val: function (d) {
              var A,
                I,
                x,
                D = this[0]
              return arguments.length
                ? ((x = T(d)),
                  this.each(function (L) {
                    var k
                    this.nodeType === 1 &&
                      (x ? (k = d.call(this, L, g(this).val())) : (k = d),
                      k == null
                        ? (k = '')
                        : typeof k == 'number'
                          ? (k += '')
                          : Array.isArray(k) &&
                            (k = g.map(k, function (tt) {
                              return tt == null ? '' : tt + ''
                            })),
                      (A = g.valHooks[this.type] || g.valHooks[this.nodeName.toLowerCase()]),
                      (!A || !('set' in A) || A.set(this, k, 'value') === void 0) &&
                        (this.value = k))
                  }))
                : D
                  ? ((A = g.valHooks[D.type] || g.valHooks[D.nodeName.toLowerCase()]),
                    A && 'get' in A && (I = A.get(D, 'value')) !== void 0
                      ? I
                      : ((I = D.value), typeof I == 'string' ? I.replace(Xh, '') : (I ?? '')))
                  : void 0
            },
          }),
            g.extend({
              valHooks: {
                option: {
                  get: function (d) {
                    var A = g.find.attr(d, 'value')
                    return A ?? zr(g.text(d))
                  },
                },
                select: {
                  get: function (d) {
                    var A,
                      I,
                      x,
                      D = d.options,
                      L = d.selectedIndex,
                      k = d.type === 'select-one',
                      tt = k ? null : [],
                      q = k ? L + 1 : D.length
                    for (L < 0 ? (x = q) : (x = k ? L : 0); x < q; x++)
                      if (
                        ((I = D[x]),
                        (I.selected || x === L) &&
                          !I.disabled &&
                          (!I.parentNode.disabled || !M(I.parentNode, 'optgroup')))
                      ) {
                        if (((A = g(I).val()), k)) return A
                        tt.push(A)
                      }
                    return tt
                  },
                  set: function (d, A) {
                    for (var I, x, D = d.options, L = g.makeArray(A), k = D.length; k--; )
                      ((x = D[k]),
                        (x.selected = g.inArray(g.valHooks.option.get(x), L) > -1) && (I = !0))
                    return (I || (d.selectedIndex = -1), L)
                  },
                },
              },
            }),
            g.each(['radio', 'checkbox'], function () {
              ;((g.valHooks[this] = {
                set: function (d, A) {
                  if (Array.isArray(A)) return (d.checked = g.inArray(g(d).val(), A) > -1)
                },
              }),
                N.checkOn ||
                  (g.valHooks[this].get = function (d) {
                    return d.getAttribute('value') === null ? 'on' : d.value
                  }))
            }))
          var Ns = e.location,
            Ts = { guid: Date.now() },
            Ms = /\?/
          g.parseXML = function (d) {
            var A, I
            if (!d || typeof d != 'string') return null
            try {
              A = new e.DOMParser().parseFromString(d, 'text/xml')
            } catch {}
            return (
              (I = A && A.getElementsByTagName('parsererror')[0]),
              (!A || I) &&
                g.error(
                  'Invalid XML: ' +
                    (I
                      ? g.map(I.childNodes, function (x) {
                          return x.textContent
                        }).join(`
`)
                      : d)
                ),
              A
            )
          }
          var mo = /^(?:focusinfocus|focusoutblur)$/,
            qr = function (d) {
              d.stopPropagation()
            }
          ;(g.extend(g.event, {
            trigger: function (d, A, I, x) {
              var D,
                L,
                k,
                tt,
                q,
                ot,
                xt,
                Dt,
                vt = [I || R],
                _t = v.call(d, 'type') ? d.type : d,
                oe = v.call(d, 'namespace') ? d.namespace.split('.') : []
              if (
                ((L = Dt = k = I = I || R),
                !(I.nodeType === 3 || I.nodeType === 8) &&
                  !mo.test(_t + g.event.triggered) &&
                  (_t.indexOf('.') > -1 && ((oe = _t.split('.')), (_t = oe.shift()), oe.sort()),
                  (q = _t.indexOf(':') < 0 && 'on' + _t),
                  (d = d[g.expando] ? d : new g.Event(_t, typeof d == 'object' && d)),
                  (d.isTrigger = x ? 2 : 3),
                  (d.namespace = oe.join('.')),
                  (d.rnamespace = d.namespace
                    ? new RegExp('(^|\\.)' + oe.join('\\.(?:.*\\.|)') + '(\\.|$)')
                    : null),
                  (d.result = void 0),
                  d.target || (d.target = I),
                  (A = A == null ? [d] : g.makeArray(A, [d])),
                  (xt = g.event.special[_t] || {}),
                  !(!x && xt.trigger && xt.trigger.apply(I, A) === !1)))
              ) {
                if (!x && !xt.noBubble && !z(I)) {
                  for (
                    tt = xt.delegateType || _t, mo.test(tt + _t) || (L = L.parentNode);
                    L;
                    L = L.parentNode
                  )
                    (vt.push(L), (k = L))
                  k === (I.ownerDocument || R) && vt.push(k.defaultView || k.parentWindow || e)
                }
                for (D = 0; (L = vt[D++]) && !d.isPropagationStopped(); )
                  ((Dt = L),
                    (d.type = D > 1 ? tt : xt.bindType || _t),
                    (ot =
                      (Bt.get(L, 'events') || Object.create(null))[d.type] && Bt.get(L, 'handle')),
                    ot && ot.apply(L, A),
                    (ot = q && L[q]),
                    ot &&
                      ot.apply &&
                      $e(L) &&
                      ((d.result = ot.apply(L, A)), d.result === !1 && d.preventDefault()))
                return (
                  (d.type = _t),
                  !x &&
                    !d.isDefaultPrevented() &&
                    (!xt._default || xt._default.apply(vt.pop(), A) === !1) &&
                    $e(I) &&
                    q &&
                    T(I[_t]) &&
                    !z(I) &&
                    ((k = I[q]),
                    k && (I[q] = null),
                    (g.event.triggered = _t),
                    d.isPropagationStopped() && Dt.addEventListener(_t, qr),
                    I[_t](),
                    d.isPropagationStopped() && Dt.removeEventListener(_t, qr),
                    (g.event.triggered = void 0),
                    k && (I[q] = k)),
                  d.result
                )
              }
            },
            simulate: function (d, A, I) {
              var x = g.extend(new g.Event(), I, { type: d, isSimulated: !0 })
              g.event.trigger(x, null, A)
            },
          }),
            g.fn.extend({
              trigger: function (d, A) {
                return this.each(function () {
                  g.event.trigger(d, A, this)
                })
              },
              triggerHandler: function (d, A) {
                var I = this[0]
                if (I) return g.event.trigger(d, A, I, !0)
              },
            }))
          var Ra = /\[\]$/,
            Tl = /\r?\n/g,
            Ml = /^(?:submit|button|image|reset|file)$/i,
            pc = /^(?:input|select|textarea|keygen)/i
          function Qr(d, A, I, x) {
            var D
            if (Array.isArray(A))
              g.each(A, function (L, k) {
                I || Ra.test(d)
                  ? x(d, k)
                  : Qr(d + '[' + (typeof k == 'object' && k != null ? L : '') + ']', k, I, x)
              })
            else if (!I && Z(A) === 'object') for (D in A) Qr(d + '[' + D + ']', A[D], I, x)
            else x(d, A)
          }
          ;((g.param = function (d, A) {
            var I,
              x = [],
              D = function (L, k) {
                var tt = T(k) ? k() : k
                x[x.length] = encodeURIComponent(L) + '=' + encodeURIComponent(tt ?? '')
              }
            if (d == null) return ''
            if (Array.isArray(d) || (d.jquery && !g.isPlainObject(d)))
              g.each(d, function () {
                D(this.name, this.value)
              })
            else for (I in d) Qr(I, d[I], A, D)
            return x.join('&')
          }),
            g.fn.extend({
              serialize: function () {
                return g.param(this.serializeArray())
              },
              serializeArray: function () {
                return this.map(function () {
                  var d = g.prop(this, 'elements')
                  return d ? g.makeArray(d) : this
                })
                  .filter(function () {
                    var d = this.type
                    return (
                      this.name &&
                      !g(this).is(':disabled') &&
                      pc.test(this.nodeName) &&
                      !Ml.test(d) &&
                      (this.checked || !hi.test(d))
                    )
                  })
                  .map(function (d, A) {
                    var I = g(this).val()
                    return I == null
                      ? null
                      : Array.isArray(I)
                        ? g.map(I, function (x) {
                            return {
                              name: A.name,
                              value: x.replace(
                                Tl,
                                `\r
`
                              ),
                            }
                          })
                        : {
                            name: A.name,
                            value: I.replace(
                              Tl,
                              `\r
`
                            ),
                          }
                  })
                  .get()
              },
            }))
          var pr = /%20/g,
            El = /#.*$/,
            Es = /([?&])_=[^&]*/,
            kr = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            Dl = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            yo = /^(?:GET|HEAD)$/,
            vc = /^\/\//,
            Ds = {},
            ka = {},
            Ol = '*/'.concat('*'),
            kn = R.createElement('a')
          kn.href = Ns.href
          function _r(d) {
            return function (A, I) {
              typeof A != 'string' && ((I = A), (A = '*'))
              var x,
                D = 0,
                L = A.toLowerCase().match(Qt) || []
              if (T(I))
                for (; (x = L[D++]); )
                  x[0] === '+'
                    ? ((x = x.slice(1) || '*'), (d[x] = d[x] || []).unshift(I))
                    : (d[x] = d[x] || []).push(I)
            }
          }
          function Os(d, A, I, x) {
            var D = {},
              L = d === ka
            function k(tt) {
              var q
              return (
                (D[tt] = !0),
                g.each(d[tt] || [], function (ot, xt) {
                  var Dt = xt(A, I, x)
                  if (typeof Dt == 'string' && !L && !D[Dt])
                    return (A.dataTypes.unshift(Dt), k(Dt), !1)
                  if (L) return !(q = Dt)
                }),
                q
              )
            }
            return k(A.dataTypes[0]) || (!D['*'] && k('*'))
          }
          function Kr(d, A) {
            var I,
              x,
              D = g.ajaxSettings.flatOptions || {}
            for (I in A) A[I] !== void 0 && ((D[I] ? d : x || (x = {}))[I] = A[I])
            return (x && g.extend(!0, d, x), d)
          }
          function Wh(d, A, I) {
            for (var x, D, L, k, tt = d.contents, q = d.dataTypes; q[0] === '*'; )
              (q.shift(), x === void 0 && (x = d.mimeType || A.getResponseHeader('Content-Type')))
            if (x) {
              for (D in tt)
                if (tt[D] && tt[D].test(x)) {
                  q.unshift(D)
                  break
                }
            }
            if (q[0] in I) L = q[0]
            else {
              for (D in I) {
                if (!q[0] || d.converters[D + ' ' + q[0]]) {
                  L = D
                  break
                }
                k || (k = D)
              }
              L = L || k
            }
            if (L) return (L !== q[0] && q.unshift(L), I[L])
          }
          function Ll(d, A, I, x) {
            var D,
              L,
              k,
              tt,
              q,
              ot = {},
              xt = d.dataTypes.slice()
            if (xt[1]) for (k in d.converters) ot[k.toLowerCase()] = d.converters[k]
            for (L = xt.shift(); L; )
              if (
                (d.responseFields[L] && (I[d.responseFields[L]] = A),
                !q && x && d.dataFilter && (A = d.dataFilter(A, d.dataType)),
                (q = L),
                (L = xt.shift()),
                L)
              ) {
                if (L === '*') L = q
                else if (q !== '*' && q !== L) {
                  if (((k = ot[q + ' ' + L] || ot['* ' + L]), !k)) {
                    for (D in ot)
                      if (
                        ((tt = D.split(' ')),
                        tt[1] === L && ((k = ot[q + ' ' + tt[0]] || ot['* ' + tt[0]]), k))
                      ) {
                        k === !0 ? (k = ot[D]) : ot[D] !== !0 && ((L = tt[0]), xt.unshift(tt[1]))
                        break
                      }
                  }
                  if (k !== !0)
                    if (k && d.throws) A = k(A)
                    else
                      try {
                        A = k(A)
                      } catch (Dt) {
                        return {
                          state: 'parsererror',
                          error: k ? Dt : 'No conversion from ' + q + ' to ' + L,
                        }
                      }
                }
              }
            return { state: 'success', data: A }
          }
          ;(g.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
              url: Ns.href,
              type: 'GET',
              isLocal: Dl.test(Ns.protocol),
              global: !0,
              processData: !0,
              async: !0,
              contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
              accepts: {
                '*': Ol,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript',
              },
              contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ },
              responseFields: { xml: 'responseXML', text: 'responseText', json: 'responseJSON' },
              converters: {
                '* text': String,
                'text html': !0,
                'text json': JSON.parse,
                'text xml': g.parseXML,
              },
              flatOptions: { url: !0, context: !0 },
            },
            ajaxSetup: function (d, A) {
              return A ? Kr(Kr(d, g.ajaxSettings), A) : Kr(g.ajaxSettings, d)
            },
            ajaxPrefilter: _r(Ds),
            ajaxTransport: _r(ka),
            ajax: function (d, A) {
              ;(typeof d == 'object' && ((A = d), (d = void 0)), (A = A || {}))
              var I,
                x,
                D,
                L,
                k,
                tt,
                q,
                ot,
                xt,
                Dt,
                vt = g.ajaxSetup({}, A),
                _t = vt.context || vt,
                oe = vt.context && (_t.nodeType || _t.jquery) ? g(_t) : g.event,
                Te = g.Deferred(),
                ge = g.Callbacks('once memory'),
                Sn = vt.statusCode || {},
                vn = {},
                Wi = {},
                Fi = 'canceled',
                Ce = {
                  readyState: 0,
                  getResponseHeader: function (Oe) {
                    var nn
                    if (q) {
                      if (!L)
                        for (L = {}; (nn = kr.exec(D)); )
                          L[nn[1].toLowerCase() + ' '] = (
                            L[nn[1].toLowerCase() + ' '] || []
                          ).concat(nn[2])
                      nn = L[Oe.toLowerCase() + ' ']
                    }
                    return nn == null ? null : nn.join(', ')
                  },
                  getAllResponseHeaders: function () {
                    return q ? D : null
                  },
                  setRequestHeader: function (Oe, nn) {
                    return (
                      q == null &&
                        ((Oe = Wi[Oe.toLowerCase()] = Wi[Oe.toLowerCase()] || Oe), (vn[Oe] = nn)),
                      this
                    )
                  },
                  overrideMimeType: function (Oe) {
                    return (q == null && (vt.mimeType = Oe), this)
                  },
                  statusCode: function (Oe) {
                    var nn
                    if (Oe)
                      if (q) Ce.always(Oe[Ce.status])
                      else for (nn in Oe) Sn[nn] = [Sn[nn], Oe[nn]]
                    return this
                  },
                  abort: function (Oe) {
                    var nn = Oe || Fi
                    return (I && I.abort(nn), $r(0, nn), this)
                  },
                }
              if (
                (Te.promise(Ce),
                (vt.url = ((d || vt.url || Ns.href) + '').replace(vc, Ns.protocol + '//')),
                (vt.type = A.method || A.type || vt.method || vt.type),
                (vt.dataTypes = (vt.dataType || '*').toLowerCase().match(Qt) || ['']),
                vt.crossDomain == null)
              ) {
                tt = R.createElement('a')
                try {
                  ;((tt.href = vt.url),
                    (tt.href = tt.href),
                    (vt.crossDomain = kn.protocol + '//' + kn.host != tt.protocol + '//' + tt.host))
                } catch {
                  vt.crossDomain = !0
                }
              }
              if (
                (vt.data &&
                  vt.processData &&
                  typeof vt.data != 'string' &&
                  (vt.data = g.param(vt.data, vt.traditional)),
                Os(Ds, vt, A, Ce),
                q)
              )
                return Ce
              ;((ot = g.event && vt.global),
                ot && g.active++ === 0 && g.event.trigger('ajaxStart'),
                (vt.type = vt.type.toUpperCase()),
                (vt.hasContent = !yo.test(vt.type)),
                (x = vt.url.replace(El, '')),
                vt.hasContent
                  ? vt.data &&
                    vt.processData &&
                    (vt.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 &&
                    (vt.data = vt.data.replace(pr, '+'))
                  : ((Dt = vt.url.slice(x.length)),
                    vt.data &&
                      (vt.processData || typeof vt.data == 'string') &&
                      ((x += (Ms.test(x) ? '&' : '?') + vt.data), delete vt.data),
                    vt.cache === !1 &&
                      ((x = x.replace(Es, '$1')),
                      (Dt = (Ms.test(x) ? '&' : '?') + '_=' + Ts.guid++ + Dt)),
                    (vt.url = x + Dt)),
                vt.ifModified &&
                  (g.lastModified[x] && Ce.setRequestHeader('If-Modified-Since', g.lastModified[x]),
                  g.etag[x] && Ce.setRequestHeader('If-None-Match', g.etag[x])),
                ((vt.data && vt.hasContent && vt.contentType !== !1) || A.contentType) &&
                  Ce.setRequestHeader('Content-Type', vt.contentType),
                Ce.setRequestHeader(
                  'Accept',
                  vt.dataTypes[0] && vt.accepts[vt.dataTypes[0]]
                    ? vt.accepts[vt.dataTypes[0]] +
                        (vt.dataTypes[0] !== '*' ? ', ' + Ol + '; q=0.01' : '')
                    : vt.accepts['*']
                ))
              for (xt in vt.headers) Ce.setRequestHeader(xt, vt.headers[xt])
              if (vt.beforeSend && (vt.beforeSend.call(_t, Ce, vt) === !1 || q)) return Ce.abort()
              if (
                ((Fi = 'abort'),
                ge.add(vt.complete),
                Ce.done(vt.success),
                Ce.fail(vt.error),
                (I = Os(ka, vt, A, Ce)),
                !I)
              )
                $r(-1, 'No Transport')
              else {
                if (((Ce.readyState = 1), ot && oe.trigger('ajaxSend', [Ce, vt]), q)) return Ce
                vt.async &&
                  vt.timeout > 0 &&
                  (k = e.setTimeout(function () {
                    Ce.abort('timeout')
                  }, vt.timeout))
                try {
                  ;((q = !1), I.send(vn, $r))
                } catch (Oe) {
                  if (q) throw Oe
                  $r(-1, Oe)
                }
              }
              function $r(Oe, nn, ta, ea) {
                var Ji,
                  _a,
                  Ti,
                  mr,
                  yr,
                  ii = nn
                q ||
                  ((q = !0),
                  k && e.clearTimeout(k),
                  (I = void 0),
                  (D = ea || ''),
                  (Ce.readyState = Oe > 0 ? 4 : 0),
                  (Ji = (Oe >= 200 && Oe < 300) || Oe === 304),
                  ta && (mr = Wh(vt, Ce, ta)),
                  !Ji &&
                    g.inArray('script', vt.dataTypes) > -1 &&
                    g.inArray('json', vt.dataTypes) < 0 &&
                    (vt.converters['text script'] = function () {}),
                  (mr = Ll(vt, mr, Ce, Ji)),
                  Ji
                    ? (vt.ifModified &&
                        ((yr = Ce.getResponseHeader('Last-Modified')),
                        yr && (g.lastModified[x] = yr),
                        (yr = Ce.getResponseHeader('etag')),
                        yr && (g.etag[x] = yr)),
                      Oe === 204 || vt.type === 'HEAD'
                        ? (ii = 'nocontent')
                        : Oe === 304
                          ? (ii = 'notmodified')
                          : ((ii = mr.state), (_a = mr.data), (Ti = mr.error), (Ji = !Ti)))
                    : ((Ti = ii), (Oe || !ii) && ((ii = 'error'), Oe < 0 && (Oe = 0))),
                  (Ce.status = Oe),
                  (Ce.statusText = (nn || ii) + ''),
                  Ji ? Te.resolveWith(_t, [_a, ii, Ce]) : Te.rejectWith(_t, [Ce, ii, Ti]),
                  Ce.statusCode(Sn),
                  (Sn = void 0),
                  ot && oe.trigger(Ji ? 'ajaxSuccess' : 'ajaxError', [Ce, vt, Ji ? _a : Ti]),
                  ge.fireWith(_t, [Ce, ii]),
                  ot &&
                    (oe.trigger('ajaxComplete', [Ce, vt]),
                    --g.active || g.event.trigger('ajaxStop')))
              }
              return Ce
            },
            getJSON: function (d, A, I) {
              return g.get(d, A, I, 'json')
            },
            getScript: function (d, A) {
              return g.get(d, void 0, A, 'script')
            },
          }),
            g.each(['get', 'post'], function (d, A) {
              g[A] = function (I, x, D, L) {
                return (
                  T(x) && ((L = L || D), (D = x), (x = void 0)),
                  g.ajax(
                    g.extend(
                      { url: I, type: A, dataType: L, data: x, success: D },
                      g.isPlainObject(I) && I
                    )
                  )
                )
              }
            }),
            g.ajaxPrefilter(function (d) {
              var A
              for (A in d.headers)
                A.toLowerCase() === 'content-type' && (d.contentType = d.headers[A] || '')
            }),
            (g._evalUrl = function (d, A, I) {
              return g.ajax({
                url: d,
                type: 'GET',
                dataType: 'script',
                cache: !0,
                async: !1,
                global: !1,
                converters: { 'text script': function () {} },
                dataFilter: function (x) {
                  g.globalEval(x, A, I)
                },
              })
            }),
            g.fn.extend({
              wrapAll: function (d) {
                var A
                return (
                  this[0] &&
                    (T(d) && (d = d.call(this[0])),
                    (A = g(d, this[0].ownerDocument).eq(0).clone(!0)),
                    this[0].parentNode && A.insertBefore(this[0]),
                    A.map(function () {
                      for (var I = this; I.firstElementChild; ) I = I.firstElementChild
                      return I
                    }).append(this)),
                  this
                )
              },
              wrapInner: function (d) {
                return T(d)
                  ? this.each(function (A) {
                      g(this).wrapInner(d.call(this, A))
                    })
                  : this.each(function () {
                      var A = g(this),
                        I = A.contents()
                      I.length ? I.wrapAll(d) : A.append(d)
                    })
              },
              wrap: function (d) {
                var A = T(d)
                return this.each(function (I) {
                  g(this).wrapAll(A ? d.call(this, I) : d)
                })
              },
              unwrap: function (d) {
                return (
                  this.parent(d)
                    .not('body')
                    .each(function () {
                      g(this).replaceWith(this.childNodes)
                    }),
                  this
                )
              },
            }),
            (g.expr.pseudos.hidden = function (d) {
              return !g.expr.pseudos.visible(d)
            }),
            (g.expr.pseudos.visible = function (d) {
              return !!(d.offsetWidth || d.offsetHeight || d.getClientRects().length)
            }),
            (g.ajaxSettings.xhr = function () {
              try {
                return new e.XMLHttpRequest()
              } catch {}
            }))
          var zl = { 0: 200, 1223: 204 },
            vr = g.ajaxSettings.xhr()
          ;((N.cors = !!vr && 'withCredentials' in vr),
            (N.ajax = vr = !!vr),
            g.ajaxTransport(function (d) {
              var A, I
              if (N.cors || (vr && !d.crossDomain))
                return {
                  send: function (x, D) {
                    var L,
                      k = d.xhr()
                    if ((k.open(d.type, d.url, d.async, d.username, d.password), d.xhrFields))
                      for (L in d.xhrFields) k[L] = d.xhrFields[L]
                    ;(d.mimeType && k.overrideMimeType && k.overrideMimeType(d.mimeType),
                      !d.crossDomain &&
                        !x['X-Requested-With'] &&
                        (x['X-Requested-With'] = 'XMLHttpRequest'))
                    for (L in x) k.setRequestHeader(L, x[L])
                    ;((A = function (tt) {
                      return function () {
                        A &&
                          ((A =
                            I =
                            k.onload =
                            k.onerror =
                            k.onabort =
                            k.ontimeout =
                            k.onreadystatechange =
                              null),
                          tt === 'abort'
                            ? k.abort()
                            : tt === 'error'
                              ? typeof k.status != 'number'
                                ? D(0, 'error')
                                : D(k.status, k.statusText)
                              : D(
                                  zl[k.status] || k.status,
                                  k.statusText,
                                  (k.responseType || 'text') !== 'text' ||
                                    typeof k.responseText != 'string'
                                    ? { binary: k.response }
                                    : { text: k.responseText },
                                  k.getAllResponseHeaders()
                                ))
                      }
                    }),
                      (k.onload = A()),
                      (I = k.onerror = k.ontimeout = A('error')),
                      k.onabort !== void 0
                        ? (k.onabort = I)
                        : (k.onreadystatechange = function () {
                            k.readyState === 4 &&
                              e.setTimeout(function () {
                                A && I()
                              })
                          }),
                      (A = A('abort')))
                    try {
                      k.send((d.hasContent && d.data) || null)
                    } catch (tt) {
                      if (A) throw tt
                    }
                  },
                  abort: function () {
                    A && A()
                  },
                }
            }),
            g.ajaxPrefilter(function (d) {
              d.crossDomain && (d.contents.script = !1)
            }),
            g.ajaxSetup({
              accepts: {
                script:
                  'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript',
              },
              contents: { script: /\b(?:java|ecma)script\b/ },
              converters: {
                'text script': function (d) {
                  return (g.globalEval(d), d)
                },
              },
            }),
            g.ajaxPrefilter('script', function (d) {
              ;(d.cache === void 0 && (d.cache = !1), d.crossDomain && (d.type = 'GET'))
            }),
            g.ajaxTransport('script', function (d) {
              if (d.crossDomain || d.scriptAttrs) {
                var A, I
                return {
                  send: function (x, D) {
                    ;((A = g('<script>')
                      .attr(d.scriptAttrs || {})
                      .prop({ charset: d.scriptCharset, src: d.url })
                      .on(
                        'load error',
                        (I = function (L) {
                          ;(A.remove(), (I = null), L && D(L.type === 'error' ? 404 : 200, L.type))
                        })
                      )),
                      R.head.appendChild(A[0]))
                  },
                  abort: function () {
                    I && I()
                  },
                }
              }
            }))
          var Ls = [],
            Ao = /(=)\?(?=&|$)|\?\?/
          ;(g.ajaxSetup({
            jsonp: 'callback',
            jsonpCallback: function () {
              var d = Ls.pop() || g.expando + '_' + Ts.guid++
              return ((this[d] = !0), d)
            },
          }),
            g.ajaxPrefilter('json jsonp', function (d, A, I) {
              var x,
                D,
                L,
                k =
                  d.jsonp !== !1 &&
                  (Ao.test(d.url)
                    ? 'url'
                    : typeof d.data == 'string' &&
                      (d.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 &&
                      Ao.test(d.data) &&
                      'data')
              if (k || d.dataTypes[0] === 'jsonp')
                return (
                  (x = d.jsonpCallback = T(d.jsonpCallback) ? d.jsonpCallback() : d.jsonpCallback),
                  k
                    ? (d[k] = d[k].replace(Ao, '$1' + x))
                    : d.jsonp !== !1 && (d.url += (Ms.test(d.url) ? '&' : '?') + d.jsonp + '=' + x),
                  (d.converters['script json'] = function () {
                    return (L || g.error(x + ' was not called'), L[0])
                  }),
                  (d.dataTypes[0] = 'json'),
                  (D = e[x]),
                  (e[x] = function () {
                    L = arguments
                  }),
                  I.always(function () {
                    ;(D === void 0 ? g(e).removeProp(x) : (e[x] = D),
                      d[x] && ((d.jsonpCallback = A.jsonpCallback), Ls.push(x)),
                      L && T(D) && D(L[0]),
                      (L = D = void 0))
                  }),
                  'script'
                )
            }),
            (N.createHTMLDocument = (function () {
              var d = R.implementation.createHTMLDocument('').body
              return ((d.innerHTML = '<form></form><form></form>'), d.childNodes.length === 2)
            })()),
            (g.parseHTML = function (d, A, I) {
              if (typeof d != 'string') return []
              typeof A == 'boolean' && ((I = A), (A = !1))
              var x, D, L
              return (
                A ||
                  (N.createHTMLDocument
                    ? ((A = R.implementation.createHTMLDocument('')),
                      (x = A.createElement('base')),
                      (x.href = R.location.href),
                      A.head.appendChild(x))
                    : (A = R)),
                (D = ct.exec(d)),
                (L = !I && []),
                D
                  ? [A.createElement(D[1])]
                  : ((D = lc([d], A, L)), L && L.length && g(L).remove(), g.merge([], D.childNodes))
              )
            }),
            (g.fn.load = function (d, A, I) {
              var x,
                D,
                L,
                k = this,
                tt = d.indexOf(' ')
              return (
                tt > -1 && ((x = zr(d.slice(tt))), (d = d.slice(0, tt))),
                T(A) ? ((I = A), (A = void 0)) : A && typeof A == 'object' && (D = 'POST'),
                k.length > 0 &&
                  g
                    .ajax({ url: d, type: D || 'GET', dataType: 'html', data: A })
                    .done(function (q) {
                      ;((L = arguments), k.html(x ? g('<div>').append(g.parseHTML(q)).find(x) : q))
                    })
                    .always(
                      I &&
                        function (q, ot) {
                          k.each(function () {
                            I.apply(this, L || [q.responseText, ot, q])
                          })
                        }
                    ),
                this
              )
            }),
            (g.expr.pseudos.animated = function (d) {
              return g.grep(g.timers, function (A) {
                return d === A.elem
              }).length
            }),
            (g.offset = {
              setOffset: function (d, A, I) {
                var x,
                  D,
                  L,
                  k,
                  tt,
                  q,
                  ot,
                  xt = g.css(d, 'position'),
                  Dt = g(d),
                  vt = {}
                ;(xt === 'static' && (d.style.position = 'relative'),
                  (tt = Dt.offset()),
                  (L = g.css(d, 'top')),
                  (q = g.css(d, 'left')),
                  (ot = (xt === 'absolute' || xt === 'fixed') && (L + q).indexOf('auto') > -1),
                  ot
                    ? ((x = Dt.position()), (k = x.top), (D = x.left))
                    : ((k = parseFloat(L) || 0), (D = parseFloat(q) || 0)),
                  T(A) && (A = A.call(d, I, g.extend({}, tt))),
                  A.top != null && (vt.top = A.top - tt.top + k),
                  A.left != null && (vt.left = A.left - tt.left + D),
                  'using' in A ? A.using.call(d, vt) : Dt.css(vt))
              },
            }),
            g.fn.extend({
              offset: function (d) {
                if (arguments.length)
                  return d === void 0
                    ? this
                    : this.each(function (D) {
                        g.offset.setOffset(this, d, D)
                      })
                var A,
                  I,
                  x = this[0]
                if (x)
                  return x.getClientRects().length
                    ? ((A = x.getBoundingClientRect()),
                      (I = x.ownerDocument.defaultView),
                      { top: A.top + I.pageYOffset, left: A.left + I.pageXOffset })
                    : { top: 0, left: 0 }
              },
              position: function () {
                if (this[0]) {
                  var d,
                    A,
                    I,
                    x = this[0],
                    D = { top: 0, left: 0 }
                  if (g.css(x, 'position') === 'fixed') A = x.getBoundingClientRect()
                  else {
                    for (
                      A = this.offset(),
                        I = x.ownerDocument,
                        d = x.offsetParent || I.documentElement;
                      d &&
                      (d === I.body || d === I.documentElement) &&
                      g.css(d, 'position') === 'static';

                    )
                      d = d.parentNode
                    d &&
                      d !== x &&
                      d.nodeType === 1 &&
                      ((D = g(d).offset()),
                      (D.top += g.css(d, 'borderTopWidth', !0)),
                      (D.left += g.css(d, 'borderLeftWidth', !0)))
                  }
                  return {
                    top: A.top - D.top - g.css(x, 'marginTop', !0),
                    left: A.left - D.left - g.css(x, 'marginLeft', !0),
                  }
                }
              },
              offsetParent: function () {
                return this.map(function () {
                  for (var d = this.offsetParent; d && g.css(d, 'position') === 'static'; )
                    d = d.offsetParent
                  return d || Jn
                })
              },
            }),
            g.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, function (d, A) {
              var I = A === 'pageYOffset'
              g.fn[d] = function (x) {
                return At(
                  this,
                  function (D, L, k) {
                    var tt
                    if ((z(D) ? (tt = D) : D.nodeType === 9 && (tt = D.defaultView), k === void 0))
                      return tt ? tt[A] : D[L]
                    tt ? tt.scrollTo(I ? tt.pageXOffset : k, I ? k : tt.pageYOffset) : (D[L] = k)
                  },
                  d,
                  x,
                  arguments.length
                )
              }
            }),
            g.each(['top', 'left'], function (d, A) {
              g.cssHooks[A] = Cl(N.pixelPosition, function (I, x) {
                if (x) return ((x = Ea(I, A)), uo.test(x) ? g(I).position()[A] + 'px' : x)
              })
            }),
            g.each({ Height: 'height', Width: 'width' }, function (d, A) {
              g.each({ padding: 'inner' + d, content: A, '': 'outer' + d }, function (I, x) {
                g.fn[x] = function (D, L) {
                  var k = arguments.length && (I || typeof D != 'boolean'),
                    tt = I || (D === !0 || L === !0 ? 'margin' : 'border')
                  return At(
                    this,
                    function (q, ot, xt) {
                      var Dt
                      return z(q)
                        ? x.indexOf('outer') === 0
                          ? q['inner' + d]
                          : q.document.documentElement['client' + d]
                        : q.nodeType === 9
                          ? ((Dt = q.documentElement),
                            Math.max(
                              q.body['scroll' + d],
                              Dt['scroll' + d],
                              q.body['offset' + d],
                              Dt['offset' + d],
                              Dt['client' + d]
                            ))
                          : xt === void 0
                            ? g.css(q, ot, tt)
                            : g.style(q, ot, xt, tt)
                    },
                    A,
                    k ? D : void 0,
                    k
                  )
                }
              })
            }),
            g.each(
              ['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'],
              function (d, A) {
                g.fn[A] = function (I) {
                  return this.on(A, I)
                }
              }
            ),
            g.fn.extend({
              bind: function (d, A, I) {
                return this.on(d, null, A, I)
              },
              unbind: function (d, A) {
                return this.off(d, null, A)
              },
              delegate: function (d, A, I, x) {
                return this.on(A, d, I, x)
              },
              undelegate: function (d, A, I) {
                return arguments.length === 1 ? this.off(d, '**') : this.off(A, d || '**', I)
              },
              hover: function (d, A) {
                return this.on('mouseenter', d).on('mouseleave', A || d)
              },
            }),
            g.each(
              'blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu'.split(
                ' '
              ),
              function (d, A) {
                g.fn[A] = function (I, x) {
                  return arguments.length > 0 ? this.on(A, null, I, x) : this.trigger(A)
                }
              }
            ))
          var Fh = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g
          ;((g.proxy = function (d, A) {
            var I, x, D
            if ((typeof A == 'string' && ((I = d[A]), (A = d), (d = I)), !!T(d)))
              return (
                (x = o.call(arguments, 2)),
                (D = function () {
                  return d.apply(A || this, x.concat(o.call(arguments)))
                }),
                (D.guid = d.guid = d.guid || g.guid++),
                D
              )
          }),
            (g.holdReady = function (d) {
              d ? g.readyWait++ : g.ready(!0)
            }),
            (g.isArray = Array.isArray),
            (g.parseJSON = JSON.parse),
            (g.nodeName = M),
            (g.isFunction = T),
            (g.isWindow = z),
            (g.camelCase = Se),
            (g.type = Z),
            (g.now = Date.now),
            (g.isNumeric = function (d) {
              var A = g.type(d)
              return (A === 'number' || A === 'string') && !isNaN(d - parseFloat(d))
            }),
            (g.trim = function (d) {
              return d == null ? '' : (d + '').replace(Fh, '$1')
            }))
          var Jh = e.jQuery,
            qh = e.$
          return (
            (g.noConflict = function (d) {
              return (e.$ === g && (e.$ = qh), d && e.jQuery === g && (e.jQuery = Jh), g)
            }),
            typeof n > 'u' && (e.jQuery = e.$ = g),
            g
          )
        })
      })(Yf)),
    Yf.exports
  )
}
var Tb
function CM() {
  return (
    Tb ||
      ((Tb = 1),
      (function (t) {
        ;(function (e) {
          var n =
            (typeof self == 'object' && self.self === self && self) ||
            (typeof window == 'object' && window.global === window && window)
          {
            var i = bM,
              s
            try {
              s = Nw()
            } catch {}
            e(n, t, i, s)
          }
        })(function (e, n, i, s) {
          var o = e.Backbone,
            u = Array.prototype.slice
          ;((n.VERSION = '1.4.1'),
            (n.$ = s),
            (n.noConflict = function () {
              return ((e.Backbone = o), this)
            }),
            (n.emulateHTTP = !1),
            (n.emulateJSON = !1))
          var c = (n.Events = {}),
            h = /\s+/,
            p,
            y = function (E, P, Y, J, At) {
              var Nt = 0,
                Yt
              if (Y && typeof Y == 'object')
                for (
                  J !== void 0 && ('context' in At) && At.context === void 0 && (At.context = J),
                    Yt = i.keys(Y);
                  Nt < Yt.length;
                  Nt++
                )
                  P = y(E, P, Yt[Nt], Y[Yt[Nt]], At)
              else if (Y && h.test(Y))
                for (Yt = Y.split(h); Nt < Yt.length; Nt++) P = E(P, Yt[Nt], J, At)
              else P = E(P, Y, J, At)
              return P
            }
          ;((c.on = function (E, P, Y) {
            if (
              ((this._events = y(v, this._events || {}, E, P, {
                context: Y,
                ctx: this,
                listening: p,
              })),
              p)
            ) {
              var J = this._listeners || (this._listeners = {})
              ;((J[p.id] = p), (p.interop = !1))
            }
            return this
          }),
            (c.listenTo = function (E, P, Y) {
              if (!E) return this
              var J = E._listenId || (E._listenId = i.uniqueId('l')),
                At = this._listeningTo || (this._listeningTo = {}),
                Nt = (p = At[J])
              Nt ||
                (this._listenId || (this._listenId = i.uniqueId('l')),
                (Nt = p = At[J] = new R(this, E)))
              var Yt = C(E, P, Y, this)
              if (((p = void 0), Yt)) throw Yt
              return (Nt.interop && Nt.on(P, Y), this)
            }))
          var v = function (E, P, Y, J) {
              if (Y) {
                var At = E[P] || (E[P] = []),
                  Nt = J.context,
                  Yt = J.ctx,
                  se = J.listening
                ;(se && se.count++,
                  At.push({ callback: Y, context: Nt, ctx: Nt || Yt, listening: se }))
              }
              return E
            },
            C = function (E, P, Y, J) {
              try {
                E.on(P, Y, J)
              } catch (At) {
                return At
              }
            }
          ;((c.off = function (E, P, Y) {
            return this._events
              ? ((this._events = y(w, this._events, E, P, {
                  context: Y,
                  listeners: this._listeners,
                })),
                this)
              : this
          }),
            (c.stopListening = function (E, P, Y) {
              var J = this._listeningTo
              if (!J) return this
              for (var At = E ? [E._listenId] : i.keys(J), Nt = 0; Nt < At.length; Nt++) {
                var Yt = J[At[Nt]]
                if (!Yt) break
                ;(Yt.obj.off(P, Y, this), Yt.interop && Yt.off(P, Y))
              }
              return (i.isEmpty(J) && (this._listeningTo = void 0), this)
            }))
          var w = function (E, P, Y, J) {
            if (E) {
              var At = J.context,
                Nt = J.listeners,
                Yt = 0,
                se
              if (!P && !At && !Y) {
                for (se = i.keys(Nt); Yt < se.length; Yt++) Nt[se[Yt]].cleanup()
                return
              }
              for (se = P ? [P] : i.keys(E); Yt < se.length; Yt++) {
                P = se[Yt]
                var Se = E[P]
                if (!Se) break
                for (var $e = [], Ye = 0; Ye < Se.length; Ye++) {
                  var Bt = Se[Ye]
                  if (
                    (Y && Y !== Bt.callback && Y !== Bt.callback._callback) ||
                    (At && At !== Bt.context)
                  )
                    $e.push(Bt)
                  else {
                    var ae = Bt.listening
                    ae && ae.off(P, Y)
                  }
                }
                $e.length ? (E[P] = $e) : delete E[P]
              }
              return E
            }
          }
          ;((c.once = function (E, P, Y) {
            var J = y(N, {}, E, P, this.off.bind(this))
            return (typeof E == 'string' && Y == null && (P = void 0), this.on(J, P, Y))
          }),
            (c.listenToOnce = function (E, P, Y) {
              var J = y(N, {}, P, Y, this.stopListening.bind(this, E))
              return this.listenTo(E, J)
            }))
          var N = function (E, P, Y, J) {
            if (Y) {
              var At = (E[P] = i.once(function () {
                ;(J(P, At), Y.apply(this, arguments))
              }))
              At._callback = Y
            }
            return E
          }
          c.trigger = function (E) {
            if (!this._events) return this
            for (var P = Math.max(0, arguments.length - 1), Y = Array(P), J = 0; J < P; J++)
              Y[J] = arguments[J + 1]
            return (y(T, this._events, E, void 0, Y), this)
          }
          var T = function (E, P, Y, J) {
              if (E) {
                var At = E[P],
                  Nt = E.all
                ;(At && Nt && (Nt = Nt.slice()), At && z(At, J), Nt && z(Nt, [P].concat(J)))
              }
              return E
            },
            z = function (E, P) {
              var Y,
                J = -1,
                At = E.length,
                Nt = P[0],
                Yt = P[1],
                se = P[2]
              switch (P.length) {
                case 0:
                  for (; ++J < At; ) (Y = E[J]).callback.call(Y.ctx)
                  return
                case 1:
                  for (; ++J < At; ) (Y = E[J]).callback.call(Y.ctx, Nt)
                  return
                case 2:
                  for (; ++J < At; ) (Y = E[J]).callback.call(Y.ctx, Nt, Yt)
                  return
                case 3:
                  for (; ++J < At; ) (Y = E[J]).callback.call(Y.ctx, Nt, Yt, se)
                  return
                default:
                  for (; ++J < At; ) (Y = E[J]).callback.apply(Y.ctx, P)
                  return
              }
            },
            R = function (E, P) {
              ;((this.id = E._listenId),
                (this.listener = E),
                (this.obj = P),
                (this.interop = !0),
                (this.count = 0),
                (this._events = void 0))
            }
          ;((R.prototype.on = c.on),
            (R.prototype.off = function (E, P) {
              var Y
              ;(this.interop
                ? ((this._events = y(w, this._events, E, P, {
                    context: void 0,
                    listeners: void 0,
                  })),
                  (Y = !this._events))
                : (this.count--, (Y = this.count === 0)),
                Y && this.cleanup())
            }),
            (R.prototype.cleanup = function () {
              ;(delete this.listener._listeningTo[this.obj._listenId],
                this.interop || delete this.obj._listeners[this.id])
            }),
            (c.bind = c.on),
            (c.unbind = c.off),
            i.extend(n, c))
          var B = (n.Model = function (E, P) {
            var Y = E || {}
            ;(P || (P = {}),
              this.preinitialize.apply(this, arguments),
              (this.cid = i.uniqueId(this.cidPrefix)),
              (this.attributes = {}),
              P.collection && (this.collection = P.collection),
              P.parse && (Y = this.parse(Y, P) || {}))
            var J = i.result(this, 'defaults')
            ;((Y = i.defaults(i.extend({}, J, Y), J)),
              this.set(Y, P),
              (this.changed = {}),
              this.initialize.apply(this, arguments))
          })
          i.extend(B.prototype, c, {
            changed: null,
            validationError: null,
            idAttribute: 'id',
            cidPrefix: 'c',
            preinitialize: function () {},
            initialize: function () {},
            toJSON: function (E) {
              return i.clone(this.attributes)
            },
            sync: function () {
              return n.sync.apply(this, arguments)
            },
            get: function (E) {
              return this.attributes[E]
            },
            escape: function (E) {
              return i.escape(this.get(E))
            },
            has: function (E) {
              return this.get(E) != null
            },
            matches: function (E) {
              return !!i.iteratee(E, this)(this.attributes)
            },
            set: function (E, P, Y) {
              if (E == null) return this
              var J
              if (
                (typeof E == 'object' ? ((J = E), (Y = P)) : ((J = {})[E] = P),
                Y || (Y = {}),
                !this._validate(J, Y))
              )
                return !1
              var At = Y.unset,
                Nt = Y.silent,
                Yt = [],
                se = this._changing
              ;((this._changing = !0),
                se || ((this._previousAttributes = i.clone(this.attributes)), (this.changed = {})))
              var Se = this.attributes,
                $e = this.changed,
                Ye = this._previousAttributes
              for (var Bt in J)
                ((P = J[Bt]),
                  i.isEqual(Se[Bt], P) || Yt.push(Bt),
                  i.isEqual(Ye[Bt], P) ? delete $e[Bt] : ($e[Bt] = P),
                  At ? delete Se[Bt] : (Se[Bt] = P))
              if (this.idAttribute in J) {
                var ae = this.id
                ;((this.id = this.get(this.idAttribute)), this.trigger('changeId', this, ae, Y))
              }
              if (!Nt) {
                Yt.length && (this._pending = Y)
                for (var fe = 0; fe < Yt.length; fe++)
                  this.trigger('change:' + Yt[fe], this, Se[Yt[fe]], Y)
              }
              if (se) return this
              if (!Nt)
                for (; this._pending; )
                  ((Y = this._pending), (this._pending = !1), this.trigger('change', this, Y))
              return ((this._pending = !1), (this._changing = !1), this)
            },
            unset: function (E, P) {
              return this.set(E, void 0, i.extend({}, P, { unset: !0 }))
            },
            clear: function (E) {
              var P = {}
              for (var Y in this.attributes) P[Y] = void 0
              return this.set(P, i.extend({}, E, { unset: !0 }))
            },
            hasChanged: function (E) {
              return E == null ? !i.isEmpty(this.changed) : i.has(this.changed, E)
            },
            changedAttributes: function (E) {
              if (!E) return this.hasChanged() ? i.clone(this.changed) : !1
              var P = this._changing ? this._previousAttributes : this.attributes,
                Y = {},
                J
              for (var At in E) {
                var Nt = E[At]
                i.isEqual(P[At], Nt) || ((Y[At] = Nt), (J = !0))
              }
              return J ? Y : !1
            },
            previous: function (E) {
              return E == null || !this._previousAttributes ? null : this._previousAttributes[E]
            },
            previousAttributes: function () {
              return i.clone(this._previousAttributes)
            },
            fetch: function (E) {
              E = i.extend({ parse: !0 }, E)
              var P = this,
                Y = E.success
              return (
                (E.success = function (J) {
                  var At = E.parse ? P.parse(J, E) : J
                  if (!P.set(At, E)) return !1
                  ;(Y && Y.call(E.context, P, J, E), P.trigger('sync', P, J, E))
                }),
                Xt(this, E),
                this.sync('read', this, E)
              )
            },
            save: function (E, P, Y) {
              var J
              ;(E == null || typeof E == 'object' ? ((J = E), (Y = P)) : ((J = {})[E] = P),
                (Y = i.extend({ validate: !0, parse: !0 }, Y)))
              var At = Y.wait
              if (J && !At) {
                if (!this.set(J, Y)) return !1
              } else if (!this._validate(J, Y)) return !1
              var Nt = this,
                Yt = Y.success,
                se = this.attributes
              ;((Y.success = function (Ye) {
                Nt.attributes = se
                var Bt = Y.parse ? Nt.parse(Ye, Y) : Ye
                if ((At && (Bt = i.extend({}, J, Bt)), Bt && !Nt.set(Bt, Y))) return !1
                ;(Yt && Yt.call(Y.context, Nt, Ye, Y), Nt.trigger('sync', Nt, Ye, Y))
              }),
                Xt(this, Y),
                J && At && (this.attributes = i.extend({}, se, J)))
              var Se = this.isNew() ? 'create' : Y.patch ? 'patch' : 'update'
              Se === 'patch' && !Y.attrs && (Y.attrs = J)
              var $e = this.sync(Se, this, Y)
              return ((this.attributes = se), $e)
            },
            destroy: function (E) {
              E = E ? i.clone(E) : {}
              var P = this,
                Y = E.success,
                J = E.wait,
                At = function () {
                  ;(P.stopListening(), P.trigger('destroy', P, P.collection, E))
                }
              E.success = function (Yt) {
                ;(J && At(),
                  Y && Y.call(E.context, P, Yt, E),
                  P.isNew() || P.trigger('sync', P, Yt, E))
              }
              var Nt = !1
              return (
                this.isNew()
                  ? i.defer(E.success)
                  : (Xt(this, E), (Nt = this.sync('delete', this, E))),
                J || At(),
                Nt
              )
            },
            url: function () {
              var E = i.result(this, 'urlRoot') || i.result(this.collection, 'url') || de()
              if (this.isNew()) return E
              var P = this.get(this.idAttribute)
              return E.replace(/[^\/]$/, '$&/') + encodeURIComponent(P)
            },
            parse: function (E, P) {
              return E
            },
            clone: function () {
              return new this.constructor(this.attributes)
            },
            isNew: function () {
              return !this.has(this.idAttribute)
            },
            isValid: function (E) {
              return this._validate({}, i.extend({}, E, { validate: !0 }))
            },
            _validate: function (E, P) {
              if (!P.validate || !this.validate) return !0
              E = i.extend({}, this.attributes, E)
              var Y = (this.validationError = this.validate(E, P) || null)
              return Y
                ? (this.trigger('invalid', this, Y, i.extend(P, { validationError: Y })), !1)
                : !0
            },
          })
          var H = (n.Collection = function (E, P) {
              ;(P || (P = {}),
                this.preinitialize.apply(this, arguments),
                P.model && (this.model = P.model),
                P.comparator !== void 0 && (this.comparator = P.comparator),
                this._reset(),
                this.initialize.apply(this, arguments),
                E && this.reset(E, i.extend({ silent: !0 }, P)))
            }),
            Z = { add: !0, remove: !0, merge: !0 },
            U = { add: !0, remove: !1 },
            nt = function (E, P, Y) {
              Y = Math.min(Math.max(Y, 0), E.length)
              var J = Array(E.length - Y),
                At = P.length,
                Nt
              for (Nt = 0; Nt < J.length; Nt++) J[Nt] = E[Nt + Y]
              for (Nt = 0; Nt < At; Nt++) E[Nt + Y] = P[Nt]
              for (Nt = 0; Nt < J.length; Nt++) E[Nt + At + Y] = J[Nt]
            }
          i.extend(H.prototype, c, {
            model: B,
            preinitialize: function () {},
            initialize: function () {},
            toJSON: function (E) {
              return this.map(function (P) {
                return P.toJSON(E)
              })
            },
            sync: function () {
              return n.sync.apply(this, arguments)
            },
            add: function (E, P) {
              return this.set(E, i.extend({ merge: !1 }, P, U))
            },
            remove: function (E, P) {
              P = i.extend({}, P)
              var Y = !i.isArray(E)
              E = Y ? [E] : E.slice()
              var J = this._removeModels(E, P)
              return (
                !P.silent &&
                  J.length &&
                  ((P.changes = { added: [], merged: [], removed: J }),
                  this.trigger('update', this, P)),
                Y ? J[0] : J
              )
            },
            set: function (E, P) {
              if (E != null) {
                ;((P = i.extend({}, Z, P)),
                  P.parse && !this._isModel(E) && (E = this.parse(E, P) || []))
                var Y = !i.isArray(E)
                E = Y ? [E] : E.slice()
                var J = P.at
                ;(J != null && (J = +J),
                  J > this.length && (J = this.length),
                  J < 0 && (J += this.length + 1))
                var At = [],
                  Nt = [],
                  Yt = [],
                  se = [],
                  Se = {},
                  $e = P.add,
                  Ye = P.merge,
                  Bt = P.remove,
                  ae = !1,
                  fe = this.comparator && J == null && P.sort !== !1,
                  Fn = i.isString(this.comparator) ? this.comparator : null,
                  Ne,
                  ln
                for (ln = 0; ln < E.length; ln++) {
                  Ne = E[ln]
                  var Zn = this.get(Ne)
                  if (Zn) {
                    if (Ye && Ne !== Zn) {
                      var wi = this._isModel(Ne) ? Ne.attributes : Ne
                      ;(P.parse && (wi = Zn.parse(wi, P)),
                        Zn.set(wi, P),
                        Yt.push(Zn),
                        fe && !ae && (ae = Zn.hasChanged(Fn)))
                    }
                    ;(Se[Zn.cid] || ((Se[Zn.cid] = !0), At.push(Zn)), (E[ln] = Zn))
                  } else
                    $e &&
                      ((Ne = E[ln] = this._prepareModel(Ne, P)),
                      Ne &&
                        (Nt.push(Ne), this._addReference(Ne, P), (Se[Ne.cid] = !0), At.push(Ne)))
                }
                if (Bt) {
                  for (ln = 0; ln < this.length; ln++)
                    ((Ne = this.models[ln]), Se[Ne.cid] || se.push(Ne))
                  se.length && this._removeModels(se, P)
                }
                var xn = !1,
                  Jn = !fe && $e && Bt
                if (
                  (At.length && Jn
                    ? ((xn =
                        this.length !== At.length ||
                        i.some(this.models, function (Ln, fr) {
                          return Ln !== At[fr]
                        })),
                      (this.models.length = 0),
                      nt(this.models, At, 0),
                      (this.length = this.models.length))
                    : Nt.length &&
                      (fe && (ae = !0),
                      nt(this.models, Nt, J ?? this.length),
                      (this.length = this.models.length)),
                  ae && this.sort({ silent: !0 }),
                  !P.silent)
                ) {
                  for (ln = 0; ln < Nt.length; ln++)
                    (J != null && (P.index = J + ln), (Ne = Nt[ln]), Ne.trigger('add', Ne, this, P))
                  ;((ae || xn) && this.trigger('sort', this, P),
                    (Nt.length || se.length || Yt.length) &&
                      ((P.changes = { added: Nt, removed: se, merged: Yt }),
                      this.trigger('update', this, P)))
                }
                return Y ? E[0] : E
              }
            },
            reset: function (E, P) {
              P = P ? i.clone(P) : {}
              for (var Y = 0; Y < this.models.length; Y++) this._removeReference(this.models[Y], P)
              return (
                (P.previousModels = this.models),
                this._reset(),
                (E = this.add(E, i.extend({ silent: !0 }, P))),
                P.silent || this.trigger('reset', this, P),
                E
              )
            },
            push: function (E, P) {
              return this.add(E, i.extend({ at: this.length }, P))
            },
            pop: function (E) {
              var P = this.at(this.length - 1)
              return this.remove(P, E)
            },
            unshift: function (E, P) {
              return this.add(E, i.extend({ at: 0 }, P))
            },
            shift: function (E) {
              var P = this.at(0)
              return this.remove(P, E)
            },
            slice: function () {
              return u.apply(this.models, arguments)
            },
            get: function (E) {
              if (E != null)
                return (
                  this._byId[E] ||
                  this._byId[this.modelId(this._isModel(E) ? E.attributes : E, E.idAttribute)] ||
                  (E.cid && this._byId[E.cid])
                )
            },
            has: function (E) {
              return this.get(E) != null
            },
            at: function (E) {
              return (E < 0 && (E += this.length), this.models[E])
            },
            where: function (E, P) {
              return this[P ? 'find' : 'filter'](E)
            },
            findWhere: function (E) {
              return this.where(E, !0)
            },
            sort: function (E) {
              var P = this.comparator
              if (!P) throw new Error('Cannot sort a set without a comparator')
              E || (E = {})
              var Y = P.length
              return (
                i.isFunction(P) && (P = P.bind(this)),
                Y === 1 || i.isString(P) ? (this.models = this.sortBy(P)) : this.models.sort(P),
                E.silent || this.trigger('sort', this, E),
                this
              )
            },
            pluck: function (E) {
              return this.map(E + '')
            },
            fetch: function (E) {
              E = i.extend({ parse: !0 }, E)
              var P = E.success,
                Y = this
              return (
                (E.success = function (J) {
                  var At = E.reset ? 'reset' : 'set'
                  ;(Y[At](J, E), P && P.call(E.context, Y, J, E), Y.trigger('sync', Y, J, E))
                }),
                Xt(this, E),
                this.sync('read', this, E)
              )
            },
            create: function (E, P) {
              P = P ? i.clone(P) : {}
              var Y = P.wait
              if (((E = this._prepareModel(E, P)), !E)) return !1
              Y || this.add(E, P)
              var J = this,
                At = P.success
              return (
                (P.success = function (Nt, Yt, se) {
                  ;(Y && J.add(Nt, se), At && At.call(se.context, Nt, Yt, se))
                }),
                E.save(null, P),
                E
              )
            },
            parse: function (E, P) {
              return E
            },
            clone: function () {
              return new this.constructor(this.models, {
                model: this.model,
                comparator: this.comparator,
              })
            },
            modelId: function (E, P) {
              return E[P || this.model.prototype.idAttribute || 'id']
            },
            values: function () {
              return new S(this, M)
            },
            keys: function () {
              return new S(this, _)
            },
            entries: function () {
              return new S(this, W)
            },
            _reset: function () {
              ;((this.length = 0), (this.models = []), (this._byId = {}))
            },
            _prepareModel: function (E, P) {
              if (this._isModel(E)) return (E.collection || (E.collection = this), E)
              ;((P = P ? i.clone(P) : {}), (P.collection = this))
              var Y
              return (
                this.model.prototype ? (Y = new this.model(E, P)) : (Y = this.model(E, P)),
                Y.validationError ? (this.trigger('invalid', this, Y.validationError, P), !1) : Y
              )
            },
            _removeModels: function (E, P) {
              for (var Y = [], J = 0; J < E.length; J++) {
                var At = this.get(E[J])
                if (At) {
                  var Nt = this.indexOf(At)
                  ;(this.models.splice(Nt, 1), this.length--, delete this._byId[At.cid])
                  var Yt = this.modelId(At.attributes, At.idAttribute)
                  ;(Yt != null && delete this._byId[Yt],
                    P.silent || ((P.index = Nt), At.trigger('remove', At, this, P)),
                    Y.push(At),
                    this._removeReference(At, P))
                }
              }
              return Y
            },
            _isModel: function (E) {
              return E instanceof B
            },
            _addReference: function (E, P) {
              this._byId[E.cid] = E
              var Y = this.modelId(E.attributes, E.idAttribute)
              ;(Y != null && (this._byId[Y] = E), E.on('all', this._onModelEvent, this))
            },
            _removeReference: function (E, P) {
              delete this._byId[E.cid]
              var Y = this.modelId(E.attributes, E.idAttribute)
              ;(Y != null && delete this._byId[Y],
                this === E.collection && delete E.collection,
                E.off('all', this._onModelEvent, this))
            },
            _onModelEvent: function (E, P, Y, J) {
              if (P) {
                if ((E === 'add' || E === 'remove') && Y !== this) return
                if ((E === 'destroy' && this.remove(P, J), E === 'changeId')) {
                  var At = this.modelId(P.previousAttributes(), P.idAttribute),
                    Nt = this.modelId(P.attributes, P.idAttribute)
                  ;(At != null && delete this._byId[At], Nt != null && (this._byId[Nt] = P))
                }
              }
              this.trigger.apply(this, arguments)
            },
          })
          var g = typeof Symbol == 'function' && Symbol.iterator
          g && (H.prototype[g] = H.prototype.values)
          var S = function (E, P) {
              ;((this._collection = E), (this._kind = P), (this._index = 0))
            },
            M = 1,
            _ = 2,
            W = 3
          ;(g &&
            (S.prototype[g] = function () {
              return this
            }),
            (S.prototype.next = function () {
              if (this._collection) {
                if (this._index < this._collection.length) {
                  var E = this._collection.at(this._index)
                  this._index++
                  var P
                  if (this._kind === M) P = E
                  else {
                    var Y = this._collection.modelId(E.attributes, E.idAttribute)
                    this._kind === _ ? (P = Y) : (P = [Y, E])
                  }
                  return { value: P, done: !1 }
                }
                this._collection = void 0
              }
              return { value: void 0, done: !0 }
            }))
          var $ = (n.View = function (E) {
              ;((this.cid = i.uniqueId('view')),
                this.preinitialize.apply(this, arguments),
                i.extend(this, i.pick(E, Ct)),
                this._ensureElement(),
                this.initialize.apply(this, arguments))
            }),
            X = /^(\S+)\s*(.*)$/,
            Ct = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events']
          i.extend($.prototype, c, {
            tagName: 'div',
            $: function (E) {
              return this.$el.find(E)
            },
            preinitialize: function () {},
            initialize: function () {},
            render: function () {
              return this
            },
            remove: function () {
              return (this._removeElement(), this.stopListening(), this)
            },
            _removeElement: function () {
              this.$el.remove()
            },
            setElement: function (E) {
              return (this.undelegateEvents(), this._setElement(E), this.delegateEvents(), this)
            },
            _setElement: function (E) {
              ;((this.$el = E instanceof n.$ ? E : n.$(E)), (this.el = this.$el[0]))
            },
            delegateEvents: function (E) {
              if ((E || (E = i.result(this, 'events')), !E)) return this
              this.undelegateEvents()
              for (var P in E) {
                var Y = E[P]
                if ((i.isFunction(Y) || (Y = this[Y]), !!Y)) {
                  var J = P.match(X)
                  this.delegate(J[1], J[2], Y.bind(this))
                }
              }
              return this
            },
            delegate: function (E, P, Y) {
              return (this.$el.on(E + '.delegateEvents' + this.cid, P, Y), this)
            },
            undelegateEvents: function () {
              return (this.$el && this.$el.off('.delegateEvents' + this.cid), this)
            },
            undelegate: function (E, P, Y) {
              return (this.$el.off(E + '.delegateEvents' + this.cid, P, Y), this)
            },
            _createElement: function (E) {
              return document.createElement(E)
            },
            _ensureElement: function () {
              if (this.el) this.setElement(i.result(this, 'el'))
              else {
                var E = i.extend({}, i.result(this, 'attributes'))
                ;(this.id && (E.id = i.result(this, 'id')),
                  this.className && (E.class = i.result(this, 'className')),
                  this.setElement(this._createElement(i.result(this, 'tagName'))),
                  this._setAttributes(E))
              }
            },
            _setAttributes: function (E) {
              this.$el.attr(E)
            },
          })
          var Tt = function (E, P, Y, J) {
              switch (P) {
                case 1:
                  return function () {
                    return E[Y](this[J])
                  }
                case 2:
                  return function (At) {
                    return E[Y](this[J], At)
                  }
                case 3:
                  return function (At, Nt) {
                    return E[Y](this[J], Q(At, this), Nt)
                  }
                case 4:
                  return function (At, Nt, Yt) {
                    return E[Y](this[J], Q(At, this), Nt, Yt)
                  }
                default:
                  return function () {
                    var At = u.call(arguments)
                    return (At.unshift(this[J]), E[Y].apply(E, At))
                  }
              }
            },
            G = function (E, P, Y, J) {
              i.each(Y, function (At, Nt) {
                P[Nt] && (E.prototype[Nt] = Tt(P, At, Nt, J))
              })
            },
            Q = function (E, P) {
              return i.isFunction(E)
                ? E
                : i.isObject(E) && !P._isModel(E)
                  ? it(E)
                  : i.isString(E)
                    ? function (Y) {
                        return Y.get(E)
                      }
                    : E
            },
            it = function (E) {
              var P = i.matches(E)
              return function (Y) {
                return P(Y.attributes)
              }
            },
            st = {
              forEach: 3,
              each: 3,
              map: 3,
              collect: 3,
              reduce: 0,
              foldl: 0,
              inject: 0,
              reduceRight: 0,
              foldr: 0,
              find: 3,
              detect: 3,
              filter: 3,
              select: 3,
              reject: 3,
              every: 3,
              all: 3,
              some: 3,
              any: 3,
              include: 3,
              includes: 3,
              contains: 3,
              invoke: 0,
              max: 3,
              min: 3,
              toArray: 1,
              size: 1,
              first: 3,
              head: 3,
              take: 3,
              initial: 3,
              rest: 3,
              tail: 3,
              drop: 3,
              last: 3,
              without: 0,
              difference: 0,
              indexOf: 3,
              shuffle: 1,
              lastIndexOf: 3,
              isEmpty: 1,
              chain: 1,
              sample: 3,
              partition: 3,
              groupBy: 3,
              countBy: 3,
              sortBy: 3,
              indexBy: 3,
              findIndex: 3,
              findLastIndex: 3,
            },
            F = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0, omit: 0, chain: 1, isEmpty: 1 }
          ;(i.each(
            [
              [H, st, 'models'],
              [B, F, 'attributes'],
            ],
            function (E) {
              var P = E[0],
                Y = E[1],
                J = E[2]
              ;((P.mixin = function (At) {
                var Nt = i.reduce(
                  i.functions(At),
                  function (Yt, se) {
                    return ((Yt[se] = 0), Yt)
                  },
                  {}
                )
                G(P, At, Nt, J)
              }),
                G(P, i, Y, J))
            }
          ),
            (n.sync = function (E, P, Y) {
              var J = ht[E]
              i.defaults(Y || (Y = {}), { emulateHTTP: n.emulateHTTP, emulateJSON: n.emulateJSON })
              var At = { type: J, dataType: 'json' }
              if (
                (Y.url || (At.url = i.result(P, 'url') || de()),
                Y.data == null &&
                  P &&
                  (E === 'create' || E === 'update' || E === 'patch') &&
                  ((At.contentType = 'application/json'),
                  (At.data = JSON.stringify(Y.attrs || P.toJSON(Y)))),
                Y.emulateJSON &&
                  ((At.contentType = 'application/x-www-form-urlencoded'),
                  (At.data = At.data ? { model: At.data } : {})),
                Y.emulateHTTP && (J === 'PUT' || J === 'DELETE' || J === 'PATCH'))
              ) {
                ;((At.type = 'POST'), Y.emulateJSON && (At.data._method = J))
                var Nt = Y.beforeSend
                Y.beforeSend = function (Se) {
                  if ((Se.setRequestHeader('X-HTTP-Method-Override', J), Nt))
                    return Nt.apply(this, arguments)
                }
              }
              At.type !== 'GET' && !Y.emulateJSON && (At.processData = !1)
              var Yt = Y.error
              Y.error = function (Se, $e, Ye) {
                ;((Y.textStatus = $e), (Y.errorThrown = Ye), Yt && Yt.call(Y.context, Se, $e, Ye))
              }
              var se = (Y.xhr = n.ajax(i.extend(At, Y)))
              return (P.trigger('request', P, se, Y), se)
            }))
          var ht = { create: 'POST', update: 'PUT', patch: 'PATCH', delete: 'DELETE', read: 'GET' }
          n.ajax = function () {
            return n.$.ajax.apply(n.$, arguments)
          }
          var ct = (n.Router = function (E) {
              ;(E || (E = {}),
                this.preinitialize.apply(this, arguments),
                E.routes && (this.routes = E.routes),
                this._bindRoutes(),
                this.initialize.apply(this, arguments))
            }),
            St = /\((.*?)\)/g,
            bt = /(\(\?)?:\w+/g,
            kt = /\*\w+/g,
            lt = /[\-{}\[\]+?.,\\\^$|#\s]/g
          i.extend(ct.prototype, c, {
            preinitialize: function () {},
            initialize: function () {},
            route: function (E, P, Y) {
              ;(i.isRegExp(E) || (E = this._routeToRegExp(E)),
                i.isFunction(P) && ((Y = P), (P = '')),
                Y || (Y = this[P]))
              var J = this
              return (
                n.history.route(E, function (At) {
                  var Nt = J._extractParameters(E, At)
                  J.execute(Y, Nt, P) !== !1 &&
                    (J.trigger.apply(J, ['route:' + P].concat(Nt)),
                    J.trigger('route', P, Nt),
                    n.history.trigger('route', J, P, Nt))
                }),
                this
              )
            },
            execute: function (E, P, Y) {
              E && E.apply(this, P)
            },
            navigate: function (E, P) {
              return (n.history.navigate(E, P), this)
            },
            _bindRoutes: function () {
              if (this.routes) {
                this.routes = i.result(this, 'routes')
                for (var E, P = i.keys(this.routes); (E = P.pop()) != null; )
                  this.route(E, this.routes[E])
              }
            },
            _routeToRegExp: function (E) {
              return (
                (E = E.replace(lt, '\\$&')
                  .replace(St, '(?:$1)?')
                  .replace(bt, function (P, Y) {
                    return Y ? P : '([^/?]+)'
                  })
                  .replace(kt, '([^?]*?)')),
                new RegExp('^' + E + '(?:\\?([\\s\\S]*))?$')
              )
            },
            _extractParameters: function (E, P) {
              var Y = E.exec(P).slice(1)
              return i.map(Y, function (J, At) {
                return At === Y.length - 1 ? J || null : J ? decodeURIComponent(J) : null
              })
            },
          })
          var gt = (n.History = function () {
              ;((this.handlers = []),
                (this.checkUrl = this.checkUrl.bind(this)),
                typeof window < 'u' &&
                  ((this.location = window.location), (this.history = window.history)))
            }),
            Et = /^[#\/]|\s+$/g,
            Ft = /^\/+|\/+$/g,
            Qt = /#.*$/
          ;((gt.started = !1),
            i.extend(gt.prototype, c, {
              interval: 50,
              atRoot: function () {
                var E = this.location.pathname.replace(/[^\/]$/, '$&/')
                return E === this.root && !this.getSearch()
              },
              matchRoot: function () {
                var E = this.decodeFragment(this.location.pathname),
                  P = E.slice(0, this.root.length - 1) + '/'
                return P === this.root
              },
              decodeFragment: function (E) {
                return decodeURI(E.replace(/%25/g, '%2525'))
              },
              getSearch: function () {
                var E = this.location.href.replace(/#.*/, '').match(/\?.+/)
                return E ? E[0] : ''
              },
              getHash: function (E) {
                var P = (E || this).location.href.match(/#(.*)$/)
                return P ? P[1] : ''
              },
              getPath: function () {
                var E = this.decodeFragment(this.location.pathname + this.getSearch()).slice(
                  this.root.length - 1
                )
                return E.charAt(0) === '/' ? E.slice(1) : E
              },
              getFragment: function (E) {
                return (
                  E == null &&
                    (this._usePushState || !this._wantsHashChange
                      ? (E = this.getPath())
                      : (E = this.getHash())),
                  E.replace(Et, '')
                )
              },
              start: function (E) {
                if (gt.started) throw new Error('Backbone.history has already been started')
                if (
                  ((gt.started = !0),
                  (this.options = i.extend({ root: '/' }, this.options, E)),
                  (this.root = this.options.root),
                  (this._wantsHashChange = this.options.hashChange !== !1),
                  (this._hasHashChange =
                    'onhashchange' in window &&
                    (document.documentMode === void 0 || document.documentMode > 7)),
                  (this._useHashChange = this._wantsHashChange && this._hasHashChange),
                  (this._wantsPushState = !!this.options.pushState),
                  (this._hasPushState = !!(this.history && this.history.pushState)),
                  (this._usePushState = this._wantsPushState && this._hasPushState),
                  (this.fragment = this.getFragment()),
                  (this.root = ('/' + this.root + '/').replace(Ft, '/')),
                  this._wantsHashChange && this._wantsPushState)
                )
                  if (!this._hasPushState && !this.atRoot()) {
                    var P = this.root.slice(0, -1) || '/'
                    return (this.location.replace(P + '#' + this.getPath()), !0)
                  } else
                    this._hasPushState &&
                      this.atRoot() &&
                      this.navigate(this.getHash(), { replace: !0 })
                if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
                  ;((this.iframe = document.createElement('iframe')),
                    (this.iframe.src = 'javascript:0'),
                    (this.iframe.style.display = 'none'),
                    (this.iframe.tabIndex = -1))
                  var Y = document.body,
                    J = Y.insertBefore(this.iframe, Y.firstChild).contentWindow
                  ;(J.document.open(), J.document.close(), (J.location.hash = '#' + this.fragment))
                }
                var At =
                  window.addEventListener ||
                  function (Nt, Yt) {
                    return attachEvent('on' + Nt, Yt)
                  }
                if (
                  (this._usePushState
                    ? At('popstate', this.checkUrl, !1)
                    : this._useHashChange && !this.iframe
                      ? At('hashchange', this.checkUrl, !1)
                      : this._wantsHashChange &&
                        (this._checkUrlInterval = setInterval(this.checkUrl, this.interval)),
                  !this.options.silent)
                )
                  return this.loadUrl()
              },
              stop: function () {
                var E =
                  window.removeEventListener ||
                  function (P, Y) {
                    return detachEvent('on' + P, Y)
                  }
                ;(this._usePushState
                  ? E('popstate', this.checkUrl, !1)
                  : this._useHashChange && !this.iframe && E('hashchange', this.checkUrl, !1),
                  this.iframe && (document.body.removeChild(this.iframe), (this.iframe = null)),
                  this._checkUrlInterval && clearInterval(this._checkUrlInterval),
                  (gt.started = !1))
              },
              route: function (E, P) {
                this.handlers.unshift({ route: E, callback: P })
              },
              checkUrl: function (E) {
                var P = this.getFragment()
                if (
                  (P === this.fragment &&
                    this.iframe &&
                    (P = this.getHash(this.iframe.contentWindow)),
                  P === this.fragment)
                )
                  return !1
                ;(this.iframe && this.navigate(P), this.loadUrl())
              },
              loadUrl: function (E) {
                return this.matchRoot()
                  ? ((E = this.fragment = this.getFragment(E)),
                    i.some(this.handlers, function (P) {
                      if (P.route.test(E)) return (P.callback(E), !0)
                    }))
                  : !1
              },
              navigate: function (E, P) {
                if (!gt.started) return !1
                ;((!P || P === !0) && (P = { trigger: !!P }), (E = this.getFragment(E || '')))
                var Y = this.root
                ;(E === '' || E.charAt(0) === '?') && (Y = Y.slice(0, -1) || '/')
                var J = Y + E
                E = E.replace(Qt, '')
                var At = this.decodeFragment(E)
                if (this.fragment !== At) {
                  if (((this.fragment = At), this._usePushState))
                    this.history[P.replace ? 'replaceState' : 'pushState']({}, document.title, J)
                  else if (this._wantsHashChange) {
                    if (
                      (this._updateHash(this.location, E, P.replace),
                      this.iframe && E !== this.getHash(this.iframe.contentWindow))
                    ) {
                      var Nt = this.iframe.contentWindow
                      ;(P.replace || (Nt.document.open(), Nt.document.close()),
                        this._updateHash(Nt.location, E, P.replace))
                    }
                  } else return this.location.assign(J)
                  if (P.trigger) return this.loadUrl(E)
                }
              },
              _updateHash: function (E, P, Y) {
                if (Y) {
                  var J = E.href.replace(/(javascript:|#).*$/, '')
                  E.replace(J + '#' + P)
                } else E.hash = '#' + P
              },
            }),
            (n.history = new gt()))
          var qt = function (E, P) {
            var Y = this,
              J
            return (
              E && i.has(E, 'constructor')
                ? (J = E.constructor)
                : (J = function () {
                    return Y.apply(this, arguments)
                  }),
              i.extend(J, Y, P),
              (J.prototype = i.create(Y.prototype, E)),
              (J.prototype.constructor = J),
              (J.__super__ = Y.prototype),
              J
            )
          }
          B.extend = H.extend = ct.extend = $.extend = gt.extend = qt
          var de = function () {
              throw new Error('A "url" property or function must be specified')
            },
            Xt = function (E, P) {
              var Y = P.error
              P.error = function (J) {
                ;(Y && Y.call(P.context, E, J, P), E.trigger('error', E, J, P))
              }
            }
          return n
        })
      })(Wg)),
    Wg
  )
}
var wM = CM()
const En = Hu(wM)
var xM = Nw()
const Ie = Hu(xM),
  yt = (function () {
    var t = typeof window == 'object' && !!window.SVGAngle
    if (!t)
      return function () {
        throw new Error('SVG is required to use Vectorizer.')
      }
    var e = {
        svg: 'http://www.w3.org/2000/svg',
        xmlns: 'http://www.w3.org/2000/xmlns/',
        xml: 'http://www.w3.org/XML/1998/namespace',
        xlink: 'http://www.w3.org/1999/xlink',
        xhtml: 'http://www.w3.org/1999/xhtml',
      },
      n = '1.1',
      i = Math,
      s = i.PI,
      o = i.atan2,
      u = i.sqrt,
      c = i.min,
      h = i.max,
      p = i.cos,
      y = i.sin,
      v = function (g, S, M) {
        if (!(this instanceof v)) return v.apply(Object.create(v.prototype), arguments)
        if (g) {
          if ((v.isV(g) && (g = g.node), (S = S || {}), v.isString(g))) {
            if (((g = g.trim()), g.toLowerCase() === 'svg')) g = v.createSvgDocument()
            else if (g[0] === '<') {
              var _ = v.createSvgDocument(g)
              if (_.childNodes.length > 1) {
                var W = [],
                  $,
                  X
                for ($ = 0, X = _.childNodes.length; $ < X; $++) {
                  var Ct = _.childNodes[$]
                  W.push(new v(document.importNode(Ct, !0)))
                }
                return W
              }
              g = document.importNode(_.firstChild, !0)
            } else g = document.createElementNS(e.svg, g)
            v.ensureId(g)
          }
          return ((this.node = g), this.setAttributes(S), M && this.append(M), this)
        }
      },
      C = v.prototype
    ;(Object.defineProperty(C, 'id', {
      enumerable: !0,
      get: function () {
        return this.node.id
      },
      set: function (g) {
        this.node.id = g
      },
    }),
      (C.getTransformToElement = function (g) {
        var S = this.node
        if (v.isSVGGraphicsElement(g) && v.isSVGGraphicsElement(S)) {
          var M = v.toNode(g).getScreenCTM(),
            _ = S.getScreenCTM()
          if (M && _) return M.inverse().multiply(_)
        }
        return v.createSVGMatrix()
      }),
      (C.transform = function (g, S) {
        var M = this.node
        if (v.isUndefined(g)) return v.transformStringToMatrix(this.attr('transform'))
        if (S && S.absolute) return this.attr('transform', v.matrixToTransformString(g))
        var _ = v.createSVGTransform(g)
        return (M.transform.baseVal.appendItem(_), this)
      }),
      (C.translate = function (g, S, M) {
        ;((M = M || {}), (S = S || 0))
        var _ = this.attr('transform') || '',
          W = v.parseTransformString(_)
        if (((_ = W.value), v.isUndefined(g))) return W.translate
        _ = _.replace(/translate\([^)]*\)/g, '').trim()
        var $ = M.absolute ? g : W.translate.tx + g,
          X = M.absolute ? S : W.translate.ty + S,
          Ct = 'translate(' + $ + ',' + X + ')'
        return (this.attr('transform', (Ct + ' ' + _).trim()), this)
      }),
      (C.rotate = function (g, S, M, _) {
        _ = _ || {}
        var W = this.attr('transform') || '',
          $ = v.parseTransformString(W)
        if (((W = $.value), v.isUndefined(g))) return $.rotate
        ;((W = W.replace(/rotate\([^)]*\)/g, '').trim()), (g %= 360))
        var X = _.absolute ? g : $.rotate.angle + g,
          Ct = S !== void 0 && M !== void 0 ? ',' + S + ',' + M : '',
          Tt = 'rotate(' + X + Ct + ')'
        return (this.attr('transform', (W + ' ' + Tt).trim()), this)
      }),
      (C.scale = function (g, S) {
        S = v.isUndefined(S) ? g : S
        var M = this.attr('transform') || '',
          _ = v.parseTransformString(M)
        if (((M = _.value), v.isUndefined(g))) return _.scale
        M = M.replace(/scale\([^)]*\)/g, '').trim()
        var W = 'scale(' + g + ',' + S + ')'
        return (this.attr('transform', (M + ' ' + W).trim()), this)
      }),
      (C.bbox = function (g, S) {
        var M,
          _ = this.node,
          W = _.ownerSVGElement
        if (!W) return new Pt(0, 0, 0, 0)
        try {
          M = _.getBBox()
        } catch {
          M = { x: _.clientLeft, y: _.clientTop, width: _.clientWidth, height: _.clientHeight }
        }
        if (g) return new Pt(M)
        var $ = this.getTransformToElement(S || W)
        return v.transformRect(M, $)
      }),
      (C.getBBox = function (g) {
        var S = {},
          M,
          _ = this.node,
          W = _.ownerSVGElement
        if (!W || !v.isSVGGraphicsElement(_)) return new Pt(0, 0, 0, 0)
        if (
          (g &&
            (g.target && (S.target = v.toNode(g.target)),
            g.recursive && (S.recursive = g.recursive)),
          S.recursive)
        ) {
          var X = this.children(),
            Ct = X.length
          if (Ct === 0) return this.getBBox({ target: S.target, recursive: !1 })
          S.target || (S.target = this)
          for (var Tt = 0; Tt < Ct; Tt++) {
            var G = X[Tt],
              Q
            ;(G.children().length === 0
              ? (Q = G.getBBox({ target: S.target, recursive: !1 }))
              : (Q = G.getBBox({ target: S.target, recursive: !0 })),
              M ? (M = M.union(Q)) : (M = Q))
          }
          return M
        } else {
          try {
            M = _.getBBox()
          } catch {
            M = { x: _.clientLeft, y: _.clientTop, width: _.clientWidth, height: _.clientHeight }
          }
          if (S.target) {
            var $ = this.getTransformToElement(S.target)
            return v.transformRect(M, $)
          } else return new Pt(M)
        }
      }))
    function w(g, S) {
      g || (g = {})
      var M = v('textPath'),
        _ = g.d
      if (_ && g['xlink:href'] === void 0) {
        var W = v('path').attr('d', _).appendTo(S.defs())
        M.attr('xlink:href', '#' + W.id)
      }
      return (v.isObject(g) && M.attr(g), M.node)
    }
    function N(g, S, M) {
      M || (M = {})
      for (
        var _ = M.includeAnnotationIndices,
          W = M.eol,
          $ = M.lineHeight,
          X = M.baseSize,
          Ct = 0,
          Tt = {},
          G = S.length - 1,
          Q = 0;
        Q <= G;
        Q++
      ) {
        var it = S[Q],
          st = null
        if (v.isObject(it)) {
          var F = it.attrs,
            ht = v('tspan', F),
            ct = ht.node,
            St = it.t
          ;(W && Q === G && (St += W), (ct.textContent = St))
          var bt = F.class
          ;(bt && ht.addClass(bt),
            _ && ht.attr('annotations', it.annotations),
            (st = parseFloat(F['font-size'])),
            isFinite(st) || (st = X),
            st && st > Ct && (Ct = st))
        } else
          (W && Q === G && (it += W),
            (ct = document.createTextNode(it || ' ')),
            X && X > Ct && (Ct = X))
        g.appendChild(ct)
      }
      return (
        Ct && (Tt.maxFontSize = Ct),
        $ ? (Tt.lineHeight = $) : Ct && (Tt.lineHeight = Ct * 1.2),
        Tt
      )
    }
    var T = /em$/
    function z(g, S) {
      var M = parseFloat(g)
      return T.test(g) ? M * S : M
    }
    function R(g, S, M, _) {
      if (!Array.isArray(S)) return 0
      var W = S.length
      if (!W) return 0
      for (var $ = S[0], X = z($.maxFontSize, M) || M, Ct = 0, Tt = z(_, M), G = 1; G < W; G++) {
        $ = S[G]
        var Q = z($.lineHeight, M) || Tt
        Ct += Q
      }
      var it = z($.maxFontSize, M) || M,
        st
      switch (g) {
        case 'middle':
          st = X / 2 - 0.15 * it - Ct / 2
          break
        case 'bottom':
          st = -(0.25 * it) - Ct
          break
        default:
        case 'top':
          st = 0.8 * X
          break
      }
      return st
    }
    ;((C.text = function (g, S) {
      if (g && typeof g != 'string')
        throw new Error('Vectorizer: text() expects the first argument to be a string.')
      ;((g = v.sanitizeText(g)), S || (S = {}))
      var M = S.displayEmpty,
        _ = S.eol,
        W = S.textPath,
        $ = S.textVerticalAnchor,
        X = $ === 'middle' || $ === 'bottom' || $ === 'top',
        Ct = S.x
      Ct === void 0 && (Ct = this.attr('x') || 0)
      var Tt = S.includeAnnotationIndices,
        G = S.annotations
      G && !v.isArray(G) && (G = [G])
      var Q = S.lineHeight,
        it = Q === 'auto',
        st = it ? '1.5em' : Q || '1em'
      ;(this.empty(), this.attr({ 'xml:space': 'preserve', display: g || M ? null : 'none' }))
      var F = parseFloat(this.attr('font-size'))
      F || ((F = 16), (X || G) && this.attr('font-size', F))
      var ht = document,
        ct
      W
        ? (typeof W == 'string' && (W = { d: W }), (ct = w(W, this)))
        : (ct = ht.createDocumentFragment())
      for (
        var St = 0,
          bt = g.split(`
`),
          kt = [],
          lt,
          gt = 0,
          Et = bt.length - 1;
        gt <= Et;
        gt++
      ) {
        var Ft = st,
          Qt = 'v-line',
          qt = ht.createElementNS(e.svg, 'tspan'),
          de = bt[gt],
          Xt
        if (de)
          if (G) {
            var E = v.annotateString(de, G, { offset: -St, includeAnnotationIndices: Tt })
            Xt = N(qt, E, {
              includeAnnotationIndices: Tt,
              eol: gt !== Et && _,
              lineHeight: it ? null : st,
              baseSize: F,
            })
            var P = Xt.lineHeight
            ;(P && it && gt !== 0 && (Ft = P), gt === 0 && (lt = Xt.maxFontSize * 0.8))
          } else (_ && gt !== Et && (de += _), (qt.textContent = de))
        else {
          ;((qt.textContent = '-'), (Qt += ' v-empty-line'))
          var Y = qt.style
          if (((Y.fillOpacity = 0), (Y.strokeOpacity = 0), G)) {
            ;((Xt = {}), (E = v.findAnnotationsAtIndex(G, St)))
            let At = F
            for (let Nt = E.length; Nt > 0; Nt--) {
              const Yt = E[Nt - 1].attrs
              if (!Yt || !('font-size' in Yt)) continue
              const se = parseFloat(Yt['font-size'])
              if (isFinite(se)) {
                At = se
                break
              }
            }
            ;(it && (gt > 0 ? (Ft = At * 1.2) : (lt = At * 0.8)),
              qt.setAttribute('font-size', At),
              (Xt.maxFontSize = At))
          }
        }
        ;(Xt && kt.push(Xt),
          gt > 0 && qt.setAttribute('dy', Ft),
          (gt > 0 || W) && qt.setAttribute('x', Ct),
          (qt.className.baseVal = Qt),
          ct.appendChild(qt),
          (St += de.length + 1))
      }
      if (X)
        if (G) Ft = R($, kt, F, st)
        else if ($ === 'top') Ft = '0.8em'
        else {
          var J
          switch (
            (Et > 0 ? ((J = parseFloat(st) || 1), (J *= Et), T.test(st) || (J /= F)) : (J = 0), $)
          ) {
            case 'middle':
              Ft = 0.3 - J / 2 + 'em'
              break
            case 'bottom':
              Ft = -J - 0.3 + 'em'
              break
          }
        }
      else
        $ === 0
          ? (Ft = '0em')
          : $
            ? (Ft = $)
            : ((Ft = 0), this.attr('y') === null && this.attr('y', lt || '0.8em'))
      return (ct.firstChild.setAttribute('dy', Ft), this.append(ct), this)
    }),
      (C.removeAttr = function (g) {
        const S = U[g],
          { ns: M, local: _ } = v.qualifyAttr(S),
          W = this.node
        return (
          M
            ? W.hasAttributeNS(M, _) && W.removeAttributeNS(M, _)
            : W.hasAttribute(S) && W.removeAttribute(S),
          this
        )
      }),
      (C.attr = function (g, S) {
        if (v.isUndefined(g)) {
          for (var M = this.node.attributes, _ = {}, W = 0; W < M.length; W++)
            _[M[W].name] = M[W].value
          return _
        }
        if (v.isString(g) && v.isUndefined(S)) return this.node.getAttribute(U[g])
        if (typeof g == 'object') for (var $ in g) g.hasOwnProperty($) && this.setAttribute($, g[$])
        else this.setAttribute(g, S)
        return this
      }),
      (C.normalizePath = function () {
        var g = this.tagName()
        return (g === 'PATH' && this.attr('d', v.normalizePathData(this.attr('d'))), this)
      }),
      (C.remove = function () {
        return (this.node.parentNode && this.node.parentNode.removeChild(this.node), this)
      }),
      (C.empty = function () {
        for (; this.node.firstChild; ) this.node.removeChild(this.node.firstChild)
        return this
      }),
      (C.setAttributes = function (g) {
        for (var S in g) g.hasOwnProperty(S) && this.setAttribute(S, g[S])
        return this
      }),
      (C.append = function (g) {
        v.isArray(g) || (g = [g])
        for (var S = 0, M = g.length; S < M; S++) this.node.appendChild(v.toNode(g[S]))
        return this
      }),
      (C.prepend = function (g) {
        var S = this.node.firstChild
        return S ? v(S).before(g) : this.append(g)
      }),
      (C.before = function (g) {
        var S = this.node,
          M = S.parentNode
        if (M) {
          v.isArray(g) || (g = [g])
          for (var _ = 0, W = g.length; _ < W; _++) M.insertBefore(v.toNode(g[_]), S)
        }
        return this
      }),
      (C.appendTo = function (g) {
        return (v.toNode(g).appendChild(this.node), this)
      }),
      (C.svg = function () {
        return this.node instanceof window.SVGSVGElement ? this : v(this.node.ownerSVGElement)
      }),
      (C.tagName = function () {
        return this.node.tagName.toUpperCase()
      }),
      (C.defs = function () {
        var g = this.svg() || this,
          S = g.node.getElementsByTagName('defs')[0]
        return S ? v(S) : v('defs').appendTo(g)
      }),
      (C.clone = function () {
        var g = v(this.node.cloneNode(!0))
        return ((g.node.id = v.uniqueId()), g)
      }),
      (C.findOne = function (g) {
        var S = this.node.querySelector(g)
        return S ? v(S) : void 0
      }),
      (C.find = function (g) {
        var S = [],
          M = this.node.querySelectorAll(g)
        if (M) for (var _ = 0; _ < M.length; _++) S.push(v(M[_]))
        return S
      }),
      (C.children = function () {
        for (var g = this.node.childNodes, S = [], M = 0; M < g.length; M++) {
          var _ = g[M]
          _.nodeType === 1 && S.push(v(g[M]))
        }
        return S
      }),
      (C.parent = function () {
        return v(this.node.parentNode) || null
      }),
      (C.index = function () {
        for (var g = 0, S = this.node.previousSibling; S; )
          (S.nodeType === 1 && g++, (S = S.previousSibling))
        return g
      }),
      (C.findParentByClass = function (g, S) {
        for (
          var M = this.node.ownerSVGElement, _ = this.node.parentNode;
          _ && _ !== S && _ !== M;

        ) {
          var W = v(_)
          if (W.hasClass(g)) return W
          _ = _.parentNode
        }
        return null
      }),
      (C.contains = function (g) {
        var S = this.node,
          M = v.toNode(g),
          _ = M && M.parentNode
        return S === _ || !!(_ && _.nodeType === 1 && S.compareDocumentPosition(_) & 16)
      }),
      (C.toLocalPoint = function (g, S) {
        var M = this.svg().node,
          _ = M.createSVGPoint()
        ;((_.x = g), (_.y = S))
        try {
          var W = _.matrixTransform(M.getScreenCTM().inverse()),
            $ = this.getTransformToElement(M).inverse()
        } catch {
          return _
        }
        return W.matrixTransform($)
      }),
      (C.translateCenterToPoint = function (g) {
        var S = this.getBBox({ target: this.svg() }),
          M = S.center()
        return (this.translate(g.x - M.x, g.y - M.y), this)
      }),
      (C.translateAndAutoOrient = function (g, S, M) {
        ;((g = new et(g)), (S = new et(S)), M || (M = this.svg()))
        var _ = this.scale()
        this.attr('transform', '')
        var W = this.getBBox({ target: M }).scale(_.sx, _.sy),
          $ = v.createSVGTransform()
        $.setTranslate(-W.x - W.width / 2, -W.y - W.height / 2)
        var X = v.createSVGTransform(),
          Ct = g.angleBetween(S, g.clone().offset(1, 0))
        Ct && X.setRotate(Ct, 0, 0)
        var Tt = v.createSVGTransform(),
          G = g.clone().move(S, W.width / 2)
        Tt.setTranslate(2 * g.x - G.x, 2 * g.y - G.y)
        var Q = this.getTransformToElement(M),
          it = v.createSVGTransform()
        return (
          it.setMatrix(
            Tt.matrix.multiply(X.matrix.multiply($.matrix.multiply(Q.scale(_.sx, _.sy))))
          ),
          this.attr('transform', v.matrixToTransformString(it.matrix)),
          this
        )
      }),
      (C.animateAlongPath = function (g, S) {
        S = v.toNode(S)
        var M = v.ensureId(S),
          _ = v('animateMotion', g),
          W = v('mpath', { 'xlink:href': '#' + M })
        ;(_.append(W), this.append(_))
        try {
          _.node.beginElement()
        } catch {
          if (document.documentElement.getAttribute('smiling') === 'fake') {
            var $ = _.node
            $.animators = []
            var X = $.getAttribute('id')
            X && (id2anim[X] = $)
            for (var Ct = getTargets($), Tt = 0, G = Ct.length; Tt < G; Tt++) {
              var Q = Ct[Tt],
                it = new Animator($, Q, Tt)
              ;(animators.push(it), ($.animators[Tt] = it), it.register())
            }
          }
        }
        return this
      }))
    const B = /[^\x20\t\r\n\f]+/g
    function H(g) {
      return v.isString(g) ? g.trim().match(B) || [] : []
    }
    ;((C.hasClass = function (g) {
      return v.isString(g) ? this.node.classList.contains(g.trim()) : !1
    }),
      (C.addClass = function (g) {
        return (this.node.classList.add(...H(g)), this)
      }),
      (C.removeClass = function (g) {
        return (this.node.classList.remove(...H(g)), this)
      }),
      (C.toggleClass = function (g, S) {
        const M = H(g)
        for (let _ = 0; _ < M.length; _++) this.node.classList.toggle(M[_], S)
        return this
      }),
      (C.sample = function (g) {
        g = g || 1
        for (var S = this.node, M = S.getTotalLength(), _ = [], W = 0, $; W < M; )
          (($ = S.getPointAtLength(W)), _.push({ x: $.x, y: $.y, distance: W }), (W += g))
        return _
      }),
      (C.convertToPath = function () {
        var g = v('path')
        g.attr(this.attr())
        var S = this.convertToPathData()
        return (S && g.attr('d', S), g)
      }),
      (C.convertToPathData = function () {
        var g = this.tagName()
        switch (g) {
          case 'PATH':
            return this.attr('d')
          case 'LINE':
            return v.convertLineToPathData(this.node)
          case 'POLYGON':
            return v.convertPolygonToPathData(this.node)
          case 'POLYLINE':
            return v.convertPolylineToPathData(this.node)
          case 'ELLIPSE':
            return v.convertEllipseToPathData(this.node)
          case 'CIRCLE':
            return v.convertCircleToPathData(this.node)
          case 'RECT':
            return v.convertRectToPathData(this.node)
        }
        throw new Error(g + ' cannot be converted to PATH.')
      }),
      (v.prototype.toGeometryShape = function () {
        var g, S, M, _, W, $, X, Ct, Tt, G, Q, it, st, F, ht
        switch (this.tagName()) {
          case 'RECT':
            return (
              (g = parseFloat(this.attr('x')) || 0),
              (S = parseFloat(this.attr('y')) || 0),
              (M = parseFloat(this.attr('width')) || 0),
              (_ = parseFloat(this.attr('height')) || 0),
              new Pt(g, S, M, _)
            )
          case 'CIRCLE':
            return (
              (W = parseFloat(this.attr('cx')) || 0),
              ($ = parseFloat(this.attr('cy')) || 0),
              (X = parseFloat(this.attr('r')) || 0),
              new li({ x: W, y: $ }, X, X)
            )
          case 'ELLIPSE':
            return (
              (W = parseFloat(this.attr('cx')) || 0),
              ($ = parseFloat(this.attr('cy')) || 0),
              (Ct = parseFloat(this.attr('rx')) || 0),
              (Tt = parseFloat(this.attr('ry')) || 0),
              new li({ x: W, y: $ }, Ct, Tt)
            )
          case 'POLYLINE':
            return ((G = v.getPointsFromSvgNode(this)), new qe(G))
          case 'POLYGON':
            return ((G = v.getPointsFromSvgNode(this)), G.length > 1 && G.push(G[0]), new qe(G))
          case 'PATH':
            return (
              (Q = this.attr('d')),
              Jt.isDataSupported(Q) || (Q = v.normalizePathData(Q)),
              new Jt(Q)
            )
          case 'LINE':
            return (
              (it = parseFloat(this.attr('x1')) || 0),
              (F = parseFloat(this.attr('y1')) || 0),
              (st = parseFloat(this.attr('x2')) || 0),
              (ht = parseFloat(this.attr('y2')) || 0),
              new Ut({ x: it, y: F }, { x: st, y: ht })
            )
        }
        return this.getBBox()
      }),
      (C.findIntersection = function (g, S) {
        var M = this.svg().node
        S = S || M
        var _ = this.getBBox({ target: S }),
          W = _.center()
        if (_.intersectionWithLineFromCenterToPoint(g)) {
          var $,
            X = this.tagName()
          if (X === 'RECT') {
            var Ct = new Pt(
                parseFloat(this.attr('x') || 0),
                parseFloat(this.attr('y') || 0),
                parseFloat(this.attr('width')),
                parseFloat(this.attr('height'))
              ),
              Tt = this.getTransformToElement(S),
              G = v.decomposeMatrix(Tt),
              Q = M.createSVGTransform()
            Q.setRotate(-G.rotation, W.x, W.y)
            var it = v.transformRect(Ct, Q.matrix.multiply(Tt))
            $ = new Pt(it).intersectionWithLineFromCenterToPoint(g, G.rotation)
          } else if (
            X === 'PATH' ||
            X === 'POLYGON' ||
            X === 'POLYLINE' ||
            X === 'CIRCLE' ||
            X === 'ELLIPSE'
          ) {
            var st = X === 'PATH' ? this : this.convertToPath(),
              F = st.sample(),
              ht = 1 / 0,
              ct = [],
              St,
              bt,
              kt,
              lt,
              gt,
              Et
            for (St = 0; St < F.length; St++)
              ((bt = F[St]),
                (kt = v.createSVGPoint(bt.x, bt.y)),
                (kt = kt.matrixTransform(this.getTransformToElement(S))),
                (bt = new et(kt)),
                (lt = bt.distance(W)),
                (gt = bt.distance(g) * 1.1),
                (Et = lt + gt),
                Et < ht
                  ? ((ht = Et), (ct = [{ sample: bt, refDistance: gt }]))
                  : Et < ht + 1 && ct.push({ sample: bt, refDistance: gt }))
            ;(ct.sort(function (Ft, Qt) {
              return Ft.refDistance - Qt.refDistance
            }),
              ct[0] && ($ = ct[0].sample))
          }
          return $
        }
      }),
      (C.setAttribute = function (g, S) {
        const M = this.node
        if (S === null) return (this.removeAttr(g), this)
        const _ = U[g],
          { ns: W } = v.qualifyAttr(_)
        return (
          W ? M.setAttributeNS(W, _, S) : _ === 'id' ? (M.id = S) : M.setAttribute(_, S),
          this
        )
      }),
      (v.createSvgDocument = function (g) {
        if (g) {
          const M = `<svg xmlns="${e.svg}" xmlns:xlink="${e.xlink}" version="${n}">${g}</svg>`,
            { documentElement: _ } = v.parseXML(M, { async: !1 })
          return _
        }
        const S = document.createElementNS(e.svg, 'svg')
        return (S.setAttributeNS(e.xmlns, 'xmlns:xlink', e.xlink), S.setAttribute('version', n), S)
      }),
      (v.createSVGStyle = function (g) {
        const { node: S } = v('style', { type: 'text/css' }, [v.createCDATASection(g)])
        return S
      }),
      (v.createCDATASection = function (g = '') {
        return document.implementation.createDocument(null, 'xml', null).createCDATASection(g)
      }),
      (v.idCounter = 0),
      (v.uniqueId = function () {
        return 'v-' + ++v.idCounter
      }),
      (v.toNode = function (g) {
        return v.isV(g) ? g.node : (g.nodeName && g) || g[0]
      }),
      (v.ensureId = function (g) {
        return ((g = v.toNode(g)), g.id || (g.id = v.uniqueId()))
      }),
      (v.sanitizeText = function (g) {
        return (g || '').replace(/ /g, ' ')
      }),
      (v.isUndefined = function (g) {
        return typeof g > 'u'
      }),
      (v.isString = function (g) {
        return typeof g == 'string'
      }),
      (v.isObject = function (g) {
        return g && typeof g == 'object'
      }),
      (v.isArray = Array.isArray),
      (v.parseXML = function (g, S) {
        S = S || {}
        var M
        try {
          var _ = new DOMParser()
          ;(v.isUndefined(S.async) || (_.async = S.async), (M = _.parseFromString(g, 'text/xml')))
        } catch {
          M = void 0
        }
        if (!M || M.getElementsByTagName('parsererror').length) throw new Error('Invalid XML: ' + g)
        return M
      }))
    const Z = Object.create(null)
    ;[
      'baseFrequency',
      'baseProfile',
      'clipPathUnits',
      'contentScriptType',
      'contentStyleType',
      'diffuseConstant',
      'edgeMode',
      'externalResourcesRequired',
      'filterRes',
      'filterUnits',
      'gradientTransform',
      'gradientUnits',
      'kernelMatrix',
      'kernelUnitLength',
      'keyPoints',
      'lengthAdjust',
      'limitingConeAngle',
      'markerHeight',
      'markerUnits',
      'markerWidth',
      'maskContentUnits',
      'maskUnits',
      'numOctaves',
      'pathLength',
      'patternContentUnits',
      'patternTransform',
      'patternUnits',
      'pointsAtX',
      'pointsAtY',
      'pointsAtZ',
      'preserveAlpha',
      'preserveAspectRatio',
      'primitiveUnits',
      'refX',
      'refY',
      'requiredExtensions',
      'requiredFeatures',
      'specularConstant',
      'specularExponent',
      'spreadMethod',
      'startOffset',
      'stdDeviation',
      'stitchTiles',
      'surfaceScale',
      'systemLanguage',
      'tableValues',
      'targetX',
      'targetY',
      'textLength',
      'viewBox',
      'viewTarget',
      'xChannelSelector',
      'yChannelSelector',
      'zoomAndPan',
    ].forEach(g => (Z[g] = g))
    const U = new Proxy(Z, {
      get(g, S) {
        return v.supportCamelCaseAttributes
          ? S in g
            ? g[S]
            : (g[S] = S.replace(/[A-Z]/g, '-$&').toLowerCase())
          : S
      },
    })
    ;(Object.defineProperty(v, 'attributeNames', { value: U, writable: !1 }),
      Object.defineProperty(v, 'supportCamelCaseAttributes', { value: !1, writable: !0 }),
      (v.qualifyAttr = function (g) {
        if (g.indexOf(':') !== -1) {
          var S = g.split(':')
          return { ns: e[S[0]], local: S[1] }
        }
        return { ns: null, local: g }
      }),
      (v.transformSeparatorRegex = /[ ,]+/),
      (v.transformRegex = /\b\w+\([^()]+\)/g),
      (v.transformFunctionRegex = /\b(\w+)\(([^()]+)\)/),
      (v.transformTranslateRegex = /\btranslate\(([^()]+)\)/),
      (v.transformRotateRegex = /\brotate\(([^()]+)\)/),
      (v.transformScaleRegex = /\bscale\(([^()]+)\)/),
      (v.transformStringToMatrix = function (g) {
        let S = v.createSVGMatrix()
        const M = g && g.match(v.transformRegex)
        if (!M) return S
        const _ = M.length
        for (let W = 0; W < _; W++) {
          const X = M[W].match(v.transformFunctionRegex)
          if (X) {
            let Ct,
              Tt,
              G,
              Q,
              it,
              st = v.createSVGMatrix()
            const F = X[1].toLowerCase(),
              ht = X[2].split(v.transformSeparatorRegex)
            switch (F) {
              case 'scale':
                ;((Ct = parseFloat(ht[0])),
                  (Tt = ht[1] === void 0 ? Ct : parseFloat(ht[1])),
                  (st = st.scaleNonUniform(Ct, Tt)))
                break
              case 'translate':
                ;((G = parseFloat(ht[0])), (Q = parseFloat(ht[1])), (st = st.translate(G, Q)))
                break
              case 'rotate':
                ;((it = parseFloat(ht[0])),
                  (G = parseFloat(ht[1]) || 0),
                  (Q = parseFloat(ht[2]) || 0),
                  G !== 0 || Q !== 0
                    ? (st = st.translate(G, Q).rotate(it).translate(-G, -Q))
                    : (st = st.rotate(it)))
                break
              case 'skewx':
                ;((it = parseFloat(ht[0])), (st = st.skewX(it)))
                break
              case 'skewy':
                ;((it = parseFloat(ht[0])), (st = st.skewY(it)))
                break
              case 'matrix':
                ;((st.a = parseFloat(ht[0])),
                  (st.b = parseFloat(ht[1])),
                  (st.c = parseFloat(ht[2])),
                  (st.d = parseFloat(ht[3])),
                  (st.e = parseFloat(ht[4])),
                  (st.f = parseFloat(ht[5])))
                break
              default:
                continue
            }
            S = S.multiply(st)
          }
        }
        return S
      }),
      (v.matrixToTransformString = function (g) {
        return (
          g || (g = !0),
          'matrix(' +
            (g.a !== void 0 ? g.a : 1) +
            ',' +
            (g.b !== void 0 ? g.b : 0) +
            ',' +
            (g.c !== void 0 ? g.c : 0) +
            ',' +
            (g.d !== void 0 ? g.d : 1) +
            ',' +
            (g.e !== void 0 ? g.e : 0) +
            ',' +
            (g.f !== void 0 ? g.f : 0) +
            ')'
        )
      }),
      (v.parseTransformString = function (g) {
        var S, M, _
        if (g) {
          var W = v.transformSeparatorRegex
          if (g.trim().indexOf('matrix') >= 0) {
            var $ = v.transformStringToMatrix(g),
              X = v.decomposeMatrix($)
            ;((S = [X.translateX, X.translateY]), (_ = [X.scaleX, X.scaleY]), (M = [X.rotation]))
            var Ct = []
            ;((S[0] !== 0 || S[1] !== 0) && Ct.push('translate(' + S + ')'),
              (_[0] !== 1 || _[1] !== 1) && Ct.push('scale(' + _ + ')'),
              M[0] !== 0 && Ct.push('rotate(' + M + ')'),
              (g = Ct.join(' ')))
          } else {
            const G = g.match(v.transformTranslateRegex)
            G && (S = G[1].split(W))
            const Q = g.match(v.transformRotateRegex)
            Q && (M = Q[1].split(W))
            const it = g.match(v.transformScaleRegex)
            it && (_ = it[1].split(W))
          }
        }
        var Tt = _ && _[0] ? parseFloat(_[0]) : 1
        return {
          value: g,
          translate: {
            tx: S && S[0] ? parseInt(S[0], 10) : 0,
            ty: S && S[1] ? parseInt(S[1], 10) : 0,
          },
          rotate: {
            angle: M && M[0] ? parseInt(M[0], 10) : 0,
            cx: M && M[1] ? parseInt(M[1], 10) : void 0,
            cy: M && M[2] ? parseInt(M[2], 10) : void 0,
          },
          scale: { sx: Tt, sy: _ && _[1] ? parseFloat(_[1]) : Tt },
        }
      }),
      (v.deltaTransformPoint = function (g, S) {
        var M = S.x * g.a + S.y * g.c + 0,
          _ = S.x * g.b + S.y * g.d + 0
        return { x: M, y: _ }
      }),
      (v.decomposeMatrix = function (g) {
        var S = v.deltaTransformPoint(g, { x: 0, y: 1 }),
          M = v.deltaTransformPoint(g, { x: 1, y: 0 }),
          _ = (180 / s) * o(S.y, S.x) - 90,
          W = (180 / s) * o(M.y, M.x)
        return {
          translateX: g.e,
          translateY: g.f,
          scaleX: u(g.a * g.a + g.b * g.b),
          scaleY: u(g.c * g.c + g.d * g.d),
          skewX: _,
          skewY: W,
          rotation: _,
        }
      }),
      (v.matrixToScale = function (g) {
        var S, M, _, W
        return (
          g
            ? ((S = v.isUndefined(g.a) ? 1 : g.a),
              (W = v.isUndefined(g.d) ? 1 : g.d),
              (M = g.b),
              (_ = g.c))
            : (S = W = 1),
          { sx: M ? u(S * S + M * M) : S, sy: _ ? u(_ * _ + W * W) : W }
        )
      }),
      (v.matrixToRotate = function (g) {
        var S = { x: 0, y: 1 }
        return (g && (S = v.deltaTransformPoint(g, S)), { angle: Dr(dh(o(S.y, S.x)) - 90) })
      }),
      (v.matrixToTranslate = function (g) {
        return { tx: (g && g.e) || 0, ty: (g && g.f) || 0 }
      }),
      (v.isV = function (g) {
        return g instanceof v
      }),
      (v.isVElement = v.isV),
      (v.isSVGGraphicsElement = function (g) {
        return g
          ? ((g = v.toNode(g)), g instanceof SVGElement && typeof g.getScreenCTM == 'function')
          : !1
      }))
    var nt = v('svg').node
    return (
      (v.createSVGMatrix = function (g) {
        var S = nt.createSVGMatrix()
        for (var M in g) S[M] = g[M]
        return S
      }),
      (v.createSVGTransform = function (g) {
        return v.isUndefined(g)
          ? nt.createSVGTransform()
          : (g instanceof SVGMatrix || (g = v.createSVGMatrix(g)),
            nt.createSVGTransformFromMatrix(g))
      }),
      (v.createSVGPoint = function (g, S) {
        var M = nt.createSVGPoint()
        return ((M.x = g), (M.y = S), M)
      }),
      (v.transformRect = function (g, S) {
        var M = nt.createSVGPoint()
        ;((M.x = g.x), (M.y = g.y))
        var _ = M.matrixTransform(S)
        ;((M.x = g.x + g.width), (M.y = g.y))
        var W = M.matrixTransform(S)
        ;((M.x = g.x + g.width), (M.y = g.y + g.height))
        var $ = M.matrixTransform(S)
        ;((M.x = g.x), (M.y = g.y + g.height))
        var X = M.matrixTransform(S),
          Ct = c(_.x, W.x, $.x, X.x),
          Tt = h(_.x, W.x, $.x, X.x),
          G = c(_.y, W.y, $.y, X.y),
          Q = h(_.y, W.y, $.y, X.y)
        return new Pt(Ct, G, Tt - Ct, Q - G)
      }),
      (v.transformPoint = function (g, S) {
        return new et(v.createSVGPoint(g.x, g.y).matrixTransform(S))
      }),
      (v.transformLine = function (g, S) {
        return new Ut(v.transformPoint(g.start, S), v.transformPoint(g.end, S))
      }),
      (v.transformPolyline = function (g, S) {
        var M = g instanceof qe ? g.points : g
        v.isArray(M) || (M = [])
        for (var _ = [], W = 0, $ = M.length; W < $; W++) _[W] = v.transformPoint(M[W], S)
        return new qe(_)
      }),
      (v.styleToObject = function (g) {
        for (var S = {}, M = g.split(';'), _ = 0; _ < M.length; _++) {
          var W = M[_],
            $ = W.split('=')
          S[$[0].trim()] = $[1].trim()
        }
        return S
      }),
      (v.createSlicePathData = function (g, S, M, _) {
        var W = 2 * s - 1e-6,
          $ = g,
          X = S,
          Ct = M,
          Tt = _,
          G = (Tt < Ct && ((G = Ct), (Ct = Tt), (Tt = G)), Tt - Ct),
          Q = G < s ? '0' : '1',
          it = p(Ct),
          st = y(Ct),
          F = p(Tt),
          ht = y(Tt)
        return G >= W
          ? $
            ? 'M0,' +
              X +
              'A' +
              X +
              ',' +
              X +
              ' 0 1,1 0,' +
              -X +
              'A' +
              X +
              ',' +
              X +
              ' 0 1,1 0,' +
              X +
              'M0,' +
              $ +
              'A' +
              $ +
              ',' +
              $ +
              ' 0 1,0 0,' +
              -$ +
              'A' +
              $ +
              ',' +
              $ +
              ' 0 1,0 0,' +
              $ +
              'Z'
            : 'M0,' +
              X +
              'A' +
              X +
              ',' +
              X +
              ' 0 1,1 0,' +
              -X +
              'A' +
              X +
              ',' +
              X +
              ' 0 1,1 0,' +
              X +
              'Z'
          : $
            ? 'M' +
              X * it +
              ',' +
              X * st +
              'A' +
              X +
              ',' +
              X +
              ' 0 ' +
              Q +
              ',1 ' +
              X * F +
              ',' +
              X * ht +
              'L' +
              $ * F +
              ',' +
              $ * ht +
              'A' +
              $ +
              ',' +
              $ +
              ' 0 ' +
              Q +
              ',0 ' +
              $ * it +
              ',' +
              $ * st +
              'Z'
            : 'M' +
              X * it +
              ',' +
              X * st +
              'A' +
              X +
              ',' +
              X +
              ' 0 ' +
              Q +
              ',1 ' +
              X * F +
              ',' +
              X * ht +
              'L0,0Z'
      }),
      (v.mergeAttrs = function (g, S) {
        for (var M in S)
          M === 'class'
            ? (g[M] = g[M] ? g[M] + ' ' + S[M] : S[M])
            : M === 'style'
              ? v.isObject(g[M]) && v.isObject(S[M])
                ? (g[M] = v.mergeAttrs(g[M], S[M]))
                : v.isObject(g[M])
                  ? (g[M] = v.mergeAttrs(g[M], v.styleToObject(S[M])))
                  : v.isObject(S[M])
                    ? (g[M] = v.mergeAttrs(v.styleToObject(g[M]), S[M]))
                    : (g[M] = v.mergeAttrs(v.styleToObject(g[M]), v.styleToObject(S[M])))
              : (g[M] = S[M])
        return g
      }),
      (v.annotateString = function (g, S, M) {
        ;((S = S || []), (M = M || {}))
        for (var _ = M.offset || 0, W = [], $, X = [], Ct, Tt, G = 0; G < g.length; G++) {
          Ct = X[G] = g[G]
          for (var Q = 0; Q < S.length; Q++) {
            var it = S[Q],
              st = it.start + _,
              F = it.end + _
            G >= st &&
              G < F &&
              (v.isObject(Ct)
                ? (Ct.attrs = v.mergeAttrs(v.mergeAttrs({}, Ct.attrs), it.attrs))
                : (Ct = X[G] = { t: g[G], attrs: it.attrs }),
              M.includeAnnotationIndices && (Ct.annotations || (Ct.annotations = [])).push(Q))
          }
          ;((Tt = X[G - 1]),
            Tt
              ? v.isObject(Ct) && v.isObject(Tt)
                ? JSON.stringify(Ct.attrs) === JSON.stringify(Tt.attrs)
                  ? ($.t += Ct.t)
                  : (W.push($), ($ = Ct))
                : v.isObject(Ct) || v.isObject(Tt)
                  ? (W.push($), ($ = Ct))
                  : ($ = ($ || '') + Ct)
              : ($ = Ct))
        }
        return ($ && W.push($), W)
      }),
      (v.findAnnotationsAtIndex = function (g, S) {
        var M = []
        return (
          g &&
            g.forEach(function (_) {
              _.start < S && S <= _.end && M.push(_)
            }),
          M
        )
      }),
      (v.findAnnotationsBetweenIndexes = function (g, S, M) {
        var _ = []
        return (
          g &&
            g.forEach(function (W) {
              ;((S >= W.start && S < W.end) ||
                (M > W.start && M <= W.end) ||
                (W.start >= S && W.end < M)) &&
                _.push(W)
            }),
          _
        )
      }),
      (v.shiftAnnotations = function (g, S, M) {
        return (
          g &&
            g.forEach(function (_) {
              _.start < S && _.end >= S
                ? (_.end += M)
                : _.start >= S && ((_.start += M), (_.end += M))
            }),
          g
        )
      }),
      (v.convertLineToPathData = function (g) {
        g = v(g)
        var S = ['M', g.attr('x1'), g.attr('y1'), 'L', g.attr('x2'), g.attr('y2')].join(' ')
        return S
      }),
      (v.convertPolygonToPathData = function (g) {
        var S = v.getPointsFromSvgNode(g)
        return S.length === 0 ? null : v.svgPointsToPath(S) + ' Z'
      }),
      (v.convertPolylineToPathData = function (g) {
        var S = v.getPointsFromSvgNode(g)
        return S.length === 0 ? null : v.svgPointsToPath(S)
      }),
      (v.svgPointsToPath = function (g) {
        for (var S = 0, M = g.length; S < M; S++) g[S] = g[S].x + ' ' + g[S].y
        return 'M ' + g.join(' L')
      }),
      (v.getPointsFromSvgNode = function (g) {
        g = v.toNode(g)
        var S = [],
          M = g.points
        if (M) for (var _ = 0, W = M.numberOfItems; _ < W; _++) S.push(M.getItem(_))
        return S
      }),
      (v.KAPPA = 0.551784),
      (v.convertCircleToPathData = function (g) {
        g = v(g)
        var S = parseFloat(g.attr('cx')) || 0,
          M = parseFloat(g.attr('cy')) || 0,
          _ = parseFloat(g.attr('r')),
          W = _ * v.KAPPA,
          $ = [
            'M',
            S,
            M - _,
            'C',
            S + W,
            M - _,
            S + _,
            M - W,
            S + _,
            M,
            'C',
            S + _,
            M + W,
            S + W,
            M + _,
            S,
            M + _,
            'C',
            S - W,
            M + _,
            S - _,
            M + W,
            S - _,
            M,
            'C',
            S - _,
            M - W,
            S - W,
            M - _,
            S,
            M - _,
            'Z',
          ].join(' ')
        return $
      }),
      (v.convertEllipseToPathData = function (g) {
        g = v(g)
        var S = parseFloat(g.attr('cx')) || 0,
          M = parseFloat(g.attr('cy')) || 0,
          _ = parseFloat(g.attr('rx')),
          W = parseFloat(g.attr('ry')) || _,
          $ = _ * v.KAPPA,
          X = W * v.KAPPA,
          Ct = [
            'M',
            S,
            M - W,
            'C',
            S + $,
            M - W,
            S + _,
            M - X,
            S + _,
            M,
            'C',
            S + _,
            M + X,
            S + $,
            M + W,
            S,
            M + W,
            'C',
            S - $,
            M + W,
            S - _,
            M + X,
            S - _,
            M,
            'C',
            S - _,
            M - X,
            S - $,
            M - W,
            S,
            M - W,
            'Z',
          ].join(' ')
        return Ct
      }),
      (v.convertRectToPathData = function (g) {
        return (
          (g = v(g)),
          v.rectToPath({
            x: parseFloat(g.attr('x')) || 0,
            y: parseFloat(g.attr('y')) || 0,
            width: parseFloat(g.attr('width')) || 0,
            height: parseFloat(g.attr('height')) || 0,
            rx: parseFloat(g.attr('rx')) || 0,
            ry: parseFloat(g.attr('ry')) || 0,
          })
        )
      }),
      (v.rectToPath = function (g) {
        var S,
          M = g.x,
          _ = g.y,
          W = g.width,
          $ = g.height,
          X = c(g.rx || g['top-rx'] || 0, W / 2),
          Ct = c(g.rx || g['bottom-rx'] || 0, W / 2),
          Tt = c(g.ry || g['top-ry'] || 0, $ / 2),
          G = c(g.ry || g['bottom-ry'] || 0, $ / 2)
        return (
          X || Ct || Tt || G
            ? (S = [
                'M',
                M,
                _ + Tt,
                'v',
                $ - Tt - G,
                'a',
                Ct,
                G,
                0,
                0,
                0,
                Ct,
                G,
                'h',
                W - 2 * Ct,
                'a',
                Ct,
                G,
                0,
                0,
                0,
                Ct,
                -G,
                'v',
                -($ - G - Tt),
                'a',
                X,
                Tt,
                0,
                0,
                0,
                -X,
                -Tt,
                'h',
                -(W - 2 * X),
                'a',
                X,
                Tt,
                0,
                0,
                0,
                -X,
                Tt,
                'Z',
              ])
            : (S = ['M', M, _, 'H', M + W, 'V', _ + $, 'H', M, 'V', _, 'Z']),
          S.join(' ')
        )
      }),
      (v.normalizePathData = (function () {
        var g = `	
\v\f\r   ᠎             　\u2028\u2029`,
          S = new RegExp(
            '([a-z])[' + g + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + g + ']*,?[' + g + ']*)+)',
            'ig'
          ),
          M = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + g + ']*,?[' + g + ']*', 'ig'),
          _ = Math,
          W = _.PI,
          $ = _.sin,
          X = _.cos,
          Ct = _.tan,
          Tt = _.asin,
          G = _.sqrt,
          Q = _.abs
        function it(bt, kt, lt, gt, Et, Ft) {
          var Qt = 0.3333333333333333,
            qt = 2 / 3
          return [
            Qt * bt + qt * lt,
            Qt * kt + qt * gt,
            Qt * Et + qt * lt,
            Qt * Ft + qt * gt,
            Et,
            Ft,
          ]
        }
        function st(bt, kt, lt) {
          var gt = bt * X(lt) - kt * $(lt),
            Et = bt * $(lt) + kt * X(lt)
          return { x: gt, y: Et }
        }
        function F(bt, kt, lt, gt, Et, Ft, Qt, qt, de, Xt) {
          var E = (W * 120) / 180,
            P = (W / 180) * (+Et || 0),
            Y = [],
            J
          if (Xt) ((ae = Xt[0]), (fe = Xt[1]), (Ye = Xt[2]), (Bt = Xt[3]))
          else {
            ;((J = st(bt, kt, -P)),
              (bt = J.x),
              (kt = J.y),
              (J = st(qt, de, -P)),
              (qt = J.x),
              (de = J.y))
            var At = (bt - qt) / 2,
              Nt = (kt - de) / 2,
              Yt = (At * At) / (lt * lt) + (Nt * Nt) / (gt * gt)
            Yt > 1 && ((Yt = G(Yt)), (lt = Yt * lt), (gt = Yt * gt))
            var se = lt * lt,
              Se = gt * gt,
              $e =
                (Ft == Qt ? -1 : 1) *
                G(Q((se * Se - se * Nt * Nt - Se * At * At) / (se * Nt * Nt + Se * At * At))),
              Ye = ($e * lt * Nt) / gt + (bt + qt) / 2,
              Bt = ($e * -gt * At) / lt + (kt + de) / 2,
              ae = Tt(((kt - Bt) / gt).toFixed(9)),
              fe = Tt(((de - Bt) / gt).toFixed(9))
            ;((ae = bt < Ye ? W - ae : ae),
              (fe = qt < Ye ? W - fe : fe),
              ae < 0 && (ae = W * 2 + ae),
              fe < 0 && (fe = W * 2 + fe),
              Qt && ae > fe && (ae = ae - W * 2),
              !Qt && fe > ae && (fe = fe - W * 2))
          }
          var Fn = fe - ae
          if (Q(Fn) > E) {
            var Ne = fe,
              ln = qt,
              Zn = de
            ;((fe = ae + E * (Qt && fe > ae ? 1 : -1)),
              (qt = Ye + lt * X(fe)),
              (de = Bt + gt * $(fe)),
              (Y = F(qt, de, lt, gt, Et, 0, Qt, ln, Zn, [fe, Ne, Ye, Bt])))
          }
          Fn = fe - ae
          var wi = X(ae),
            xn = $(ae),
            Jn = X(fe),
            Ln = $(fe),
            fr = Ct(Fn / 4),
            xi = (4 / 3) * (lt * fr),
            ms = (4 / 3) * (gt * fr),
            Sa = [bt, kt],
            hr = [bt + xi * xn, kt - ms * wi],
            Si = [qt + xi * Ln, de - ms * Jn],
            hi = [qt, de]
          if (((hr[0] = 2 * Sa[0] - hr[0]), (hr[1] = 2 * Sa[1] - hr[1]), Xt))
            return [hr, Si, hi].concat(Y)
          Y = [hr, Si, hi].concat(Y).join().split(',')
          for (var ys = [], As = Y.length, en = 0; en < As; en++)
            ys[en] = en % 2 ? st(Y[en - 1], Y[en], P).y : st(Y[en], Y[en + 1], P).x
          return ys
        }
        function ht(bt) {
          if (!bt) return null
          var kt = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
            lt = []
          return (
            String(bt).replace(S, function (gt, Et, Ft) {
              var Qt = [],
                qt = Et.toLowerCase()
              for (
                Ft.replace(M, function (de, Xt) {
                  Xt && Qt.push(+Xt)
                }),
                  qt === 'm' &&
                    Qt.length > 2 &&
                    (lt.push([Et].concat(Qt.splice(0, 2))),
                    (qt = 'l'),
                    (Et = Et === 'm' ? 'l' : 'L'));
                Qt.length >= kt[qt] && (lt.push([Et].concat(Qt.splice(0, kt[qt]))), !!kt[qt]);

              );
            }),
            lt
          )
        }
        function ct(bt) {
          if (
            ((!Array.isArray(bt) || !Array.isArray(bt && bt[0])) && (bt = ht(bt)),
            !bt || !bt.length)
          )
            return [['M', 0, 0]]
          for (
            var kt = [], lt = 0, gt = 0, Et = 0, Ft = 0, Qt = 0, qt, de = bt.length, Xt = Qt;
            Xt < de;
            Xt++
          ) {
            var E = []
            kt.push(E)
            var P = bt[Xt]
            if (((qt = P[0]), qt != qt.toUpperCase())) {
              E[0] = qt.toUpperCase()
              var Y, J
              switch (E[0]) {
                case 'A':
                  ;((E[1] = P[1]),
                    (E[2] = P[2]),
                    (E[3] = P[3]),
                    (E[4] = P[4]),
                    (E[5] = P[5]),
                    (E[6] = +P[6] + lt),
                    (E[7] = +P[7] + gt))
                  break
                case 'V':
                  E[1] = +P[1] + gt
                  break
                case 'H':
                  E[1] = +P[1] + lt
                  break
                case 'M':
                  for (Et = +P[1] + lt, Ft = +P[2] + gt, Y = P.length, J = 1; J < Y; J++)
                    E[J] = +P[J] + (J % 2 ? lt : gt)
                  break
                default:
                  for (Y = P.length, J = 1; J < Y; J++) E[J] = +P[J] + (J % 2 ? lt : gt)
                  break
              }
            } else for (var At = P.length, Nt = 0; Nt < At; Nt++) E[Nt] = P[Nt]
            switch (E[0]) {
              case 'Z':
                ;((lt = +Et), (gt = +Ft))
                break
              case 'H':
                lt = E[1]
                break
              case 'V':
                gt = E[1]
                break
              case 'M':
                ;((Et = E[E.length - 2]),
                  (Ft = E[E.length - 1]),
                  (lt = E[E.length - 2]),
                  (gt = E[E.length - 1]))
                break
              default:
                ;((lt = E[E.length - 2]), (gt = E[E.length - 1]))
                break
            }
          }
          return kt
        }
        function St(bt) {
          var kt = ct(bt),
            lt = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }
          function gt(Y, J, At) {
            var Nt, Yt
            if (!Y) return ['C', J.x, J.y, J.x, J.y, J.x, J.y]
            switch ((Y[0] in { T: 1, Q: 1 } || ((J.qx = null), (J.qy = null)), Y[0])) {
              case 'M':
                ;((J.X = Y[1]), (J.Y = Y[2]))
                break
              case 'A':
                parseFloat(Y[1]) === 0 || parseFloat(Y[2]) === 0
                  ? (Y = ['L', Y[6], Y[7]])
                  : (Y = ['C'].concat(F.apply(0, [J.x, J.y].concat(Y.slice(1)))))
                break
              case 'S':
                ;(At === 'C' || At === 'S'
                  ? ((Nt = J.x * 2 - J.bx), (Yt = J.y * 2 - J.by))
                  : ((Nt = J.x), (Yt = J.y)),
                  (Y = ['C', Nt, Yt].concat(Y.slice(1))))
                break
              case 'T':
                ;(At === 'Q' || At === 'T'
                  ? ((J.qx = J.x * 2 - J.qx), (J.qy = J.y * 2 - J.qy))
                  : ((J.qx = J.x), (J.qy = J.y)),
                  (Y = ['C'].concat(it(J.x, J.y, J.qx, J.qy, Y[1], Y[2]))))
                break
              case 'Q':
                ;((J.qx = Y[1]),
                  (J.qy = Y[2]),
                  (Y = ['C'].concat(it(J.x, J.y, Y[1], Y[2], Y[3], Y[4]))))
                break
              case 'H':
                Y = ['L'].concat(Y[1], J.y)
                break
              case 'V':
                Y = ['L'].concat(J.x, Y[1])
                break
            }
            return Y
          }
          function Et(Y, J) {
            if (Y[J].length > 7) {
              Y[J].shift()
              for (var At = Y[J]; At.length; )
                ((Ft[J] = 'A'), Y.splice(J++, 0, ['C'].concat(At.splice(0, 6))))
              ;(Y.splice(J, 1), (de = kt.length))
            }
          }
          for (var Ft = [], Qt = '', qt = '', de = kt.length, Xt = 0; Xt < de; Xt++) {
            ;(kt[Xt] && (Qt = kt[Xt][0]),
              Qt !== 'C' && ((Ft[Xt] = Qt), Xt > 0 && (qt = Ft[Xt - 1])),
              (kt[Xt] = gt(kt[Xt], lt, qt)),
              Ft[Xt] !== 'A' && Qt === 'C' && (Ft[Xt] = 'C'),
              Et(kt, Xt))
            var E = kt[Xt],
              P = E.length
            ;((lt.x = E[P - 2]),
              (lt.y = E[P - 1]),
              (lt.bx = parseFloat(E[P - 4]) || lt.x),
              (lt.by = parseFloat(E[P - 3]) || lt.y))
          }
          return ((!kt[0][0] || kt[0][0] !== 'M') && kt.unshift(['M', 0, 0]), kt)
        }
        return function (bt) {
          return St(bt).join(',').split(',').join(' ')
        }
      })()),
      (v.namespace = e),
      (v.g = $C),
      v
    )
  })(),
  Yi = {
    useCSSSelectors: !0,
    classNamePrefix: 'joint-',
    defaultTheme: 'default',
    doubleTapInterval: 300,
  },
  ju = '[object Arguments]',
  dv = '[object Array]',
  Mh = '[object Boolean]',
  ym = '[object Date]',
  Tw = '[object Error]',
  SM = '[object Function]',
  Ju = '[object Map]',
  Eh = '[object Number]',
  NM = '[object Null]',
  rl = '[object Object]',
  Am = '[object RegExp]',
  qu = '[object Set]',
  Dh = '[object String]',
  Oh = '[object Symbol]',
  TM = '[object Undefined]',
  MM = '[object WeakMap]',
  bm = '[object ArrayBuffer]',
  Im = '[object DataView]',
  Mw = '[object Float32Array]',
  Ew = '[object Float64Array]',
  Dw = '[object Int8Array]',
  Ow = '[object Int16Array]',
  Lw = '[object Int32Array]',
  zw = '[object Uint8Array]',
  Rw = '[object Uint8ClampedArray]',
  kw = '[object Uint16Array]',
  _w = '[object Uint32Array]',
  EM = {
    [ju]: !0,
    [dv]: !0,
    [bm]: !0,
    [Im]: !0,
    [Mh]: !0,
    [ym]: !0,
    [Mw]: !0,
    [Ew]: !0,
    [Dw]: !0,
    [Ow]: !0,
    [Lw]: !0,
    [Ju]: !0,
    [Eh]: !0,
    [rl]: !0,
    [Am]: !0,
    [qu]: !0,
    [Dh]: !0,
    [Oh]: !0,
    [zw]: !0,
    [Rw]: !0,
    [kw]: !0,
    [_w]: !0,
    [Tw]: !1,
    [SM]: !1,
    [MM]: !1,
  },
  Cm = '\\ud800-\\udfff',
  DM = '\\u0300-\\u036f',
  OM = '\\ufe20-\\ufe2f',
  LM = '\\u20d0-\\u20ff',
  zM = '\\u1ab0-\\u1aff',
  RM = '\\u1dc0-\\u1dff',
  kM = DM + OM + LM + zM + RM,
  Bw = '\\u2700-\\u27bf',
  jw = 'a-z\\xdf-\\xf6\\xf8-\\xff',
  _M = '\\xac\\xb1\\xd7\\xf7',
  BM = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
  jM = '\\u2000-\\u206f',
  PM =
    ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
  Pw = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
  GM = '\\ufe0e\\ufe0f',
  Gw = _M + BM + jM + PM,
  Zw = "['’]",
  Mb = `[${Gw}]`,
  wm = `[${kM}]`,
  Uw = '\\d',
  ZM = `[${Bw}]`,
  Yw = `[${jw}]`,
  Hw = `[^${Cm}${Gw + Uw + Bw + jw + Pw}]`,
  gv = '\\ud83c[\\udffb-\\udfff]',
  UM = `(?:${wm}|${gv})`,
  Vw = `[^${Cm}]`,
  xm = '(?:\\ud83c[\\udde6-\\uddff]){2}',
  Sm = '[\\ud800-\\udbff][\\udc00-\\udfff]',
  nl = `[${Pw}]`,
  YM = '\\u200d',
  Eb = `(?:${Yw}|${Hw})`,
  HM = `(?:${nl}|${Hw})`,
  Db = `(?:${Zw}(?:d|ll|m|re|s|t|ve))?`,
  Ob = `(?:${Zw}(?:D|LL|M|RE|S|T|VE))?`,
  Xw = `${UM}?`,
  Ww = `[${GM}]?`,
  VM = `(?:${YM}(?:${[Vw, xm, Sm].join('|')})${Ww + Xw})*`,
  XM = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
  WM = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
  Fw = Ww + Xw + VM,
  FM = `(?:${[ZM, xm, Sm].join('|')})${Fw}`,
  JM = RegExp(
    [
      `${nl}?${Yw}+${Db}(?=${[Mb, nl, '$'].join('|')})`,
      `${HM}+${Ob}(?=${[Mb, nl + Eb, '$'].join('|')})`,
      `${nl}?${Eb}+${Db}`,
      `${nl}+${Ob}`,
      WM,
      XM,
      `${Uw}+`,
      FM,
    ].join('|'),
    'g'
  ),
  Nm = 200,
  pv = '__hash_undefined__',
  qM = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/,
  QM = `[${Cm}]`,
  KM = `${Vw}${wm}?`,
  $M = `(?:${[KM, wm, xm, Sm, QM].join('|')})`,
  Jw = RegExp(`${gv}(?=${gv})|${$M + Fw}`, 'g'),
  t3 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  e3 = /^\w*$/,
  n3 = 46,
  i3 = /\\(\\)?/g,
  r3 = RegExp(
    `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
    'g'
  ),
  a3 = /^(?:0|[1-9]\d*)$/,
  s3 = RegExp.prototype.test.bind(
    /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/
  ),
  o3 = 4294967294,
  l3 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
  qw = t => Jw.test(t),
  u3 = t => t.match(Jw) || [],
  c3 = t => t.split(''),
  Qw = t => (qw(t) ? u3(t) : c3(t)),
  f3 = t => (t == null ? [] : Qu(t).map(e => t[e])),
  Qu = t => (Vi(t) ? Kw(t) : Object.keys(Object(t))),
  h3 = t => {
    if (!Lh(t)) return Object.keys(t)
    var e = []
    for (var n in Object(t)) hasOwnProperty.call(t, n) && n != 'constructor' && e.push(n)
    return e
  },
  Kw = (t, e) => {
    const n = Array.isArray(t),
      i = !n && lr(t) && ur(t) === ju,
      s = !n && !i && $u(t),
      o = n || i || s,
      u = t.length,
      c = new Array(o ? u : 0)
    let h = o ? -1 : u
    for (; ++h < u; ) c[h] = `${h}`
    for (const p in t)
      (e || hasOwnProperty.call(t, p)) && !(o && (p === 'length' || Om(p, u))) && c.push(p)
    return c
  },
  Tf = (t, e) => {
    let { length: n } = t
    for (; n--; ) if (yl(t[n][0], e)) return n
    return -1
  },
  yl = (t, e) => t === e || (t !== t && e !== e),
  lr = t => t != null && typeof t == 'object',
  th = (t, e, n) => {
    if (!ze(n)) return !1
    const i = typeof e
    return (i == 'number' ? Vi(n) && e > -1 && e < n.length : i == 'string' && e in n)
      ? yl(n[e], t)
      : !1
  },
  d3 = t => lr(t) && ur(t) == qu,
  g3 = t => lr(t) && ur(t) == Ju,
  Lh = t => {
    const e = t && t.constructor,
      n = (typeof e == 'function' && e.prototype) || Object.prototype
    return t === n
  },
  so = (t, e, n) => {
    const i = t[e]
    ;(!(hasOwnProperty.call(t, e) && yl(i, n)) || (n === void 0 && !(e in t))) && (t[e] = n)
  },
  Ku = (t, e, n) => {
    let i = -1
    const s = e.length
    for (; ++i < s; ) {
      const o = e[i]
      so(n, o, t[o])
    }
    return n
  },
  Vi = t =>
    t != null &&
    typeof t != 'function' &&
    typeof t.length == 'number' &&
    t.length > -1 &&
    t.length % 1 === 0,
  gl = t => typeof t == 'symbol' || (lr(t) && ur(t) === Oh),
  p3 = t => {
    const e = t.length
    let n = new t.constructor(e)
    return (
      e &&
        typeof t[0] == 'string' &&
        hasOwnProperty.call(t, 'index') &&
        ((n.index = t.index), (n.input = t.input)),
      n
    )
  },
  Tm = (t, e) => {
    let n = -1
    const i = t.length
    for (e || (e = new Array(i)); ++n < i; ) e[n] = t[n]
    return e
  },
  ur = t => (t == null ? (t === void 0 ? TM : NM) : Object.prototype.toString.call(t)),
  Mm = t => {
    const e = new t.constructor(t.byteLength)
    return (new Uint8Array(e).set(new Uint8Array(t)), e)
  },
  $w = (t, e) => {
    const n = e ? Mm(t.buffer) : t.buffer
    return new t.constructor(n, t.byteOffset, t.length)
  },
  v3 = t => {
    const e = new t.constructor(t.source, /\w*$/.exec(t))
    return ((e.lastIndex = t.lastIndex), e)
  },
  tx = t =>
    typeof t.constructor == 'function' && !Lh(t) ? Object.create(Object.getPrototypeOf(t)) : {},
  Em = t =>
    t == null
      ? []
      : ((t = Object(t)),
        Object.getOwnPropertySymbols(t).filter(n => propertyIsEnumerable.call(t, n))),
  m3 = (t, e) => Ku(t, Em(t), e)
function y3(t, e) {
  const n = e ? Mm(t.buffer) : t.buffer
  return new t.constructor(n, t.byteOffset, t.byteLength)
}
const A3 = (t, e, n) => {
    const i = t.constructor
    switch (e) {
      case bm:
        return Mm(t)
      case Mh:
      case ym:
        return new i(+t)
      case Im:
        return y3(t, n)
      case Mw:
      case Ew:
      case Dw:
      case Ow:
      case Lw:
      case zw:
      case Rw:
      case kw:
      case _w:
        return $w(t, n)
      case Ju:
        return new i(t)
      case Eh:
      case Dh:
        return new i(t)
      case Am:
        return v3(t)
      case qu:
        return new i()
      case Oh:
        return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(t)) : {}
    }
  },
  $u = t => lr(t) && qM.test(ur(t)),
  vv = t => {
    const e = Object.keys(t)
    return (!Array.isArray(t) && t != null && e.push(...Em(Object(t))), e)
  },
  ex = t => {
    const e = []
    for (; t; ) (e.push(...Em(t)), (t = Object.getPrototypeOf(Object(t))))
    return e
  },
  nx = t => {
    const e = []
    for (const n in t) e.push(n)
    return (Array.isArray(t) || e.push(...ex(t)), e)
  },
  Mf = ({ __data__: t }, e) => {
    const n = t
    return L3(e) ? n[typeof e == 'string' ? 'string' : 'hash'] : n.map
  },
  b3 = (t, e, n, i) => {
    const s = vv(t),
      o = s.length,
      c = vv(e).length
    if (o != c) return !1
    let h,
      p = o
    for (; p--; ) if (((h = s[p]), !hasOwnProperty.call(e, h))) return !1
    const y = i.get(t),
      v = i.get(e)
    if (y && v) return y == e && v == t
    let C = !0
    ;(i.set(t, e), i.set(e, t))
    let w
    for (; ++p < o; ) {
      h = s[p]
      const N = t[h],
        T = e[h]
      if (!(N === T || n(N, T, i))) {
        C = !1
        break
      }
      w || (w = h == 'constructor')
    }
    if (C && !w) {
      const N = t.constructor,
        T = e.constructor
      N != T &&
        'constructor' in t &&
        'constructor' in e &&
        !(typeof N == 'function' && N instanceof N && typeof T == 'function' && T instanceof T) &&
        (C = !1)
    }
    return (i.delete(t), i.delete(e), C)
  },
  zh = (t, e, n) =>
    t === e
      ? !0
      : t == null || e == null || (!lr(t) && !lr(e))
        ? t !== t && e !== e
        : I3(t, e, zh, n),
  I3 = (t, e, n, i) => {
    let s = Array.isArray(t)
    const o = Array.isArray(e)
    let u = s ? dv : ur(t),
      c = o ? dv : ur(e)
    ;((u = u == ju ? rl : u), (c = c == ju ? rl : c))
    let h = u == rl
    const p = c == rl,
      y = u == c
    if (y && !h) return (i || (i = new ul()), s || $u(t) ? ix(t, e, !1, n, i) : x3(t, e, u, n, i))
    const v = h && hasOwnProperty.call(t, '__wrapped__'),
      C = p && hasOwnProperty.call(e, '__wrapped__')
    if (v || C) {
      const w = v ? t.value() : t,
        N = C ? e.value() : e
      return (i || (i = new ul()), n(w, N, i))
    }
    return y ? (i || (i = new ul()), b3(t, e, n, i)) : !1
  },
  ix = (t, e, n, i, s) => {
    const o = t.length,
      u = e.length
    if (o != u) return !1
    const c = s.get(t),
      h = s.get(e)
    if (c && h) return c == e && h == t
    let p = -1,
      y = !0
    const v = n ? new pl() : void 0
    for (s.set(t, e), s.set(e, t); ++p < o; ) {
      const C = t[p],
        w = e[p]
      if (v) {
        if (
          !C3(e, (N, T) => {
            if (!w3(v, T) && (C === N || i(C, N, s))) return v.push(T)
          })
        ) {
          y = !1
          break
        }
      } else if (!(C === w || i(C, w, s))) {
        y = !1
        break
      }
    }
    return (s.delete(t), s.delete(e), y)
  },
  C3 = (t, e) => {
    let n = -1
    const i = t == null ? 0 : t.length
    for (; ++n < i; ) if (e(t[n], n, t)) return !0
    return !1
  },
  w3 = (t, e) => t.has(e),
  Lb = (t, e, n, i) =>
    !(t.byteLength != e.byteLength || !n(new Uint8Array(t), new Uint8Array(e), i)),
  x3 = (t, e, n, i, s) => {
    switch (n) {
      case Im:
        return t.byteLength != e.byteLength || t.byteOffset != e.byteOffset
          ? !1
          : ((t = t.buffer), (e = e.buffer), Lb(t, e, i, s))
      case bm:
        return Lb(t, e, i, s)
      case Mh:
      case ym:
      case Eh:
        return yl(+t, +e)
      case Tw:
        return t.name == e.name && t.message == e.message
      case Am:
      case Dh:
        return t == `${e}`
      case Ju:
        let o = rx
      case qu:
        if ((o || (o = Rh), t.size != e.size)) return !1
        const u = s.get(t)
        if (u) return u == e
        s.set(t, e)
        const c = ix(o(t), o(e), !0, i, s)
        return (s.delete(t), c)
      case Oh:
        return Symbol.prototype.valueOf.call(t) == Symbol.prototype.valueOf.call(e)
    }
    return !1
  },
  rx = t => {
    let e = -1,
      n = Array(t.size)
    return (
      t.forEach((i, s) => {
        n[++e] = [s, i]
      }),
      n
    )
  },
  Rh = t => {
    let e = -1
    const n = new Array(t.size)
    return (
      t.forEach(i => {
        n[++e] = i
      }),
      n
    )
  },
  Dm = (t, e) => {
    if (Array.isArray(t)) return !1
    const n = typeof t
    return n === 'number' || n === 'boolean' || t == null || gl(t)
      ? !0
      : e3.test(t) || !t3.test(t) || (e != null && t in Object(e))
  },
  S3 = t => {
    const e = []
    return (
      t.charCodeAt(0) === n3 && e.push(''),
      t.replace(r3, (n, i, s, o) => {
        let u = n
        ;(s ? (u = o.replace(i3, '$1')) : i && (u = i.trim()), e.push(u))
      }),
      e
    )
  },
  gs = (t, e) => (Array.isArray(t) ? t : Dm(t, e) ? [t] : S3(`${t}`)),
  tc = (t, e) => {
    e = gs(e, t)
    let n = 0
    const i = e.length
    for (; t != null && n < i; ) ((t = t[Ca(e[n])]), n++)
    return n && n == i ? t : void 0
  }
function N3(t, e) {
  if (t !== e) {
    const n = t !== void 0,
      i = t === null,
      s = t === t,
      o = gl(t),
      u = e !== void 0,
      c = e === null,
      h = e === e,
      p = gl(e)
    if ((!c && !p && !o && t > e) || (o && u && h && !c && !p) || (i && u && h) || (!n && h) || !s)
      return 1
    if ((!i && !o && !p && t < e) || (p && n && s && !i && !o) || (c && n && s) || (!u && s) || !h)
      return -1
  }
  return 0
}
function T3(t, e, n) {
  let i = -1
  const s = t.criteria,
    o = e.criteria,
    u = s.length,
    c = n.length
  for (; ++i < u; ) {
    const h = i < c ? n[i] : null,
      y = (h && typeof h == 'function' ? h : N3)(s[i], o[i])
    if (y) return h && typeof h != 'function' ? y * (h == 'desc' ? -1 : 1) : y
  }
  return t.index - e.index
}
const ax = (t, e) => {
    let n = (u, c) => !!(u == null ? 0 : u.length) && u.indexOf(c) > -1,
      i = !0
    const s = [],
      o = e.length
    if (!t.length) return s
    e.length >= Nm && ((n = (u, c) => u.has(c)), (i = !1), (e = new pl(e)))
    t: for (let u in t) {
      let c = t[u]
      const h = c
      if (((c = c !== 0 ? c : 0), i && h === h)) {
        let p = o
        for (; p--; ) if (e[p] === h) continue t
        s.push(c)
      } else n(e, h) || s.push(c)
    }
    return s
  },
  M3 = t => {
    const e = (C, w) => !!(C == null ? 0 : C.length) && C.indexOf(w) > -1,
      n = (C, w) => C.has(w),
      i = t[0].length,
      s = t.length,
      o = new Array(s),
      u = []
    let c,
      h = 1 / 0,
      p = s
    for (; p--; )
      ((c = t[p]),
        (h = Math.min(c.length, h)),
        (o[p] = i >= 120 && c.length >= 120 ? new pl(p && c) : void 0))
    c = t[0]
    let y = -1
    const v = o[0]
    t: for (; ++y < i && u.length < h; ) {
      let C = c[y]
      const w = C
      if (((C = C !== 0 ? C : 0), !(v ? n(v, w) : e(u, w)))) {
        for (p = s; --p; ) {
          const N = o[p]
          if (!(N ? n(N, w) : e(t[p], w))) continue t
        }
        ;(v && v.push(w), u.push(C))
      }
    }
    return u
  },
  Ca = t => {
    if (typeof t == 'string' || gl(t)) return t
    const e = `${t}`
    return e == '0' && 1 / t == -1 / 0 ? '-0' : e
  },
  ll = (t, e = !1, n = !1, i = !0, s, o, u, c) => {
    let h
    if ((s && (h = u ? s(t, o, u, c) : s(t)), h !== void 0)) return h
    if (!ze(t)) return t
    const p = Array.isArray(t),
      y = ur(t)
    if (p) {
      if (((h = p3(t)), !e)) return Tm(t, h)
    } else {
      const N = typeof t == 'function'
      if (y === rl || y === ju || (N && !u)) {
        if (((h = n || N ? {} : tx(t)), !e))
          return n ? E3(t, Ku(t, Object.keys(t), h)) : m3(t, Object.assign(h, t))
      } else {
        if (N || !EM[y]) return u ? t : {}
        h = A3(t, y, e)
      }
    }
    c || (c = new ul())
    const v = c.get(t)
    if (v) return v
    if ((c.set(t, h), g3(t)))
      return (
        t.forEach((N, T) => {
          h.set(T, ll(N, e, n, i, s, T, t, c))
        }),
        h
      )
    if (d3(t))
      return (
        t.forEach(N => {
          h.add(ll(N, e, n, i, s, N, t, c))
        }),
        h
      )
    if ($u(t)) return h
    const w = p ? void 0 : (i ? (n ? nx : vv) : n ? ox : Qu)(t)
    return (
      (w || t).forEach((N, T) => {
        ;(w && ((T = N), (N = t[T])), so(h, T, ll(N, e, n, i, s, T, t, c)))
      }),
      h
    )
  },
  E3 = (t, e) => Ku(t, ex(t), e),
  sx = (t, e) => (e.length < 2 ? t : tc(t, e.slice(0, -1))),
  D3 = (t, e, n) => {
    if (!ze(t)) return t
    e = gs(e, t)
    const i = e.length,
      s = i - 1
    let o = -1,
      u = t
    for (; u != null && ++o < i; ) {
      const c = Ca(e[o])
      let h = n
      if (o != s) {
        const p = u[c]
        ;((h = void 0), h === void 0 && (h = ze(p) ? p : Om(e[o + 1]) ? [] : {}))
      }
      ;(so(u, c, h), (u = u[c]))
    }
    return t
  },
  Om = (t, e) => {
    const n = typeof t
    return (
      (e = e ?? Number.MAX_SAFE_INTEGER),
      !!e && (n === 'number' || (n !== 'symbol' && a3.test(t))) && t > -1 && t % 1 == 0 && t < e
    )
  },
  O3 = (t, e) => {
    ;((e = gs(e, t)), (t = sx(t, e)))
    const n = e[e.length - 1]
    return t == null || delete t[Ca(n)]
  },
  L3 = t => {
    const e = typeof t
    return e === 'string' || e === 'number' || e === 'symbol' || e === 'boolean'
      ? t !== '__proto__'
      : t === null
  },
  ox = t => {
    const e = []
    for (const n in t) e.push(n)
    return e
  },
  z3 = t => {
    t = Object(t)
    const e = {}
    for (const n in t) e[n] = t[n]
    return e
  },
  zb = (t, e) => {
    if (!(e === 'constructor' && typeof t[e] == 'function') && e != '__proto__') return t[e]
  }
function lx(t, e = !1) {
  return (n, ...i) => {
    let s = -1,
      o = i.length,
      u = o > 1 ? i[o - 1] : void 0
    const c = o > 2 ? i[2] : void 0
    for (
      u =
        t.length > 3 && typeof u == 'function'
          ? (o--, u)
          : e
            ? (h, p) => {
                if (Array.isArray(h) && !Array.isArray(p)) return p
              }
            : void 0,
        c && th(i[0], i[1], c) && ((u = o < 3 ? void 0 : u), (o = 1)),
        n = Object(n);
      ++s < o;

    ) {
      const h = i[s]
      h && t(n, h, s, u)
    }
    return n
  }
}
const Lm = (t, e, n, i, s) => {
    t !== e &&
      yi(e, (o, u) => {
        if (ze(o)) (s || (s = new ul()), R3(t, e, u, n, Lm, i, s))
        else {
          let c = i ? i(t[u], o, `${u}`, t, e, s) : void 0
          ;(c === void 0 && (c = o), mv(t, u, c))
        }
      })
  },
  R3 = (t, e, n, i, s, o, u) => {
    const c = zb(t, n),
      h = zb(e, n),
      p = u.get(h)
    if (p) {
      mv(t, n, p)
      return
    }
    let y = o ? o(c, h, `${n}`, t, e, u) : void 0,
      v = y === void 0
    if (v) {
      const C = Array.isArray(h),
        w = !C && $u(h)
      ;((y = h),
        C || w
          ? Array.isArray(c)
            ? (y = c)
            : lr(c) && Vi(c)
              ? (y = Tm(c))
              : w
                ? ((v = !1), (y = $w(h, !0)))
                : (y = [])
          : hn(h) || Pu(h)
            ? ((y = c), Pu(c) ? (y = z3(c)) : (typeof c == 'function' || !ze(c)) && (y = tx(h)))
            : (v = !1))
    }
    ;(v && (u.set(h, y), s(y, h, i, o, u), u.delete(h)), mv(t, n, y))
  },
  mv = (t, e, n) => {
    ;((n !== void 0 && !yl(t[e], n)) || (n === void 0 && !(e in t))) && so(t, e, n)
  }
function k3(t, e, n) {
  const i = Object(t),
    s = n(t)
  let { length: o } = s,
    u = -1
  for (; o--; ) {
    const c = s[++u]
    if (e(i[c], c, i) === !1) break
  }
  return t
}
const _3 = (t, e) => t && k3(t, e, Qu),
  zm = (t, e) => {
    if (t == null) return t
    if (!Vi(t)) return _3(t, e)
    const n = t.length,
      i = Object(t)
    let s = -1
    for (; ++s < n && e(i[s], s, i) !== !1; );
    return t
  }
function B3(t) {
  const e = t == null ? 0 : t.length
  return e ? t[e - 1] : void 0
}
const j3 = Set && 1 / Rh(new Set([void 0, -0]))[1] == 1 / 0 ? t => new Set(t) : () => {}
function ux(t, e, n, i, s, o) {
  return (ze(t) && ze(e) && (o.set(e, t), Lm(t, e, void 0, ux, o), o.delete(e)), t)
}
function P3(t, e, n) {
  e.length
    ? (e = e.map(u => (Array.isArray(u) ? c => tc(c, u.length === 1 ? u[0] : u) : u)))
    : (e = [u => u])
  let i = -1,
    s = -1
  const o = Vi(t) ? new Array(t.length) : []
  return (
    zm(t, u => {
      const c = e.map(h => h(u))
      o[++s] = { criteria: c, index: ++i, value: u }
    }),
    G3(o, (u, c) => T3(u, c, n))
  )
}
function G3(t, e) {
  let { length: n } = t
  for (t.sort(e); n--; ) t[n] = t[n].value
  return t
}
function cx(t) {
  return t === t && !ze(t)
}
function fx(t, e) {
  return n => (n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n)))
}
function hx(t, e) {
  return t != null && iE(t, e, nE)
}
function Z3(t, e) {
  return Dm(t) && cx(e)
    ? fx(Ca(t), e)
    : n => {
        const i = tc(n, t)
        return i === void 0 && i === e ? hx(n, t) : zh(e, i)
      }
}
function U3(t) {
  const e = Y3(t)
  return e.length === 1 && e[0][2] ? fx(e[0][0], e[0][1]) : n => n === t || H3(n, t, e)
}
function Y3(t) {
  const e = Qu(t)
  let n = e.length
  for (; n--; ) {
    const i = e[n],
      s = t[i]
    e[n] = [i, s, cx(s)]
  }
  return e
}
function H3(t, e, n, i) {
  let s = n.length
  const o = s
  if (t == null) return !o
  let u
  for (t = Object(t); s--; ) if (((u = n[s]), u[2] ? u[1] !== t[u[0]] : !(u[0] in t))) return !1
  for (; ++s < o; ) {
    u = n[s]
    const c = u[0],
      h = t[c],
      p = u[1]
    if (u[2]) {
      if (h === void 0 && !(c in t)) return !1
    } else {
      const y = new ul()
      if (!zh(p, h, y)) return !1
    }
  }
  return !0
}
function V3(t) {
  return Dm(t) ? X3(Ca(t)) : W3(t)
}
function X3(t) {
  return e => e?.[t]
}
function W3(t) {
  return e => tc(e, t)
}
function F3(t) {
  return typeof t == 'function'
    ? t
    : t == null
      ? e => e
      : typeof t == 'object'
        ? Array.isArray(t)
          ? Z3(t[0], t[1])
          : U3(t)
        : V3(t)
}
function kh() {
  const t = F3
  return arguments.length ? t(arguments[0]) : t
}
const J3 = (t, e, n, i) => {
    let s = -1
    const o = t == null ? 0 : t.length
    for (i && o && (n = t[++s]); ++s < o; ) n = e(n, t[s], s, t)
    return n
  },
  q3 = (t, e, n, i, s) => (
    s(t, (o, u, c) => {
      n = i ? ((i = !1), o) : e(n, o, u, c)
    }),
    n
  )
function Q3(t, e, n) {
  const i = Array.isArray(t) ? J3 : q3,
    s = arguments.length < 3
  return i(t, e, n, s, zm)
}
const K3 = t => Array.isArray(t) || Pu(t) || !!(t && t[Symbol.isConcatSpreadable])
function dx(t, e, n, i, s) {
  let o = -1
  const u = t.length
  for (n || (n = K3), s || (s = []); ++o < u; ) {
    var c = t[o]
    e > 0 && n(c) ? (e > 1 ? dx(c, e - 1, n, i, s) : s.push(...c)) : (s[s.length] = c)
  }
  return s
}
const Pu = t => lr(t) && ur(t) == '[object Arguments]',
  $3 = (t, e) => tE(t, e, (n, i) => hx(t, i)),
  tE = (t, e, n) => {
    let i = -1
    const s = e.length,
      o = {}
    for (; ++i < s; ) {
      const u = e[i],
        c = tc(t, u)
      n(c, u) && D3(o, gs(u, t), c)
    }
    return o
  },
  eE = t => typeof t == 'number' && t > -1 && t % 1 == 0 && t <= Number.MAX_SAFE_INTEGER,
  nE = (t, e) => t != null && e in Object(t),
  iE = (t, e, n) => {
    e = gs(e, t)
    for (var i = -1, s = e.length, o = !1; ++i < s; ) {
      var u = Ca(e[i])
      if (!(o = t != null && n(t, u))) break
      t = t[u]
    }
    return o || ++i != s
      ? o
      : ((s = t == null ? 0 : t.length), !!s && eE(s) && Om(u, s) && (Array.isArray(t) || Pu(t)))
  },
  rE = t => t.match(l3),
  aE = t => t.match(JM),
  sE = (t, e) => (s3(t) ? aE(t) : rE(t)) || [],
  oE = (t, e, n) => {
    const { length: i } = t
    return ((n = n === void 0 ? i : n), !e && n >= i ? t : t.slice(e, n))
  },
  lE = uE('toUpperCase')
function uE(t) {
  return e => {
    if (!e) return ''
    const n = qw(e) ? Qw(e) : void 0,
      i = n ? n[0] : e[0],
      s = n ? oE(n, 1).join('') : e.slice(1)
    return i[t]() + s
  }
}
class ul {
  constructor(e) {
    const n = (this.__data__ = new Jg(e))
    this.size = n.size
  }
  clear() {
    ;((this.__data__ = new Jg()), (this.size = 0))
  }
  delete(e) {
    const n = this.__data__,
      i = n.delete(e)
    return ((this.size = n.size), i)
  }
  get(e) {
    return this.__data__.get(e)
  }
  has(e) {
    return this.__data__.has(e)
  }
  set(e, n) {
    let i = this.__data__
    if (i instanceof Jg) {
      const s = i.__data__
      if (s.length < Nm - 1) return (s.push([e, n]), (this.size = ++i.size), this)
      i = this.__data__ = new gx(s)
    }
    return (i.set(e, n), (this.size = i.size), this)
  }
}
class Jg {
  constructor(e) {
    let n = -1
    const i = e == null ? 0 : e.length
    for (this.clear(); ++n < i; ) {
      const s = e[n]
      this.set(s[0], s[1])
    }
  }
  clear() {
    ;((this.__data__ = []), (this.size = 0))
  }
  delete(e) {
    const n = this.__data__,
      i = Tf(n, e)
    if (i < 0) return !1
    const s = n.length - 1
    return (i == s ? n.pop() : n.splice(i, 1), --this.size, !0)
  }
  get(e) {
    const n = this.__data__,
      i = Tf(n, e)
    return i < 0 ? void 0 : n[i][1]
  }
  has(e) {
    return Tf(this.__data__, e) > -1
  }
  set(e, n) {
    const i = this.__data__,
      s = Tf(i, e)
    return (s < 0 ? (++this.size, i.push([e, n])) : (i[s][1] = n), this)
  }
}
class gx {
  constructor(e) {
    let n = -1
    const i = e == null ? 0 : e.length
    for (this.clear(); ++n < i; ) {
      const s = e[n]
      this.set(s[0], s[1])
    }
  }
  clear() {
    ;((this.size = 0), (this.__data__ = { hash: new Rb(), map: new Map(), string: new Rb() }))
  }
  delete(e) {
    const n = Mf(this, e).delete(e)
    return ((this.size -= n ? 1 : 0), n)
  }
  get(e) {
    return Mf(this, e).get(e)
  }
  has(e) {
    return Mf(this, e).has(e)
  }
  set(e, n) {
    const i = Mf(this, e),
      s = i.size
    return (i.set(e, n), (this.size += i.size == s ? 0 : 1), this)
  }
}
class Rb {
  constructor(e) {
    let n = -1
    const i = e == null ? 0 : e.length
    for (this.clear(); ++n < i; ) {
      const s = e[n]
      this.set(s[0], s[1])
    }
  }
  clear() {
    ;((this.__data__ = Object.create(null)), (this.size = 0))
  }
  delete(e) {
    const n = this.has(e) && delete this.__data__[e]
    return ((this.size -= n ? 1 : 0), n)
  }
  get(e) {
    const i = this.__data__[e]
    return i === pv ? void 0 : i
  }
  has(e) {
    return this.__data__[e] !== void 0
  }
  set(e, n) {
    const i = this.__data__
    return ((this.size += this.has(e) ? 0 : 1), (i[e] = n === void 0 ? pv : n), this)
  }
}
class pl {
  constructor(e) {
    let n = -1
    const i = e == null ? 0 : e.length
    for (this.__data__ = new gx(); ++n < i; ) this.add(e[n])
  }
  add(e) {
    return (this.__data__.set(e, pv), this)
  }
  has(e) {
    return this.__data__.has(e)
  }
}
pl.prototype.push = pl.prototype.add
const px = function (t) {
    var e = Object.prototype.toString
    return t === !0 || t === !1 || (!!t && typeof t == 'object' && e.call(t) === Mh)
  },
  ze = function (t) {
    return !!t && (typeof t == 'object' || typeof t == 'function')
  },
  ai = function (t) {
    var e = Object.prototype.toString
    return typeof t == 'number' || (!!t && typeof t == 'object' && e.call(t) === Eh)
  },
  Wn = function (t) {
    var e = Object.prototype.toString
    return typeof t == 'string' || (!!t && typeof t == 'object' && e.call(t) === Dh)
  },
  Kt = lx((t, e) => {
    if (Lh(e) || Vi(e)) {
      Ku(e, Qu(e), t)
      return
    }
    for (var n in e) hasOwnProperty.call(e, n) && so(t, n, e[n])
  }),
  vx = Kt,
  cE = vx,
  mx = (t, ...e) => {
    let n = -1,
      i = e.length
    const s = i > 2 ? e[2] : void 0
    for (s && th(e[0], e[1], s) && (i = 1); ++n < i; ) {
      const o = e[n]
      if (o == null) continue
      const u = Object.keys(o),
        c = u.length
      let h = -1
      for (; ++h < c; ) {
        const p = u[h],
          y = t[p]
        ;(y === void 0 || (yl(y, Object.prototype[p]) && !hasOwnProperty.call(t, p))) &&
          (t[p] = o[p])
      }
    }
    return t
  },
  mi = mx,
  yx = function (...e) {
    return (e.push(void 0, ux), An.apply(void 0, e))
  },
  _h = yx,
  Ui = (t, e, ...n) => {
    let i = -1
    const s = typeof e == 'function',
      o = Vi(t) ? new Array(t.length) : []
    return (
      zm(t, u => {
        o[++i] = s ? e.apply(u, n) : Ax(u, e, ...n)
      }),
      o
    )
  },
  Ax = (t, e, ...n) => {
    ;((e = gs(e, t)), (t = sx(t, e)))
    const i = t == null ? t : t[Ca(B3(e))]
    return i?.apply(t, n)
  },
  Rm = (t, e, n) => {
    let i = 0,
      s = t == null ? 0 : t.length
    if (s == 0) return 0
    ;((n = kh(n, 2)), (e = n(e)))
    const o = e !== e,
      u = e === null,
      c = gl(e),
      h = e === void 0
    for (; i < s; ) {
      let p
      const y = Math.floor((i + s) / 2),
        v = n(t[y]),
        C = v !== void 0,
        w = v === null,
        N = v === v,
        T = gl(v)
      ;(o
        ? (p = N)
        : h
          ? (p = N && C)
          : u
            ? (p = N && C && !w)
            : c
              ? (p = N && C && !w && !T)
              : w || T
                ? (p = !1)
                : (p = v < e),
        p ? (i = y + 1) : (s = y))
    }
    return Math.min(s, o3)
  },
  cs = (t, e) => {
    let n = -1,
      i = (h, p) => !!(h == null ? 0 : h.length) && h.indexOf(p) > -1
    e = kh(e, 2)
    let s = !0
    const { length: o } = t,
      u = []
    let c = u
    if (o >= Nm) {
      const h = e ? null : j3(t)
      if (h) return Rh(h)
      ;((s = !1), (i = (p, y) => p.has(y)), (c = new pl()))
    } else c = e ? [] : u
    t: for (; ++n < o; ) {
      let h = t[n]
      const p = e ? e(h) : h
      if (((h = h !== 0 ? h : 0), s && p === p)) {
        let y = c.length
        for (; y--; ) if (c[y] === p) continue t
        ;(e && c.push(p), u.push(h))
      } else i(c, p) || (c !== u && c.push(p), u.push(h))
    }
    return u
  },
  Bi = t => ll(t),
  ti = t => ll(t, !0),
  Hr = t => {
    if (t == null) return !0
    if (
      Vi(t) &&
      (Array.isArray(t) || typeof t == 'string' || typeof t.splice == 'function' || $u(t) || Pu(t))
    )
      return !t.length
    const e = ur(t)
    if (e == '[object Map]' || e == '[object Set]') return !t.size
    if (Lh(t)) return !h3(t).length
    for (const n in t) if (hasOwnProperty.call(t, n)) return !1
    return !0
  },
  qs = (t, e) => zh(t, e),
  Ze = t => typeof t == 'function',
  hn = t => {
    if (!lr(t) || ur(t) != '[object Object]') return !1
    if (Object.getPrototypeOf(t) === null) return !0
    let e = t
    for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e)
    return Object.getPrototypeOf(t) === e
  },
  xe = t => {
    if (!t) return []
    if (Vi(t)) return Wn(t) ? Qw(t) : Tm(t)
    if (Symbol.iterator && Symbol.iterator in Object(t)) {
      const i = t[Symbol.iterator]()
      let s
      const o = []
      for (; !(s = i.next()).done; ) o.push(s.value)
      return o
    }
    const e = ur(t)
    return (e == Ju ? rx : e == qu ? Rh : f3)(t)
  }
function bx(t, e, n) {
  if (typeof t != 'function') throw new TypeError('Expected a function')
  let i,
    s,
    o,
    u,
    c,
    h,
    p = 0,
    y = !1,
    v = !1,
    C = !0
  const w = !e && e !== 0 && window && typeof window.requestAnimationFrame == 'function'
  ;((e = +e || 0),
    ze(n) &&
      ((y = !!n.leading),
      (v = 'maxWait' in n),
      (o = v ? Math.max(+n.maxWait || 0, e) : o),
      (C = 'trailing' in n ? !!n.trailing : C)))
  function N(g) {
    const S = i,
      M = s
    return ((i = s = void 0), (p = g), (u = t.apply(M, S)), u)
  }
  function T(g, S) {
    return w ? (window.cancelAnimationFrame(c), window.requestAnimationFrame(g)) : setTimeout(g, S)
  }
  function z(g) {
    if (w) return window.cancelAnimationFrame(g)
    clearTimeout(g)
  }
  function R(g) {
    return ((p = g), (c = T(Z, e)), y ? N(g) : u)
  }
  function B(g) {
    const S = g - h,
      M = g - p,
      _ = e - S
    return v ? Math.min(_, o - M) : _
  }
  function H(g) {
    const S = g - h,
      M = g - p
    return h === void 0 || S >= e || S < 0 || (v && M >= o)
  }
  function Z() {
    const g = Date.now()
    if (H(g)) return U(g)
    c = T(Z, B(g))
  }
  function U(g) {
    return ((c = void 0), C && i ? N(g) : ((i = s = void 0), u))
  }
  function nt(...g) {
    const S = Date.now(),
      M = H(S)
    if (((i = g), (s = this), (h = S), M)) {
      if (c === void 0) return R(h)
      if (v) return ((c = T(Z, e)), N(h))
    }
    return (c === void 0 && (c = T(Z, e)), u)
  }
  return (
    (nt.cancel = () => {
      ;(c !== void 0 && z(c), (p = 0), (i = h = s = c = void 0))
    }),
    (nt.flush = () => (c === void 0 ? u : U(Date.now()))),
    (nt.pending = () => c !== void 0),
    nt
  )
}
const Ix = (t, e) => (
    (e = kh(e, 2)),
    Q3(
      t,
      (n, i, s) => ((s = e(i)), hasOwnProperty.call(n, s) ? n[s].push(i) : so(n, s, [i]), n),
      {}
    )
  ),
  Hf = (t, e = []) => {
    if (t == null) return []
    const n = e.length
    return (
      n > 1 && th(t, e[0], e[1]) ? (e = []) : n > 2 && th(e[0], e[1], e[2]) && (e = [e[0]]),
      Array.isArray(e) || (e = [kh(e, 2)]),
      P3(t, e.flat(1), [])
    )
  },
  Cx = t => ((t == null ? 0 : t.length) ? dx(t, 1 / 0) : []),
  eh = (t, ...e) => (Vi(t) ? ax(t, e) : []),
  km = (t, ...e) => (lr(t) && Vi(t) ? ax(t, e.flat(1)) : []),
  fE = (...t) => {
    const e = t.map(n => (lr(n) && Vi(n) ? n : []))
    return e.length && e[0] === t[0] ? M3(e) : []
  },
  nh = (...t) => {
    const e = t.flat(1)
    return cs(e)
  },
  Mr = (t, e) => {
    if (t == null) return !1
    typeof e == 'string' && (e = e.split('.'))
    let n = -1,
      i = t
    for (; ++n < e.length; ) {
      if (!i || !hasOwnProperty.call(i, e[n])) return !1
      i = i[e[n]]
    }
    return !0
  },
  dn = (t, e, n) => {
    e = gs(e, t)
    let i = -1,
      s = e.length
    for (s || ((s = 1), (t = void 0)); ++i < s; ) {
      let o = t?.[Ca(e[i])]
      ;(o === void 0 && ((i = s), (o = n)), (t = typeof o == 'function' ? o.call(t) : o))
    }
    return t
  },
  ba = (t, ...e) => {
    let n = {}
    if (t == null) return n
    let i = !1
    ;((e = e.flat(1).map(o => ((o = gs(o, t)), i || (i = o.length > 1), o))),
      Ku(t, nx(t), n),
      i && (n = ll(n, !0, !0, !0, o => (hn(o) ? void 0 : o))))
    let s = e.length
    for (; s--; ) O3(n, e[s])
    return n
  },
  wx = (t, ...e) => (t == null ? {} : $3(t, e.flat(1 / 0))),
  hE = (t, ...e) => (
    e.flat(1).forEach(n => {
      ;((n = Ca(n)), so(t, n, t[n].bind(t)))
    }),
    t
  ),
  yi = (t, e = n => n) => {
    let n = -1
    const i = Object(t),
      s = Vi(t) ? Kw(t, !0) : ox(t)
    let o = s.length
    for (; o--; ) {
      const u = s[++n]
      if (e(i[u], u, i) === !1) break
    }
  },
  xx = (t = '') =>
    sE(`${t}`.replace(/['\u2019]/g, '')).reduce(
      (e, n, i) => ((n = n.toLowerCase()), e + (i ? lE(n) : n)),
      ''
    )
let dE = 0
const Sx = (t = '') => {
    const e = ++dE
    return `${t}` + e
  },
  An = lx((t, e, n, i) => {
    Lm(t, e, n, i)
  }, !0),
  ir = function (t) {
    return (
      t &&
      t
        .toString()
        .split(' ')
        .map(function (e) {
          return (
            e.substr(0, Yi.classNamePrefix.length) !== Yi.classNamePrefix &&
              (e = Yi.classNamePrefix + e),
            e
          )
        })
        .join(' ')
    )
  },
  Nx = function (t) {
    return (
      t &&
      t
        .toString()
        .split(' ')
        .map(function (e) {
          return (
            e.substr(0, Yi.classNamePrefix.length) === Yi.classNamePrefix &&
              (e = e.substr(Yi.classNamePrefix.length)),
            e
          )
        })
        .join(' ')
    )
  },
  Gu = function (t, e) {
    const n = {},
      i = {},
      s = yt.namespace.svg,
      o = e || s,
      u = document.createDocumentFragment(),
      c = function (h, p, y) {
        for (let v = 0; v < h.length; v++) {
          const C = h[v]
          if (typeof C == 'string') {
            const Z = document.createTextNode(C)
            p.appendChild(Z)
            continue
          }
          if (!C.hasOwnProperty('tagName')) throw new Error('json-dom-parser: missing tagName')
          const w = C.tagName
          let N
          ;(C.hasOwnProperty('namespaceURI') && (y = C.namespaceURI),
            (N = document.createElementNS(y, w)))
          const T = y === s,
            z = T ? yt : Ie,
            R = C.attributes
          R && z(N).attr(R)
          const B = C.style
          if ((B && Ie(N).css(B), C.hasOwnProperty('className'))) {
            const Z = C.className
            T ? (N.className.baseVal = Z) : (N.className = Z)
          }
          if (
            (C.hasOwnProperty('textContent') && (N.textContent = C.textContent),
            C.hasOwnProperty('selector'))
          ) {
            const Z = C.selector
            if (n[Z]) throw new Error('json-dom-parser: selector must be unique')
            ;((n[Z] = N), z(N).attr('joint-selector', Z))
          }
          if (C.hasOwnProperty('groupSelector')) {
            let Z = C.groupSelector
            Array.isArray(Z) || (Z = [Z])
            for (let U = 0; U < Z.length; U++) {
              const nt = Z[U]
              let g = i[nt]
              ;(g || (g = i[nt] = []), g.push(N))
            }
          }
          p.appendChild(N)
          const H = C.children
          Array.isArray(H) && c(H, N, y)
        }
      }
    return (c(t, u, o), { fragment: u, selectors: n, groupSelectors: i })
  },
  Su = function (t) {
    let e = 0
    if (t.length === 0) return e
    for (let n = 0; n < t.length; n++) {
      const i = t.charCodeAt(n)
      ;((e = (e << 5) - e + i), (e = e & e))
    }
    return e
  },
  vl = function (t, e, n) {
    for (var i = Array.isArray(e) ? e : e.split(n || '/'), s, o = 0, u = i.length; o < u; )
      if (((s = i[o++]), Object(t) === t && s in t)) t = t[s]
      else return
    return t
  },
  Tx = function (t, e) {
    return (
      typeof e != 'string' && typeof e != 'number' && (e = String(e)),
      !((e === 'constructor' && typeof t[e] == 'function') || e === '__proto__')
    )
  },
  ih = function (t, e, n, i) {
    const s = Array.isArray(e) ? e : e.split(i || '/'),
      o = s.length - 1
    let u = t,
      c = 0
    for (; c < o; c++) {
      const h = s[c]
      if (!Tx(u, h)) return t
      u = u[h] || (u[h] = {})
    }
    return ((u[s[o]] = n), t)
  },
  yv = function (t, e, n) {
    const i = Array.isArray(e) ? e : e.split(n || '/'),
      s = i.length - 1
    let o = t,
      u = 0
    for (; u < s; u++) {
      const c = i[u]
      if (!Tx(o, c)) return t
      const h = o[c]
      if (!h) return t
      o = h
    }
    return (delete o[i[s]], t)
  },
  Mx = function (t, e, n) {
    e = e || '/'
    var i = {}
    for (var s in t)
      if (t.hasOwnProperty(s)) {
        var o = typeof t[s] == 'object'
        if ((o && n && n(t[s]) && (o = !1), o)) {
          var u = Mx(t[s], e, n)
          for (var c in u) u.hasOwnProperty(c) && (i[s + e + c] = u[c])
        } else i[s] = t[s]
      }
    return i
  },
  Ex = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (t) {
      var e = (Math.random() * 16) | 0,
        n = t === 'x' ? e : (e & 3) | 8
      return n.toString(16)
    })
  },
  Qs = function (t) {
    return (
      (Qs.id = Qs.id || 1),
      t === void 0 ? 'j_' + Qs.id++ : ((t.id = t.id === void 0 ? 'j_' + Qs.id++ : t.id), t.id)
    )
  },
  Dx = function (t) {
    return t.replace(/[A-Z]/g, '-$&').toLowerCase()
  },
  Ge = function (t) {
    if (t.normalized) return t
    const { originalEvent: e, target: n } = t,
      i = e && e.changedTouches && e.changedTouches[0]
    if (i) for (let s in i) t[s] === void 0 && (t[s] = i[s])
    if (n) {
      const s = n.correspondingUseElement
      s && (t.target = s)
    }
    return ((t.normalized = !0), t)
  },
  Ox = function (t) {
    let s = 0,
      o = 0,
      u = 0,
      c = 0
    return (
      'detail' in t && (o = t.detail),
      'wheelDelta' in t && (o = -t.wheelDelta / 120),
      'wheelDeltaY' in t && (o = -t.wheelDeltaY / 120),
      'wheelDeltaX' in t && (s = -t.wheelDeltaX / 120),
      'axis' in t && t.axis === t.HORIZONTAL_AXIS && ((s = o), (o = 0)),
      (u = 'deltaX' in t ? t.deltaX : s * 10),
      (c = 'deltaY' in t ? t.deltaY : o * 10),
      (u || c) &&
        t.deltaMode &&
        (t.deltaMode == 1 ? ((u *= 40), (c *= 40)) : ((u *= 800), (c *= 800))),
      t.deltaX === 0 && t.deltaY !== 0 && t.shiftKey && ((u = c), (c = 0), (s = o), (o = 0)),
      u && !s && (s = u < 1 ? -1 : 1),
      c && !o && (o = c < 1 ? -1 : 1),
      { spinX: s, spinY: o, deltaX: u, deltaY: c }
    )
  },
  Lx = function (t, e) {
    return t > e ? e : t < -e ? -e : t
  },
  rh = (function () {
    var t
    if (
      (typeof window < 'u' &&
        (t =
          window.requestAnimationFrame ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          window.oRequestAnimationFrame ||
          window.msRequestAnimationFrame),
      !t)
    ) {
      var e = 0
      t = function (n) {
        var i = new Date().getTime(),
          s = Math.max(0, 16 - (i - e)),
          o = setTimeout(function () {
            n(i + s)
          }, s)
        return ((e = i + s), o)
      }
    }
    return function (n, i, ...s) {
      return t(i !== void 0 ? n.bind(i, ...s) : n)
    }
  })(),
  ah = (function () {
    var t,
      e = typeof window < 'u'
    return (
      e &&
        (t =
          window.cancelAnimationFrame ||
          window.webkitCancelAnimationFrame ||
          window.webkitCancelRequestAnimationFrame ||
          window.msCancelAnimationFrame ||
          window.msCancelRequestAnimationFrame ||
          window.oCancelAnimationFrame ||
          window.oCancelRequestAnimationFrame ||
          window.mozCancelAnimationFrame ||
          window.mozCancelRequestAnimationFrame),
      (t = t || clearTimeout),
      e ? t.bind(window) : t
    )
  })(),
  gE = function (t, e, n, i) {
    var s, o
    if (!n) {
      var u = e.$('.scalable')[0],
        c = e.$('.rotatable')[0]
      u && u.firstChild ? (n = u.firstChild) : c && c.firstChild && (n = c.firstChild)
    }
    return (
      n
        ? ((o = yt(n).findIntersection(i, t.paper.cells)),
          o || (s = yt(n).getBBox({ target: t.paper.cells })))
        : ((s = e.model.getBBox()), (o = s.intersectionWithLineFromCenterToPoint(i))),
      o || s.center()
    )
  },
  Dn = function (t) {
    return Wn(t) && t.slice(-1) === '%'
  },
  zx = function (t, e) {
    function n(c) {
      var h = new RegExp('(?:\\d+(?:\\.\\d+)*)(' + c + ')$').exec(t)
      return h ? h[1] : null
    }
    var i = parseFloat(t)
    if (Number.isNaN(i)) return null
    var s = {}
    s.value = i
    var o
    if (e == null) o = '[A-Za-z]*'
    else if (Array.isArray(e)) {
      if (e.length === 0) return null
      o = e.join('|')
    } else Wn(e) && (o = e)
    var u = n(o)
    return u === null ? null : ((s.unit = u), s)
  },
  Eu = 0
function pE(t, e) {
  const n = t.split(e)
  let i = 1
  for (let s = 0, o = n.length - 1; s < o; s++) {
    const u = []
    ;((s > 0 || n[0] !== '') && u.push(Eu),
      u.push(e),
      (s < o - 1 || n[o] !== '') && u.push(Eu),
      n.splice(i, 0, ...u),
      (i += u.length + 1))
  }
  return n.filter(s => s !== '')
}
function kb(t, e) {
  if (t === null) return e.getBBox().height
  switch (t.unit) {
    case 'em':
      return e.getBBox().height * t.value
    case 'px':
    case '':
      return t.value
  }
}
const _m = function (t, e, n = {}, i = {}) {
    var s = e.width,
      o = e.height,
      u = i.svgDocument || yt('svg').node,
      c = yt('tspan').node,
      h = yt('text').attr(n).append(c).node,
      p = document.createTextNode('')
    ;((h.style.opacity = 0),
      (h.style.display = 'block'),
      (c.style.display = 'block'),
      c.appendChild(p),
      u.appendChild(h),
      i.svgDocument || document.body.appendChild(u))
    const y = i.preserveSpaces,
      v = ' ',
      C = i.separator || i.separator === '' ? i.separator : v,
      w = typeof C == 'string' ? C : v
    var N =
        i.eol ||
        `
`,
      T = i.hyphen ? new RegExp(i.hyphen) : /[^\w\d\u00C0-\u1FFF\u2800-\uFFFD]/,
      z = i.maxLineCount
    ai(z) || (z = 1 / 0)
    var R = t.split(C),
      B = [],
      H = [],
      Z,
      U,
      nt
    y && yt(c).attr('xml:space', 'preserve')
    for (var g = 0, S = 0, M = R.length; g < M; g++) {
      var _ = R[g]
      if (!(!_ && !y) && typeof _ == 'string') {
        var W = !1
        if (_.indexOf(N) >= 0)
          if (_.length > 1) {
            const F = pE(R[g], N)
            ;(R.splice(g, 1, ...F), g--, (M = R.length))
            continue
          } else {
            if (y && typeof R[g - 1] == 'string') {
              ;(R.splice(g, Eu, '', Eu), (M += 2), g--)
              continue
            }
            ;((H[++S] = !y || typeof R[g + 1] == 'string' ? '' : void 0), (W = !0))
          }
        if (!W) {
          let F
          if (
            (y ? (F = H[S] !== void 0 ? H[S] + w + _ : _) : (F = H[S] ? H[S] + w + _ : _),
            (p.data = F),
            c.getComputedTextLength() <= s)
          )
            ((H[S] = F), (Z || U) && ((B[S++] = !0), (Z = 0), (U = 0)))
          else {
            if (!H[S] || Z) {
              var $ = !!Z
              if (((Z = _.length - 1), $ || !Z)) {
                if (!Z) {
                  if (!H[S]) {
                    H = []
                    break
                  }
                  ;(R.splice(g, 2, _ + R[g + 1]), M--, (B[S++] = !0), g--)
                  continue
                }
                R[g] = _.substring(0, Z)
                const ht = R[g + 1]
                R[g + 1] = _.substring(Z) + (ht === void 0 || ht === Eu ? '' : ht)
              } else {
                if (U) (R.splice(g, 2, R[g] + R[g + 1]), (U = 0))
                else {
                  var X = _.search(T)
                  ;(X > -1 && X !== _.length - 1 && X !== 0 && ((U = X + 1), (Z = 0)),
                    R.splice(g, 1, _.substring(0, U || Z), _.substring(U || Z)),
                    M++)
                }
                S && !B[S - 1] && S--
              }
              ;(!y || H[S] !== '') && g--
              continue
            }
            ;(S++, g--)
          }
        }
        var Ct = null
        if (H.length > z) Ct = z - 1
        else if (o !== void 0) {
          if (nt === void 0 && p.data !== '')
            if (n.lineHeight === 'auto') nt = kb({ value: 1.5, unit: 'em' }, h)
            else {
              const F = zx(n.lineHeight, ['em', 'px', ''])
              nt = kb(F, h)
            }
          nt * H.length > o && (Ct = Math.floor(o / nt) - 1)
        }
        if (Ct !== null) {
          H.splice(Ct + 1)
          var Tt = i.ellipsis
          if (!Tt || Ct < 0) break
          typeof Tt != 'string' && (Tt = '…')
          var G = H[Ct]
          if (!G && !W) break
          var Q = G.length,
            it,
            st
          do {
            if (
              ((st = G[Q]),
              (it = G.substring(0, Q)),
              st ? st.match(C) && (it += st) : (it += w),
              (it += Tt),
              (p.data = it),
              c.getComputedTextLength() <= s)
            ) {
              H[Ct] = it
              break
            }
            Q--
          } while (Q >= 0)
          break
        }
      }
    }
    return (i.svgDocument ? u.removeChild(h) : document.body.removeChild(u), H.join(N))
  },
  Rx = function (t) {
    var e = Ie(Ie.parseHTML('<div>' + t + '</div>', null, !1))
    return (
      e.find('*').each(function () {
        var n = this
        Ie.each(n.attributes, function () {
          var i = this,
            s = i.name,
            o = i.value
          ;(s.startsWith('on') ||
            o.startsWith('javascript:') ||
            o.startsWith('data:') ||
            o.startsWith('vbscript:')) &&
            Ie(n).removeAttr(s)
        })
      }),
      e.html()
    )
  },
  kx = function (t, e) {
    if (window.navigator.msSaveBlob) window.navigator.msSaveBlob(t, e)
    else {
      var n = window.URL.createObjectURL(t),
        i = document.createElement('a')
      ;((i.href = n),
        (i.download = e),
        document.body.appendChild(i),
        i.click(),
        document.body.removeChild(i),
        window.URL.revokeObjectURL(n))
    }
  },
  vE = function (t, e) {
    const n = _x(t)
    kx(n, e)
  },
  _x = function (t) {
    ;((t = t.replace(/\s/g, '')), (t = decodeURIComponent(t)))
    var e = t.indexOf(','),
      n = t.slice(0, e),
      i = n.split(':')[1].split(';')[0],
      s = t.slice(e + 1),
      o
    n.indexOf('base64') >= 0 ? (o = atob(s)) : (o = unescape(encodeURIComponent(s)))
    for (var u = new Uint8Array(o.length), c = 0; c < o.length; c++) u[c] = o.charCodeAt(c)
    return new Blob([u], { type: i })
  },
  mE = function (t, e) {
    if (!t || t.substr(0, 5) === 'data:')
      return setTimeout(function () {
        e(null, t)
      }, 0)
    var n = function (o, u) {
        if (o.status === 200) {
          var c = new FileReader()
          ;((c.onload = function (h) {
            var p = h.target.result
            u(null, p)
          }),
            (c.onerror = function () {
              u(new Error('Failed to load image ' + t))
            }),
            c.readAsDataURL(o.response))
        } else u(new Error('Failed to load image ' + t))
      },
      i = function (o, u) {
        var c = function (w) {
          for (var N = 32768, T = [], z = 0; z < w.length; z += N)
            T.push(String.fromCharCode.apply(null, w.subarray(z, z + N)))
          return T.join('')
        }
        if (o.status === 200) {
          var h = new Uint8Array(o.response),
            p = t.split('.').pop() || 'png',
            y = { svg: 'svg+xml' },
            v = 'data:image/' + (y[p] || p) + ';base64,',
            C = v + btoa(c(h))
          u(null, C)
        } else u(new Error('Failed to load image ' + t))
      },
      s = new XMLHttpRequest()
    ;(s.open('GET', t, !0),
      s.addEventListener('error', function () {
        e(new Error('Failed to load image ' + t))
      }),
      (s.responseType = window.FileReader ? 'blob' : 'arraybuffer'),
      s.addEventListener('load', function () {
        window.FileReader ? n(s, e) : i(s, e)
      }),
      s.send())
  },
  yE = function (t) {
    var e = Ie(t)
    if (e.length === 0) throw new Error('Element not found')
    var n = e[0],
      i = n.ownerDocument,
      s = n.getBoundingClientRect(),
      o = 0,
      u = 0
    if (n.ownerSVGElement) {
      var c = yt(n),
        h = c.getBBox({ target: c.svg() })
      ;((o = s.width - h.width), (u = s.height - h.height))
    }
    return {
      x: s.left + window.pageXOffset - i.documentElement.offsetLeft + o / 2,
      y: s.top + window.pageYOffset - i.documentElement.offsetTop + u / 2,
      width: s.width - o,
      height: s.height - u,
    }
  },
  Bx = function (t, e) {
    var n = Ie(t),
      i = n.map(function () {
        var s = this,
          o = s.parentNode,
          u = o.insertBefore(document.createTextNode(''), s.nextSibling)
        return function () {
          if (o === this)
            throw new Error("You can't sort elements if any one is a descendant of another.")
          ;(o.insertBefore(this, u), o.removeChild(u))
        }
      })
    return Array.prototype.sort.call(n, e).each(function (s) {
      i[s].call(this)
    })
  },
  AE = function (t, e) {
    var n = Ie(t)
    yi(e, function (i, s) {
      var o = n.find(s).addBack().filter(s)
      ;(Mr(i, 'class') && (o.addClass(i.class), (i = ba(i, 'class'))), o.attr(i))
    })
  },
  Ia = function (t) {
    if (Object(t) !== t) {
      var e = 0
      return (isFinite(t) && (e = +t), { top: e, right: e, bottom: e, left: e })
    }
    var n, i, s, o
    return (
      (n = i = s = o = 0),
      isFinite(t.vertical) && (n = s = +t.vertical),
      isFinite(t.horizontal) && (i = o = +t.horizontal),
      isFinite(t.top) && (n = +t.top),
      isFinite(t.right) && (i = +t.right),
      isFinite(t.bottom) && (s = +t.bottom),
      isFinite(t.left) && (o = +t.left),
      { top: n, right: i, bottom: s, left: o }
    )
  },
  jx = {
    linear: function (t) {
      return t
    },
    quad: function (t) {
      return t * t
    },
    cubic: function (t) {
      return t * t * t
    },
    inout: function (t) {
      if (t <= 0) return 0
      if (t >= 1) return 1
      var e = t * t,
        n = e * t
      return 4 * (t < 0.5 ? n : 3 * (t - e) + n - 0.75)
    },
    exponential: function (t) {
      return Math.pow(2, 10 * (t - 1))
    },
    bounce: function (t) {
      for (var e = 0, n = 1; ; e += n, n /= 2)
        if (t >= (7 - 4 * e) / 11) {
          var i = (11 - 6 * e - 11 * t) / 4
          return -i * i + n * n
        }
    },
    reverse: function (t) {
      return function (e) {
        return 1 - t(1 - e)
      }
    },
    reflect: function (t) {
      return function (e) {
        return 0.5 * (e < 0.5 ? t(2 * e) : 2 - t(2 - 2 * e))
      }
    },
    clamp: function (t, e, n) {
      return (
        (e = e || 0),
        (n = n || 1),
        function (i) {
          var s = t(i)
          return s < e ? e : s > n ? n : s
        }
      )
    },
    back: function (t) {
      return (
        t || (t = 1.70158),
        function (e) {
          return e * e * ((t + 1) * e - t)
        }
      )
    },
    elastic: function (t) {
      return (
        t || (t = 1.5),
        function (e) {
          return Math.pow(2, 10 * (e - 1)) * Math.cos(((20 * Math.PI * t) / 3) * e)
        }
      )
    },
  },
  Bm = {
    number: function (t, e) {
      var n = e - t
      return function (i) {
        return t + n * i
      }
    },
    object: function (t, e) {
      var n = Object.keys(t)
      return function (i) {
        var s,
          o,
          u = {}
        for (s = n.length - 1; s != -1; s--) ((o = n[s]), (u[o] = t[o] + (e[o] - t[o]) * i))
        return u
      }
    },
    hexColor: function (t, e) {
      var n = parseInt(t.slice(1), 16),
        i = parseInt(e.slice(1), 16),
        s = n & 255,
        o = (i & 255) - s,
        u = n & 65280,
        c = (i & 65280) - u,
        h = n & 16711680,
        p = (i & 16711680) - h
      return function (y) {
        var v = (s + o * y) & 255,
          C = (u + c * y) & 65280,
          w = (h + p * y) & 16711680
        return '#' + ((1 << 24) | v | C | w).toString(16).slice(1)
      }
    },
    unit: function (t, e) {
      var n = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/,
        i = n.exec(t),
        s = n.exec(e),
        o = s[1].indexOf('.'),
        u = o > 0 ? s[1].length - o - 1 : 0
      t = +i[1]
      var c = +s[1] - t,
        h = i[2]
      return function (p) {
        return (t + c * p).toFixed(u) + h
      }
    },
  },
  Px = {
    outline: function (t) {
      var e =
          '<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" /><feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" /><feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/><feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/><feMerge><feMergeNode in="outline"/><feMergeNode in="SourceGraphic"/></feMerge></filter>',
        n = Number.isFinite(t.margin) ? t.margin : 2,
        i = Number.isFinite(t.width) ? t.width : 1
      return $n(e)({
        color: t.color || 'blue',
        opacity: Number.isFinite(t.opacity) ? t.opacity : 1,
        outerRadius: n + i,
        innerRadius: n,
      })
    },
    highlight: function (t) {
      var e =
        '<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width}"/><feComposite result="composed" in="colored" in2="morphed" operator="in"/><feGaussianBlur result="blured" in="composed" stdDeviation="${blur}"/><feBlend in="SourceGraphic" in2="blured" mode="normal"/></filter>'
      return $n(e)({
        color: t.color || 'red',
        width: Number.isFinite(t.width) ? t.width : 1,
        blur: Number.isFinite(t.blur) ? t.blur : 0,
        opacity: Number.isFinite(t.opacity) ? t.opacity : 1,
      })
    },
    blur: function (t) {
      var e = Number.isFinite(t.x) ? t.x : 2
      return $n('<filter><feGaussianBlur stdDeviation="${stdDeviation}"/></filter>')({
        stdDeviation: Number.isFinite(t.y) ? [e, t.y] : e,
      })
    },
    dropShadow: function (t) {
      var e =
        'SVGFEDropShadowElement' in window
          ? '<filter><feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}"/></filter>'
          : '<filter><feGaussianBlur in="SourceAlpha" stdDeviation="${blur}"/><feOffset dx="${dx}" dy="${dy}" result="offsetblur"/><feFlood flood-color="${color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="${opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>'
      return $n(e)({
        dx: t.dx || 0,
        dy: t.dy || 0,
        opacity: Number.isFinite(t.opacity) ? t.opacity : 1,
        color: t.color || 'black',
        blur: Number.isFinite(t.blur) ? t.blur : 4,
      })
    },
    grayscale: function (t) {
      var e = Number.isFinite(t.amount) ? t.amount : 1
      return $n(
        '<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/></filter>'
      )({
        a: 0.2126 + 0.7874 * (1 - e),
        b: 0.7152 - 0.7152 * (1 - e),
        c: 0.0722 - 0.0722 * (1 - e),
        d: 0.2126 - 0.2126 * (1 - e),
        e: 0.7152 + 0.2848 * (1 - e),
        f: 0.0722 - 0.0722 * (1 - e),
        g: 0.2126 - 0.2126 * (1 - e),
        h: 0.0722 + 0.9278 * (1 - e),
      })
    },
    sepia: function (t) {
      var e = Number.isFinite(t.amount) ? t.amount : 1
      return $n(
        '<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/></filter>'
      )({
        a: 0.393 + 0.607 * (1 - e),
        b: 0.769 - 0.769 * (1 - e),
        c: 0.189 - 0.189 * (1 - e),
        d: 0.349 - 0.349 * (1 - e),
        e: 0.686 + 0.314 * (1 - e),
        f: 0.168 - 0.168 * (1 - e),
        g: 0.272 - 0.272 * (1 - e),
        h: 0.534 - 0.534 * (1 - e),
        i: 0.131 + 0.869 * (1 - e),
      })
    },
    saturate: function (t) {
      var e = Number.isFinite(t.amount) ? t.amount : 1
      return $n('<filter><feColorMatrix type="saturate" values="${amount}"/></filter>')({
        amount: 1 - e,
      })
    },
    hueRotate: function (t) {
      return $n('<filter><feColorMatrix type="hueRotate" values="${angle}"/></filter>')({
        angle: t.angle || 0,
      })
    },
    invert: function (t) {
      var e = Number.isFinite(t.amount) ? t.amount : 1
      return $n(
        '<filter><feComponentTransfer><feFuncR type="table" tableValues="${amount} ${amount2}"/><feFuncG type="table" tableValues="${amount} ${amount2}"/><feFuncB type="table" tableValues="${amount} ${amount2}"/></feComponentTransfer></filter>'
      )({ amount: e, amount2: 1 - e })
    },
    brightness: function (t) {
      return $n(
        '<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}"/><feFuncG type="linear" slope="${amount}"/><feFuncB type="linear" slope="${amount}"/></feComponentTransfer></filter>'
      )({ amount: Number.isFinite(t.amount) ? t.amount : 1 })
    },
    contrast: function (t) {
      var e = Number.isFinite(t.amount) ? t.amount : 1
      return $n(
        '<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}" intercept="${amount2}"/><feFuncG type="linear" slope="${amount}" intercept="${amount2}"/><feFuncB type="linear" slope="${amount}" intercept="${amount2}"/></feComponentTransfer></filter>'
      )({ amount: e, amount2: 0.5 - e / 2 })
    },
  },
  bE = {
    number: function (t, e, n) {
      n = n || { currency: ['$', ''], decimal: '.', thousands: ',', grouping: [3] }
      var i = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,
        s = i.exec(t),
        o = s[1] || ' ',
        u = s[2] || '>',
        c = s[3] || '',
        h = s[4] || '',
        p = s[5],
        y = +s[6],
        v = s[7],
        C = s[8],
        w = s[9],
        N = 1,
        T = '',
        z = '',
        R = !1
      switch (
        (C && (C = +C.substring(1)),
        (p || (o === '0' && u === '=')) &&
          ((p = o = '0'), (u = '='), v && (y -= Math.floor((y - 1) / 4))),
        w)
      ) {
        case 'n':
          ;((v = !0), (w = 'g'))
          break
        case '%':
          ;((N = 100), (z = '%'), (w = 'f'))
          break
        case 'p':
          ;((N = 100), (z = '%'), (w = 'r'))
          break
        case 'b':
        case 'o':
        case 'x':
        case 'X':
          h === '#' && (T = '0' + w.toLowerCase())
          break
        case 'c':
        case 'd':
          ;((R = !0), (C = 0))
          break
        case 's':
          ;((N = -1), (w = 'r'))
          break
      }
      ;(h === '$' && ((T = n.currency[0]), (z = n.currency[1])),
        w == 'r' && !C && (w = 'g'),
        C != null &&
          (w == 'g'
            ? (C = Math.max(1, Math.min(21, C)))
            : (w == 'e' || w == 'f') && (C = Math.max(0, Math.min(20, C)))))
      var B = p && v
      if (R && e % 1) return ''
      var H = e < 0 || (e === 0 && 1 / e < 0) ? ((e = -e), '-') : c,
        Z = z
      if (N < 0) {
        var U = this.prefix(e, C)
        ;((e = U.scale(e)), (Z = U.symbol + z))
      } else e *= N
      e = this.convert(w, e, C)
      var nt = e.lastIndexOf('.'),
        g = nt < 0 ? e : e.substring(0, nt),
        S = nt < 0 ? '' : n.decimal + e.substring(nt + 1)
      function M($) {
        for (var X = $.length, Ct = [], Tt = 0, G = n.grouping[0]; X > 0 && G > 0; )
          (Ct.push($.substring((X -= G), X + G)),
            (G = n.grouping[(Tt = (Tt + 1) % n.grouping.length)]))
        return Ct.reverse().join(n.thousands)
      }
      !p && v && n.grouping && (g = M(g))
      var _ = T.length + g.length + S.length + (B ? 0 : H.length),
        W = _ < y ? new Array((_ = y - _ + 1)).join(o) : ''
      return (
        B && (g = M(W + g)),
        (H += T),
        (e = g + S),
        (u === '<'
          ? H + e + W
          : u === '>'
            ? W + H + e
            : u === '^'
              ? W.substring(0, (_ >>= 1)) + H + e + W.substring(_)
              : H + (B ? e : W + e)) + Z
      )
    },
    string: function (t, e) {
      for (var n, i = '{', s = !1, o = []; (n = t.indexOf(i)) !== -1; ) {
        var u, c, h
        if (((u = t.slice(0, n)), s)) {
          ;((c = u.split(':')), (h = c.shift().split('.')), (u = e))
          for (var p = 0; p < h.length; p++) u = u[h[p]]
          c.length && (u = this.number(c, u))
        }
        ;(o.push(u), (t = t.slice(n + 1)), (s = !s), (i = s ? '}' : '{'))
      }
      return (o.push(t), o.join(''))
    },
    convert: function (t, e, n) {
      switch (t) {
        case 'b':
          return e.toString(2)
        case 'c':
          return String.fromCharCode(e)
        case 'o':
          return e.toString(8)
        case 'x':
          return e.toString(16)
        case 'X':
          return e.toString(16).toUpperCase()
        case 'g':
          return e.toPrecision(n)
        case 'e':
          return e.toExponential(n)
        case 'f':
          return e.toFixed(n)
        case 'r':
          return (e = this.round(e, this.precision(e, n))).toFixed(
            Math.max(0, Math.min(20, this.precision(e * (1 + 1e-15), n)))
          )
        default:
          return e + ''
      }
    },
    round: function (t, e) {
      return e ? Math.round(t * (e = Math.pow(10, e))) / e : Math.round(t)
    },
    precision: function (t, e) {
      return e - (t ? Math.ceil(Math.log(t) / Math.LN10) : 1)
    },
    prefix: function (t, e) {
      var n = [
          'y',
          'z',
          'a',
          'f',
          'p',
          'n',
          'µ',
          'm',
          '',
          'k',
          'M',
          'G',
          'T',
          'P',
          'E',
          'Z',
          'Y',
        ].map(function (s, o) {
          var u = Math.pow(10, Math.abs(8 - o) * 3)
          return {
            scale:
              o > 8
                ? function (c) {
                    return c / u
                  }
                : function (c) {
                    return c * u
                  },
            symbol: s,
          }
        }),
        i = 0
      return (
        t &&
          (t < 0 && (t *= -1),
          e && (t = this.round(t, this.precision(t, e))),
          (i = 1 + Math.floor(1e-12 + Math.log(t) / Math.LN10)),
          (i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3)))),
        n[8 + i / 3]
      )
    },
  },
  $n = function (t) {
    var e = /<%= ([^ ]+) %>|\$\{ ?([^{} ]+) ?\}|\{\{([^{} ]+)\}\}/g
    return function (n) {
      return (
        (n = n || {}),
        t.replace(e, function (i) {
          for (
            var s = Array.from(arguments),
              o = s.slice(1, 4).find(function (h) {
                return !!h
              }),
              u = o.split('.'),
              c = n[u.shift()];
            c !== void 0 && u.length;

          )
            c = c[u.shift()]
          return c !== void 0 ? c : ''
        })
      )
    }
  },
  IE = function (t) {
    var e = window.top.document
    t = t || e.body
    function n(i, s) {
      for (var o = ['webkit', 'moz', 'ms', 'o', ''], u = 0; u < o.length; u++) {
        var c = o[u],
          h = c ? c + s : s.substr(0, 1).toLowerCase() + s.substr(1)
        if (i[h] !== void 0) return Ze(i[h]) ? i[h]() : i[h]
      }
    }
    n(e, 'FullscreenElement') || n(e, 'FullScreenElement')
      ? n(e, 'ExitFullscreen') || n(e, 'CancelFullScreen')
      : n(t, 'RequestFullscreen') || n(t, 'RequestFullScreen')
  },
  Ws = function () {}
function jm(t) {
  t = cs(t)
  const e = xe(t).reduce(function (n, i) {
    return ((n[i.id] = i.clone()), n)
  }, {})
  return (
    xe(t).forEach(function (n) {
      const i = e[n.id]
      if (i.isLink()) {
        const u = i.source(),
          c = i.target()
        ;(u.id && e[u.id] && i.prop('source/id', e[u.id].id),
          c.id && e[c.id] && i.prop('target/id', e[c.id].id))
      }
      const s = n.get('parent')
      s && e[s] && i.set('parent', e[s].id)
      const o = xe(n.get('embeds')).reduce(function (u, c) {
        return (e[c] && u.push(e[c].id), u)
      }, [])
      Hr(o) || i.set('embeds', o)
    }),
    e
  )
}
const CE = [
    'checked',
    'selected',
    'disabled',
    'readOnly',
    'contentEditable',
    'value',
    'indeterminate',
  ],
  wE = CE.reduce((t, e) => ((t[e] = !0), t), {}),
  xE = {
    qualify: function (t) {
      return hn(t)
    },
    set: function (t, e, n) {
      Object.keys(t).forEach(function (i) {
        if (wE[i] && i in n) {
          const s = t[i]
          n.tagName === 'SELECT' && Array.isArray(s)
            ? Array.from(n.options).forEach(function (o, u) {
                o.selected = s.includes(o.value)
              })
            : (n[i] = s)
        }
      })
    },
  }
function as(t, e) {
  return function (n, i) {
    var s = Dn(n)
    ;((n = parseFloat(n)), s && (n /= 100))
    var o = {}
    if (isFinite(n)) {
      var u = s || (n >= 0 && n <= 1) ? n * i[e] : Math.max(n + i[e], 0)
      o[t] = u
    }
    return o
  }
}
function Ef(t, e, n) {
  return function (i, s) {
    var o = Dn(i)
    ;((i = parseFloat(i)), o && (i /= 100))
    var u
    if (isFinite(i)) {
      var c = s[n]()
      o || (i > 0 && i < 1) ? (u = c[t] + s[e] * i) : (u = c[t] + i)
    }
    var h = et()
    return ((h[t] = u || 0), h)
  }
}
function _b(t, e, n) {
  return function (i, s) {
    var o
    i === 'middle'
      ? (o = s[e] / 2)
      : i === n
        ? (o = s[e])
        : isFinite(i)
          ? (o = i > -1 && i < 1 ? -s[e] * i : -i)
          : Dn(i)
            ? (o = (s[e] * parseFloat(i)) / 100)
            : (o = 0)
    var u = et()
    return ((u[t] = -(s[t] + o)), u)
  }
}
function Gx(t, e) {
  var n = 'joint-shape',
    i = e && e.resetOffset
  return function (s, o, u) {
    var c = Ie(u),
      h = c.data(n)
    if (!h || h.value !== s) {
      var p = t(s)
      ;((h = { value: s, shape: p, shapeBBox: p.bbox() }), c.data(n, h))
    }
    var y = h.shape.clone(),
      v = h.shapeBBox.clone(),
      C = v.origin(),
      w = o.origin()
    ;((v.x = w.x), (v.y = w.y))
    var N = o.maxRectScaleToFit(v, w),
      T = v.width === 0 || o.width === 0 ? 1 : N.sx,
      z = v.height === 0 || o.height === 0 ? 1 : N.sy
    return (y.scale(T, z, C), i && y.translate(-C.x, -C.y), y)
  }
}
function Bb(t) {
  function e(i) {
    return new Jt(yt.normalizePathData(i))
  }
  var n = Gx(e, t)
  return function (i, s, o) {
    var u = n(i, s, o)
    return { d: u.serialize() }
  }
}
function jb(t) {
  var e = Gx(qe, t)
  return function (n, i, s) {
    var o = e(n, i, s)
    return { points: o.serialize() }
  }
}
function Df(t, e) {
  var n = new et(1, 0)
  return function (i) {
    var s,
      o,
      u = this[t](i)
    return (
      u
        ? ((o = e.rotate ? u.vector().vectorAngle(n) : 0), (s = u.start))
        : ((s = this.path.start), (o = 0)),
      o === 0
        ? { transform: 'translate(' + s.x + ',' + s.y + ')' }
        : { transform: 'translate(' + s.x + ',' + s.y + ') rotate(' + o + ')' }
    )
  }
}
function Pb(t) {
  return function (n, i, s) {
    const o = yt(s)
    o.attr(t) !== n && o.attr(t, n)
  }
}
function Ko(t, e, n) {
  return n.text !== void 0
}
function wu() {
  return this.model.isLink()
}
function qg(t) {
  var e = {},
    n = t.stroke
  typeof n == 'string' && ((e.stroke = n), (e.fill = n))
  var i = t.strokeOpacity
  return (
    i === void 0 && (i = t['stroke-opacity']),
    i === void 0 && (i = t.opacity),
    i !== void 0 && ((e['stroke-opacity'] = i), (e['fill-opacity'] = i)),
    e
  )
}
function Gb(t) {
  const { paper: e } = this
  return `url(#${t.type === 'pattern' ? e.definePattern(t) : e.defineGradient(t)})`
}
const he = {
  xlinkShow: { set: 'xlink:show' },
  xlinkRole: { set: 'xlink:role' },
  xlinkType: { set: 'xlink:type' },
  xlinkArcrole: { set: 'xlink:arcrole' },
  xlinkTitle: { set: 'xlink:title' },
  xlinkActuate: { set: 'xlink:actuate' },
  xmlSpace: { set: 'xml:space' },
  xmlBase: { set: 'xml:base' },
  xmlLang: { set: 'xml:lang' },
  preserveAspectRatio: { set: 'preserveAspectRatio' },
  requiredExtension: { set: 'requiredExtension' },
  requiredFeatures: { set: 'requiredFeatures' },
  systemLanguage: { set: 'systemLanguage' },
  externalResourcesRequired: { set: 'externalResourceRequired' },
  href: { set: Pb('href') },
  xlinkHref: { set: Pb('xlink:href') },
  filter: {
    qualify: hn,
    set: function (t) {
      return 'url(#' + this.paper.defineFilter(t) + ')'
    },
  },
  fill: { qualify: hn, set: Gb },
  stroke: { qualify: hn, set: Gb },
  sourceMarker: {
    qualify: hn,
    set: function (t, e, n, i) {
      return ((t = Kt(qg(i), t)), { 'marker-start': 'url(#' + this.paper.defineMarker(t) + ')' })
    },
  },
  targetMarker: {
    qualify: hn,
    set: function (t, e, n, i) {
      return (
        (t = Kt(qg(i), { transform: 'rotate(180)' }, t)),
        { 'marker-end': 'url(#' + this.paper.defineMarker(t) + ')' }
      )
    },
  },
  vertexMarker: {
    qualify: hn,
    set: function (t, e, n, i) {
      return ((t = Kt(qg(i), t)), { 'marker-mid': 'url(#' + this.paper.defineMarker(t) + ')' })
    },
  },
  text: {
    qualify: function (t, e, n) {
      return !n.textWrap || !hn(n.textWrap)
    },
    set: function (t, e, n, i) {
      const s = Ie(n),
        o = 'joint-text',
        u = s.data(o),
        { lineHeight: c, annotations: h, textVerticalAnchor: p, eol: y, displayEmpty: v } = i
      let C = i.textPath,
        w = i.x
      Gi(w) && (w = Zi(w, e))
      let N = i['font-size'] || i.fontSize
      Gi(N) && (N = Zi(N, e))
      const T = JSON.stringify([t, c, h, p, y, v, C, w, N])
      if (u === void 0 || u !== T) {
        if ((N && n.setAttribute('font-size', N), ze(C))) {
          const z = C.selector
          if (typeof z == 'string') {
            const [R] = this.findBySelector(z)
            R instanceof SVGPathElement && (C = Kt({ 'xlink:href': '#' + R.id }, C))
          }
        }
        ;(yt(n).text('' + t, {
          lineHeight: c,
          annotations: h,
          textPath: C,
          x: w,
          textVerticalAnchor: p,
          eol: y,
          displayEmpty: v,
        }),
          s.data(o, T))
      }
    },
  },
  textWrap: {
    qualify: hn,
    set: function (t, e, n, i) {
      var s = {},
        o = t.width || 0
      Dn(o)
        ? (s.width = (e.width * parseFloat(o)) / 100)
        : Gi(o)
          ? (s.width = Number(Zi(o, e)))
          : t.width === null
            ? (s.width = 1 / 0)
            : o <= 0
              ? (s.width = e.width + o)
              : (s.width = o)
      var u = t.height || 0
      Dn(u)
        ? (s.height = (e.height * parseFloat(u)) / 100)
        : Gi(u)
          ? (s.height = Number(Zi(u, e)))
          : t.height === null || (u <= 0 ? (s.height = e.height + u) : (s.height = u))
      var c,
        h = t.text
      if ((h === void 0 && (h = i.text), h !== void 0)) {
        const p = t.breakText || _m,
          y = i['font-size'] || i.fontSize
        c = p(
          '' + h,
          s,
          {
            'font-weight': i['font-weight'] || i.fontWeight,
            'font-size': Gi(y) ? Zi(y, e) : y,
            'font-family': i['font-family'] || i.fontFamily,
            lineHeight: i.lineHeight,
            'letter-spacing': 'letter-spacing' in i ? i['letter-spacing'] : i.letterSpacing,
          },
          {
            svgDocument: this.paper.svg,
            ellipsis: t.ellipsis,
            hyphen: t.hyphen,
            separator: t.separator,
            maxLineCount: t.maxLineCount,
            preserveSpaces: t.preserveSpaces,
          }
        )
      } else c = ''
      he.text.set.call(this, c, e, n, i)
    },
  },
  title: {
    qualify: function (t, e) {
      return e instanceof SVGElement
    },
    set: function (t, e, n) {
      var i = Ie(n),
        s = 'joint-title',
        o = i.data(s)
      if (o === void 0 || o !== t) {
        if ((i.data(s, t), n.tagName === 'title')) {
          n.textContent = t
          return
        }
        var u = n.firstElementChild
        if (u && u.tagName === 'title') u.textContent = t
        else {
          var c = document.createElementNS(n.namespaceURI, 'title')
          ;((c.textContent = t), n.insertBefore(c, u))
        }
      }
    },
  },
  lineHeight: { qualify: Ko },
  textVerticalAnchor: { qualify: Ko },
  textPath: { qualify: Ko },
  annotations: { qualify: Ko },
  eol: { qualify: Ko },
  displayEmpty: { qualify: Ko },
  port: {
    set: function (t) {
      return t === null || t.id === void 0 ? t : t.id
    },
  },
  style: {
    qualify: hn,
    set: function (t, e, n) {
      Ie(n).css(t)
    },
  },
  html: {
    set: function (t, e, n) {
      Ie(n).html(t + '')
    },
  },
  props: xE,
  ref: {},
  refX: { position: Ef('x', 'width', 'origin') },
  refY: { position: Ef('y', 'height', 'origin') },
  refDx: { position: Ef('x', 'width', 'corner') },
  refDy: { position: Ef('y', 'height', 'corner') },
  refWidth: { set: as('width', 'width') },
  refHeight: { set: as('height', 'height') },
  refRx: { set: as('rx', 'width') },
  refRy: { set: as('ry', 'height') },
  refRInscribed: {
    set: (function (t) {
      var e = as(t, 'width'),
        n = as(t, 'height')
      return function (i, s) {
        var o = s.height > s.width ? e : n
        return o(i, s)
      }
    })('r'),
  },
  refRCircumscribed: {
    set: function (t, e) {
      var n = Dn(t)
      ;((t = parseFloat(t)), n && (t /= 100))
      var i = Math.sqrt(e.height * e.height + e.width * e.width),
        s
      return (
        isFinite(t) && (n || (t >= 0 && t <= 1) ? (s = t * i) : (s = Math.max(t + i, 0))),
        { r: s }
      )
    },
  },
  refCx: { set: as('cx', 'width') },
  refCy: { set: as('cy', 'height') },
  xAlignment: { offset: _b('x', 'width', 'right') },
  yAlignment: { offset: _b('y', 'height', 'bottom') },
  resetOffset: {
    offset: function (t, e) {
      return t ? { x: -e.x, y: -e.y } : { x: 0, y: 0 }
    },
  },
  refDResetOffset: { set: Bb({ resetOffset: !0 }) },
  refDKeepOffset: { set: Bb({ resetOffset: !1 }) },
  refPointsResetOffset: { set: jb({ resetOffset: !0 }) },
  refPointsKeepOffset: { set: jb({ resetOffset: !1 }) },
  connection: {
    qualify: wu,
    set: function ({ stubs: t = 0 }) {
      let e
      if (isFinite(t) && t !== 0) {
        let n
        t < 0 ? (n = (this.getConnectionLength() + t) / 2) : (n = t)
        const i = this.getConnection(),
          s = this.getConnectionSubdivisions(),
          o = i.divideAtLength(n, { segmentSubdivisions: s }),
          u = i.divideAtLength(-n, { segmentSubdivisions: s })
        o && u && (e = `${o[0].serialize()} ${u[1].serialize()}`)
      }
      return { d: e || this.getSerializedConnection() }
    },
  },
  atConnectionLengthKeepGradient: { qualify: wu, set: Df('getTangentAtLength', { rotate: !0 }) },
  atConnectionLengthIgnoreGradient: { qualify: wu, set: Df('getTangentAtLength', { rotate: !1 }) },
  atConnectionRatioKeepGradient: { qualify: wu, set: Df('getTangentAtRatio', { rotate: !0 }) },
  atConnectionRatioIgnoreGradient: { qualify: wu, set: Df('getTangentAtRatio', { rotate: !1 }) },
}
he['xlink:href'] = he.xlinkHref
;['transform', 'd', 'points', 'cx', 'cy', 'x1', 'x2', 'y1', 'y2', 'x', 'y', 'dx', 'dy'].forEach(
  t => {
    he[t] = {
      qualify: Gi,
      set: function (n, i) {
        return { [t]: Zi(n, i) }
      },
    }
  }
)
;['width', 'height', 'r', 'rx', 'ry', 'font-size', 'stroke-width'].forEach(t => {
  he[t] = {
    qualify: Gi,
    set: function (n, i) {
      return { [t]: Math.max(0, Zi(n, i)) }
    },
  }
})
he.refR = he.refRInscribed
he.refD = he.refDResetOffset
he.refPoints = he.refPointsResetOffset
he.atConnectionLength = he.atConnectionLengthKeepGradient
he.atConnectionRatio = he.atConnectionRatioKeepGradient
he.fontSize = he['font-size']
he.strokeWidth = he['stroke-width']
he.refX2 = he.refX
he.refY2 = he.refY
he.refWidth2 = he.refWidth
he.refHeight2 = he.refHeight
he['ref-x'] = he.refX
he['ref-y'] = he.refY
he['ref-dy'] = he.refDy
he['ref-dx'] = he.refDx
he['ref-width'] = he.refWidth
he['ref-height'] = he.refHeight
he['x-alignment'] = he.xAlignment
he['y-alignment'] = he.yAlignment
const Pm = he,
  Er = En.Model.extend(
    {
      constructor: function (t, e) {
        var n,
          i = t || {}
        ;(typeof this.preinitialize == 'function' && this.preinitialize.apply(this, arguments),
          (this.cid = Sx('c')),
          (this.attributes = {}),
          e && e.collection && (this.collection = e.collection),
          e && e.parse && (i = this.parse(i, e) || {}),
          (n = dn(this, 'defaults')) && (i = An({}, n, i)),
          this.set(i, e),
          (this.changed = {}),
          this.initialize.apply(this, arguments))
      },
      translate: function (t, e, n) {
        throw new Error('Must define a translate() method.')
      },
      toJSON: function () {
        const e = dn(this.constructor.prototype, 'defaults').attrs || {},
          n = this.attributes.attrs,
          i = {}
        yi(n, function (o, u) {
          const c = e[u]
          yi(o, function (h, p) {
            ze(h) && !Array.isArray(h)
              ? yi(h, function (y, v) {
                  ;(!c || !c[p] || !qs(c[p][v], y)) &&
                    ((i[u] = i[u] || {}), ((i[u][p] || (i[u][p] = {}))[v] = y))
                })
              : (!c || !qs(c[p], h)) && ((i[u] = i[u] || {}), (i[u][p] = h))
          })
        })
        const s = ti(ba(this.attributes, 'attrs'))
        return ((s.attrs = i), s)
      },
      initialize: function (t) {
        const e = this.getIdAttribute()
        ;((!t || t[e] === void 0) && this.set(e, this.generateId(), { silent: !0 }),
          (this._transitionIds = {}),
          (this._scheduledTransitionIds = {}),
          this.processPorts(),
          this.on('change:attrs', this.processPorts, this))
      },
      getIdAttribute: function () {
        return this.idAttribute || 'id'
      },
      generateId: function () {
        return Ex()
      },
      processPorts: function () {
        var t = this.ports,
          e = {}
        yi(this.get('attrs'), function (o, u) {
          o &&
            o.port &&
            (o.port.id !== void 0 ? (e[o.port.id] = o.port) : (e[o.port] = { id: o.port }))
        })
        var n = {}
        if (
          (yi(t, function (o, u) {
            e[u] || (n[u] = !0)
          }),
          this.graph && !Hr(n))
        ) {
          var i = this.graph.getConnectedLinks(this, { inbound: !0 })
          i.forEach(function (o) {
            n[o.get('target').port] && o.remove()
          })
          var s = this.graph.getConnectedLinks(this, { outbound: !0 })
          s.forEach(function (o) {
            n[o.get('source').port] && o.remove()
          })
        }
        this.ports = e
      },
      remove: function (t = {}) {
        const { graph: e, collection: n } = this
        if (!e) return (n && n.remove(this, t), this)
        e.startBatch('remove')
        const i = this.getParentCell()
        i && i.unembed(this, t)
        const s = this.getEmbeddedCells()
        for (let o = 0, u = s.length; o < u; o++) {
          const c = s[o]
          c && c.remove(t)
        }
        return (this.trigger('remove', this, e.attributes.cells, t), e.stopBatch('remove'), this)
      },
      toFront: function (t) {
        var e = this.graph
        if (e) {
          t = mi(t || {}, { foregroundEmbeds: !0 })
          let n
          t.deep
            ? ((n = this.getEmbeddedCells({
                deep: !0,
                breadthFirst: t.breadthFirst !== !1,
                sortSiblings: t.foregroundEmbeds,
              })),
              n.unshift(this))
            : (n = [this])
          const i = t.foregroundEmbeds ? n : Hf(n, h => h.z())
          let o = e.maxZIndex() - n.length + 1
          const u = e.get('cells')
          let c = u.indexOf(i[0]) !== u.length - n.length
          ;(c ||
            (c = i.some(function (h, p) {
              return h.z() !== o + p
            })),
            c &&
              (this.startBatch('to-front'),
              (o = o + n.length),
              i.forEach(function (h, p) {
                h.set('z', o + p, t)
              }),
              this.stopBatch('to-front')))
        }
        return this
      },
      toBack: function (t) {
        var e = this.graph
        if (e) {
          t = mi(t || {}, { foregroundEmbeds: !0 })
          let i
          t.deep
            ? ((i = this.getEmbeddedCells({
                deep: !0,
                breadthFirst: t.breadthFirst !== !1,
                sortSiblings: t.foregroundEmbeds,
              })),
              i.unshift(this))
            : (i = [this])
          const s = t.foregroundEmbeds ? i : Hf(i, c => c.z())
          let o = e.minZIndex()
          var n = e.get('cells')
          let u = n.indexOf(s[0]) !== 0
          ;(u ||
            (u = s.some(function (c, h) {
              return c.z() !== o + h
            })),
            u &&
              (this.startBatch('to-back'),
              (o -= i.length),
              s.forEach(function (c, h) {
                c.set('z', o + h, t)
              }),
              this.stopBatch('to-back')))
        }
        return this
      },
      parent: function (t, e) {
        return t === void 0 ? this.get('parent') : this.set('parent', t, e)
      },
      embed: function (t, e) {
        const n = Array.isArray(t) ? t : [t]
        if (!this.canEmbed(n)) throw new Error('Recursive embedding not allowed.')
        if (n.some(i => i.isEmbedded() && this.id !== i.parent()))
          throw new Error('Embedding of already embedded cells is not allowed.')
        return (this._embedCells(n, e), this)
      },
      unembed: function (t, e) {
        const n = Array.isArray(t) ? t : [t]
        return (this._unembedCells(n, e), this)
      },
      canEmbed: function (t) {
        return (Array.isArray(t) ? t : [t]).every(n => this !== n && !this.isEmbeddedIn(n))
      },
      _embedCells: function (t, e) {
        const n = 'embed'
        this.startBatch(n)
        const i = Kt([], this.get('embeds'))
        ;(t.forEach(s => {
          ;(i[s.isLink() ? 'unshift' : 'push'](s.id), s.parent(this.id, e))
        }),
          this.set('embeds', cs(i), e),
          this.stopBatch(n))
      },
      _unembedCells: function (t, e) {
        const n = 'unembed'
        ;(this.startBatch(n),
          t.forEach(i => i.unset('parent', e)),
          this.set('embeds', eh(this.get('embeds'), ...t.map(i => i.id)), e),
          this.stopBatch(n))
      },
      getParentCell: function () {
        var t = this.parent(),
          e = this.graph
        return (t && e && e.getCell(t)) || null
      },
      getAncestors: function () {
        var t = []
        if (!this.graph) return t
        for (var e = this.getParentCell(); e; ) (t.push(e), (e = e.getParentCell()))
        return t
      },
      getEmbeddedCells: function (t) {
        if (((t = t || {}), !this.graph)) return []
        if (t.deep)
          return t.breadthFirst
            ? this._getEmbeddedCellsBfs(t.sortSiblings)
            : this._getEmbeddedCellsDfs(t.sortSiblings)
        const e = this.get('embeds')
        if (Hr(e)) return []
        let n = e.map(this.graph.getCell, this.graph)
        return (t.sortSiblings && (n = Hf(n, i => i.z())), n)
      },
      _getEmbeddedCellsBfs: function (t) {
        const e = [],
          n = []
        for (n.push(this); n.length > 0; ) {
          const i = n.shift()
          e.push(i)
          const s = i.getEmbeddedCells({ sortSiblings: t })
          n.push(...s)
        }
        return (e.shift(), e)
      },
      _getEmbeddedCellsDfs: function (t) {
        const e = [],
          n = []
        for (n.push(this); n.length > 0; ) {
          const i = n.pop()
          e.push(i)
          const s = i.getEmbeddedCells({ sortSiblings: t })
          for (let o = s.length - 1; o >= 0; --o) n.push(s[o])
        }
        return (e.shift(), e)
      },
      isEmbeddedIn: function (t, e) {
        var n = Wn(t) ? t : t.id,
          i = this.parent()
        if (((e = Kt({ deep: !0 }, e)), this.graph && e.deep)) {
          for (; i; ) {
            if (i === n) return !0
            i = this.graph.getCell(i).parent()
          }
          return !1
        } else return i === n
      },
      isEmbedded: function () {
        return !!this.parent()
      },
      clone: function (t) {
        if (((t = t || {}), t.deep))
          return xe(jm([this].concat(this.getEmbeddedCells({ deep: !0 }))))
        var e = En.Model.prototype.clone.apply(this, arguments)
        return (
          e.set(this.getIdAttribute(), this.generateId()),
          e.unset('embeds'),
          e.unset('parent'),
          e
        )
      },
      prop: function (t, e, n) {
        var i = '/',
          s = Wn(t)
        if (s || Array.isArray(t))
          if (arguments.length > 1) {
            var o, u
            s ? ((o = t), (u = o.split('/'))) : ((o = t.join(i)), (u = t.slice()))
            var c = u[0],
              h = u.length
            const H = n || {}
            ;((H.propertyPath = o),
              (H.propertyValue = e),
              (H.propertyPathArray = u),
              'rewrite' in H || (H.rewrite = !1))
            for (var p = {}, y = p, v = c, C = 1; C < h; C++) {
              var w = u[C],
                N = Number.isFinite(s ? Number(w) : w)
              ;((y = y[v] = N ? [] : {}), (v = w))
            }
            p = ih(p, u, e, '/')
            var T = An({}, this.attributes)
            H.rewrite && yv(T, o, '/')
            var z = An(T, p)
            return this.set(c, z[c], H)
          } else return vl(this.attributes, t, i)
        const R = e || {}
        ;((R.propertyPath = null),
          (R.propertyValue = t),
          (R.propertyPathArray = []),
          'rewrite' in R || (R.rewrite = !1))
        const B = {}
        for (const H in t) {
          const { changedValue: Z } = An(
            {},
            { changedValue: this.attributes[H] },
            { changedValue: t[H] }
          )
          B[H] = Z
        }
        return this.set(B, R)
      },
      removeProp: function (t, e) {
        e = e || {}
        var n = Array.isArray(t) ? t : t.split('/'),
          i = n[0]
        if ((i === 'attrs' && (e.dirty = !0), n.length === 1)) return this.unset(t, e)
        var s = n.slice(1),
          o = this.get(i)
        return o == null ? this : ((o = ti(o)), yv(o, s, '/'), this.set(i, o, e))
      },
      attr: function (t, e, n) {
        var i = Array.from(arguments)
        return i.length === 0
          ? this.get('attrs')
          : (Array.isArray(t)
              ? (i[0] = ['attrs'].concat(t))
              : Wn(t)
                ? (i[0] = 'attrs/' + t)
                : (i[0] = { attrs: t }),
            this.prop.apply(this, i))
      },
      removeAttr: function (t, e) {
        return Array.isArray(t)
          ? this.removeProp(['attrs'].concat(t))
          : this.removeProp('attrs/' + t, e)
      },
      transition: function (t, e, n, i) {
        i = i || '/'
        var s = { duration: 100, delay: 10, timingFunction: jx.linear, valueFunction: Bm.number }
        n = Kt(s, n)
        var o = 0,
          u,
          c = function (v) {
            var C, w, N
            ;((o = o || v),
              (v -= o),
              (w = v / n.duration),
              w < 1
                ? (this._transitionIds[t] = C = rh(c))
                : ((w = 1), delete this._transitionIds[t]),
              (N = u(n.timingFunction(w))),
              (n.transitionId = C),
              this.prop(t, N, n),
              C || this.trigger('transition:end', this, t))
          }.bind(this)
        const { _scheduledTransitionIds: h } = this
        let p
        var y = v => {
          ;(h[t] && ((h[t] = eh(h[t], p)), h[t].length === 0 && delete h[t]),
            this.stopPendingTransitions(t, i),
            (u = n.valueFunction(vl(this.attributes, t, i), e)),
            (this._transitionIds[t] = rh(v)),
            this.trigger('transition:start', this, t))
        }
        return ((p = setTimeout(y, n.delay, c)), h[t] || (h[t] = []), h[t].push(p), p)
      },
      getTransitions: function () {
        return nh(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds))
      },
      stopScheduledTransitions: function (t, e = '/') {
        const { _scheduledTransitionIds: n = {} } = this
        let i = Object.keys(n)
        if (t) {
          const s = t.split(e)
          i = i.filter(o => qs(s, o.split(e).slice(0, s.length)))
        }
        return (
          i.forEach(s => {
            ;(n[s].forEach(u => clearTimeout(u)), delete n[s])
          }),
          this
        )
      },
      stopPendingTransitions(t, e = '/') {
        const { _transitionIds: n = {} } = this
        let i = Object.keys(n)
        if (t) {
          const s = t.split(e)
          i = i.filter(o => qs(s, o.split(e).slice(0, s.length)))
        }
        i.forEach(s => {
          const o = n[s]
          ;(ah(o), delete n[s], this.trigger('transition:end', this, s))
        })
      },
      stopTransitions: function (t, e = '/') {
        return (this.stopScheduledTransitions(t, e), this.stopPendingTransitions(t, e), this)
      },
      addTo: function (t, e) {
        return (t.addCell(this, e), this)
      },
      findView: function (t) {
        return t.findViewByModel(this)
      },
      isElement: function () {
        return !1
      },
      isLink: function () {
        return !1
      },
      startBatch: function (t, e) {
        return (this.graph && this.graph.startBatch(t, Kt({}, e, { cell: this })), this)
      },
      stopBatch: function (t, e) {
        return (this.graph && this.graph.stopBatch(t, Kt({}, e, { cell: this })), this)
      },
      getChangeFlag: function (t) {
        var e = 0
        if (!t) return e
        for (var n in t) !t.hasOwnProperty(n) || !this.hasChanged(n) || (e |= t[n])
        return e
      },
      angle: function () {
        return 0
      },
      position: function () {
        return new et(0, 0)
      },
      z: function () {
        return this.get('z') || 0
      },
      getPointFromConnectedLink: function () {
        return new et()
      },
      getBBox: function () {
        return new Pt(0, 0, 0, 0)
      },
      getPointRotatedAroundCenter(t, e, n) {
        const i = new et(e, n)
        return (t && i.rotate(this.getBBox().center(), t), i)
      },
      getAbsolutePointFromRelative(t, e) {
        return this.getPointRotatedAroundCenter(-this.angle(), this.position().offset(t, e))
      },
      getRelativePointFromAbsolute(t, e) {
        return this.getPointRotatedAroundCenter(this.angle(), t, e).difference(this.position())
      },
    },
    {
      getAttributeDefinition: function (t) {
        var e = this.attributes,
          n = Pm
        return (e && e[t]) || n[t]
      },
      define: function (t, e, n, i) {
        n = Kt({ defaults: _h({ type: t }, e, this.prototype.defaults) }, n)
        var s = this.extend(n, i)
        return (typeof joint < 'u' && Mr(joint, 'shapes') && ih(joint.shapes, t, s, '.'), s)
      },
    }
  ),
  Zx = function (t, e, n) {
    if (Wn(n)) {
      if (!sh[n]) throw new Error('Unknown wrapper: "' + n + '"')
      n = sh[n]
    }
    if (!Ze(n)) throw new Error('Wrapper must be a function.')
    xe(e).forEach(function (i) {
      t[i] = n(t[i])
    })
  },
  sh = {
    cells: function (t) {
      return function () {
        var e = Array.from(arguments),
          n = e.length,
          i = (n > 0 && e[0]) || [],
          s = (n > 1 && e[n - 1]) || {}
        return (
          Array.isArray(i) ||
            (s instanceof Er ? (i = e) : i instanceof Er && (e.length > 1 && e.pop(), (i = e))),
          s instanceof Er && (s = {}),
          t.call(this, i, s)
        )
      }
    },
  }
function SE(t, ...e) {
  const n = []
  return (
    t.forEach((s, o) => {
      ;(n.push(s), o in e && n.push(e[o]))
    }),
    NE(n.join(''))
  )
}
function NE(t) {
  const e = new DOMParser(),
    n = `<svg>${t.trim()}</svg>`
  if (
    e.parseFromString(n.replace(/@/g, ''), 'application/xml').getElementsByTagName('parsererror')[0]
  )
    throw new Error('Invalid SVG markup')
  const o = e.parseFromString(n, 'text/html').querySelector('svg')
  return TE(o)
}
function Ux(t) {
  const e = {},
    { tagName: n, attributes: i, namespaceURI: s, style: o, childNodes: u } = t
  ;((e.namespaceURI = s), (e.tagName = s === yt.namespace.xhtml ? n.toLowerCase() : n))
  const c = {}
  for (var h = o.length; h--; ) {
    var p = o[h]
    c[p] = o.getPropertyValue(p)
  }
  e.style = c
  const y = i.getNamedItem('@selector')
  y && ((e.selector = y.value), i.removeNamedItem('@selector'))
  const v = i.getNamedItem('@group-selector')
  if (v) {
    const T = v.value.split(',')
    ;((e.groupSelector = T.map(z => z.trim())), i.removeNamedItem('@group-selector'))
  }
  const C = i.getNamedItem('class')
  C && (e.className = C.value)
  const w = []
  ;(u.forEach(T => {
    switch (T.nodeType) {
      case Node.TEXT_NODE: {
        const z = T.data.replace(/\s\s+/g, ' ')
        z.trim() && w.push(z)
        break
      }
      case Node.ELEMENT_NODE: {
        w.push(Ux(T))
        break
      }
    }
  }),
    w.length && (e.children = w))
  const N = {}
  return (
    Array.from(i).forEach(T => {
      const { name: z, value: R } = T
      N[z] = R
    }),
    Object.keys(N).length > 0 && (e.attributes = N),
    e
  )
}
function TE(t) {
  const e = []
  return (
    Array.from(t.children).forEach(n => {
      e.push(Ux(n))
    }),
    e
  )
}
const fn = {
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom',
  LEFT: 'left',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right',
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  CENTER: 'center',
}
function Gm(t, e) {
  const n = new Pt(t)
  switch (e) {
    case void 0:
      throw new Error('Position required')
    case fn.LEFT:
    case 'leftMiddle':
      return n.leftMiddle()
    case fn.RIGHT:
    case 'rightMiddle':
      return n.rightMiddle()
    case fn.TOP:
    case 'topMiddle':
      return n.topMiddle()
    case fn.BOTTOM:
    case 'bottomMiddle':
      return n.bottomMiddle()
    case fn.TOP_LEFT:
    case 'topLeft':
    case 'origin':
      return n.topLeft()
    case fn.TOP_RIGHT:
    case 'topRight':
      return n.topRight()
    case fn.BOTTOM_LEFT:
    case 'bottomLeft':
      return n.bottomLeft()
    case fn.BOTTOM_RIGHT:
    case 'bottomRight':
    case 'corner':
      return n.bottomRight()
    case fn.CENTER:
      return n.center()
    default:
      throw new Error(`Unknown position: ${e}`)
  }
}
const ME = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      addClassNamePrefix: ir,
      assign: Kt,
      bindAll: hE,
      breakText: _m,
      camelCase: xx,
      cancelFrame: ah,
      cap: Lx,
      clone: Bi,
      cloneCells: jm,
      cloneDeep: ti,
      dataUriToBlob: _x,
      debounce: bx,
      deepMixin: cE,
      deepSupplement: yx,
      defaults: mi,
      defaultsDeep: _h,
      difference: km,
      downloadBlob: kx,
      downloadDataUri: vE,
      filter: Px,
      flattenDeep: Cx,
      flattenObject: Mx,
      forIn: yi,
      format: bE,
      getByPath: vl,
      getElementBBox: yE,
      getRectPoint: Gm,
      groupBy: Ix,
      guid: Qs,
      has: Mr,
      hashCode: Su,
      imageToDataUri: mE,
      interpolate: Bm,
      intersection: fE,
      invoke: Ui,
      invokeProperty: Ax,
      isBoolean: px,
      isEmpty: Hr,
      isEqual: qs,
      isFunction: Ze,
      isNumber: ai,
      isObject: ze,
      isPercentage: Dn,
      isPlainObject: hn,
      isString: Wn,
      merge: An,
      mixin: vx,
      nextFrame: rh,
      noop: Ws,
      normalizeEvent: Ge,
      normalizeSides: Ia,
      normalizeWheel: Ox,
      omit: ba,
      parseCssNumeric: zx,
      parseDOMJSON: Gu,
      pick: wx,
      removeClassNamePrefix: Nx,
      result: dn,
      sanitizeHTML: Rx,
      setAttributesBySelector: AE,
      setByPath: ih,
      shapePerimeterConnectionPoint: gE,
      sortBy: Hf,
      sortElements: Bx,
      sortedIndex: Rm,
      supplement: mx,
      svg: SE,
      template: $n,
      timing: jx,
      toArray: xe,
      toKebabCase: Dx,
      toggleFullScreen: IE,
      union: nh,
      uniq: cs,
      uniqueId: Sx,
      unsetByPath: yv,
      uuid: Ex,
      without: eh,
      wrapWith: Zx,
      wrappers: sh,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function Yx(t, e, n) {
  var i = t.toJSON()
  return ((i.angle = e || 0), mi({}, n, i))
}
function ec(t, e, n, i) {
  return t.map(
    function (s, o, u) {
      var c = this.pointAt((o + 0.5) / u.length)
      return ((s.dx || s.dy) && c.offset(s.dx || 0, s.dy || 0), Yx(c.round(), 0, Zm(i, s)))
    },
    Ks(e, n)
  )
}
function Hx(t, e, n, i) {
  var s = e.center(),
    o = e.width / e.height,
    u = e.topMiddle(),
    c = li.fromRect(e)
  return t.map(function (h, p, y) {
    var v = n + i(p, y.length),
      C = u.clone().rotate(s, -v).scale(o, 1, s),
      w = h.compensateRotation ? -c.tangentTheta(C) : 0
    return (
      (h.dx || h.dy) && C.offset(h.dx || 0, h.dy || 0),
      h.dr && C.move(s, h.dr),
      Yx(C.round(), w, Zm(e, h))
    )
  })
}
function Zm(t, e) {
  let { x: n, y: i, angle: s } = e
  return (
    Dn(n) ? (n = (parseFloat(n) / 100) * t.width) : Gi(n) && (n = Number(Zi(n, t))),
    Dn(i) ? (i = (parseFloat(i) / 100) * t.height) : Gi(i) && (i = Number(Zi(i, t))),
    { x: n, y: i, angle: s }
  )
}
function Av(t, e) {
  const { x: n, y: i } = Zm(t, e)
  return new et(n || 0, i || 0)
}
const EE = function (t, e) {
    return t.map(n => {
      const i = Av(e, n).round().toJSON()
      return ((i.angle = n.angle || 0), i)
    })
  },
  DE = function (t, e, n) {
    return n.fn(t, e, n)
  },
  OE = function (t, e, n) {
    var i = Av(e, n.start || e.origin()),
      s = Av(e, n.end || e.corner())
    return ec(t, i, s, e)
  },
  LE = function (t, e, n) {
    return ec(t, e.origin(), e.bottomLeft(), e)
  },
  zE = function (t, e, n) {
    return ec(t, e.topRight(), e.corner(), e)
  },
  RE = function (t, e, n) {
    return ec(t, e.origin(), e.topRight(), e)
  },
  kE = function (t, e, n) {
    return ec(t, e.bottomLeft(), e.corner(), e)
  },
  _E = function (t, e, n) {
    var i = n.startAngle || 0,
      s = n.step || 360 / t.length
    return Hx(t, e, i, function (o) {
      return o * s
    })
  },
  BE = function (t, e, n) {
    var i = n.startAngle || 0,
      s = n.step || 20
    return Hx(t, e, i, function (o, u) {
      return (o + 0.5 - u / 2) * s
    })
  },
  Vx = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        absolute: EE,
        bottom: kE,
        ellipse: BE,
        ellipseSpread: _E,
        fn: DE,
        left: LE,
        line: OE,
        right: zE,
        top: RE,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function ps(t, e) {
  return _h({}, t, e, { x: 0, y: 0, angle: 0, attrs: {} })
}
function Xx(t) {
  var e = t.center(),
    n = e.theta(t.origin()),
    i = e.theta(t.bottomLeft()),
    s = e.theta(t.corner()),
    o = e.theta(t.topRight())
  return [n, o, s, i]
}
function Wx(t, e, n, i) {
  i = mi({}, i, { offset: 15 })
  var s = e.center().theta(t),
    o,
    u,
    c,
    h,
    p = i.offset,
    y = 0
  const [v, C, w, N] = Xx(e)
  s < C || s > w
    ? ((c = '.3em'), (o = p), (u = 0), (h = 'start'))
    : s < v
      ? ((o = 0),
        (u = -p),
        n ? ((y = -90), (h = 'start'), (c = '.3em')) : ((h = 'middle'), (c = '0')))
      : s < N
        ? ((c = '.3em'), (o = -p), (u = 0), (h = 'end'))
        : ((o = 0),
          (u = p),
          n ? ((y = 90), (h = 'start'), (c = '.3em')) : ((h = 'middle'), (c = '.6em')))
  var T = Math.round
  return ps(i, { x: T(o), y: T(u), angle: y, attrs: { labelText: { y: c, textAnchor: h } } })
}
function Fx(t, e, n, i) {
  i = mi({}, i, { offset: 15 })
  var s = e.center().theta(t),
    o,
    u,
    c,
    h,
    p = i.offset,
    y = 0
  const [v, C, w, N] = Xx(e)
  s < C || s > w
    ? ((c = '.3em'), (o = -p), (u = 0), (h = 'end'))
    : s < v
      ? ((o = 0),
        (u = p),
        n ? ((y = 90), (h = 'start'), (c = '.3em')) : ((h = 'middle'), (c = '.6em')))
      : s < N
        ? ((c = '.3em'), (o = p), (u = 0), (h = 'start'))
        : ((o = 0),
          (u = -p),
          n ? ((y = -90), (h = 'start'), (c = '.3em')) : ((h = 'middle'), (c = '0')))
  var T = Math.round
  return ps(i, { x: T(o), y: T(u), angle: y, attrs: { labelText: { y: c, textAnchor: h } } })
}
function Jx(t, e, n) {
  n = mi({}, n, { offset: 20 })
  var i = Ff(0, 0),
    s = -t.theta(i),
    o = s,
    u = t.clone().move(i, n.offset).difference(t).round(),
    c = '.3em',
    h
  ;(s + 90) % 180 === 0
    ? ((h = e ? 'end' : 'middle'), !e && s === -270 && (c = '0em'))
    : s > -270 && s < -90
      ? ((h = 'start'), (o = s - 180))
      : (h = 'end')
  var p = Math.round
  return ps(n, {
    x: p(u.x),
    y: p(u.y),
    angle: e ? o : 0,
    attrs: { labelText: { y: c, textAnchor: h } },
  })
}
const jE = function (t, e, n) {
    return ps(n)
  },
  PE = function (t, e, n) {
    return ps(n, { x: -15, attrs: { labelText: { y: '.3em', textAnchor: 'end' } } })
  },
  GE = function (t, e, n) {
    return ps(n, { x: 15, attrs: { labelText: { y: '.3em', textAnchor: 'start' } } })
  },
  ZE = function (t, e, n) {
    return ps(n, { y: -15, attrs: { labelText: { y: '0', textAnchor: 'middle' } } })
  },
  UE = function (t, e, n) {
    return ps(n, { y: 15, attrs: { labelText: { y: '.6em', textAnchor: 'middle' } } })
  },
  YE = function (t, e, n) {
    return Wx(t, e, !0, n)
  },
  HE = function (t, e, n) {
    return Wx(t, e, !1, n)
  },
  VE = function (t, e, n) {
    return Fx(t, e, !0, n)
  },
  XE = function (t, e, n) {
    return Fx(t, e, !1, n)
  },
  WE = function (t, e, n) {
    return Jx(t.difference(e.center()), !1, n)
  },
  FE = function (t, e, n) {
    return Jx(t.difference(e.center()), !0, n)
  },
  qx = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        bottom: UE,
        inside: XE,
        insideOriented: VE,
        left: PE,
        manual: jE,
        outside: HE,
        outsideOriented: YE,
        radial: WE,
        radialOriented: FE,
        right: GE,
        top: ZE,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  wn = Er.extend(
    {
      markup: [
        '<path class="connection" stroke="black" d="M 0 0 0 0"/>',
        '<path class="marker-source" fill="black" stroke="black" d="M 0 0 0 0"/>',
        '<path class="marker-target" fill="black" stroke="black" d="M 0 0 0 0"/>',
        '<path class="connection-wrap" d="M 0 0 0 0"/>',
        '<g class="labels"/>',
        '<g class="marker-vertices"/>',
        '<g class="marker-arrowheads"/>',
        '<g class="link-tools"/>',
      ].join(''),
      toolMarkup: [
        '<g class="link-tool">',
        '<g class="tool-remove" event="remove">',
        '<circle r="11" />',
        '<path transform="scale(.8) translate(-16, -16)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z" />',
        '<title>Remove link.</title>',
        '</g>',
        '<g class="tool-options" event="link:options">',
        '<circle r="11" transform="translate(25)"/>',
        '<path fill="white" transform="scale(.55) translate(29, -16)" d="M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z"/>',
        '<title>Link options.</title>',
        '</g>',
        '</g>',
      ].join(''),
      doubleToolMarkup: void 0,
      vertexMarkup: [
        '<g class="marker-vertex-group" transform="translate(<%= x %>, <%= y %>)">',
        '<circle class="marker-vertex" idx="<%= idx %>" r="10" />',
        '<path class="marker-vertex-remove-area" idx="<%= idx %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>',
        '<path class="marker-vertex-remove" idx="<%= idx %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">',
        '<title>Remove vertex.</title>',
        '</path>',
        '</g>',
      ].join(''),
      arrowheadMarkup: [
        '<g class="marker-arrowhead-group marker-arrowhead-group-<%= end %>">',
        '<path class="marker-arrowhead" end="<%= end %>" d="M 26 0 L 0 13 L 26 26 z" />',
        '</g>',
      ].join(''),
      defaultLabel: void 0,
      labelMarkup: void 0,
      _builtins: {
        defaultLabel: {
          markup: [
            { tagName: 'rect', selector: 'rect' },
            { tagName: 'text', selector: 'text' },
          ],
          attrs: {
            text: {
              fill: '#000000',
              fontSize: 14,
              textAnchor: 'middle',
              yAlignment: 'middle',
              pointerEvents: 'none',
            },
            rect: {
              ref: 'text',
              fill: '#ffffff',
              rx: 3,
              ry: 3,
              refWidth: 1,
              refHeight: 1,
              refX: 0,
              refY: 0,
            },
          },
          position: { distance: 0.5 },
        },
      },
      defaults: { type: 'link', source: {}, target: {} },
      isLink: function () {
        return !0
      },
      disconnect: function (t) {
        return this.set({ source: { x: 0, y: 0 }, target: { x: 0, y: 0 } }, t)
      },
      source: function (t, e, n) {
        if (t === void 0) return Bi(this.get('source'))
        var i,
          s,
          o = t instanceof Er
        if (o) return ((i = Bi(e) || {}), (i.id = t.id), (s = n), this.set('source', i, s))
        var u = !hn(t)
        return u
          ? ((i = Bi(e) || {}), (i.x = t.x), (i.y = t.y), (s = n), this.set('source', i, s))
          : ((i = t), (s = e), this.set('source', i, s))
      },
      target: function (t, e, n) {
        if (t === void 0) return Bi(this.get('target'))
        var i,
          s,
          o = t instanceof Er
        if (o) return ((i = Bi(e) || {}), (i.id = t.id), (s = n), this.set('target', i, s))
        var u = !hn(t)
        return u
          ? ((i = Bi(e) || {}), (i.x = t.x), (i.y = t.y), (s = n), this.set('target', i, s))
          : ((i = t), (s = e), this.set('target', i, s))
      },
      router: function (t, e, n) {
        if (t === void 0) {
          var i = this.get('router')
          return i
            ? typeof i == 'object'
              ? Bi(i)
              : i
            : this.get('manhattan')
              ? { name: 'orthogonal' }
              : null
        }
        var s = typeof t == 'object' || typeof t == 'function',
          o = s ? t : { name: t, args: e },
          u = s ? e : n
        return this.set('router', o, u)
      },
      connector: function (t, e, n) {
        if (t === void 0) {
          var i = this.get('connector')
          return i
            ? typeof i == 'object'
              ? Bi(i)
              : i
            : this.get('smooth')
              ? { name: 'smooth' }
              : null
        }
        var s = typeof t == 'object' || typeof t == 'function',
          o = s ? t : { name: t, args: e },
          u = s ? e : n
        return this.set('connector', o, u)
      },
      label: function (t, e, n) {
        var i = this.labels()
        return (
          (t = isFinite(t) && t !== null ? t | 0 : 0),
          t < 0 && (t = i.length + t),
          arguments.length <= 1 ? this.prop(['labels', t]) : this.prop(['labels', t], e, n)
        )
      },
      labels: function (t, e) {
        return arguments.length === 0
          ? ((t = this.get('labels')), Array.isArray(t) ? t.slice() : [])
          : (Array.isArray(t) || (t = []), this.set('labels', t, e))
      },
      hasLabels: function () {
        const { labels: t } = this.attributes
        return Array.isArray(t) && t.length > 0
      },
      insertLabel: function (t, e, n) {
        if (!e) throw new Error('dia.Link: no label provided')
        var i = this.labels(),
          s = i.length
        return (
          (t = isFinite(t) && t !== null ? t | 0 : s),
          t < 0 && (t = s + t + 1),
          i.splice(t, 0, e),
          this.labels(i, n)
        )
      },
      appendLabel: function (t, e) {
        return this.insertLabel(-1, t, e)
      },
      removeLabel: function (t, e) {
        var n = this.labels()
        return ((t = isFinite(t) && t !== null ? t | 0 : -1), n.splice(t, 1), this.labels(n, e))
      },
      vertex: function (t, e, n) {
        var i = this.vertices()
        if (
          ((t = isFinite(t) && t !== null ? t | 0 : 0),
          t < 0 && (t = i.length + t),
          arguments.length <= 1)
        )
          return this.prop(['vertices', t])
        var s = this._normalizeVertex(e)
        return this.prop(['vertices', t], s, n)
      },
      vertices: function (t, e) {
        if (arguments.length === 0)
          return ((t = this.get('vertices')), Array.isArray(t) ? t.slice() : [])
        Array.isArray(t) || (t = [])
        for (var n = [], i = 0; i < t.length; i++) {
          var s = t[i],
            o = this._normalizeVertex(s)
          n.push(o)
        }
        return this.set('vertices', n, e)
      },
      insertVertex: function (t, e, n) {
        if (!e) throw new Error('dia.Link: no vertex provided')
        var i = this.vertices(),
          s = i.length
        ;((t = isFinite(t) && t !== null ? t | 0 : s), t < 0 && (t = s + t + 1))
        var o = this._normalizeVertex(e)
        return (i.splice(t, 0, o), this.vertices(i, n))
      },
      removeVertex: function (t, e) {
        var n = this.vertices()
        return ((t = isFinite(t) && t !== null ? t | 0 : -1), n.splice(t, 1), this.vertices(n, e))
      },
      _normalizeVertex: function (t) {
        var e = !hn(t)
        return e ? { x: t.x, y: t.y } : t
      },
      translate: function (t, e, n) {
        return (
          (n = n || {}),
          (n.translateBy = n.translateBy || this.id),
          (n.tx = t),
          (n.ty = e),
          this.applyToPoints(function (i) {
            return { x: (i.x || 0) + t, y: (i.y || 0) + e }
          }, n)
        )
      },
      scale: function (t, e, n, i) {
        return this.applyToPoints(function (s) {
          return et(s).scale(t, e, n).toJSON()
        }, i)
      },
      applyToPoints: function (t, e) {
        if (!Ze(t))
          throw new TypeError(
            'dia.Link: applyToPoints expects its first parameter to be a function.'
          )
        var n = {},
          { source: i, target: s } = this.attributes
        ;(i.id || (n.source = t(i)), s.id || (n.target = t(s)))
        var o = this.vertices()
        return (o.length > 0 && (n.vertices = o.map(t)), this.set(n, e))
      },
      getSourcePoint: function () {
        var t = this.getSourceCell()
        return t ? t.getPointFromConnectedLink(this, 'source') : new et(this.source())
      },
      getTargetPoint: function () {
        var t = this.getTargetCell()
        return t ? t.getPointFromConnectedLink(this, 'target') : new et(this.target())
      },
      getPointFromConnectedLink: function () {
        return this.getPolyline().pointAt(0.5)
      },
      getPolyline: function () {
        const t = [this.getSourcePoint(), ...this.vertices().map(et), this.getTargetPoint()]
        return new qe(t)
      },
      getBBox: function () {
        return this.getPolyline().bbox()
      },
      reparent: function (t) {
        var e
        if (this.graph) {
          var n = this.getSourceElement(),
            i = this.getTargetElement(),
            s = this.getParentCell()
          ;(n &&
            i &&
            (n === i || n.isEmbeddedIn(i)
              ? (e = i)
              : i.isEmbeddedIn(n)
                ? (e = n)
                : (e = this.graph.getCommonAncestor(n, i))),
            s && (!e || e.id !== s.id) && s.unembed(this, t),
            e && e.embed(this, t))
        }
        return e
      },
      hasLoop: function (t) {
        t = t || {}
        var { source: e, target: n } = this.attributes,
          i = e.id,
          s = n.id
        if (!i || !s) return !1
        var o = i === s
        if (!o && t.deep && this.graph) {
          var u = this.getSourceCell(),
            c = this.getTargetCell()
          o = u.isEmbeddedIn(c) || c.isEmbeddedIn(u)
        }
        return o
      },
      getSourceCell: function () {
        const { graph: t, attributes: e } = this
        var n = e.source
        return (n && n.id && t && t.getCell(n.id)) || null
      },
      getSourceElement: function () {
        var t = this,
          e = {}
        do {
          if (e[t.id]) return null
          ;((e[t.id] = !0), (t = t.getSourceCell()))
        } while (t && t.isLink())
        return t
      },
      getTargetCell: function () {
        const { graph: t, attributes: e } = this
        var n = e.target
        return (n && n.id && t && t.getCell(n.id)) || null
      },
      getTargetElement: function () {
        var t = this,
          e = {}
        do {
          if (e[t.id]) return null
          ;((e[t.id] = !0), (t = t.getTargetCell()))
        } while (t && t.isLink())
        return t
      },
      getRelationshipAncestor: function () {
        var t
        if (this.graph) {
          var e = [this, this.getSourceElement(), this.getTargetElement()].filter(function (n) {
            return !!n
          })
          t = this.graph.getCommonAncestor.apply(this.graph, e)
        }
        return t || null
      },
      isRelationshipEmbeddedIn: function (t) {
        var e = Wn(t) || ai(t) ? t : t.id,
          n = this.getRelationshipAncestor()
        return !!n && (n.id === e || n.isEmbeddedIn(e))
      },
      _getDefaultLabel: function () {
        var t = this.get('defaultLabel') || this.defaultLabel || {},
          e = {}
        return (
          (e.markup = t.markup || this.get('labelMarkup') || this.labelMarkup),
          (e.position = t.position),
          (e.attrs = t.attrs),
          (e.size = t.size),
          e
        )
      },
    },
    {
      endsEqual: function (t, e) {
        var n = t.port === e.port || (!t.port && !e.port)
        return t.id === e.id && n
      },
    }
  )
var Qx = function (t) {
  var e = ti(t) || {}
  ;((this.ports = []),
    (this.groups = {}),
    (this.portLayoutNamespace = Vx),
    (this.portLabelLayoutNamespace = qx),
    this._init(e))
}
Qx.prototype = {
  getPorts: function () {
    return this.ports
  },
  getGroup: function (t) {
    return this.groups[t] || {}
  },
  getPortsByGroup: function (t) {
    return this.ports.filter(function (e) {
      return e.group === t
    })
  },
  getGroupPortsMetrics: function (t, e) {
    var n = this.getGroup(t),
      i = this.getPortsByGroup(t),
      s = n.position || {},
      o = s.name,
      u = this.portLayoutNamespace
    u[o] || (o = 'left')
    var c = s.args || {},
      h = i.map(function (v) {
        return v && v.position && v.position.args
      }),
      p = u[o](h, e, c),
      y = { ports: i, result: [] }
    return (
      xe(p).reduce(
        function (v, C, w) {
          var N = v.ports[w]
          return (
            v.result.push({
              portId: N.id,
              portTransformation: C,
              labelTransformation: this._getPortLabelLayout(N, et(C), e),
              portAttrs: N.attrs,
              portSize: N.size,
              labelSize: N.label.size,
            }),
            v
          )
        }.bind(this),
        y
      ),
      y.result
    )
  },
  _getPortLabelLayout: function (t, e, n) {
    var i = this.portLabelLayoutNamespace,
      s = t.label.position.name || 'left'
    return i[s] ? i[s](e, n, t.label.position.args) : null
  },
  _init: function (t) {
    if (ze(t.groups))
      for (var e = Object.keys(t.groups), n = 0, i = e.length; n < i; n++) {
        var s = e[n]
        this.groups[s] = this._evaluateGroup(t.groups[s])
      }
    for (var o = xe(t.items), u = 0, c = o.length; u < c; u++)
      this.ports.push(this._evaluatePort(o[u]))
  },
  _evaluateGroup: function (t) {
    return An(t, { position: this._getPosition(t.position, !0), label: this._getLabel(t, !0) })
  },
  _evaluatePort: function (t) {
    var e = Kt({}, t),
      n = this.getGroup(t.group)
    return (
      (e.markup = e.markup || n.markup),
      (e.attrs = An({}, n.attrs, e.attrs)),
      (e.position = this._createPositionNode(n, e)),
      (e.label = An({}, n.label, this._getLabel(e))),
      (e.z = this._getZIndex(n, e)),
      (e.size = Kt({}, n.size, e.size)),
      e
    )
  },
  _getZIndex: function (t, e) {
    return ai(e.z) ? e.z : ai(t.z) || t.z === 'auto' ? t.z : 'auto'
  },
  _createPositionNode: function (t, e) {
    return An({ name: 'left', args: {} }, t.position, { args: e.args })
  },
  _getPosition: function (t, e) {
    var n = {},
      i
    Ze(t)
      ? ((i = 'fn'), (n.fn = t))
      : Wn(t)
        ? (i = t)
        : t === void 0
          ? (i = e ? 'left' : null)
          : Array.isArray(t)
            ? ((i = 'absolute'), (n.x = t[0]), (n.y = t[1]))
            : ze(t) && ((i = t.name), Kt(n, t.args))
    var s = { args: n }
    return (i && (s.name = i), s)
  },
  _getLabel: function (t, e) {
    var n = t.label || {},
      i = n
    return ((i.position = this._getPosition(n.position, e)), i)
  },
}
const JE = {
    _initializePorts: function () {
      ;(this._createPortData(),
        this.on(
          'change:ports',
          function () {
            ;(this._processRemovedPort(), this._createPortData())
          },
          this
        ))
    },
    _processRemovedPort: function () {
      var t = this.get('ports') || {},
        e = {}
      xe(t.items).forEach(function (c) {
        e[c.id] = !0
      })
      var n = this.previous('ports') || {},
        i = {}
      xe(n.items).forEach(function (c) {
        e[c.id] || (i[c.id] = !0)
      })
      var s = this.graph
      if (s && !Hr(i)) {
        var o = s.getConnectedLinks(this, { inbound: !0 })
        o.forEach(function (c) {
          i[c.get('target').port] && c.remove()
        })
        var u = s.getConnectedLinks(this, { outbound: !0 })
        u.forEach(function (c) {
          i[c.get('source').port] && c.remove()
        })
      }
    },
    hasPorts: function () {
      var t = this.prop('ports/items')
      return Array.isArray(t) && t.length > 0
    },
    hasPort: function (t) {
      return this.getPortIndex(t) !== -1
    },
    getPorts: function () {
      return ti(this.prop('ports/items')) || []
    },
    getGroupPorts: function (t) {
      const e = xe(this.prop(['ports', 'items'])).filter(n => n.group === t)
      return ti(e)
    },
    getPort: function (t) {
      return ti(
        xe(this.prop('ports/items')).find(function (e) {
          return e.id && e.id === t
        })
      )
    },
    getPortsPositions: function (t) {
      var e = this._portSettingsData.getGroupPortsMetrics(t, Pt(this.size()))
      return e.reduce(function (n, i) {
        var s = i.portTransformation
        return ((n[i.portId] = { x: s.x, y: s.y, angle: s.angle }), n)
      }, {})
    },
    getPortIndex: function (t) {
      var e = ze(t) ? t.id : t
      return this._isValidPortId(e)
        ? xe(this.prop('ports/items')).findIndex(function (n) {
            return n.id === e
          })
        : -1
    },
    addPort: function (t, e) {
      if (!ze(t) || Array.isArray(t)) throw new Error('Element: addPort requires an object.')
      var n = Kt([], this.prop('ports/items'))
      return (n.push(t), this.prop('ports/items', n, e), this)
    },
    insertPort: function (t, e, n) {
      const i = typeof t == 'number' ? t : this.getPortIndex(t)
      if (!ze(e) || Array.isArray(e)) throw new Error('dia.Element: insertPort requires an object.')
      const s = Kt([], this.prop('ports/items'))
      return (s.splice(i, 0, e), this.prop('ports/items', s, n), this)
    },
    portProp: function (t, e, n, i) {
      var s = this.getPortIndex(t)
      if (s === -1) throw new Error('Element: unable to find port with id ' + t)
      var o = Array.prototype.slice.call(arguments, 1)
      return (
        Array.isArray(e)
          ? (o[0] = ['ports', 'items', s].concat(e))
          : Wn(e)
            ? (o[0] = ['ports/items/', s, '/', e].join(''))
            : ((o = ['ports/items/' + s]), hn(e) && (o.push(e), o.push(n))),
        this.prop.apply(this, o)
      )
    },
    _validatePorts: function () {
      var t = this.get('ports') || {},
        e = []
      t = t || {}
      var n = xe(t.items)
      return (
        n.forEach(function (i) {
          ;(typeof i != 'object' && e.push('Element: invalid port ', i),
            this._isValidPortId(i.id) || (i.id = this.generatePortId()))
        }, this),
        cs(n, 'id').length !== n.length && e.push('Element: found id duplicities in ports.'),
        e
      )
    },
    generatePortId: function () {
      return this.generateId()
    },
    _isValidPortId: function (t) {
      return t != null && !ze(t)
    },
    addPorts: function (t, e) {
      return (
        t.length && this.prop('ports/items', Kt([], this.prop('ports/items')).concat(t), e),
        this
      )
    },
    removePort: function (t, e) {
      const n = e || {},
        i = this.getPortIndex(t)
      if (i !== -1) {
        const s = Kt([], this.prop(['ports', 'items']))
        ;(s.splice(i, 1),
          (n.rewrite = !0),
          this.startBatch('port-remove'),
          this.prop(['ports', 'items'], s, n),
          this.stopBatch('port-remove'))
      }
      return this
    },
    removePorts: function (t, e) {
      let n, i
      if (Array.isArray(t)) {
        if (((n = e || {}), t.length === 0)) return this.this
        i = Kt([], this.prop(['ports', 'items'])).filter(function (o) {
          return !t.some(function (u) {
            const c = ze(u) ? u.id : u
            return o.id === c
          })
        })
      } else ((n = t || {}), (i = []))
      return (
        this.startBatch('port-remove'),
        (n.rewrite = !0),
        this.prop(['ports', 'items'], i, n),
        this.stopBatch('port-remove'),
        this
      )
    },
    _createPortData: function () {
      var t = this._validatePorts()
      if (t.length > 0) throw (this.set('ports', this.previous('ports')), new Error(t.join(' ')))
      var e
      ;(this._portSettingsData && (e = this._portSettingsData.getPorts()),
        (this._portSettingsData = new Qx(this.get('ports'))))
      var n = this._portSettingsData.getPorts()
      if (e) {
        var i = n.filter(function (o) {
            if (
              !e.find(function (u) {
                return u.id === o.id
              })
            )
              return o
          }),
          s = e.filter(function (o) {
            if (
              !n.find(function (u) {
                return u.id === o.id
              })
            )
              return o
          })
        ;(s.length > 0 && this.trigger('ports:remove', this, s),
          i.length > 0 && this.trigger('ports:add', this, i))
      }
    },
  },
  qE = {
    portContainerMarkup: 'g',
    portMarkup: [
      {
        tagName: 'circle',
        selector: 'circle',
        attributes: { r: 10, fill: '#FFFFFF', stroke: '#000000' },
      },
    ],
    portLabelMarkup: [{ tagName: 'text', selector: 'text', attributes: { fill: '#000000' } }],
    _portElementsCache: null,
    _initializePorts: function () {
      this._cleanPortsCache()
    },
    _refreshPorts: function () {
      ;(this._removePorts(), this._cleanPortsCache(), this._renderPorts())
    },
    _cleanPortsCache: function () {
      this._portElementsCache = {}
    },
    _renderPorts: function () {
      for (
        var t = [], e = this._getContainerElement(), n = 0, i = e.node.childNodes.length;
        n < i;
        n++
      )
        t.push(e.node.childNodes[n])
      var s = Ix(this.model._portSettingsData.getPorts(), 'z'),
        o = 'auto'
      xe(s[o]).forEach(function (y) {
        var v = this._getPortElement(y)
        ;(e.append(v), t.push(v))
      }, this)
      for (var u = Object.keys(s), c = 0; c < u.length; c++) {
        var h = u[c]
        if (h !== o) {
          var p = parseInt(h, 10)
          this._appendPorts(s[h], p, t)
        }
      }
      this._updatePorts()
    },
    _getContainerElement: function () {
      return this.rotatableNode || this.vel
    },
    _appendPorts: function (t, e, n) {
      var i = this._getContainerElement(),
        s = xe(t).map(this._getPortElement, this)
      n[e] || e < 0 ? yt(n[Math.max(e, 0)]).before(s) : i.append(s)
    },
    _getPortElement: function (t) {
      return this._portElementsCache[t.id]
        ? this._portElementsCache[t.id].portElement
        : this._createPortElement(t)
    },
    findPortNode: function (t, e) {
      const n = this._portElementsCache[t]
      if (!n) return null
      if (!e) return n.portContentElement.node
      const i = n.portElement.node,
        s = n.portSelectors,
        [o = null] = this.findBySelector(e, i, s)
      return o
    },
    _updatePorts: function () {
      this._updatePortGroup(void 0)
      var t = Object.keys(this.model._portSettingsData.groups)
      t.forEach(this._updatePortGroup, this)
    },
    _removePorts: function () {
      Ui(this._portElementsCache, 'portElement.remove')
    },
    _createPortElement: function (t) {
      let e, n, i, s
      var o = yt(this.portContainerMarkup).addClass('joint-port'),
        u = this._getPortMarkup(t)
      if (Array.isArray(u)) {
        var c = this.parseDOMJSON(u, o.node),
          h = c.fragment
        ;(h.childNodes.length > 1 ? (e = yt('g').append(h)) : (e = yt(h.firstChild)),
          (s = c.selectors))
      } else ((e = yt(u)), Array.isArray(e) && (e = yt('g').append(e)))
      if (!e) throw new Error('ElementView: Invalid port markup.')
      e.attr({ port: t.id, 'port-group': t.group })
      const p = this._getPortLabelMarkup(t.label)
      if (Array.isArray(p)) {
        const { fragment: T, selectors: z } = this.parseDOMJSON(p, o.node),
          R = T.childNodes.length
        R > 0 && ((i = z), (n = R === 1 ? yt(T.firstChild) : yt('g').append(T)))
      } else ((n = yt(p)), Array.isArray(n) && (n = yt('g').append(n)))
      var y
      if (s && i) {
        for (var v in i)
          if (s[v] && v !== this.selector)
            throw new Error('ElementView: selectors within port must be unique.')
        y = Kt({}, s, i)
      } else y = s || i || {}
      const C = 'portRoot',
        w = 'labelRoot',
        N = 'labelText'
      if ((C in y || (y[C] = e.node), n)) {
        const T = n.node
        if ((w in y || (y[w] = T), !(N in y))) {
          const z = n.tagName() === 'TEXT' ? T : Array.from(T.querySelectorAll('text'))
          ;((y[N] = z), i || (i = {}), (i[N] = z))
        }
      }
      return (
        o.append(e.addClass('joint-port-body')),
        n && o.append(n.addClass('joint-port-label')),
        (this._portElementsCache[t.id] = {
          portElement: o,
          portLabelElement: n,
          portSelectors: y,
          portLabelSelectors: i,
          portContentElement: e,
          portContentSelectors: s,
        }),
        o
      )
    },
    _updatePortGroup: function (t) {
      for (
        var e = Pt(this.model.size()),
          n = this.model._portSettingsData.getGroupPortsMetrics(t, e),
          i = 0,
          s = n.length;
        i < s;
        i++
      ) {
        var o = n[i],
          u = o.portId,
          c = this._portElementsCache[u] || {},
          h = o.portTransformation,
          p = o.labelTransformation
        ;(p &&
          c.portLabelElement &&
          (this.updateDOMSubtreeAttributes(c.portLabelElement.node, p.attrs, {
            rootBBox: new Pt(o.labelSize),
            selectors: c.portLabelSelectors,
          }),
          this.applyPortTransform(c.portLabelElement, p, -h.angle || 0)),
          this.updateDOMSubtreeAttributes(c.portElement.node, o.portAttrs, {
            rootBBox: new Pt(o.portSize),
            selectors: c.portSelectors,
          }),
          this.applyPortTransform(c.portElement, h))
      }
    },
    applyPortTransform: function (t, e, n) {
      var i = yt
        .createSVGMatrix()
        .rotate(n || 0)
        .translate(e.x || 0, e.y || 0)
        .rotate(e.angle || 0)
      t.transform(i, { absolute: !0 })
    },
    _getPortMarkup: function (t) {
      return t.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup
    },
    _getPortLabelMarkup: function (t) {
      return (
        t.markup ||
        this.model.get('portLabelMarkup') ||
        this.model.portLabelMarkup ||
        this.portLabelMarkup
      )
    },
  },
  an = Er.extend({
    defaults: { position: { x: 0, y: 0 }, size: { width: 1, height: 1 }, angle: 0 },
    initialize: function () {
      ;(this._initializePorts(), Er.prototype.initialize.apply(this, arguments))
    },
    _initializePorts: function () {},
    _refreshPorts: function () {},
    isElement: function () {
      return !0
    },
    position: function (t, e, n) {
      const i = ai(e)
      n = (i ? n : t) || {}
      const { parentRelative: s, deep: o, restrictedArea: u } = n
      let c
      if (s) {
        if (!this.graph) throw new Error('Element must be part of a graph.')
        const h = this.getParentCell()
        h && !h.isLink() && (c = h.get('position'))
      }
      if (i) {
        if ((c && ((t += c.x), (e += c.y)), o || u)) {
          const { x: h, y: p } = this.get('position')
          this.translate(t - h, e - p, n)
        } else this.set('position', { x: t, y: e }, n)
        return this
      } else {
        const h = et(this.get('position'))
        return s ? h.difference(c) : h
      }
    },
    translate: function (t, e, n) {
      if (((t = t || 0), (e = e || 0), t === 0 && e === 0)) return this
      ;((n = n || {}), (n.translateBy = n.translateBy || this.id))
      var i = this.get('position') || { x: 0, y: 0 },
        s = n.restrictedArea
      if (s && n.translateBy === this.id)
        if (typeof s == 'function') {
          var o = s.call(this, i.x + t, i.y + e, n)
          ;((t = o.x - i.x), (e = o.y - i.y))
        } else {
          var u = this.getBBox({ deep: !0 }),
            c = i.x - u.x,
            h = i.y - u.y,
            p = Math.max(s.x + c, Math.min(s.x + s.width + c - u.width, i.x + t)),
            y = Math.max(s.y + h, Math.min(s.y + s.height + h - u.height, i.y + e))
          ;((t = p - i.x), (e = y - i.y))
        }
      var v = { x: i.x + t, y: i.y + e }
      return (
        (n.tx = t),
        (n.ty = e),
        n.transition
          ? (ze(n.transition) || (n.transition = {}),
            this.transition('position', v, Kt({}, n.transition, { valueFunction: Bm.object })),
            Ui(this.getEmbeddedCells(), 'translate', t, e, n))
          : (this.startBatch('translate', n),
            this.set('position', v, n),
            Ui(this.getEmbeddedCells(), 'translate', t, e, n),
            this.stopBatch('translate', n)),
        this
      )
    },
    size: function (t, e, n) {
      var i = this.get('size')
      return t === void 0
        ? { width: i.width, height: i.height }
        : (ze(t) &&
            ((n = e),
            (e = ai(t.height) ? t.height : i.height),
            (t = ai(t.width) ? t.width : i.width)),
          this.resize(t, e, n))
    },
    resize: function (t, e, n) {
      if (((n = n || {}), this.startBatch('resize', n), n.direction)) {
        var i = this.get('size')
        switch (n.direction) {
          case 'left':
          case 'right':
            e = i.height
            break
          case 'top':
          case 'bottom':
            t = i.width
            break
        }
        var s = Dr(this.get('angle') || 0),
          o = this.getBBox(),
          u
        if (s) {
          var c = {
            'top-right': 0,
            right: 0,
            'top-left': 1,
            top: 1,
            'bottom-left': 2,
            left: 2,
            'bottom-right': 3,
            bottom: 3,
          }[n.direction]
          n.absolute && ((c += Math.floor((s + 45) / 90)), (c %= 4))
          var h = o[['bottomLeft', 'corner', 'topRight', 'origin'][c]](),
            p = et(h).rotate(o.center(), -s),
            y = Math.sqrt(t * t + e * e) / 2,
            v = (c * Math.PI) / 2
          ;((v += Math.atan(c % 2 == 0 ? e / t : t / e)), (v -= Ai(s)))
          var C = et.fromPolar(y, v, p)
          u = et(C).offset(t / -2, e / -2)
        } else
          switch (((u = o.topLeft()), n.direction)) {
            case 'top':
            case 'top-right':
              u.offset(0, o.height - e)
              break
            case 'left':
            case 'bottom-left':
              u.offset(o.width - t, 0)
              break
            case 'top-left':
              u.offset(o.width - t, o.height - e)
              break
          }
        ;(this.set('size', { width: t, height: e }, n), this.position(u.x, u.y, n))
      } else this.set('size', { width: t, height: e }, n)
      return (this.stopBatch('resize', n), this)
    },
    scale: function (t, e, n, i) {
      var s = this.getBBox().scale(t, e, n)
      return (
        this.startBatch('scale', i),
        this.position(s.x, s.y, i),
        this.resize(s.width, s.height, i),
        this.stopBatch('scale'),
        this
      )
    },
    fitEmbeds: function (t) {
      return this.fitToChildren(t)
    },
    fitToChildren: function (t = {}) {
      const { graph: e } = this
      if (!e) throw new Error('Element must be part of a graph.')
      const n = this.getEmbeddedCells().filter(i => i.isElement())
      return n.length === 0
        ? this
        : (this.startBatch('fit-embeds', t),
          t.deep && Ui(n, 'fitToChildren', t),
          this._fitToElements(Object.assign({ elements: n }, t)),
          this.stopBatch('fit-embeds'),
          this)
    },
    fitParent: function (t = {}) {
      const { graph: e } = this
      if (!e) throw new Error('Element must be part of a graph.')
      if (t.deep && t.terminator && (t.terminator === this || t.terminator === this.id)) return this
      const n = this.getParentCell()
      if (!n || !n.isElement()) return this
      const i = n.getEmbeddedCells().filter(s => s.isElement())
      return i.length === 0
        ? this
        : (this.startBatch('fit-parent', t),
          n._fitToElements(Object.assign({ elements: i }, t)),
          t.deep && n.fitParent(t),
          this.stopBatch('fit-parent'),
          this)
    },
    _fitToElements: function (t = {}) {
      const e = this.graph.getCellsBBox(t.elements)
      if (!e) return
      const { expandOnly: n, shrinkOnly: i } = t
      if (n && i) return
      let { x: s, y: o, width: u, height: c } = e
      const { left: h, right: p, top: y, bottom: v } = Ia(t.padding)
      ;((s -= h), (o -= y), (u += h + p), (c += v + y))
      let C = new Pt(s, o, u, c)
      if (n) C = this.getBBox().union(C)
      else if (i) {
        const w = this.getBBox().intersect(C)
        if (!w) return
        C = w
      }
      this.set({ position: { x: C.x, y: C.y }, size: { width: C.width, height: C.height } }, t)
    },
    rotate: function (t, e, n, i) {
      if (n) {
        var s = this.getBBox().center(),
          o = this.get('size'),
          u = this.get('position')
        s.rotate(n, this.get('angle') - t)
        var c = s.x - o.width / 2 - u.x,
          h = s.y - o.height / 2 - u.y
        ;(this.startBatch('rotate', { angle: t, absolute: e, origin: n }),
          this.position(u.x + c, u.y + h, i),
          this.rotate(t, e, null, i),
          this.stopBatch('rotate'))
      } else this.set('angle', e ? t : (this.get('angle') + t) % 360, i)
      return this
    },
    angle: function () {
      return Dr(this.get('angle') || 0)
    },
    getBBox: function (t = {}) {
      const { graph: e, attributes: n } = this,
        { deep: i, rotate: s } = t
      if (i && e) {
        const v = this.getEmbeddedCells({ deep: !0, breadthFirst: !0 })
        return (v.push(this), e.getCellsBBox(v, t))
      }
      const {
          angle: o = 0,
          position: { x: u, y: c },
          size: { width: h, height: p },
        } = n,
        y = new Pt(u, c, h, p)
      return (s && y.rotateAroundCenter(o), y)
    },
    getPointFromConnectedLink: function (t, e) {
      var n = this.getBBox(),
        i = n.center(),
        s = t.get(e)
      if (!s) return i
      var o = s.port
      if (!o || !this.hasPort(o)) return i
      var u = this.portProp(o, ['group']),
        c = this.getPortsPositions(u),
        h = new et(c[o]).offset(n.origin()),
        p = this.angle()
      return (p && h.rotate(i, -p), h)
    },
  })
Kt(an.prototype, JE)
const QE = En.Collection.extend({
    initialize: function (t, e) {
      ;(e.cellNamespace
        ? (this.cellNamespace = e.cellNamespace)
        : (this.cellNamespace = typeof joint < 'u' && Mr(joint, 'shapes') ? joint.shapes : null),
        (this.graph = e.graph))
    },
    model: function (t, e) {
      var n = e.collection,
        i = n.cellNamespace,
        s = t.type === 'link' ? wn : vl(i, t.type, '.') || an,
        o = new s(t, e)
      return (e.dry || (o.graph = n.graph), o)
    },
    comparator: function (t) {
      return t.get('z') || 0
    },
  }),
  Vr = En.Model.extend(
    {
      initialize: function (t, e) {
        e = e || {}
        var n = new QE([], { model: e.cellModel, cellNamespace: e.cellNamespace, graph: this })
        ;(En.Model.prototype.set.call(this, 'cells', n),
          n.on('all', this.trigger, this),
          this.on('change:z', this._sortOnChangeZ, this),
          (this._out = {}),
          (this._in = {}),
          (this._nodes = {}),
          (this._edges = {}),
          (this._batches = {}),
          n.on('add', this._restructureOnAdd, this),
          n.on('remove', this._restructureOnRemove, this),
          n.on('reset', this._restructureOnReset, this),
          n.on('change:source', this._restructureOnChangeSource, this),
          n.on('change:target', this._restructureOnChangeTarget, this),
          n.on('remove', this._removeCell, this))
      },
      _sortOnChangeZ: function () {
        this.get('cells').sort()
      },
      _restructureOnAdd: function (t) {
        if (t.isLink()) {
          this._edges[t.id] = !0
          var { source: e, target: n } = t.attributes
          ;(e.id && ((this._out[e.id] || (this._out[e.id] = {}))[t.id] = !0),
            n.id && ((this._in[n.id] || (this._in[n.id] = {}))[t.id] = !0))
        } else this._nodes[t.id] = !0
      },
      _restructureOnRemove: function (t) {
        if (t.isLink()) {
          delete this._edges[t.id]
          var { source: e, target: n } = t.attributes
          ;(e.id && this._out[e.id] && this._out[e.id][t.id] && delete this._out[e.id][t.id],
            n.id && this._in[n.id] && this._in[n.id][t.id] && delete this._in[n.id][t.id])
        } else delete this._nodes[t.id]
      },
      _restructureOnReset: function (t) {
        ;((t = t.models),
          (this._out = {}),
          (this._in = {}),
          (this._nodes = {}),
          (this._edges = {}),
          t.forEach(this._restructureOnAdd, this))
      },
      _restructureOnChangeSource: function (t) {
        var e = t.previous('source')
        e.id && this._out[e.id] && delete this._out[e.id][t.id]
        var n = t.attributes.source
        n.id && ((this._out[n.id] || (this._out[n.id] = {}))[t.id] = !0)
      },
      _restructureOnChangeTarget: function (t) {
        var e = t.previous('target')
        e.id && this._in[e.id] && delete this._in[e.id][t.id]
        var n = t.get('target')
        n.id && ((this._in[n.id] || (this._in[n.id] = {}))[t.id] = !0)
      },
      getOutboundEdges: function (t) {
        return (this._out && this._out[t]) || {}
      },
      getInboundEdges: function (t) {
        return (this._in && this._in[t]) || {}
      },
      toJSON: function () {
        var t = En.Model.prototype.toJSON.apply(this, arguments)
        return ((t.cells = this.get('cells').toJSON()), t)
      },
      fromJSON: function (t, e) {
        if (!t.cells) throw new Error('Graph JSON must contain cells array.')
        return this.set(t, e)
      },
      set: function (t, e, n) {
        var i
        return (
          typeof t == 'object' ? ((i = t), (n = e)) : ((i = {})[t] = e),
          i.hasOwnProperty('cells') && (this.resetCells(i.cells, n), (i = ba(i, 'cells'))),
          En.Model.prototype.set.call(this, i, n)
        )
      },
      clear: function (t) {
        t = Kt({}, t, { clear: !0 })
        var e = this.get('cells')
        if (e.length === 0) return this
        this.startBatch('clear', t)
        var n = e.sortBy(function (i) {
          return i.isLink() ? 1 : 2
        })
        do n.shift().remove(t)
        while (n.length > 0)
        return (this.stopBatch('clear'), this)
      },
      _prepareCell: function (t, e) {
        var n
        if (
          (t instanceof En.Model
            ? ((n = t.attributes), !t.graph && (!e || !e.dry) && (t.graph = this))
            : (n = t),
          !Wn(n.type))
        )
          throw new TypeError('dia.Graph: cell type must be a string.')
        return t
      },
      minZIndex: function () {
        var t = this.get('cells').first()
        return (t && t.get('z')) || 0
      },
      maxZIndex: function () {
        var t = this.get('cells').last()
        return (t && t.get('z')) || 0
      },
      addCell: function (t, e) {
        return Array.isArray(t)
          ? this.addCells(t, e)
          : (t instanceof En.Model
              ? t.has('z') || t.set('z', this.maxZIndex() + 1)
              : t.z === void 0 && (t.z = this.maxZIndex() + 1),
            this.get('cells').add(this._prepareCell(t, e), e || {}),
            this)
      },
      addCells: function (t, e) {
        return t.length === 0
          ? this
          : ((t = Cx(t)),
            (e.maxPosition = e.position = t.length - 1),
            this.startBatch('add', e),
            t.forEach(function (n) {
              ;(this.addCell(n, e), e.position--)
            }, this),
            this.stopBatch('add', e),
            this)
      },
      resetCells: function (t, e) {
        var n = xe(t).map(function (i) {
          return this._prepareCell(i, e)
        }, this)
        return (this.get('cells').reset(n, e), this)
      },
      removeCells: function (t, e) {
        return (
          t.length && (this.startBatch('remove'), Ui(t, 'remove', e), this.stopBatch('remove')),
          this
        )
      },
      _removeCell: function (t, e, n) {
        ;((n = n || {}),
          n.clear || (n.disconnectLinks ? this.disconnectLinks(t, n) : this.removeLinks(t, n)),
          this.get('cells').remove(t, { silent: !0 }),
          t.graph === this && (t.graph = null))
      },
      getCell: function (t) {
        return this.get('cells').get(t)
      },
      getCells: function () {
        return this.get('cells').toArray()
      },
      getElements: function () {
        return this.get('cells').filter(t => t.isElement())
      },
      getLinks: function () {
        return this.get('cells').filter(t => t.isLink())
      },
      getFirstCell: function () {
        return this.get('cells').first()
      },
      getLastCell: function () {
        return this.get('cells').last()
      },
      getConnectedLinks: function (t, e) {
        e = e || {}
        var n = e.indirect,
          i = e.inbound,
          s = e.outbound
        i === void 0 && s === void 0 && (i = s = !0)
        var o = [],
          u = {}
        ;(s && c(this, t), i && h(this, t))
        function c(v, C) {
          if (
            (yi(
              v.getOutboundEdges(C.id),
              function (N, T) {
                if (!u[T]) {
                  var z = v.getCell(T)
                  ;(o.push(z), (u[T] = !0), n && (i && h(v, z), s && c(v, z)))
                }
              }.bind(v)
            ),
            n && C.isLink())
          ) {
            var w = C.getTargetCell()
            w && w.isLink() && (u[w.id] || (o.push(w), c(v, w)))
          }
        }
        function h(v, C) {
          if (
            (yi(
              v.getInboundEdges(C.id),
              function (N, T) {
                if (!u[T]) {
                  var z = v.getCell(T)
                  ;(o.push(z), (u[T] = !0), n && (i && h(v, z), s && c(v, z)))
                }
              }.bind(v)
            ),
            n && C.isLink())
          ) {
            var w = C.getSourceCell()
            w && w.isLink() && (u[w.id] || (o.push(w), h(v, w)))
          }
        }
        if (e.deep) {
          var p = t.getEmbeddedCells({ deep: !0 }),
            y = {}
          ;(p.forEach(function (v) {
            v.isElement() && (y[v.id] = !0)
          }),
            p.forEach(function (v) {
              v.isLink() ||
                (s &&
                  yi(
                    this.getOutboundEdges(v.id),
                    function (C, w) {
                      if (!u[w]) {
                        var N = this.getCell(w),
                          { source: T, target: z } = N.attributes,
                          R = T.id,
                          B = z.id
                        if (!e.includeEnclosed && R && y[R] && B && y[B]) return
                        ;(o.push(this.getCell(w)), (u[w] = !0))
                      }
                    }.bind(this)
                  ),
                i &&
                  yi(
                    this.getInboundEdges(v.id),
                    function (C, w) {
                      if (!u[w]) {
                        var N = this.getCell(w),
                          { source: T, target: z } = N.attributes,
                          R = T.id,
                          B = z.id
                        if (!e.includeEnclosed && R && y[R] && B && y[B]) return
                        ;(o.push(this.getCell(w)), (u[w] = !0))
                      }
                    }.bind(this)
                  ))
            }, this))
        }
        return o
      },
      getNeighbors: function (t, e) {
        e || (e = {})
        var n = e.inbound,
          i = e.outbound
        n === void 0 && i === void 0 && (n = i = !0)
        var s = this.getConnectedLinks(t, e).reduce(
          function (c, h) {
            var { source: p, target: y } = h.attributes,
              v = h.hasLoop(e)
            if (n && Mr(p, 'id') && !c[p.id]) {
              var C = this.getCell(p.id)
              C.isElement() &&
                (v || (C && C !== t && (!e.deep || !C.isEmbeddedIn(t)))) &&
                (c[p.id] = C)
            }
            if (i && Mr(y, 'id') && !c[y.id]) {
              var w = this.getCell(y.id)
              w.isElement() &&
                (v || (w && w !== t && (!e.deep || !w.isEmbeddedIn(t)))) &&
                (c[y.id] = w)
            }
            return c
          }.bind(this),
          {}
        )
        if (t.isLink()) {
          if (n) {
            var o = t.getSourceCell()
            o && o.isElement() && !s[o.id] && (s[o.id] = o)
          }
          if (i) {
            var u = t.getTargetCell()
            u && u.isElement() && !s[u.id] && (s[u.id] = u)
          }
        }
        return xe(s)
      },
      getCommonAncestor: function () {
        var t = Array.from(arguments).map(function (n) {
          for (var i = [], s = n.get('parent'); s; )
            (i.push(s), (s = this.getCell(s).get('parent')))
          return i
        }, this)
        t = t.sort(function (n, i) {
          return n.length - i.length
        })
        var e = xe(t.shift()).find(function (n) {
          return t.every(function (i) {
            return i.includes(n)
          })
        })
        return this.getCell(e)
      },
      getSuccessors: function (t, e) {
        e = e || {}
        var n = []
        return (
          this.search(
            t,
            function (i) {
              i !== t && n.push(i)
            },
            Kt({}, e, { outbound: !0 })
          ),
          n
        )
      },
      cloneCells: jm,
      cloneSubgraph: function (t, e) {
        var n = this.getSubgraph(t, e)
        return this.cloneCells(n)
      },
      getSubgraph: function (t, e) {
        e = e || {}
        var n = [],
          i = {},
          s = [],
          o = []
        return (
          xe(t).forEach(function (u) {
            if (
              (i[u.id] || (n.push(u), (i[u.id] = u), u.isLink() ? o.push(u) : s.push(u)), e.deep)
            ) {
              var c = u.getEmbeddedCells({ deep: !0 })
              c.forEach(function (h) {
                i[h.id] || (n.push(h), (i[h.id] = h), h.isLink() ? o.push(h) : s.push(h))
              })
            }
          }),
          o.forEach(function (u) {
            var { source: c, target: h } = u.attributes
            if (c.id && !i[c.id]) {
              var p = this.getCell(c.id)
              ;(n.push(p), (i[p.id] = p), s.push(p))
            }
            if (h.id && !i[h.id]) {
              var y = this.getCell(h.id)
              ;(n.push(this.getCell(h.id)), (i[y.id] = y), s.push(y))
            }
          }, this),
          s.forEach(function (u) {
            var c = this.getConnectedLinks(u, e)
            c.forEach(function (h) {
              var { source: p, target: y } = h.attributes
              !i[h.id] && p.id && i[p.id] && y.id && i[y.id] && (n.push(h), (i[h.id] = h))
            })
          }, this),
          n
        )
      },
      getPredecessors: function (t, e) {
        e = e || {}
        var n = []
        return (
          this.search(
            t,
            function (i) {
              i !== t && n.push(i)
            },
            Kt({}, e, { inbound: !0 })
          ),
          n
        )
      },
      search: function (t, e, n) {
        ;((n = n || {}), n.breadthFirst ? this.bfs(t, e, n) : this.dfs(t, e, n))
      },
      bfs: function (t, e, n = {}) {
        const i = {},
          s = {},
          o = []
        for (o.push(t), s[t.id] = 0; o.length > 0; ) {
          var u = o.shift()
          if (i[u.id] || ((i[u.id] = !0), e.call(this, u, s[u.id]) === !1)) continue
          const c = this.getNeighbors(u, n)
          for (let h = 0, p = c.length; h < p; h++) {
            const y = c[h]
            ;((s[y.id] = s[u.id] + 1), o.push(y))
          }
        }
      },
      dfs: function (t, e, n = {}) {
        const i = {},
          s = {},
          o = []
        for (o.push(t), s[t.id] = 0; o.length > 0; ) {
          const u = o.pop()
          if (i[u.id] || ((i[u.id] = !0), e.call(this, u, s[u.id]) === !1)) continue
          const c = this.getNeighbors(u, n),
            h = o.length
          for (let p = 0, y = c.length; p < y; p++) {
            const v = c[p]
            ;((s[v.id] = s[u.id] + 1), o.splice(h, 0, v))
          }
        }
      },
      getSources: function () {
        var t = []
        return (
          yi(
            this._nodes,
            function (e, n) {
              ;(!this._in[n] || Hr(this._in[n])) && t.push(this.getCell(n))
            }.bind(this)
          ),
          t
        )
      },
      getSinks: function () {
        var t = []
        return (
          yi(
            this._nodes,
            function (e, n) {
              ;(!this._out[n] || Hr(this._out[n])) && t.push(this.getCell(n))
            }.bind(this)
          ),
          t
        )
      },
      isSource: function (t) {
        return !this._in[t.id] || Hr(this._in[t.id])
      },
      isSink: function (t) {
        return !this._out[t.id] || Hr(this._out[t.id])
      },
      isSuccessor: function (t, e) {
        var n = !1
        return (
          this.search(
            t,
            function (i) {
              if (i === e && i !== t) return ((n = !0), !1)
            },
            { outbound: !0 }
          ),
          n
        )
      },
      isPredecessor: function (t, e) {
        var n = !1
        return (
          this.search(
            t,
            function (i) {
              if (i === e && i !== t) return ((n = !0), !1)
            },
            { inbound: !0 }
          ),
          n
        )
      },
      isNeighbor: function (t, e, n) {
        n = n || {}
        var i = n.inbound,
          s = n.outbound
        i === void 0 && s === void 0 && (i = s = !0)
        var o = !1
        return (
          this.getConnectedLinks(t, n).forEach(function (u) {
            var { source: c, target: h } = u.attributes
            if ((i && Mr(c, 'id') && c.id === e.id) || (s && Mr(h, 'id') && h.id === e.id))
              return ((o = !0), !1)
          }),
          o
        )
      },
      disconnectLinks: function (t, e) {
        this.getConnectedLinks(t).forEach(function (n) {
          n.set(n.attributes.source.id === t.id ? 'source' : 'target', { x: 0, y: 0 }, e)
        })
      },
      removeLinks: function (t, e) {
        Ui(this.getConnectedLinks(t), 'remove', e)
      },
      findModelsFromPoint: function (t) {
        return this.getElements().filter(e => e.getBBox({ rotate: !0 }).containsPoint(t))
      },
      findModelsInArea: function (t, e = {}) {
        const n = new Pt(t),
          { strict: i = !1 } = e,
          s = i ? 'containsRect' : 'intersect'
        return this.getElements().filter(o => n[s](o.getBBox({ rotate: !0 })))
      },
      findModelsUnderElement: function (t, e = {}) {
        const { searchBy: n = 'bbox' } = e,
          i = t.getBBox().rotateAroundCenter(t.angle())
        return (
          n === 'bbox' ? this.findModelsInArea(i) : this.findModelsFromPoint(Gm(i, n))
        ).filter(o => t.id !== o.id && !o.isEmbeddedIn(t))
      },
      getBBox: function () {
        return this.getCellsBBox(this.getCells())
      },
      getCellsBBox: function (t, e = {}) {
        const { rotate: n = !0 } = e
        return xe(t).reduce(function (i, s) {
          const o = s.getBBox({ rotate: n })
          return o ? (i ? i.union(o) : o) : i
        }, null)
      },
      translate: function (t, e, n) {
        var i = this.getCells().filter(function (s) {
          return !s.isEmbedded()
        })
        return (Ui(i, 'translate', t, e, n), this)
      },
      resize: function (t, e, n) {
        return this.resizeCells(t, e, this.getCells(), n)
      },
      resizeCells: function (t, e, n, i) {
        var s = this.getCellsBBox(n)
        if (s) {
          var o = Math.max(t / s.width, 0),
            u = Math.max(e / s.height, 0)
          Ui(n, 'scale', o, u, s.origin(), i)
        }
        return this
      },
      startBatch: function (t, e) {
        return (
          (e = e || {}),
          (this._batches[t] = (this._batches[t] || 0) + 1),
          this.trigger('batch:start', Kt({}, e, { batchName: t }))
        )
      },
      stopBatch: function (t, e) {
        return (
          (e = e || {}),
          (this._batches[t] = (this._batches[t] || 0) - 1),
          this.trigger('batch:stop', Kt({}, e, { batchName: t }))
        )
      },
      hasActiveBatch: function (t) {
        const e = this._batches
        let n
        return (
          arguments.length === 0 ? (n = Object.keys(e)) : Array.isArray(t) ? (n = t) : (n = [t]),
          n.some(i => e[i] > 0)
        )
      },
    },
    {
      validations: {
        multiLinks: function (t, e) {
          var { source: n, target: i } = e.attributes
          if (n.id && i.id) {
            var s = e.getSourceCell()
            if (s) {
              var o = t.getConnectedLinks(s, { outbound: !0 }),
                u = o.filter(function (c) {
                  var { source: h, target: p } = c.attributes
                  return (
                    h &&
                    h.id === n.id &&
                    (!h.port || h.port === n.port) &&
                    p &&
                    p.id === i.id &&
                    (!p.port || p.port === i.port)
                  )
                })
              if (u.length > 1) return !1
            }
          }
          return !0
        },
        linkPinning: function (t, e) {
          var { source: n, target: i } = e.attributes
          return n.id && i.id
        },
      },
    }
  )
Zx(Vr.prototype, ['resetCells', 'addCells', 'removeCells'], sh.cells)
const ya = {},
  or = En.View.extend(
    {
      options: {},
      theme: null,
      themeClassNamePrefix: ir('theme-'),
      requireSetThemeOverride: !1,
      defaultTheme: Yi.defaultTheme,
      children: null,
      childNodes: null,
      DETACHABLE: !0,
      UPDATE_PRIORITY: 2,
      FLAG_INSERT: 1 << 30,
      FLAG_REMOVE: 1 << 29,
      FLAG_INIT: 1 << 28,
      constructor: function (t) {
        ;((this.requireSetThemeOverride = t && !!t.theme),
          (this.options = Kt({}, this.options, t)),
          En.View.call(this, t))
      },
      initialize: function () {
        ;((ya[this.cid] = this),
          this.setTheme(this.options.theme || this.defaultTheme),
          this.init())
      },
      unmount: function () {
        this.svgElement ? this.vel.remove() : this.$el.remove()
      },
      isMounted: function () {
        return this.el.parentNode !== null
      },
      renderChildren: function (t) {
        if ((t || (t = dn(this, 'children')), t)) {
          var e = this.svgElement,
            n = yt.namespace[e ? 'svg' : 'xhtml'],
            i = Gu(t, n)
          ;((e ? this.vel : this.$el).empty().append(i.fragment), (this.childNodes = i.selectors))
        }
        return this
      },
      findAttribute: function (t, e) {
        for (var n = e; n && n.nodeType === 1; ) {
          var i = n.getAttribute(t)
          if (i) return i
          if (n === this.el) return null
          n = n.parentNode
        }
        return null
      },
      _ensureElement: function () {
        if (this.el) this.setElement(dn(this, 'el'))
        else {
          var t = dn(this, 'tagName'),
            e = Kt({}, dn(this, 'attributes')),
            n = Kt({}, dn(this, 'style'))
          ;(this.id && (e.id = dn(this, 'id')),
            this.setElement(this._createElement(t)),
            this._setAttributes(e),
            this._setStyle(n))
        }
        this._ensureElClassName()
      },
      _setAttributes: function (t) {
        this.svgElement ? this.vel.attr(t) : this.$el.attr(t)
      },
      _setStyle: function (t) {
        this.$el.css(t)
      },
      _createElement: function (t) {
        return this.svgElement
          ? document.createElementNS(yt.namespace.svg, t)
          : document.createElement(t)
      },
      _setElement: function (t) {
        ;((this.$el = t instanceof En.$ ? t : En.$(t)),
          (this.el = this.$el[0]),
          this.svgElement && (this.vel = yt(this.el)))
      },
      _ensureElClassName: function () {
        var t = dn(this, 'className')
        if (t) {
          var e = ir(t)
          this.svgElement
            ? this.vel.removeClass(t).addClass(e)
            : this.$el.removeClass(t).addClass(e)
        }
      },
      init: function () {},
      onRender: function () {},
      confirmUpdate: function () {
        return 0
      },
      setTheme: function (t, e) {
        return (
          (e = e || {}),
          this.theme && this.requireSetThemeOverride && !e.override
            ? this
            : (this.removeThemeClassName(),
              this.addThemeClassName(t),
              this.onSetTheme(this.theme, t),
              (this.theme = t),
              this)
        )
      },
      addThemeClassName: function (t) {
        if (((t = t || this.theme), !t)) return this
        var e = this.themeClassNamePrefix + t
        return (this.svgElement ? this.vel.addClass(e) : this.$el.addClass(e), this)
      },
      removeThemeClassName: function (t) {
        t = t || this.theme
        var e = this.themeClassNamePrefix + t
        return (this.svgElement ? this.vel.removeClass(e) : this.$el.removeClass(e), this)
      },
      onSetTheme: function (t, e) {},
      remove: function () {
        return (
          this.onRemove(),
          this.undelegateDocumentEvents(),
          (ya[this.cid] = null),
          En.View.prototype.remove.apply(this, arguments),
          this
        )
      },
      onRemove: function () {},
      getEventNamespace: function () {
        return '.joint-event-ns-' + this.cid
      },
      delegateElementEvents: function (t, e, n) {
        if (!e) return this
        n || (n = {})
        var i = this.getEventNamespace()
        for (var s in e) {
          var o = e[s]
          ;(typeof o != 'function' && (o = this[o]), o && Ie(t).on(s + i, n, o.bind(this)))
        }
        return this
      },
      undelegateElementEvents: function (t) {
        return (Ie(t).off(this.getEventNamespace()), this)
      },
      delegateDocumentEvents: function (t, e) {
        return (t || (t = dn(this, 'documentEvents')), this.delegateElementEvents(document, t, e))
      },
      undelegateDocumentEvents: function () {
        return this.undelegateElementEvents(document)
      },
      eventData: function (t, e) {
        if (!t) throw new Error('eventData(): event object required.')
        var n = t.data,
          i = '__' + this.cid + '__'
        return e === void 0
          ? n
            ? n[i] || {}
            : {}
          : (n || (n = t.data = {}), n[i] || (n[i] = {}), Kt(n[i], e), this)
      },
      stopPropagation: function (t) {
        return (this.eventData(t, { propagationStopped: !0 }), this)
      },
      isPropagationStopped: function (t) {
        return !!this.eventData(t).propagationStopped
      },
    },
    {
      extend: function () {
        var t = Array.from(arguments),
          e = (t[0] && Kt({}, t[0])) || {},
          n = (t[1] && Kt({}, t[1])) || {},
          i = e.render || (this.prototype && this.prototype.render) || null
        return (
          (e.render = function () {
            return (
              typeof i == 'function' && i.apply(this, arguments),
              this.render.__render__ === i && this.onRender(),
              this
            )
          }),
          (e.render.__render__ = i),
          En.View.extend.call(this, e, n)
        )
      },
    }
  ),
  Zb = 'dbltap'
if (Ie.event && !(Zb in Ie.event.special)) {
  const t = Yi.doubleTapInterval,
    e = 30
  Ie.event.special[Zb] = {
    bindType: 'touchend',
    delegateType: 'touchend',
    handle: function (n, ...i) {
      const { handleObj: s, target: o } = n,
        u = Ie.data(o),
        c = new Date().getTime(),
        h = 'lastTouch' in u ? c - u.lastTouch : 0
      h < t && h > e
        ? ((u.lastTouch = null), (n.type = s.origType), s.handler.call(this, n, ...i))
        : (u.lastTouch = c)
    },
  }
}
class KE {
  constructor(...e) {
    this.callbackArguments = e
  }
  listenTo(e, n, ...i) {
    const { callbackArguments: s } = this
    if (yt.isObject(n)) {
      const [o = null] = i
      Object.entries(n).forEach(([u, c]) => {
        typeof c == 'function' &&
          ((o || s.length > 0) && (c = c.bind(o, ...s)), En.Events.listenTo.call(this, e, u, c))
      })
    } else if (typeof n == 'string' && typeof i[0] == 'function') {
      let [o, u = null] = i
      ;((u || s.length > 0) && (o = o.bind(u, ...s)), En.Events.listenTo.call(this, e, n, o))
    }
  }
  stopListening() {
    En.Events.stopListening.call(this)
  }
}
const $E = Object.freeze(
    Object.defineProperty(
      { __proto__: null, Listener: KE, View: or, views: ya },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Pi = { CELLS: 'cells', BACK: 'back', FRONT: 'front', TOOLS: 'tools', LABELS: 'labels' },
  Kx = or.extend({
    tagName: 'g',
    svgElement: !0,
    pivotNodes: null,
    defaultTheme: null,
    options: { name: '' },
    className: function () {
      return ir(`${this.options.name}-layer`)
    },
    init: function () {
      this.pivotNodes = {}
    },
    insertSortedNode: function (t, e) {
      this.el.insertBefore(t, this.insertPivot(e))
    },
    insertNode: function (t) {
      const { el: e } = this
      t.parentNode !== e && e.appendChild(t)
    },
    insertPivot: function (t) {
      const { el: e, pivotNodes: n } = this
      ;((t = +t), t || (t = 0))
      let i = n[t]
      if (i) return i
      i = n[t] = document.createComment('z-index:' + (t + 1))
      let s = -1 / 0
      for (let o in n) ((o = +o), o < t && o > s && ((s = o), t - 1))
      if (s !== -1 / 0) {
        const o = n[s]
        e.insertBefore(i, o.nextSibling)
      } else e.insertBefore(i, e.firstChild)
      return i
    },
    removePivots: function () {
      const { el: t, pivotNodes: e } = this
      for (let n in e) t.removeChild(e[n])
      this.pivotNodes = {}
    },
  })
function xu(t) {
  return t ? (Array.isArray(t) ? t : [t]) : []
}
const rr = or.extend(
    {
      tagName: 'g',
      svgElement: !0,
      className: 'highlight',
      HIGHLIGHT_FLAG: 1,
      UPDATE_PRIORITY: 3,
      DETACHABLE: !1,
      UPDATABLE: !0,
      MOUNTABLE: !0,
      cellView: null,
      nodeSelector: null,
      node: null,
      updateRequested: !1,
      postponedUpdate: !1,
      transformGroup: null,
      detachedTransformGroup: null,
      requestUpdate(t, e) {
        const { paper: n } = t
        ;((this.cellView = t),
          (this.nodeSelector = e),
          n &&
            ((this.updateRequested = !0),
            n.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY)))
      },
      confirmUpdate() {
        this.updateRequested = !1
        const { cellView: t, nodeSelector: e } = this
        return t.isMounted()
          ? (this.update(t, e), this.mount(), this.transform(), 0)
          : ((this.postponedUpdate = !0), 0)
      },
      findNode(t, e = null) {
        let n
        if (typeof e == 'string') [n] = t.findBySelector(e)
        else if (hn(e)) {
          const i = t.model.isLink(),
            { label: s = null, port: o, selector: u } = e
          i && s !== null
            ? (n = t.findLabelNode(s, u))
            : !i && o
              ? (n = t.findPortNode(o, u))
              : ([n] = t.findBySelector(u))
        } else e && ((n = yt.toNode(e)), n instanceof SVGElement || (n = null))
        return n || null
      },
      getNodeMatrix(t, e) {
        const { options: n } = this,
          { layer: i } = n,
          { rotatableNode: s } = t,
          o = t.getNodeMatrix(e)
        return s
          ? i
            ? s.contains(e)
              ? o
              : t.getRootRotateMatrix().inverse().multiply(o)
            : t.getNodeRotateMatrix(e).multiply(o)
          : o
      },
      mount() {
        const {
          MOUNTABLE: t,
          cellView: e,
          el: n,
          options: i,
          transformGroup: s,
          detachedTransformGroup: o,
          postponedUpdate: u,
          nodeSelector: c,
        } = this
        if (!t || s) return
        if (u) {
          ;(this.update(e, c), this.transform())
          return
        }
        const { vel: h, paper: p } = e,
          { layer: y } = i
        if (y) {
          let v
          ;(o
            ? ((v = o), (this.detachedTransformGroup = null))
            : (v = yt('g').addClass('highlight-transform').append(n)),
            (this.transformGroup = v),
            p.getLayerView(y).insertSortedNode(v.node, i.z))
        } else (!n.parentNode || n.nextSibling) && h.append(n)
      },
      unmount() {
        const { MOUNTABLE: t, transformGroup: e, vel: n } = this
        t &&
          (e
            ? ((this.transformGroup = null), (this.detachedTransformGroup = e), e.remove())
            : n.remove())
      },
      transform() {
        const { transformGroup: t, cellView: e, updateRequested: n } = this
        if (!t || e.model.isLink() || n) return
        const i = e.getRootTranslateMatrix(),
          s = e.getRootRotateMatrix(),
          o = i.multiply(s)
        t.attr('transform', yt.matrixToTransformString(o))
      },
      update() {
        const { node: t, cellView: e, nodeSelector: n, updateRequested: i, id: s } = this
        if (i) return
        this.postponedUpdate = !1
        const o = (this.node = this.findNode(e, n))
        ;(t && this.unhighlight(e, t),
          o
            ? (this.highlight(e, o), this.mount())
            : (this.unmount(), e.notify('cell:highlight:invalid', s, this)))
      },
      onRemove() {
        const { node: t, cellView: e, id: n, constructor: i } = this
        ;(t && this.unhighlight(e, t), this.unmount(), i._removeRef(e, n))
      },
      highlight(t, e) {},
      unhighlight(t, e) {},
      listenToUpdateAttributes(t) {
        const e = dn(this, 'UPDATE_ATTRIBUTES')
        !Array.isArray(e) ||
          e.length === 0 ||
          this.listenTo(t.model, 'change', this.onCellAttributeChange)
      },
      onCellAttributeChange() {
        const { cellView: t } = this
        if (!t) return
        const { model: e, paper: n } = t
        dn(this, 'UPDATE_ATTRIBUTES').some(s => e.hasChanged(s)) &&
          n.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY)
      },
    },
    {
      _views: {},
      highlight: function (t, e, n) {
        const i = this.uniqueId(e, n)
        this.add(t, e, i, n)
      },
      unhighlight: function (t, e, n) {
        const i = this.uniqueId(e, n)
        this.remove(t, i)
      },
      get(t, e = null) {
        const { cid: n } = t,
          { _views: i } = this,
          s = i[n]
        if (e === null) {
          const o = []
          if (!s) return o
          for (let u in s) {
            const c = s[u]
            c instanceof this && o.push(c)
          }
          return o
        } else {
          if (!s) return null
          if (e in s) {
            const o = s[e]
            if (o instanceof this) return o
          }
          return null
        }
      },
      add(t, e, n, i = {}) {
        if (!n) throw new Error('dia.HighlighterView: An ID required.')
        const s = rr.get(t, n)
        s && s.remove()
        const o = new this(i)
        return (
          (o.id = n),
          this._addRef(t, n, o),
          o.requestUpdate(t, e),
          o.listenToUpdateAttributes(t),
          o
        )
      },
      _addRef(t, e, n) {
        const { cid: i } = t,
          { _views: s } = this
        let o = s[i]
        ;(o || (o = s[i] = {}), (o[e] = n))
      },
      _removeRef(t, e) {
        const { cid: n } = t,
          { _views: i } = this,
          s = i[n]
        if (s) {
          e && delete s[e]
          for (let o in s) return
          delete i[n]
        }
      },
      remove(t, e = null) {
        xu(this.get(t, e)).forEach(n => {
          n.remove()
        })
      },
      removeAll(t, e = null) {
        const { _views: n } = this
        for (let i in n)
          for (let s in n[i]) {
            const o = n[i][s]
            o.cellView.paper === t && o instanceof this && (e === null || s === e) && o.remove()
          }
      },
      update(t, e = null, n = !1) {
        xu(this.get(t, e)).forEach(i => {
          ;(n || i.UPDATABLE) && i.update()
        })
      },
      transform(t, e = null) {
        xu(this.get(t, e)).forEach(n => {
          n.UPDATABLE && n.transform()
        })
      },
      unmount(t, e = null) {
        xu(this.get(t, e)).forEach(n => n.unmount())
      },
      mount(t, e = null) {
        xu(this.get(t, e)).forEach(n => n.mount())
      },
      uniqueId(t, e = '') {
        return yt.ensureId(t) + JSON.stringify(e)
      },
    }
  ),
  $o = {
    DEFAULT: 'default',
    EMBEDDING: 'embedding',
    CONNECTING: 'connecting',
    MAGNET_AVAILABILITY: 'magnetAvailability',
    ELEMENT_AVAILABILITY: 'elementAvailability',
  },
  tD = { TOOLS: 'TOOLS' },
  Ae = or.extend(
    {
      tagName: 'g',
      svgElement: !0,
      selector: 'root',
      metrics: null,
      className: function () {
        var t = ['cell'],
          e = this.model.get('type')
        return (
          e &&
            e
              .toLowerCase()
              .split('.')
              .forEach(function (n, i, s) {
                t.push('type-' + s.slice(0, i + 1).join('-'))
              }),
          t.join(' ')
        )
      },
      _presentationAttributes: null,
      _flags: null,
      setFlags: function () {
        var t = {},
          e = {},
          n = 0,
          i,
          s,
          o,
          u = dn(this, 'presentationAttributes')
        for (var c in u)
          if (u.hasOwnProperty(c)) {
            var h = u[c]
            for (Array.isArray(h) || (h = [h]), i = 0, s = h.length; i < s; i++) {
              o = h[i]
              var p = t[o]
              ;(p || (p = t[o] = 1 << n++), (e[c] |= p))
            }
          }
        var y = dn(this, 'initFlag')
        for (Array.isArray(y) || (y = [y]), i = 0, s = y.length; i < s; i++)
          ((o = y[i]), t[o] || (t[o] = 1 << n++))
        if (n > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.')
        ;((this._flags = t), (this._presentationAttributes = e))
      },
      hasFlag: function (t, e) {
        return t & this.getFlag(e)
      },
      removeFlag: function (t, e) {
        return t ^ (t & this.getFlag(e))
      },
      getFlag: function (t) {
        var e = this._flags
        if (!e) return 0
        var n = 0
        if (Array.isArray(t)) for (var i = 0, s = t.length; i < s; i++) n |= e[t[i]]
        else n |= e[t]
        return n
      },
      attributes: function () {
        var t = this.model
        return { 'model-id': t.id, 'data-type': t.attributes.type }
      },
      constructor: function (t) {
        ;((t.id = t.id || Qs(this)), or.call(this, t))
      },
      initialize: function () {
        ;(this.setFlags(),
          or.prototype.initialize.apply(this, arguments),
          this.cleanNodesCache(),
          this.$el.data('view', this),
          this.startListening())
      },
      startListening: function () {
        this.listenTo(this.model, 'change', this.onAttributesChange)
      },
      onAttributesChange: function (t, e) {
        var n = t.getChangeFlag(this._presentationAttributes)
        e.updateHandled ||
          !n ||
          (e.dirty && this.hasFlag(n, 'UPDATE') && (n |= this.getFlag('RENDER')),
          e.tool && (e.async = !1),
          this.requestUpdate(n, e))
      },
      requestUpdate: function (t, e) {
        const { paper: n } = this
        n && t > 0 && n.requestViewUpdate(this, t, this.UPDATE_PRIORITY, e)
      },
      parseDOMJSON: function (t, e) {
        var n = Gu(t),
          i = n.selectors,
          s = n.groupSelectors
        for (var o in s) {
          if (i[o]) throw new Error('dia.CellView: ambiguous group selector')
          i[o] = s[o]
        }
        if (e) {
          var u = this.selector
          if (i[u]) throw new Error('dia.CellView: ambiguous root selector.')
          i[u] = e
        }
        return { fragment: n.fragment, selectors: i }
      },
      can: function (t) {
        var e = Ze(this.options.interactive)
          ? this.options.interactive(this)
          : this.options.interactive
        return (ze(e) && e[t] !== !1) || (px(e) && e !== !1)
      },
      findBySelector: function (t, e, n) {
        if ((e || (e = this.el), n || (n = this.selectors), !t || t === '.')) return [e]
        if (n) {
          var i = n[t]
          if (i) return Array.isArray(i) ? i : [i]
        }
        return Yi.useCSSSelectors ? Ie(e).find(t).toArray() : []
      },
      notify: function (t) {
        if (this.paper) {
          var e = Array.prototype.slice.call(arguments, 1)
          ;(this.trigger.apply(this, [t].concat(e)),
            this.paper.trigger.apply(this.paper, [t, this].concat(e)))
        }
      },
      getBBox: function (t) {
        var e
        if (t && t.useModelGeometry) {
          var n = this.model
          e = n.getBBox().bbox(n.angle())
        } else e = this.getNodeBBox(this.el)
        return this.paper.localToPaperRect(e)
      },
      getNodeBBox: function (t) {
        const e = this.getNodeBoundingRect(t),
          n = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(t)),
          i = this.getNodeMatrix(t)
        return yt.transformRect(e, n.multiply(i))
      },
      getNodeRotateMatrix(t) {
        return !this.rotatableNode || this.rotatableNode.contains(t)
          ? this.getRootRotateMatrix()
          : yt.createSVGMatrix()
      },
      getNodeUnrotatedBBox: function (t) {
        var e = this.getNodeBoundingRect(t),
          n = this.getNodeMatrix(t),
          i = this.getRootTranslateMatrix()
        return yt.transformRect(e, i.multiply(n))
      },
      getRootTranslateMatrix: function () {
        var t = this.model,
          e = t.position(),
          n = yt.createSVGMatrix().translate(e.x, e.y)
        return n
      },
      getRootRotateMatrix: function () {
        var t = yt.createSVGMatrix(),
          e = this.model,
          n = e.angle()
        if (n) {
          var i = e.getBBox(),
            s = i.width / 2,
            o = i.height / 2
          t = t.translate(s, o).rotate(n).translate(-s, -o)
        }
        return t
      },
      _notifyHighlight: function (t, e, n = {}) {
        const { el: i } = this
        let s
        if (
          (typeof e == 'string' ? ([s = i] = this.findBySelector(e)) : ([s = i] = this.$(e)),
          (n.partial = s !== i),
          n.type === void 0)
        ) {
          let o
          switch (!0) {
            case n.embedding:
              o = $o.EMBEDDING
              break
            case n.connecting:
              o = $o.CONNECTING
              break
            case n.magnetAvailability:
              o = $o.MAGNET_AVAILABILITY
              break
            case n.elementAvailability:
              o = $o.ELEMENT_AVAILABILITY
              break
            default:
              o = $o.DEFAULT
              break
          }
          n.type = o
        }
        return (this.notify(t, s, n), this)
      },
      highlight: function (t, e) {
        return this._notifyHighlight('cell:highlight', t, e)
      },
      unhighlight: function (t, e = {}) {
        return this._notifyHighlight('cell:unhighlight', t, e)
      },
      findMagnet: function (t) {
        const e = this.el
        let n = this.$(t)[0]
        n || (n = e)
        do {
          const i = n.getAttribute('magnet'),
            s = n === e
          if ((i || s) && i !== 'false') return n
          if (s) return
          n = n.parentNode
        } while (n)
      },
      findProxyNode: function (t, e) {
        t || (t = this.el)
        const n = t.getAttribute(`${e}-selector`)
        if (n) {
          const [i] = this.findBySelector(n)
          if (i) return i
        }
        return t
      },
      getSelector: function (t, e) {
        var n
        if (t === this.el) return (typeof e == 'string' && (n = '> ' + e), n)
        if (t) {
          var i = yt(t).index() + 1
          ;((n = t.tagName + ':nth-child(' + i + ')'),
            e && (n += ' > ' + e),
            (n = this.getSelector(t.parentNode, n)))
        }
        return n
      },
      addLinkFromMagnet: function (t, e, n) {
        var i = this.paper,
          s = i.model,
          o = i.getDefaultLink(this, t)
        return (
          o
            .set({ source: this.getLinkEnd(t, e, n, o, 'source'), target: { x: e, y: n } })
            .addTo(s, { async: !1, ui: !0 }),
          o.findView(i)
        )
      },
      getLinkEnd: function (t, ...e) {
        var n = this.model,
          i = n.id,
          s = this.findAttribute('port', t),
          o = t.getAttribute('joint-selector'),
          u = { id: i }
        return (
          o != null && (u.magnet = o),
          s != null
            ? ((u.port = s), !n.hasPort(s) && !o && (u.selector = this.getSelector(t)))
            : o == null && this.el !== t && (u.selector = this.getSelector(t)),
          this.customizeLinkEnd(u, t, ...e)
        )
      },
      customizeLinkEnd: function (t, e, n, i, s, o) {
        const { paper: u } = this,
          { connectionStrategy: c } = u.options
        if (typeof c == 'function') {
          var h = c.call(u, t, this, e, new et(n, i), s, o, u)
          if (h) return h
        }
        return t
      },
      getMagnetFromLinkEnd: function (t) {
        var e = this.el,
          n = t.port,
          i = t.magnet,
          s = this.model,
          o
        return (
          n != null && s.isElement() && s.hasPort(n)
            ? (o = this.findPortNode(n, i) || e)
            : (i || (i = t.selector),
              !i && n != null && (i = '[port="' + n + '"]'),
              (o = this.findBySelector(i, e, this.selectors)[0])),
          this.findProxyNode(o, 'magnet')
        )
      },
      dragLinkStart: function (t, e, n, i) {
        this.model.startBatch('add-link')
        const s = this.addLinkFromMagnet(e, n, i)
        ;(s.notifyPointerdown(t, n, i),
          s.eventData(t, s.startArrowheadMove('target', { whenNotAllowed: 'remove' })),
          this.eventData(t, { linkView: s }))
      },
      dragLink: function (t, e, n) {
        var i = this.eventData(t),
          s = i.linkView
        if (s) s.pointermove(t, e, n)
        else {
          var o = this.paper,
            u = o.options.magnetThreshold,
            c = this.getEventTarget(t),
            h = i.targetMagnet
          if (u === 'onleave') {
            if (h === c || yt(h).contains(c)) return
          } else if (o.eventData(t).mousemoved <= u) return
          this.dragLinkStart(t, h, e, n)
        }
      },
      dragLinkEnd: function (t, e, n) {
        var i = this.eventData(t),
          s = i.linkView
        s && (s.pointerup(t, e, n), this.model.stopBatch('add-link'))
      },
      getAttributeDefinition: function (t) {
        return this.model.constructor.getAttributeDefinition(t)
      },
      setNodeAttributes: function (t, e) {
        Hr(e) || (t instanceof SVGElement ? yt(t).attr(e) : Ie(t).attr(e))
      },
      processNodeAttributes: function (t, e) {
        var n,
          i,
          s,
          o,
          u,
          c,
          h,
          p,
          y,
          v = []
        for (n in e)
          e.hasOwnProperty(n) &&
            ((i = e[n]),
            (s = this.getAttributeDefinition(n)),
            s && (!Ze(s.qualify) || s.qualify.call(this, i, t, e, this))
              ? (Wn(s.set) && (c || (c = {}), (c[s.set] = i)), i !== null && v.push(n, s))
              : (c || (c = {}), (c[Dx(n)] = i)))
        for (o = 0, u = v.length; o < u; o += 2)
          ((n = v[o]),
            (s = v[o + 1]),
            (i = e[n]),
            Ze(s.set) && (h || (h = {}), (h[n] = i)),
            Ze(s.position) && (p || (p = {}), (p[n] = i)),
            Ze(s.offset) && (y || (y = {}), (y[n] = i)))
        return { raw: e, normal: c, set: h, position: p, offset: y }
      },
      updateRelativeAttributes: function (t, e, n, i) {
        i || (i = {})
        var s,
          o,
          u,
          c = e.raw || {},
          h = e.normal || {},
          p = e.set,
          y = e.position,
          v = e.offset
        for (s in p) {
          ;((o = p[s]), (u = this.getAttributeDefinition(s)))
          var C = u.set.call(this, o, n.clone(), t, c, this)
          ze(C) ? Kt(h, C) : C !== void 0 && (h[s] = C)
        }
        if (t instanceof HTMLElement) {
          this.setNodeAttributes(t, h)
          return
        }
        var w = h.transform,
          N = yt.transformStringToMatrix(w),
          T = et(N.e, N.f)
        w && ((h = ba(h, 'transform')), (N.e = N.f = 0))
        var z, R, B
        if (y || v) {
          var H = this.getNodeScale(t, i.scalableNode)
          ;((z = H.sx), (R = H.sy))
        }
        var Z = !1
        for (s in y)
          ((o = y[s]),
            (u = this.getAttributeDefinition(s)),
            (B = u.position.call(this, o, n.clone(), t, c, this)),
            B && (T.offset(et(B).scale(z, R)), Z || (Z = !0)))
        this.setNodeAttributes(t, h)
        var U = !1
        if (v) {
          var nt = this.getNodeBoundingRect(t)
          if (nt.width > 0 && nt.height > 0) {
            var g = yt.transformRect(nt, N).scale(1 / z, 1 / R)
            for (s in v)
              ((o = v[s]),
                (u = this.getAttributeDefinition(s)),
                (B = u.offset.call(this, o, g, t, c, this)),
                B && (T.offset(et(B).scale(z, R)), U || (U = !0)))
          }
        }
        ;(w !== void 0 || Z || U) &&
          (T.round(1),
          (N.e = T.x),
          (N.f = T.y),
          t.setAttribute('transform', yt.matrixToTransformString(N)))
      },
      getNodeScale: function (t, e) {
        var n, i
        if (e && e.contains(t)) {
          var s = e.scale()
          ;((n = 1 / s.sx), (i = 1 / s.sy))
        } else ((n = 1), (i = 1))
        return { sx: n, sy: i }
      },
      cleanNodesCache: function () {
        this.metrics = {}
      },
      nodeCache: function (t) {
        var e = this.metrics
        if (!e) return {}
        var n = yt.ensureId(t),
          i = e[n]
        return (i || (i = e[n] = {}), i)
      },
      getNodeData: function (t) {
        var e = this.nodeCache(t)
        return (e.data || (e.data = {}), e.data)
      },
      getNodeBoundingRect: function (t) {
        var e = this.nodeCache(t)
        return (
          e.boundingRect === void 0 && (e.boundingRect = yt(t).getBBox()),
          new Pt(e.boundingRect)
        )
      },
      getNodeMatrix: function (t) {
        const e = this.nodeCache(t)
        if (e.magnetMatrix === void 0) {
          const { rotatableNode: n, el: i } = this
          let s
          ;(n && n.contains(t) ? (s = n) : (s = i),
            (e.magnetMatrix = yt(t).getTransformToElement(s)))
        }
        return yt.createSVGMatrix(e.magnetMatrix)
      },
      getNodeShape: function (t) {
        var e = this.nodeCache(t)
        return (
          e.geometryShape === void 0 && (e.geometryShape = yt(t).toGeometryShape()),
          e.geometryShape.clone()
        )
      },
      isNodeConnection: function (t) {
        return this.model.isLink() && (!t || t === this.el)
      },
      findNodesAttributes: function (t, e, n, i) {
        var s,
          o,
          u,
          c,
          h = {},
          p = []
        for (var y in t)
          if (t.hasOwnProperty(y) && ((u = t[y]), !!hn(u))) {
            var v = (n[y] = this.findBySelector(y, e, i))
            for (s = 0, o = v.length; s < o; s++) {
              var C = v[s]
              c = yt.ensureId(C)
              var w = i && i[y] === C,
                N = h[c]
              if (N) {
                N.array ||
                  (p.push(c),
                  (N.array = !0),
                  (N.attributes = [N.attributes]),
                  (N.selectedLength = [N.selectedLength]))
                var T = N.attributes,
                  z = N.selectedLength
                if (w) (T.unshift(u), z.unshift(-1))
                else {
                  var R = Rm(z, o)
                  ;(T.splice(R, 0, u), z.splice(R, 0, o))
                }
              } else h[c] = { attributes: u, selectedLength: w ? -1 : o, node: C, array: !1 }
            }
          }
        for (s = 0, o = p.length; s < o; s++)
          ((c = p[s]), (u = h[c]), (u.attributes = An({}, ...u.attributes.reverse())))
        return h
      },
      getEventTarget: function (t, e = {}) {
        const { target: n, type: i, clientX: s = 0, clientY: o = 0 } = t
        return e.fromPoint ||
          i === 'touchmove' ||
          i === 'touchend' ||
          ('pointerId' in t && n.hasPointerCapture(t.pointerId))
          ? document.elementFromPoint(s, o)
          : n
      },
      updateDOMSubtreeAttributes: function (t, e, n) {
        ;(n || (n = {}),
          n.rootBBox || (n.rootBBox = Pt()),
          n.selectors || (n.selectors = this.selectors))
        var i = {},
          s = {},
          o = [],
          u = [],
          c,
          h,
          p,
          y,
          v,
          C = n.roAttributes,
          w = this.findNodesAttributes(C || e, t, i, n.selectors),
          N = C ? this.findNodesAttributes(e, t, i, n.selectors) : w
        for (var T in w)
          if (
            ((y = w[T]),
            (p = y.attributes),
            (h = y.node),
            (v = this.processNodeAttributes(h, p)),
            !v.set && !v.position && !v.offset)
          )
            this.setNodeAttributes(h, v.normal)
          else {
            var z = N[T] && N[T].attributes,
              R = z && p.ref === void 0 ? z.ref : p.ref,
              B
            if (R) {
              if (((B = (i[R] || this.findBySelector(R, t, n.selectors))[0]), !B))
                throw new Error('dia.CellView: "' + R + '" reference does not exist.')
            } else B = null
            if (((c = { node: h, refNode: B, processedAttributes: v, allAttributes: z }), B)) {
              var H = u.findIndex(function (Z) {
                return Z.refNode === h
              })
              H > -1 ? u.splice(H, 0, c) : u.push(c)
            } else o.push(c)
          }
        o.push(...u)
        for (let Z = 0, U = o.length; Z < U; Z++) {
          ;((c = o[Z]), (h = c.node), (B = c.refNode))
          const nt = B ? yt.ensureId(B) : ''
          let g = s[nt]
          ;(g || (g = s[nt] = B ? yt(B).getBBox({ target: eD(h, B) }) : n.rootBBox),
            C
              ? ((v = this.processNodeAttributes(h, c.allAttributes)),
                this.mergeProcessedAttributes(v, c.processedAttributes))
              : (v = c.processedAttributes),
            this.updateRelativeAttributes(h, v, g, n))
        }
      },
      mergeProcessedAttributes: function (t, e) {
        ;(t.set || (t.set = {}),
          t.position || (t.position = {}),
          t.offset || (t.offset = {}),
          Kt(t.set, e.set),
          Kt(t.position, e.position),
          Kt(t.offset, e.offset))
        var n = t.normal && t.normal.transform
        ;(n !== void 0 && e.normal && (e.normal.transform = n), (t.normal = e.normal))
      },
      onMount(t) {
        t || (this.mountTools(), rr.mount(this))
      },
      onDetach() {
        ;(this.unmountTools(), rr.unmount(this))
      },
      onRemove: function () {
        ;(this.removeTools(), this.removeHighlighters())
      },
      _toolsView: null,
      hasTools: function (t) {
        var e = this._toolsView
        return e ? (t ? e.getName() === t : !0) : !1
      },
      addTools: function (t) {
        return (
          this.removeTools(),
          t &&
            ((this._toolsView = t),
            t.configure({ relatedView: this }),
            t.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this))),
          this
        )
      },
      unmountTools() {
        const t = this._toolsView
        return (t && t.unmount(), this)
      },
      mountTools() {
        const t = this._toolsView
        return (t && !t.isMounted() && t.mount(), this)
      },
      updateTools: function (t) {
        var e = this._toolsView
        return (e && e.update(t), this)
      },
      removeTools: function () {
        var t = this._toolsView
        return (t && (t.remove(), (this._toolsView = null)), this)
      },
      hideTools: function () {
        var t = this._toolsView
        return (t && t.hide(), this)
      },
      showTools: function () {
        var t = this._toolsView
        return (t && t.show(), this)
      },
      onToolEvent: function (t) {
        switch (t) {
          case 'remove':
            this.removeTools()
            break
          case 'hide':
            this.hideTools()
            break
          case 'show':
            this.showTools()
            break
        }
      },
      removeHighlighters: function () {
        rr.remove(this)
      },
      updateHighlighters: function (t = !1) {
        rr.update(this, null, t)
      },
      transformHighlighters: function () {
        rr.transform(this)
      },
      preventDefaultInteraction(t) {
        this.eventData(t, { defaultInteractionPrevented: !0 })
      },
      isDefaultInteractionPrevented(t) {
        const { defaultInteractionPrevented: e = !1 } = this.eventData(t)
        return e
      },
      pointerdblclick: function (t, e, n) {
        this.notify('cell:pointerdblclick', t, e, n)
      },
      pointerclick: function (t, e, n) {
        this.notify('cell:pointerclick', t, e, n)
      },
      contextmenu: function (t, e, n) {
        this.notify('cell:contextmenu', t, e, n)
      },
      pointerdown: function (t, e, n) {
        const { model: i } = this,
          { graph: s } = i
        ;(s && (i.startBatch('pointer'), this.eventData(t, { graph: s })),
          this.notify('cell:pointerdown', t, e, n))
      },
      pointermove: function (t, e, n) {
        this.notify('cell:pointermove', t, e, n)
      },
      pointerup: function (t, e, n) {
        const { graph: i } = this.eventData(t)
        ;(this.notify('cell:pointerup', t, e, n), i && i.stopBatch('pointer', { cell: this.model }))
      },
      mouseover: function (t) {
        this.notify('cell:mouseover', t)
      },
      mouseout: function (t) {
        this.notify('cell:mouseout', t)
      },
      mouseenter: function (t) {
        this.notify('cell:mouseenter', t)
      },
      mouseleave: function (t) {
        this.notify('cell:mouseleave', t)
      },
      mousewheel: function (t, e, n, i) {
        this.notify('cell:mousewheel', t, e, n, i)
      },
      onevent: function (t, e, n, i) {
        this.notify(e, t, n, i)
      },
      onmagnet: function () {},
      magnetpointerdblclick: function () {},
      magnetcontextmenu: function () {},
      checkMouseleave(t) {
        const { paper: e, model: n } = this
        if (e.isAsync()) {
          if (n.isLink()) {
            const o = n.getSourceElement()
            if (o) {
              const c = e.findViewByModel(o)
              c && (e.dumpView(c), e.checkViewVisibility(c))
            }
            const u = n.getTargetElement()
            if (u) {
              const c = e.findViewByModel(u)
              c && (e.dumpView(c), e.checkViewVisibility(c))
            }
          }
          ;(e.dumpView(this), e.checkViewVisibility(this))
        }
        const i = this.getEventTarget(t, { fromPoint: !0 }),
          s = e.findView(i)
        s !== this && (this.mouseleave(t), s && s.mouseenter(t))
      },
      setInteractivity: function (t) {
        this.options.interactive = t
      },
    },
    {
      Flags: tD,
      Highlighting: $o,
      addPresentationAttributes: function (t) {
        return An({}, dn(this.prototype, 'presentationAttributes'), t, function (e, n) {
          if (
            !(!e || !n) &&
            (typeof e == 'string' && (e = [e]),
            typeof n == 'string' && (n = [n]),
            Array.isArray(e) && Array.isArray(n))
          )
            return cs(e.concat(n))
        })
      },
    }
  )
function eD(t, e) {
  let n = t
  do {
    if (n.contains(e)) return n
    n = n.parentNode
  } while (n)
  return null
}
const De = {
    TOOLS: Ae.Flags.TOOLS,
    UPDATE: 'UPDATE',
    TRANSLATE: 'TRANSLATE',
    RESIZE: 'RESIZE',
    PORTS: 'PORTS',
    ROTATE: 'ROTATE',
    RENDER: 'RENDER',
  },
  tl = { MOVE: 'move', MAGNET: 'magnet' },
  bn = Ae.extend(
    {
      _removePorts: function () {},
      _renderPorts: function () {},
      className: function () {
        var t = Ae.prototype.className.apply(this).split(' ')
        return (t.push('element'), t.join(' '))
      },
      initialize: function () {
        ;(Ae.prototype.initialize.apply(this, arguments), this._initializePorts())
      },
      presentationAttributes: {
        attrs: [De.UPDATE],
        position: [De.TRANSLATE, De.TOOLS],
        size: [De.RESIZE, De.PORTS, De.TOOLS],
        angle: [De.ROTATE, De.TOOLS],
        markup: [De.RENDER],
        ports: [De.PORTS],
      },
      initFlag: [De.RENDER],
      UPDATE_PRIORITY: 0,
      confirmUpdate: function (t, e) {
        const { useCSSSelectors: n } = Yi
        this.hasFlag(t, De.PORTS) && (this._removePorts(), this._cleanPortsCache())
        let i = !1
        if (this.hasFlag(t, De.RENDER))
          (this.render(),
            this.updateTools(e),
            this.updateHighlighters(!0),
            (i = !0),
            (t = this.removeFlag(t, [
              De.RENDER,
              De.UPDATE,
              De.RESIZE,
              De.TRANSLATE,
              De.ROTATE,
              De.PORTS,
              De.TOOLS,
            ])))
        else {
          let s = !1
          ;(this.hasFlag(t, De.RESIZE) &&
            (this.resize(e),
            (s = !0),
            (t = this.removeFlag(t, [De.RESIZE, De.UPDATE])),
            n && (t = this.removeFlag(t, De.PORTS))),
            this.hasFlag(t, De.UPDATE) &&
              (this.update(this.model, null, e),
              (t = this.removeFlag(t, De.UPDATE)),
              (s = !0),
              n && (t = this.removeFlag(t, De.PORTS))),
            this.hasFlag(t, De.TRANSLATE) &&
              (this.translate(), (t = this.removeFlag(t, De.TRANSLATE)), (i = !0)),
            this.hasFlag(t, De.ROTATE) &&
              (this.rotate(), (t = this.removeFlag(t, De.ROTATE)), (i = !0)),
            this.hasFlag(t, De.PORTS) &&
              (this._renderPorts(), (s = !0), (t = this.removeFlag(t, De.PORTS))),
            s && this.updateHighlighters(!1))
        }
        return (
          i && this.transformHighlighters(),
          this.hasFlag(t, De.TOOLS) && (this.updateTools(e), (t = this.removeFlag(t, De.TOOLS))),
          t
        )
      },
      _initializePorts: function () {},
      update: function (t, e) {
        this.cleanNodesCache()
        const { useCSSSelectors: n } = Yi
        n && this._removePorts()
        var i = this.model,
          s = i.attr()
        ;(this.updateDOMSubtreeAttributes(this.el, s, {
          rootBBox: new Pt(i.size()),
          selectors: this.selectors,
          scalableNode: this.scalableNode,
          rotatableNode: this.rotatableNode,
          roAttributes: e === s ? null : e,
        }),
          n && this._renderPorts())
      },
      rotatableSelector: 'rotatable',
      scalableSelector: 'scalable',
      scalableNode: null,
      rotatableNode: null,
      renderMarkup: function () {
        var t = this.model,
          e = t.get('markup') || t.markup
        if (!e) throw new Error('dia.ElementView: markup required')
        if (Array.isArray(e)) return this.renderJSONMarkup(e)
        if (typeof e == 'string') return this.renderStringMarkup(e)
        throw new Error('dia.ElementView: invalid markup')
      },
      renderJSONMarkup: function (t) {
        var e = this.parseDOMJSON(t, this.el),
          n = (this.selectors = e.selectors)
        ;((this.rotatableNode = yt(n[this.rotatableSelector]) || null),
          (this.scalableNode = yt(n[this.scalableSelector]) || null),
          this.vel.append(e.fragment))
      },
      renderStringMarkup: function (t) {
        var e = this.vel
        ;(e.append(yt(t)),
          (this.rotatableNode = e.findOne('.rotatable')),
          (this.scalableNode = e.findOne('.scalable')))
        var n = (this.selectors = {})
        n[this.selector] = this.el
      },
      render: function () {
        return (
          this.vel.empty(),
          this.renderMarkup(),
          this.scalableNode && this.update(),
          this.resize(),
          this.rotatableNode ? (this.rotate(), this.translate()) : this.updateTransformation(),
          Yi.useCSSSelectors || this._renderPorts(),
          this
        )
      },
      resize: function (t) {
        if (this.scalableNode) return this.sgResize(t)
        ;(this.model.attributes.angle && this.rotate(), this.update())
      },
      translate: function () {
        if (this.rotatableNode) return this.rgTranslate()
        this.updateTransformation()
      },
      rotate: function () {
        if (this.rotatableNode) {
          ;(this.rgRotate(), this.update())
          return
        }
        this.updateTransformation()
      },
      updateTransformation: function () {
        var t = this.getTranslateString(),
          e = this.getRotateString()
        ;(e && (t += ' ' + e), this.vel.attr('transform', t))
      },
      getTranslateString: function () {
        var t = this.model.attributes.position
        return 'translate(' + t.x + ',' + t.y + ')'
      },
      getRotateString: function () {
        var t = this.model.attributes,
          e = t.angle
        if (!e) return null
        var n = t.size
        return 'rotate(' + e + ',' + n.width / 2 + ',' + n.height / 2 + ')'
      },
      rgRotate: function () {
        this.rotatableNode.attr('transform', this.getRotateString())
      },
      rgTranslate: function () {
        this.vel.attr('transform', this.getTranslateString())
      },
      sgResize: function (t) {
        var e = this.model,
          n = e.angle(),
          i = e.size(),
          s = this.scalableNode,
          o = !1
        s.node.getElementsByTagName('path').length > 0 && (o = !0)
        var u = s.getBBox({ recursive: o }),
          c = i.width / (u.width || 1),
          h = i.height / (u.height || 1)
        s.attr('transform', 'scale(' + c + ',' + h + ')')
        var p = this.rotatableNode,
          y = p && p.attr('transform')
        if (y) {
          p.attr('transform', y + ' rotate(' + -n + ',' + i.width / 2 + ',' + i.height / 2 + ')')
          var v = s.getBBox({ target: this.paper.cells })
          ;(e.set('position', { x: v.x, y: v.y }, Kt({ updateHandled: !0 }, t)),
            this.translate(),
            this.rotate())
        }
        this.update()
      },
      prepareEmbedding: function (t = {}) {
        const e = t.model || this.model,
          i = (t.paper || this.paper).model,
          s = (t.initialZIndices = {}),
          o = e.getEmbeddedCells({ deep: !0 }),
          u = i.getConnectedLinks(e, { deep: !0, includeEnclosed: !0 })
        ;([e, ...o, ...u].forEach(p => (s[p.id] = p.attributes.z)),
          e.startBatch('to-front'),
          e.toFront({ deep: !0, ui: !0 }))
        const c = i.getElements().reduce((p, y) => Math.max(p, y.attributes.z || 0), 0)
        ;(u.forEach(p => {
          p.attributes.z <= c && p.set('z', c + 1, { ui: !0 })
        }),
          e.stopBatch('to-front'))
        const h = e.parent()
        h
          ? (i.getCell(h).unembed(e, { ui: !0 }), (t.initialParentId = h))
          : (t.initialParentId = null)
      },
      processEmbedding: function (t = {}, e, n, i) {
        const s = t.model || this.model,
          o = t.paper || this.paper,
          u = o.model,
          { findParentBy: c, frontParentOnly: h, validateEmbedding: p } = o.options
        let y
        ;(Ze(c)
          ? (y = xe(c.call(u, this, e, n, i)))
          : c === 'pointer'
            ? (y = xe(u.findModelsFromPoint({ x: n, y: i })))
            : (y = u.findModelsUnderElement(s, { searchBy: c })),
          (y = y.filter(w => w instanceof Er && s.id !== w.id && !w.isEmbeddedIn(s))),
          h && (y = y.slice(-1)))
        let v = null
        const C = t.candidateEmbedView
        for (let w = y.length - 1; w >= 0; w--) {
          const N = y[w]
          if (C && C.model.id == N.id) {
            v = C
            break
          } else {
            const T = N.findView(o)
            if (!Ze(p) || p.call(o, this, T)) {
              v = T
              break
            }
          }
        }
        ;(v &&
          v != C &&
          (this.clearEmbedding(t),
          (t.candidateEmbedView = v.highlight(v.findProxyNode(null, 'container'), {
            embedding: !0,
          }))),
          !v && C && this.clearEmbedding(t))
      },
      clearEmbedding: function (t) {
        t || (t = {})
        var e = t.candidateEmbedView
        e &&
          (e.unhighlight(e.findProxyNode(null, 'container'), { embedding: !0 }),
          (t.candidateEmbedView = null))
      },
      finalizeEmbedding: function (t = {}) {
        const e = t.candidateEmbedView,
          n = t.model || this.model,
          i = t.paper || this.paper
        if (e)
          (e.model.embed(n, { ui: !0 }),
            e.unhighlight(e.findProxyNode(null, 'container'), { embedding: !0 }),
            (t.candidateEmbedView = null))
        else {
          const { validateUnembedding: s } = i.options,
            { initialParentId: o } = t
          if (o && typeof s == 'function' && !s.call(i, this)) {
            this._disallowUnembed(t)
            return
          }
        }
        i.model.getConnectedLinks(n, { deep: !0 }).forEach(s => {
          s.reparent({ ui: !0 })
        })
      },
      _disallowUnembed: function (t) {
        const { model: e, whenNotAllowed: n = 'revert' } = t,
          i = e || this.model,
          o = (t.paper || this.paper).model
        switch (n) {
          case 'remove': {
            i.remove({ ui: !0 })
            break
          }
          case 'revert': {
            const { initialParentId: u, initialPosition: c, initialZIndices: h } = t
            if (c) {
              const { x: y, y: v } = c
              i.position(y, v, { deep: !0, ui: !0 })
            }
            h &&
              Object.keys(h).forEach(y => {
                const v = o.getCell(y)
                v && v.set('z', h[y], { ui: !0 })
              })
            const p = o.getCell(u)
            p && p.embed(i, { ui: !0 })
            break
          }
        }
      },
      getDelegatedView: function () {
        for (var t = this, e = t.model, n = t.paper; t && !e.isLink(); ) {
          if (!e.isEmbedded() || t.can('stopDelegation')) return t
          ;((e = e.getParentCell()), (t = n.findViewByModel(e)))
        }
        return null
      },
      findProxyNode: function (t, e) {
        t || (t = this.el)
        const n = t.getAttribute(`${e}-selector`)
        if (n) {
          const i = this.findAttribute('port', t)
          if (i) {
            const s = this.findPortNode(i, n)
            if (s) return s
          } else {
            const [s] = this.findBySelector(n)
            if (s) return s
          }
        }
        return t
      },
      notifyPointerdown(t, e, n) {
        ;(Ae.prototype.pointerdown.call(this, t, e, n), this.notify('element:pointerdown', t, e, n))
      },
      notifyPointermove(t, e, n) {
        ;(Ae.prototype.pointermove.call(this, t, e, n), this.notify('element:pointermove', t, e, n))
      },
      notifyPointerup(t, e, n) {
        ;(this.notify('element:pointerup', t, e, n), Ae.prototype.pointerup.call(this, t, e, n))
      },
      pointerdblclick: function (t, e, n) {
        ;(Ae.prototype.pointerdblclick.apply(this, arguments),
          this.notify('element:pointerdblclick', t, e, n))
      },
      pointerclick: function (t, e, n) {
        ;(Ae.prototype.pointerclick.apply(this, arguments),
          this.notify('element:pointerclick', t, e, n))
      },
      contextmenu: function (t, e, n) {
        ;(Ae.prototype.contextmenu.apply(this, arguments),
          this.notify('element:contextmenu', t, e, n))
      },
      pointerdown: function (t, e, n) {
        ;(this.notifyPointerdown(t, e, n), this.dragStart(t, e, n))
      },
      pointermove: function (t, e, n) {
        const i = this.eventData(t),
          { targetMagnet: s, action: o, delegatedView: u } = i
        switch ((s && this.magnetpointermove(t, s, e, n), o)) {
          case tl.MAGNET:
            this.dragMagnet(t, e, n)
            break
          case tl.MOVE:
            ;(u || this).drag(t, e, n)
          default:
            if (i.preventPointerEvents) break
            this.notifyPointermove(t, e, n)
            break
        }
        this.eventData(t, i)
      },
      pointerup: function (t, e, n) {
        const i = this.eventData(t),
          { targetMagnet: s, action: o, delegatedView: u } = i
        switch ((s && this.magnetpointerup(t, s, e, n), o)) {
          case tl.MAGNET:
            this.dragMagnetEnd(t, e, n)
            break
          case tl.MOVE:
            ;(u || this).dragEnd(t, e, n)
          default:
            if (i.preventPointerEvents) break
            this.notifyPointerup(t, e, n)
        }
        ;(s && this.magnetpointerclick(t, s, e, n), this.checkMouseleave(t))
      },
      mouseover: function (t) {
        ;(Ae.prototype.mouseover.apply(this, arguments), this.notify('element:mouseover', t))
      },
      mouseout: function (t) {
        ;(Ae.prototype.mouseout.apply(this, arguments), this.notify('element:mouseout', t))
      },
      mouseenter: function (t) {
        ;(Ae.prototype.mouseenter.apply(this, arguments), this.notify('element:mouseenter', t))
      },
      mouseleave: function (t) {
        ;(Ae.prototype.mouseleave.apply(this, arguments), this.notify('element:mouseleave', t))
      },
      mousewheel: function (t, e, n, i) {
        ;(Ae.prototype.mousewheel.apply(this, arguments),
          this.notify('element:mousewheel', t, e, n, i))
      },
      onmagnet: function (t, e, n) {
        const { currentTarget: i } = t
        ;(this.magnetpointerdown(t, i, e, n),
          this.eventData(t, { targetMagnet: i }),
          this.dragMagnetStart(t, e, n))
      },
      magnetpointerdown: function (t, e, n, i) {
        this.notify('element:magnet:pointerdown', t, e, n, i)
      },
      magnetpointermove: function (t, e, n, i) {
        this.notify('element:magnet:pointermove', t, e, n, i)
      },
      magnetpointerup: function (t, e, n, i) {
        this.notify('element:magnet:pointerup', t, e, n, i)
      },
      magnetpointerdblclick: function (t, e, n, i) {
        this.notify('element:magnet:pointerdblclick', t, e, n, i)
      },
      magnetcontextmenu: function (t, e, n, i) {
        this.notify('element:magnet:contextmenu', t, e, n, i)
      },
      dragStart: function (t, e, n) {
        if (this.isDefaultInteractionPrevented(t)) return
        var i = this.getDelegatedView()
        if (!i || !i.can('elementMove')) return
        this.eventData(t, { action: tl.MOVE, delegatedView: i })
        const s = i.model.position()
        i.eventData(t, {
          initialPosition: s,
          pointerOffset: s.difference(e, n),
          restrictedArea: this.paper.getRestrictedArea(i, e, n),
        })
      },
      dragMagnetStart: function (t, e, n) {
        const { paper: i } = this,
          s = t.isPropagationStopped()
        if (
          (s && this.eventData(t, { preventPointerEvents: !0 }),
          this.isDefaultInteractionPrevented(t) || !this.can('addLinkFromMagnet'))
        )
          return
        const { targetMagnet: o = t.currentTarget } = this.eventData(t)
        if ((t.stopPropagation(), !i.options.validateMagnet.call(i, this, o, t))) {
          s ? this.dragStart(t, e, n) : this.pointerdown(t, e, n)
          return
        }
        ;(i.options.magnetThreshold <= 0 && this.dragLinkStart(t, o, e, n),
          this.eventData(t, { action: tl.MAGNET }))
      },
      drag: function (t, e, n) {
        var i = this.paper,
          s = i.options.gridSize,
          o = this.model,
          u = this.eventData(t),
          { pointerOffset: c, restrictedArea: h, embedding: p } = u,
          y = to(e + c.x, s),
          v = to(n + c.y, s)
        ;(o.position(y, v, { restrictedArea: h, deep: !0, ui: !0 }),
          i.options.embeddingMode &&
            (p || (this.prepareEmbedding(u), (p = !0)), this.processEmbedding(u, t, e, n)),
          this.eventData(t, { embedding: p }))
      },
      dragMagnet: function (t, e, n) {
        this.dragLink(t, e, n)
      },
      dragEnd: function (t, e, n) {
        var i = this.eventData(t)
        i.embedding && this.finalizeEmbedding(i)
      },
      dragMagnetEnd: function (t, e, n) {
        this.dragLinkEnd(t, e, n)
      },
      magnetpointerclick: function (t, e, n, i) {
        var s = this.paper
        s.eventData(t).mousemoved > s.options.clickThreshold ||
          this.notify('element:magnet:pointerclick', t, e, n, i)
      },
    },
    { Flags: De }
  )
Kt(bn.prototype, qE)
const nD = function (t, e, n) {
    return t
  },
  iD = function (t, e, n) {
    var i = e.side || 'bottom',
      s = Ia(e.padding || 40),
      o = n.sourceBBox,
      u = n.targetBBox,
      c = o.center(),
      h = u.center(),
      p,
      y,
      v
    switch (i) {
      case 'bottom':
        ;((v = 1), (p = 'y'), (y = 'height'))
        break
      case 'top':
        ;((v = -1), (p = 'y'), (y = 'height'))
        break
      case 'left':
        ;((v = -1), (p = 'x'), (y = 'width'))
        break
      case 'right':
        ;((v = 1), (p = 'x'), (y = 'width'))
        break
      default:
        throw new Error('Router: invalid side')
    }
    return (
      (c[p] += v * (o[y] / 2 + s[i])),
      (h[p] += v * (u[y] / 2 + s[i])),
      v * (c[p] - h[p]) > 0 ? (h[p] = c[p]) : (c[p] = h[p]),
      [c].concat(t, h)
    )
  }
var rD = { N: 'S', S: 'N', E: 'W', W: 'E' },
  aD = { N: (-Math.PI / 2) * 3, S: -Math.PI / 2, E: 0, W: Math.PI }
function oh(t, e, n) {
  var i = new et(t.x, e.y)
  return (n.containsPoint(i) && (i = new et(e.x, t.y)), i)
}
function bv(t, e) {
  return t[e === 'W' || e === 'E' ? 'width' : 'height']
}
function ui(t, e) {
  return t.x === e.x ? (t.y > e.y ? 'N' : 'S') : t.y === e.y ? (t.x > e.x ? 'W' : 'E') : null
}
function Of(t) {
  return new Pt(t.x, t.y, 0, 0)
}
function lh(t) {
  var e = Ia(t.padding || t.elementPadding || 20)
  return { x: -e.left, y: -e.top, width: e.left + e.right, height: e.top + e.bottom }
}
function $x(t, e) {
  return t.sourceBBox.clone().moveAndExpand(lh(e))
}
function tS(t, e) {
  return t.targetBBox.clone().moveAndExpand(lh(e))
}
function sD(t, e) {
  if (t.sourceAnchor) return t.sourceAnchor
  var n = $x(t, e)
  return n.center()
}
function oD(t, e) {
  if (t.targetAnchor) return t.targetAnchor
  var n = tS(t, e)
  return n.center()
}
function eS(t, e, n) {
  var i = new et(t.x, e.y),
    s = new et(e.x, t.y),
    o = ui(t, i),
    u = ui(t, s),
    c = rD[n],
    h = o === n || (o !== c && (u === c || u !== n)) ? i : s
  return { points: [h], direction: ui(h, e) }
}
function Vf(t, e, n) {
  var i = oh(t, e, n)
  return { points: [i], direction: ui(i, e) }
}
function lD(t, e, n, i) {
  var s = {},
    o = [new et(t.x, e.y), new et(e.x, t.y)],
    u = o.filter(function (v) {
      return !n.containsPoint(v)
    }),
    c = u.filter(function (v) {
      return ui(v, t) !== i
    }),
    h
  if (c.length > 0)
    ((h = c
      .filter(function (v) {
        return ui(t, v) === i
      })
      .pop()),
      (h = h || c[0]),
      (s.points = [h]),
      (s.direction = ui(h, e)))
  else {
    h = km(o, u)[0]
    var p = new et(e).move(h, -bv(n, i) / 2),
      y = oh(p, t, n)
    ;((s.points = [y, p]), (s.direction = ui(p, e)))
  }
  return s
}
function uD(t, e, n, i) {
  var s = Vf(e, t, i),
    o = s.points[0]
  if (n.containsPoint(o)) {
    s = Vf(t, e, n)
    var u = s.points[0]
    if (i.containsPoint(u)) {
      var c = new et(t).move(u, -bv(n, ui(t, u)) / 2),
        h = new et(e).move(o, -bv(i, ui(e, o)) / 2),
        p = new Ut(c, h).midpoint(),
        y = Vf(t, p, n),
        v = eS(p, e, y.direction)
      ;((s.points = [y.points[0], v.points[0]]), (s.direction = v.direction))
    }
  }
  return s
}
function Qg(t, e, n, i, s) {
  var o = {},
    u = n.union(i).inflate(1),
    c = u.center().distance(e) > u.center().distance(t),
    h = c ? e : t,
    p = c ? t : e,
    y,
    v,
    C
  return (
    s
      ? ((y = et.fromPolar(u.width + u.height, aD[s], h)),
        (y = u.pointNearestToPoint(y).move(y, -1)))
      : (y = u.pointNearestToPoint(h).move(h, 1)),
    (v = oh(y, p, u)),
    y.round().equals(v.round())
      ? ((v = et.fromPolar(u.width + u.height, Ai(y.theta(h)) + Math.PI / 2, p)),
        (v = u.pointNearestToPoint(v).move(p, 1).round()),
        (C = oh(y, v, u)),
        (o.points = c ? [v, C, y] : [y, C, v]))
      : (o.points = c ? [v, y] : [y, v]),
    (o.direction = ui(c ? y : v, e)),
    o
  )
}
function Iv(t, e, n) {
  var i = $x(n, e),
    s = tS(n, e),
    o = sD(n, e),
    u = oD(n, e)
  ;((i = i.union(Of(o))), (s = s.union(Of(u))), (t = xe(t).map(et)), t.unshift(o), t.push(u))
  for (var c, h = [], p = 0, y = t.length - 1; p < y; p++) {
    var v = null,
      C = t[p],
      w = t[p + 1],
      N = !!ui(C, w)
    if (p === 0)
      p + 1 === y
        ? i.intersect(s.clone().inflate(1))
          ? (v = Qg(C, w, i, s))
          : N || (v = uD(C, w, i, s))
        : i.containsPoint(w)
          ? (v = Qg(C, w, i, Of(w).moveAndExpand(lh(e))))
          : N || (v = Vf(C, w, i))
    else if (p + 1 === y) {
      var T = N && ui(w, C) === c
      s.containsPoint(C) || T
        ? (v = Qg(C, w, Of(C).moveAndExpand(lh(e)), s, c))
        : N || (v = lD(C, w, s, c))
    } else N || (v = eS(C, w, c))
    ;(v ? (Array.prototype.push.apply(h, v.points), (c = v.direction)) : (c = ui(C, w)),
      p + 1 < y && h.push(w))
  }
  return h
}
var nS = {
  step: 10,
  maximumLoops: 2e3,
  precision: 1,
  maxAllowedDirectionChange: 90,
  perpendicular: !0,
  excludeEnds: [],
  excludeTypes: ['basic.Text'],
  startDirections: ['top', 'right', 'bottom', 'left'],
  endDirections: ['top', 'right', 'bottom', 'left'],
  directionMap: {
    top: { x: 0, y: -1 },
    right: { x: 1, y: 0 },
    bottom: { x: 0, y: 1 },
    left: { x: -1, y: 0 },
  },
  cost: function () {
    return this.step
  },
  directions: function () {
    var t = this.step,
      e = this.cost()
    return [
      { offsetX: t, offsetY: 0, cost: e },
      { offsetX: -t, offsetY: 0, cost: e },
      { offsetX: 0, offsetY: t, cost: e },
      { offsetX: 0, offsetY: -t, cost: e },
    ]
  },
  penalties: function () {
    return { 0: 0, 45: this.step / 2, 90: this.step / 2 }
  },
  paddingBox: function () {
    var t = this.step
    return { x: -t, y: -t, width: 2 * t, height: 2 * t }
  },
  isPointObstacle: null,
  fallbackRouter: function (t, e, n) {
    if (!Ze(Iv)) throw new Error('Manhattan requires the orthogonal router as default fallback.')
    return Iv(t, Kt({}, nS, e), n)
  },
  fallbackRoute: function (t, e, n) {
    return null
  },
  draggingRoute: null,
}
function Um(t) {
  ;((this.map = {}), (this.options = t), (this.mapGridSize = 100))
}
Um.prototype.build = function (t, e) {
  var n = this.options,
    i = xe(n.excludeEnds).reduce(function (h, p) {
      var y = e.get(p)
      if (y) {
        var v = t.getCell(y.id)
        v && h.push(v)
      }
      return h
    }, []),
    s = [],
    o = t.getCell(e.get('source').id)
  o &&
    (s = nh(
      s,
      o.getAncestors().map(function (h) {
        return h.id
      })
    ))
  var u = t.getCell(e.get('target').id)
  u &&
    (s = nh(
      s,
      u.getAncestors().map(function (h) {
        return h.id
      })
    ))
  var c = this.mapGridSize
  return (
    t.getElements().reduce(function (h, p) {
      var y = xe(n.excludeTypes).includes(p.get('type')),
        v = i.find(function (Z) {
          return Z.id === p.id
        }),
        C = s.includes(p.id),
        w = y || v || C
      if (!w)
        for (
          var N = p.getBBox().moveAndExpand(n.paddingBox),
            T = N.origin().snapToGrid(c),
            z = N.corner().snapToGrid(c),
            R = T.x;
          R <= z.x;
          R += c
        )
          for (var B = T.y; B <= z.y; B += c) {
            var H = R + '@' + B
            ;((h[H] = h[H] || []), h[H].push(N))
          }
      return h
    }, this.map),
    this
  )
}
Um.prototype.isPointAccessible = function (t) {
  var e = t.clone().snapToGrid(this.mapGridSize).toString()
  return xe(this.map[e]).every(function (n) {
    return !n.containsPoint(t)
  })
}
function oo() {
  ;((this.items = []), (this.hash = {}), (this.values = {}), (this.OPEN = 1), (this.CLOSE = 2))
}
oo.prototype.add = function (t, e) {
  ;(this.hash[t] ? this.items.splice(this.items.indexOf(t), 1) : (this.hash[t] = this.OPEN),
    (this.values[t] = e))
  var n = Rm(
    this.items,
    t,
    function (i) {
      return this.values[i]
    }.bind(this)
  )
  this.items.splice(n, 0, t)
}
oo.prototype.remove = function (t) {
  this.hash[t] = this.CLOSE
}
oo.prototype.isOpen = function (t) {
  return this.hash[t] === this.OPEN
}
oo.prototype.isClose = function (t) {
  return this.hash[t] === this.CLOSE
}
oo.prototype.isEmpty = function () {
  return this.items.length === 0
}
oo.prototype.pop = function () {
  var t = this.items.shift()
  return (this.remove(t), t)
}
function iS(t, e) {
  return e && e.paddingBox ? t.sourceBBox.clone().moveAndExpand(e.paddingBox) : t.sourceBBox.clone()
}
function rS(t, e) {
  return e && e.paddingBox ? t.targetBBox.clone().moveAndExpand(e.paddingBox) : t.targetBBox.clone()
}
function aS(t, e) {
  if (t.sourceAnchor) return t.sourceAnchor
  var n = iS(t, e)
  return n.center()
}
function cD(t, e) {
  if (t.targetAnchor) return t.targetAnchor
  var n = rS(t, e)
  return n.center()
}
function Kg(t, e, n, i, s) {
  var o = 360 / n,
    u = t.theta(fD(t, e, i, s)),
    c = Dr(u + o / 2)
  return o * Math.floor(c / o)
}
function fD(t, e, n, i) {
  var s = i.step,
    o = e.x - t.x,
    u = e.y - t.y,
    c = o / n.x,
    h = u / n.y,
    p = c * s,
    y = h * s
  return new et(t.x + p, t.y + y)
}
function Ub(t, e) {
  var n = Math.abs(t - e)
  return n > 180 ? 360 - n : n
}
function hD(t, e, n) {
  var i = n.step
  xe(n.directions).forEach(function (s) {
    ;((s.gridOffsetX = (s.offsetX / i) * e.x), (s.gridOffsetY = (s.offsetY / i) * e.y))
  })
}
function dD(t, e, n) {
  return { source: e.clone(), x: Yb(n.x - e.x, t), y: Yb(n.y - e.y, t) }
}
function Yb(t, e) {
  if (!t) return e
  var n = Math.abs(t),
    i = Math.round(n / e)
  if (!i) return n
  var s = i * e,
    o = n - s,
    u = o / i
  return e + u
}
function gD(t, e) {
  var n = e.source,
    i = to(t.x - n.x, e.x) + n.x,
    s = to(t.y - n.y, e.y) + n.y
  return new et(i, s)
}
function Nu(t, e) {
  return t.round(e)
}
function Xf(t, e, n) {
  return Nu(gD(t.clone(), e), n)
}
function Du(t) {
  return t.clone().toString()
}
function $g(t) {
  return new et(t.x === 0 ? 0 : Math.abs(t.x) / t.x, t.y === 0 ? 0 : Math.abs(t.y) / t.y)
}
function pD(t, e, n, i, s, o, u) {
  for (var c = [], h = $g(s.difference(n)), p = Du(n), y = t[p], v; y; ) {
    v = e[p]
    var C = $g(v.difference(y))
    ;(C.equals(h) || (c.unshift(v), (h = C)), (p = Du(y)), (y = t[p]))
  }
  var w = e[p],
    N = $g(w.difference(i))
  return (N.equals(h) || c.unshift(w), c)
}
function Hb(t, e) {
  for (var n = 1 / 0, i = 0, s = e.length; i < s; i++) {
    var o = t.manhattanDistance(e[i])
    o < n && (n = o)
  }
  return n
}
function Vb(t, e, n, i, s) {
  var o = s.precision,
    u = s.directionMap,
    c = t.difference(e.center()),
    h = ze(u) ? Object.keys(u) : [],
    p = xe(n),
    y = h.reduce(function (v, C) {
      if (p.includes(C)) {
        for (
          var w = u[C],
            N = new et(
              t.x + w.x * (Math.abs(c.x) + e.width),
              t.y + w.y * (Math.abs(c.y) + e.height)
            ),
            T = new Ut(t, N),
            z = T.intersect(e) || [],
            R = z.length,
            B,
            H = null,
            Z = 0;
          Z < R;
          Z++
        ) {
          var U = z[Z],
            nt = t.squaredDistance(U)
          ;(B === void 0 || nt > B) && ((B = nt), (H = U))
        }
        if (H) {
          var g = Xf(H, i, o)
          ;(e.containsPoint(g) && (g = Xf(g.offset(w.x * i.x, w.y * i.y), i, o)), v.push(g))
        }
      }
      return v
    }, [])
  return (e.containsPoint(t) || y.push(Xf(t, i, o)), y)
}
function vD(t, e, n, i) {
  var s = i.precision,
    o,
    u
  ;(t instanceof Pt ? (o = Nu(aS(this, i).clone(), s)) : (o = Nu(t.clone(), s)),
    e instanceof Pt ? (u = Nu(cD(this, i).clone(), s)) : (u = Nu(e.clone(), s)))
  var c = dD(i.step, o, u),
    h,
    p,
    y,
    v
  if (
    (t instanceof Pt ? ((h = o), (y = Vb(h, t, i.startDirections, c, i))) : ((h = o), (y = [h])),
    e instanceof Pt ? ((p = u), (v = Vb(u, e, i.endDirections, c, i))) : ((p = u), (v = [p])),
    (y = y.filter(qt => !n(qt))),
    (v = v.filter(qt => !n(qt))),
    y.length > 0 && v.length > 0)
  ) {
    for (var C = new oo(), w = {}, N = {}, T = {}, z = 0, R = y.length; z < R; z++) {
      var B = y[z],
        H = Du(B)
      ;(C.add(H, Hb(B, v)), (w[H] = B), (T[H] = 0))
    }
    var Z = i.previousDirectionAngle,
      U = Z === void 0,
      nt,
      g,
      S = i.directions
    hD(S, c, i)
    for (
      var M = S.length,
        _ = xe(v).reduce(function (qt, de) {
          var Xt = Du(de)
          return (qt.push(Xt), qt)
        }, []),
        W = i.maximumLoops;
      !C.isEmpty() && W > 0;

    ) {
      var $ = C.pop(),
        X = w[$],
        Ct = N[$],
        Tt = T[$],
        G = Ct === void 0,
        Q = X.equals(h),
        it
      G ? (U ? (Q ? (it = null) : (it = Kg(h, X, M, c, i))) : (it = Z)) : (it = Kg(Ct, X, M, c, i))
      var st = y.length === v.length
      if (st) {
        for (var F = 0; F < y.length; F++)
          if (!y[F].equals(v[F])) {
            st = !1
            break
          }
      }
      var ht = G && st
      if (!ht && _.indexOf($) >= 0) return ((i.previousDirectionAngle = it), pD(N, w, X, h, p))
      for (z = 0; z < M; z++) {
        nt = S[z]
        var ct = nt.angle
        if (((g = Ub(it, ct)), !(!(U && Q) && g > i.maxAllowedDirectionChange))) {
          var St = Xf(X.clone().offset(nt.gridOffsetX, nt.gridOffsetY), c, s),
            bt = Du(St)
          if (!(C.isClose(bt) || n(St))) {
            if (_.indexOf(bt) >= 0) {
              var kt = St.equals(p)
              if (!kt) {
                var lt = Kg(St, p, M, c, i),
                  gt = Ub(ct, lt)
                if (gt > i.maxAllowedDirectionChange) continue
              }
            }
            var Et = nt.cost,
              Ft = Q ? 0 : i.penalties[g],
              Qt = Tt + Et + Ft
            ;(!C.isOpen(bt) || Qt < T[bt]) &&
              ((w[bt] = St), (N[bt] = X), (T[bt] = Qt), C.add(bt, Qt + Hb(St, v)))
          }
        }
      }
      W--
    }
  }
  return i.fallbackRoute.call(this, h, p, i)
}
function mD(t) {
  if (
    ((t.directions = dn(t, 'directions')),
    (t.penalties = dn(t, 'penalties')),
    (t.paddingBox = dn(t, 'paddingBox')),
    (t.padding = dn(t, 'padding')),
    t.padding)
  ) {
    var e = Ia(t.padding)
    t.paddingBox = { x: -e.left, y: -e.top, width: e.left + e.right, height: e.top + e.bottom }
  }
  xe(t.directions).forEach(function (n) {
    var i = new et(0, 0),
      s = new et(n.offsetX, n.offsetY)
    n.angle = Dr(i.theta(s))
  })
}
function yD(t, e, n) {
  ;(mD(e), (n.options.perpendicular = !!e.perpendicular))
  var i = iS(n, e),
    s = rS(n, e),
    o = aS(n, e)
  let u
  if (typeof e.isPointObstacle == 'function') u = e.isPointObstacle
  else {
    const H = new Um(e)
    ;(H.build(n.paper.model, n.model), (u = Z => !H.isPointAccessible(Z)))
  }
  for (var c = xe(t).map(et), h = [], p = o, y, v, C = 0, w = c.length; C <= w; C++) {
    var N = null
    if (((v = y || i), (y = c[C]), !y)) {
      y = s
      var T = !n.model.get('source').id || !n.model.get('target').id
      if (T && Ze(e.draggingRoute)) {
        var z = v === i ? o : v,
          R = y.origin()
        N = e.draggingRoute.call(n, z, R, e)
      }
    }
    if (((N = N || vD.call(n, v, y, u, e)), N === null)) return e.fallbackRouter(t, e, n)
    var B = N[0]
    ;(B && B.equals(p) && N.shift(), (p = N[N.length - 1] || p), Array.prototype.push.apply(h, N))
  }
  return h
}
const Cv = function (t, e, n) {
  return yD(t, Kt({}, nS, e), n)
}
var AD = {
  maxAllowedDirectionChange: 45,
  diagonalCost: function () {
    var t = this.step
    return Math.ceil(Math.sqrt((t * t) << 1))
  },
  directions: function () {
    var t = this.step,
      e = this.cost(),
      n = this.diagonalCost()
    return [
      { offsetX: t, offsetY: 0, cost: e },
      { offsetX: t, offsetY: t, cost: n },
      { offsetX: 0, offsetY: t, cost: e },
      { offsetX: -t, offsetY: t, cost: n },
      { offsetX: -t, offsetY: 0, cost: e },
      { offsetX: -t, offsetY: -t, cost: n },
      { offsetX: 0, offsetY: -t, cost: e },
      { offsetX: t, offsetY: -t, cost: n },
    ]
  },
  fallbackRoute: function (t, e, n) {
    var i = t.theta(e),
      s = [],
      o = { x: e.x, y: t.y },
      u = { x: t.x, y: e.y }
    if (i % 180 > 90) {
      var c = o
      ;((o = u), (u = c))
    }
    var h = i % 90 < 45 ? o : u,
      p = new Ut(t, h),
      y = 90 * Math.ceil(i / 90),
      v = et.fromPolar(p.squaredLength(), Ai(y + 135), h),
      C = new Ut(e, v),
      w = p.intersection(C),
      N = w || e,
      T = w ? N : t,
      z = 360 / n.directions.length,
      R = T.theta(e),
      B = Dr(R + z / 2),
      H = z * Math.floor(B / z)
    return ((n.previousDirectionAngle = H), N && s.push(N.round()), s.push(e), s)
  },
}
const bD = function (t, e, n) {
    if (!Ze(Cv)) throw new Error('Metro requires the manhattan router.')
    return Cv(t, Kt({}, AD, e), n)
  },
  Rt = {
    AUTO: 'auto',
    LEFT: 'left',
    RIGHT: 'right',
    TOP: 'top',
    BOTTOM: 'bottom',
    ANCHOR_SIDE: 'anchor-side',
    MAGNET_SIDE: 'magnet-side',
  },
  Xb = [Rt.LEFT, Rt.RIGHT, Rt.TOP, Rt.BOTTOM],
  al = { [Rt.LEFT]: Rt.RIGHT, [Rt.RIGHT]: Rt.LEFT, [Rt.TOP]: Rt.BOTTOM, [Rt.BOTTOM]: Rt.TOP },
  ID = [Rt.TOP, Rt.BOTTOM],
  Lf = { 0: Rt.RIGHT, 180: Rt.LEFT, 270: Rt.TOP, 90: Rt.BOTTOM }
function Tu(t) {
  return t.angle()
}
function zf(t) {
  return new qe(t).simplify({ threshold: 1 }).points
}
function uh(t, e) {
  const { point: n, x0: i, y0: s, view: o, bbox: u, direction: c } = t,
    { point: h, x0: p, y0: y, view: v, bbox: C, direction: w } = e
  let N
  if (o)
    o.model.isLink()
      ? (N = Wb(h, n, o))
      : c === Rt.ANCHOR_SIDE
        ? (N = u.sideNearestToPoint(n))
        : c === Rt.MAGNET_SIDE
          ? (N = o.model.getBBox().sideNearestToPoint(n))
          : (N = c)
  else {
    const z = new Pt(i, s, 0, 0)
    N = Xb.includes(c) ? c : z.sideNearestToPoint(h)
  }
  let T
  if (v)
    v.model.isLink()
      ? (T = Wb(n, h, v))
      : w === Rt.ANCHOR_SIDE
        ? (T = C.sideNearestToPoint(h))
        : w === Rt.MAGNET_SIDE
          ? (T = v.model.getBBox().sideNearestToPoint(h))
          : (T = w)
  else {
    const z = new Pt(p, y, 0, 0)
    T = Xb.includes(w) ? w : z.sideNearestToPoint(n)
  }
  return [N, T]
}
function CD(t, e, n) {
  const { x0: i, y0: s, width: o, height: u, point: c, margin: h } = t,
    p = i + o,
    y = s + u,
    v = i - h,
    C = p + h,
    w = s - h,
    { x: N } = c,
    { x0: T, y0: z } = e
  return T === N && z < s
    ? Rt.BOTTOM
    : T < N && z < w
      ? Rt.RIGHT
      : T > N && z < w
        ? Rt.LEFT
        : (T < v && z >= s) || (T > C && z >= s)
          ? Rt.TOP
          : (T >= v && T <= N && z > y) || (T <= C && T >= N && z > y)
            ? n.point.x < T
              ? Rt.RIGHT
              : Rt.LEFT
            : Rt.TOP
}
function wD(t, e, n) {
  const { x0: i, y0: s, width: o, height: u, point: c, margin: h } = t,
    p = i + o,
    y = s + u,
    v = i - h,
    C = p + h,
    w = y + h,
    { x: N } = c,
    { x0: T, y0: z } = e
  return T === N && z > y
    ? Rt.TOP
    : T < N && z > w
      ? Rt.RIGHT
      : T > N && z > w
        ? Rt.LEFT
        : (T < v && z <= y) || (T > C && z <= y)
          ? Rt.BOTTOM
          : (T >= v && T <= N && z < s) || (T <= C && T >= N && z < s)
            ? n.point.x < T
              ? Rt.RIGHT
              : Rt.LEFT
            : Rt.BOTTOM
}
function xD(t, e, n) {
  const { y0: i, x0: s, width: o, height: u, point: c, margin: h } = t,
    p = s + o,
    y = i + u,
    v = s - h,
    C = i - h,
    w = y + h,
    { x: N, y: T } = c,
    { x0: z, y0: R } = e
  return z < N && R === T
    ? Rt.RIGHT
    : z <= v && R < T
      ? Rt.BOTTOM
      : z <= v && R > T
        ? Rt.TOP
        : (z >= s && R <= C) || (z >= s && R >= w)
          ? Rt.LEFT
          : (z > p && R >= C && R <= T) || (z > p && R <= w && R >= T)
            ? n.point.y < R
              ? Rt.BOTTOM
              : Rt.TOP
            : Rt.LEFT
}
function SD(t, e, n) {
  const { y0: i, x0: s, width: o, height: u, point: c, margin: h } = t,
    p = s + o,
    y = i + u,
    v = p + h,
    C = i - h,
    w = y + h,
    { x: N, y: T } = c,
    { x0: z, y0: R } = e
  return z > N && R === T
    ? Rt.LEFT
    : z >= v && R < T
      ? Rt.BOTTOM
      : z >= v && R > T
        ? Rt.TOP
        : (z <= p && R <= C) || (z <= p && R >= w)
          ? Rt.RIGHT
          : (z < s && R >= C && R <= T) || (z < s && R <= w && R >= T)
            ? n.point.y < R
              ? Rt.BOTTOM
              : Rt.TOP
            : Rt.RIGHT
}
function ND(t, e, n) {
  const [i] = uh(t, e)
  switch (i) {
    case Rt.TOP:
      return CD(t, e, n)
    case Rt.RIGHT:
      return SD(t, e, n)
    case Rt.BOTTOM:
      return wD(t, e, n)
    case Rt.LEFT:
      return xD(t, e, n)
  }
}
function Wb(t, e, n) {
  const i = n.getTangentAtLength(n.getClosestPointLength(e)),
    s = Math.round(Tu(i) / 90) * 90
  if (s % 180 === 0 && t.y === e.y) return t.x < e.x ? Rt.LEFT : Rt.RIGHT
  if (t.x === e.x) return t.y < e.y ? Rt.TOP : Rt.BOTTOM
  switch (s) {
    case 0:
    case 180:
    case 360:
      return t.y < e.y ? Rt.TOP : Rt.BOTTOM
    case 90:
    case 270:
      return t.x < e.x ? Rt.LEFT : Rt.RIGHT
  }
}
function Fb(t, e, n, i, s, o, u) {
  i === Rt.AUTO && (i = s ? Rt.MAGNET_SIDE : Rt.ANCHOR_SIDE)
  const c = t && t.model.isElement(),
    { x: h, y: p, width: y = 0, height: v = 0 } = c ? Pt.fromRectUnion(n, t.model.getBBox()) : o
  return {
    point: e,
    x0: h,
    y0: p,
    view: t,
    bbox: n,
    width: y,
    height: v,
    direction: i,
    margin: c ? u : 0,
  }
}
function tp({ x: t, y: e }) {
  const n = new et(t, e)
  return {
    point: n,
    x0: n.x,
    y0: n.y,
    view: null,
    bbox: new Pt(t, e, 0, 0),
    width: 0,
    height: 0,
    direction: null,
    margin: 0,
  }
}
function Jb(t, e, n) {
  const i = e.point.clone(),
    { x0: s, y0: o, width: u, height: c } = e
  switch (t) {
    case 'left':
      i.x = s - n
      break
    case 'right':
      i.x = s + u + n
      break
    case 'top':
      i.y = o - n
      break
    case 'bottom':
      i.y = o + c + n
      break
  }
  return i
}
function ss(t, e) {
  const { point: n, x0: i, y0: s, view: o, width: u, height: c, margin: h } = t,
    { point: p, x0: y, y0: v, width: C, height: w, margin: N } = e,
    T = y + C,
    z = v + w,
    R = i + u,
    B = s + c,
    H = o && o.model.isElement(),
    Z = i - h,
    U = R + h,
    nt = s - h,
    g = B + h,
    S = y - N,
    M = T + N,
    _ = v - N,
    W = z + N,
    [$, X] = uh(t, e),
    Ct = Jb($, { point: n, x0: i, y0: s, width: u, height: c }, h),
    Tt = Jb(X, { point: p, x0: y, y0: v, width: C, height: w }, N),
    { x: G, y: Q } = Ct,
    { x: it, y: st } = Tt,
    F = (y + T) / 2,
    ht = (v + z) / 2,
    ct = (i + R) / 2,
    St = (s + B) / 2,
    bt = (ct < F ? R + y : T + i) / 2,
    kt = (St < ht ? B + v : z + s) / 2
  if ($ === 'left' && X === 'right') {
    if (Z <= M) {
      let gt = kt
      return (
        R <= y &&
          (z >= nt && st < Q ? (gt = Math.min(_, nt)) : v <= g && st >= Q && (gt = Math.max(W, g))),
        [
          { x: G, y: Q },
          { x: G, y: gt },
          { x: it, y: gt },
          { x: it, y: st },
        ]
      )
    }
    const lt = (G + it) / 2
    return [
      { x: lt, y: Q },
      { x: lt, y: st },
    ]
  } else if ($ === 'right' && X === 'left') {
    if (U >= S) {
      let gt = kt
      return (
        G > T &&
          (z >= nt && st < Q ? (gt = Math.min(_, nt)) : v <= g && st >= Q && (gt = Math.max(W, g))),
        [
          { x: G, y: Q },
          { x: G, y: gt },
          { x: it, y: gt },
          { x: it, y: st },
        ]
      )
    }
    const lt = (G + it) / 2
    return [
      { x: lt, y: Q },
      { x: lt, y: st },
    ]
  } else if ($ === 'top' && X === 'bottom') {
    if (Q < st) {
      let gt = bt,
        Et = Q
      return (
        Q < v &&
          (T >= Z && it < G ? (gt = Math.min(S, Z)) : y <= U && it >= G && (gt = Math.max(M, U))),
        [
          { x: G, y: Et },
          { x: gt, y: Et },
          { x: gt, y: st },
          { x: it, y: st },
        ]
      )
    }
    const lt = (Q + st) / 2
    return [
      { x: G, y: lt },
      { x: it, y: lt },
    ]
  } else if ($ === 'bottom' && X === 'top') {
    if (Q - h > st) {
      let gt = bt,
        Et = Q
      return (
        Q > z &&
          (T >= Z && it < G ? (gt = Math.min(S, Z)) : y <= U && it >= G && (gt = Math.max(M, U))),
        [
          { x: G, y: Et },
          { x: gt, y: Et },
          { x: gt, y: st },
          { x: it, y: st },
        ]
      )
    }
    const lt = (Q + st) / 2
    return [
      { x: G, y: lt },
      { x: it, y: lt },
    ]
  } else if ($ === 'top' && X === 'top') {
    let lt,
      gt = Math.min((B + v) / 2, st),
      Et = Math.min((s + z) / 2, Q)
    if (st < Q) {
      if (G >= M || G <= S)
        return [
          { x: G, y: Math.min(Q, st) },
          { x: it, y: Math.min(Q, st) },
        ]
      it > G ? (lt = Math.min(G, S)) : (lt = Math.max(G, M))
    } else {
      if (it >= U || it <= Z)
        return [
          { x: G, y: Math.min(Q, st) },
          { x: it, y: Math.min(Q, st) },
        ]
      it >= G ? (lt = Math.max(it, U)) : (lt = Math.min(it, Z))
    }
    return [
      { x: G, y: Et },
      { x: lt, y: Et },
      { x: lt, y: gt },
      { x: it, y: gt },
    ]
  } else if ($ === 'bottom' && X === 'bottom') {
    let lt,
      gt = Math.max((s + z) / 2, st),
      Et = Math.max((B + v) / 2, Q)
    if (st > Q) {
      if (G >= M || G <= S)
        return [
          { x: G, y: Math.max(Q, st) },
          { x: it, y: Math.max(Q, st) },
        ]
      it > G ? (lt = Math.min(G, S)) : (lt = Math.max(G, M))
    } else {
      if (it >= U || it <= Z)
        return [
          { x: G, y: Math.max(Q, st) },
          { x: it, y: Math.max(Q, st) },
        ]
      it >= G ? (lt = Math.max(it, U)) : (lt = Math.min(it, Z))
    }
    return [
      { x: G, y: Et },
      { x: lt, y: Et },
      { x: lt, y: gt },
      { x: it, y: gt },
    ]
  } else if ($ === 'left' && X === 'left') {
    let lt,
      gt = Math.min((R + y) / 2, it),
      Et = Math.min((i + T) / 2, G)
    return (
      it > G
        ? st <= Q
          ? (lt = Math.min(nt, st))
          : (lt = Math.max(g, st))
        : st >= Q
          ? (lt = Math.min(_, Q))
          : (lt = Math.max(W, Q)),
      [
        { x: Et, y: Q },
        { x: Et, y: lt },
        { x: gt, y: lt },
        { x: gt, y: st },
      ]
    )
  } else if ($ === 'right' && X === 'right') {
    let lt,
      gt = Math.max((i + T) / 2, it),
      Et = Math.max((R + y) / 2, G)
    return (
      it < G
        ? st <= Q
          ? (lt = Math.min(nt, st))
          : (lt = Math.max(g, st))
        : st >= Q
          ? (lt = Math.min(_, Q))
          : (lt = Math.max(W, Q)),
      [
        { x: Et, y: Q },
        { x: Et, y: lt },
        { x: gt, y: lt },
        { x: gt, y: st },
      ]
    )
  } else if ($ === 'top' && X === 'right') {
    if (Q > st) {
      if (G < it) {
        let gt = kt
        return (
          (gt > ht || !H) && gt < W && G < y && (gt = _),
          [
            { x: G, y: gt },
            { x: it, y: gt },
            { x: it, y: st },
          ]
        )
      }
      return [{ x: G, y: st }]
    }
    const lt = Math.max(bt, M)
    if (it < G && st > s && st < B)
      return [
        { x: G, y: Q },
        { x: lt, y: Q },
        { x: lt, y: st },
      ]
    if ((lt > Z && st > s) || y > R) {
      const gt = Math.min(s - h, v - N),
        Et = Math.max(R + h, T + N)
      return [
        { x: G, y: gt },
        { x: Et, y: gt },
        { x: Et, y: st },
      ]
    }
    return [
      { x: G, y: Q },
      { x: Math.max(lt, it), y: Q },
      { x: Math.max(lt, it), y: st },
    ]
  } else if ($ === 'top' && X === 'left') {
    if (Q > st) {
      if (G > it) {
        let gt = kt
        return (
          (gt > ht || !H) && gt < W && G > T && (gt = _),
          [
            { x: G, y: gt },
            { x: it, y: gt },
            { x: it, y: st },
          ]
        )
      }
      return [{ x: G, y: st }]
    }
    const lt = Math.min(S, bt)
    if (G < it && B >= st)
      return [
        { x: G, y: Q },
        { x: lt, y: Q },
        { x: lt, y: st },
      ]
    if (lt < U && Q < z) {
      const gt = Math.min(nt, _),
        Et = Math.min(Z, S)
      return [
        { x: G, y: gt },
        { x: Et, y: gt },
        { x: Et, y: st },
      ]
    }
    return [
      { x: G, y: Q },
      { x: lt, y: Q },
      { x: lt, y: st },
    ]
  } else if ($ === 'bottom' && X === 'right') {
    if (Q < st) {
      if (G < it) {
        let gt = kt
        return (
          (gt < ht || !H) && gt > _ && G < y && (gt = W),
          [
            { x: G, y: gt },
            { x: it, y: gt },
            { x: it, y: st },
          ]
        )
      }
      return [{ x: G, y: st }]
    } else if (i < it) {
      const gt = Math.max(g, W),
        Et = Math.max(U, M)
      return [
        { x: G, y: gt },
        { x: Et, y: gt },
        { x: Et, y: st },
      ]
    }
    const lt = bt
    return [
      { x: G, y: Q },
      { x: lt, y: Q },
      { x: lt, y: st },
    ]
  } else if ($ === 'bottom' && X === 'left') {
    if (Q < st) {
      if (G > it) {
        let gt = kt
        return (
          (gt < ht || !H) && gt > _ && G > T && (gt = W),
          [
            { x: G, y: gt },
            { x: it, y: gt },
            { x: it, y: st },
          ]
        )
      }
      return [{ x: G, y: st }]
    } else if (R > it) {
      const gt = Math.max(g, W),
        Et = Math.min(Z, S)
      return [
        { x: G, y: gt },
        { x: Et, y: gt },
        { x: Et, y: st },
      ]
    }
    const lt = bt
    return [
      { x: G, y: Q },
      { x: lt, y: Q },
      { x: lt, y: st },
    ]
  } else if ($ === 'left' && X === 'bottom') {
    if (G >= it && Q >= W) return [{ x: it, y: Q }]
    if (G >= T && Q < st) {
      const Et = bt
      return [
        { x: Et, y: Q },
        { x: Et, y: st },
        { x: it, y: st },
      ]
    }
    if (it < R && z <= s) {
      const Et = kt
      return [
        { x: G, y: Q },
        { x: G, y: Et },
        { x: it, y: Et },
      ]
    }
    const lt = Math.min(S, G),
      gt = Math.max(g, W)
    return [
      { x: lt, y: Q },
      { x: lt, y: gt },
      { x: it, y: gt },
    ]
  } else if ($ === 'left' && X === 'top') {
    if (G > it && Q < _) return [{ x: it, y: Q }]
    if (G >= T && Q > st) {
      const Et = bt
      return [
        { x: Et, y: Q },
        { x: Et, y: st },
        { x: it, y: st },
      ]
    }
    if (it <= R && st > Q) {
      const Et = kt
      return [
        { x: G, y: Q },
        { x: G, y: Et },
        { x: it, y: Et },
      ]
    }
    const lt = st < Q ? Math.min(Z, S) : Z,
      gt = Math.min(nt, _)
    return [
      { x: lt, y: Q },
      { x: lt, y: gt },
      { x: it, y: gt },
    ]
  } else if ($ === 'right' && X === 'top') {
    if (G <= it && Q < _) return [{ x: it, y: Q }]
    if (R < y && Q > st) {
      let Et = bt
      return [
        { x: Et, y: Q },
        { x: Et, y: st },
        { x: it, y: st },
      ]
    }
    if (it < G && v > B) {
      const Et = kt
      return [
        { x: G, y: Q },
        { x: G, y: Et },
        { x: it, y: Et },
      ]
    }
    const lt = Math.max(U, M),
      gt = Math.min(nt, _)
    return [
      { x: lt, y: Q },
      { x: lt, y: gt },
      { x: it, y: gt },
    ]
  } else if ($ === 'right' && X === 'bottom') {
    if (G <= it && Q >= W) return [{ x: it, y: Q }]
    if (G <= S && Q < st) {
      const Et = bt
      return [
        { x: Et, y: Q },
        { x: Et, y: st },
        { x: it, y: st },
      ]
    }
    if (it > i && z < s) {
      const Et = kt
      return [
        { x: G, y: Q },
        { x: G, y: Et },
        { x: it, y: Et },
      ]
    }
    const lt = Math.max(M, G),
      gt = Math.max(g, W)
    return [
      { x: lt, y: Q },
      { x: lt, y: gt },
      { x: it, y: gt },
    ]
  }
}
function sS(t, e, n) {
  const { sourceDirection: i = Rt.AUTO, targetDirection: s = Rt.AUTO } = e,
    o = e.margin || 20,
    u = e.useVertices || !1,
    c = !!n.model.source().port,
    h = Fb(n.sourceView, n.sourceAnchor, n.sourceBBox, i, c, n.sourceAnchor, o),
    p = !!n.model.target().port,
    y = Fb(n.targetView, n.targetAnchor, n.targetBBox, s, p, n.targetAnchor, o)
  let v = []
  if (!u || t.length === 0) return zf(ss(h, y))
  const C = t.map(T => tp(T)),
    [w] = C
  if (
    h.view &&
    h.view.model.isElement() &&
    h.view.model.getBBox().inflate(o).containsPoint(w.point)
  ) {
    const [T] = uh(h, w),
      z = T,
      R = tp(h.point)
    ;((R.margin = o), (R.direction = T), (w.direction = z), v.push(...ss(R, w), w.point))
  } else {
    const T = C[1] || y,
      z = ND(h, w, T)
    ;((w.direction = z), v.push(...ss(h, w), w.point))
  }
  for (let T = 0; T < C.length - 1; T++) {
    const z = C[T],
      R = C[T + 1],
      B = new Ut(z.point, R.point),
      H = Tu(B)
    if (H % 90 === 0) {
      const nt = Lf[H],
        g = al[nt]
      if (nt !== z.direction) (v.push(z.point, R.point), (R.direction = g))
      else {
        const S = Dr(H - 90)
        let M = 0,
          _ = 0
        S === 90 ? (_ = -o) : S === 180 ? (M = -o) : S === 270 ? (_ = o) : S === 0 && (M = o)
        const W = { x: z.point.x + M, y: z.point.y + _ },
          $ = { x: R.point.x + M, y: R.point.y + _ },
          X = new Ut(R.point, $)
        ;((R.direction = Lf[Tu(X)]), v.push(z.point, W, $, R.point))
      }
      continue
    }
    const [Z, U] = ep(z, R)
    ;((z.direction = Z), (R.direction = U), v.push(...ss(z, R), R.point))
  }
  const N = C[C.length - 1]
  if (y.view && y.view.model.isElement())
    if (y.view.model.getBBox().inflate(o).containsPoint(N.point)) {
      const [T] = ep(N, y),
        z = tp(y.point),
        [, R] = uh(N, y)
      ;((z.margin = o), (z.direction = R), (N.direction = T), v.push(...ss(N, z)))
    } else {
      const T = zf(v),
        z = new Ut(T[T.length - 2], N.point),
        R = Lf[Math.round(Tu(z))]
      N.direction = R
      let B = ss(N, y)
      const [H, Z] = zf([...B, y.point]),
        U = new Ut(H, Z),
        nt = Math.round(Tu(U)),
        g = Lf[nt]
      ;(g !== R && R === al[g] && ((N.margin = o), (B = ss(N, y))), v.push(...B))
    }
  else {
    const [T] = ep(N, y)
    ;((N.direction = T), v.push(...ss(N, y)))
  }
  return zf(v)
}
function ep(t, e) {
  const n = t.direction,
    i = ID.includes(n)
  let s = t.direction,
    o = e.direction
  if (i) {
    const u = t.point.y > e.point.y,
      c = e.point.x - t.point.x
    n === Rt.BOTTOM
      ? ((s = u ? al[n] : c >= 0 ? Rt.RIGHT : Rt.LEFT),
        c > 0 ? (o = u ? Rt.LEFT : Rt.TOP) : c < 0 && (o = u ? Rt.RIGHT : Rt.TOP))
      : ((s = u ? (c >= 0 ? Rt.RIGHT : Rt.LEFT) : al[n]),
        c > 0 ? (o = u ? Rt.BOTTOM : Rt.LEFT) : c < 0 && (o = u ? Rt.BOTTOM : Rt.RIGHT))
  } else {
    const u = t.point.x > e.point.x,
      c = e.point.y - t.point.y
    n === Rt.RIGHT
      ? ((s = u ? al[n] : c >= 0 ? Rt.BOTTOM : Rt.TOP),
        c > 0 ? (o = u ? Rt.TOP : Rt.LEFT) : c < 0 && (o = u ? Rt.BOTTOM : Rt.LEFT))
      : ((s = u ? (c >= 0 ? Rt.BOTTOM : Rt.TOP) : al[n]),
        c > 0 ? (o = u ? Rt.RIGHT : Rt.TOP) : c < 0 && (o = u ? Rt.RIGHT : Rt.BOTTOM))
  }
  return [s, o]
}
sS.Directions = Rt
const TD = sS,
  oS = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        manhattan: Cv,
        metro: bD,
        normal: nD,
        oneSide: iD,
        orthogonal: Iv,
        rightAngle: TD,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  il = { POINT: 'point', CUBIC: 'cubic', LINE: 'line', GAP: 'gap' },
  MD = Object.values(il),
  ED = 10,
  DD = 1,
  Ym = function (t, e, n = [], i = {}) {
    const {
      cornerType: s = il.POINT,
      cornerRadius: o = ED,
      cornerPreserveAspectRatio: u = !1,
      precision: c = DD,
      raw: h = !1,
    } = i
    if (MD.indexOf(s) === -1)
      throw new Error('Invalid `cornerType` provided to `straight` connector.')
    let p
    if (s === il.POINT || !o) {
      const y = [t].concat(n).concat([e]),
        v = new qe(y)
      p = new Jt(v)
    } else {
      ;((p = new Jt()), p.appendSegment(Jt.createSegment('M', t)))
      let y
      const v = n.length
      for (let C = 0; C < v; C++) {
        const w = new et(n[C]),
          N = n[C - 1] || t,
          T = n[C + 1] || e,
          z = y || w.distance(N) / 2
        y = w.distance(T) / 2
        let R, B
        u ? (R = B = -Math.min(o, z, y)) : ((R = -Math.min(o, z)), (B = -Math.min(o, y)))
        const H = w.clone().move(N, R).round(c),
          Z = w.clone().move(T, B).round(c)
        switch ((p.appendSegment(Jt.createSegment('L', H)), s)) {
          case il.CUBIC: {
            const U = 0.3333333333333333,
              nt = 2 / 3,
              g = new et(U * H.x + nt * w.x, nt * w.y + U * H.y),
              S = new et(U * Z.x + nt * w.x, nt * w.y + U * Z.y)
            p.appendSegment(Jt.createSegment('C', g, S, Z))
            break
          }
          case il.LINE: {
            p.appendSegment(Jt.createSegment('L', Z))
            break
          }
          case il.GAP: {
            p.appendSegment(Jt.createSegment('M', Z))
            break
          }
        }
      }
      p.appendSegment(Jt.createSegment('L', e))
    }
    return h ? p : p.serialize()
  }
var OD = 5,
  qb = ['arc', 'gap', 'cubic'],
  LD = 0,
  Qb = 1,
  zD = ['smooth'],
  Rf = 1 / 3,
  kf = 2 / 3
function Kb(t, e) {
  let { x: n, y: i } = t,
    { x: s, y: o } = e
  if (n > s) {
    let u = n
    ;((n = s), (s = u), (u = i), (i = o), (o = u))
  }
  if (i > o) {
    let u = n
    ;((n = s), (s = u), (u = i), (i = o), (o = u))
  }
  return [new et(n, i), new et(s, o)]
}
function RD(t, e) {
  const [{ x: n, y: i }, { x: s, y: o }] = Kb(t.start, t.end),
    [{ x: u, y: c }, { x: h, y: p }] = Kb(e.start, e.end),
    y = n <= h && u <= s,
    v = i <= p && c <= o
  return y && v
}
function np(t, e, n) {
  var i = [].concat(t, n, e)
  return i.reduce(function (s, o, u) {
    var c = i[u + 1]
    return (c != null && (s[u] = Ks(o, c)), s)
  }, [])
}
function kD(t) {
  var e = t.paper,
    n = e._jumpOverUpdateList
  if (n == null) {
    n = e._jumpOverUpdateList = []
    var i = e.model
    ;(i.on('batch:stop', function () {
      this.hasActiveBatch() || _D(e)
    }),
      i.on('reset', function () {
        n = e._jumpOverUpdateList = []
      }))
  }
  n.indexOf(t) < 0 &&
    (n.push(t),
    t.listenToOnce(t.model, 'change:connector remove', function () {
      n.splice(n.indexOf(t), 1)
    }))
}
function _D(t) {
  for (var e = t._jumpOverUpdateList, n = 0; n < e.length; n++) {
    const i = e[n],
      s = i.getFlag(i.constructor.Flags.CONNECTOR)
    i.requestUpdate(s)
  }
}
function BD(t, e) {
  return xe(e).reduce(function (n, i) {
    var s = t.intersection(i)
    return (s && n.push(s), n)
  }, [])
}
function $b(t, e) {
  return Ks(t, e).squaredLength()
}
function jD(t, e, n) {
  return e.reduce(function (i, s, o) {
    if (s.skip === !0) return i
    var u = i.pop() || t,
      c = Ff(s).move(u.start, -n),
      h = Ff(s).move(u.start, +n),
      p = e[o + 1]
    if (p != null) {
      var y = h.distance(p)
      y <= n && ((h = p.move(u.start, y)), (p.skip = !0))
    } else {
      var v = c.distance(u.end)
      if (v < n * 2 + Qb) return (i.push(u), i)
    }
    var C = h.distance(u.start)
    if (C < n * 2 + Qb) return (i.push(u), i)
    var w = Ks(c, h)
    return ((w.isJump = !0), i.push(Ks(u.start, c), w, Ks(h, u.end)), i)
  }, [])
}
function tI(t, e, n, i) {
  var s = new Jt(),
    o
  return (
    (o = Jt.createSegment('M', t[0].start)),
    s.appendSegment(o),
    xe(t).forEach(function (u, c) {
      if (u.isJump) {
        var h, p, y, v
        if (n === 'arc') {
          ;((h = -90), (p = u.start.difference(u.end)))
          var C = +(p.x < 0 || (p.x === 0 && p.y < 0))
          C && (h += 180)
          var w = u.midpoint(),
            N = new Ut(w, u.end).rotate(w, h),
            T
          ;((T = new Ut(u.start, w)),
            (y = T.pointAt(2 / 3).rotate(u.start, h)),
            (v = N.pointAt(1 / 3).rotate(N.end, -h)),
            (o = Jt.createSegment('C', y, v, N.end)),
            s.appendSegment(o),
            (T = new Ut(w, u.end)),
            (y = N.pointAt(1 / 3).rotate(N.end, h)),
            (v = T.pointAt(1 / 3).rotate(u.end, -h)),
            (o = Jt.createSegment('C', y, v, u.end)),
            s.appendSegment(o))
        } else if (n === 'gap') ((o = Jt.createSegment('M', u.end)), s.appendSegment(o))
        else if (n === 'cubic') {
          h = u.start.theta(u.end)
          var z = e * 0.6,
            R = e * 1.35
          ;((p = u.start.difference(u.end)),
            (C = +(p.x < 0 || (p.x === 0 && p.y < 0))),
            C && (R *= -1),
            (y = et(u.start.x + z, u.start.y + R).rotate(u.start, h)),
            (v = et(u.end.x - z, u.end.y + R).rotate(u.end, h)),
            (o = Jt.createSegment('C', y, v, u.end)),
            s.appendSegment(o))
        }
      } else {
        var B = t[c + 1]
        i == 0 || !B || B.isJump
          ? ((o = Jt.createSegment('L', u.end)), s.appendSegment(o))
          : PD(i, s, u.end, u.start, B.end)
      }
    }),
    s
  )
}
function PD(t, e, n, i, s) {
  var o = n.distance(i) / 2,
    u = n.distance(s) / 2,
    c = -Math.min(t, o),
    h = -Math.min(t, u),
    p = n.clone().move(i, c).round(),
    y = n.clone().move(s, h).round(),
    v = new et(Rf * p.x + kf * n.x, kf * n.y + Rf * p.y),
    C = new et(Rf * y.x + kf * n.x, kf * n.y + Rf * y.y),
    w
  ;((w = Jt.createSegment('L', p)),
    e.appendSegment(w),
    (w = Jt.createSegment('C', v, C, y)),
    e.appendSegment(w))
}
const GD = function (t, e, n, i) {
    kD(this)
    var s = i.raw,
      o = i.size || OD,
      u = i.jump && ('' + i.jump).toLowerCase(),
      c = i.radius || LD,
      h = i.ignoreConnectors || zD
    qb.indexOf(u) === -1 && (u = qb[0])
    var p = this.paper,
      y = p.model,
      v = y.getLinks()
    if (v.length === 1) return tI(np(t, e, n), o, u, c)
    var C = this.model,
      w = v.indexOf(C),
      N = p.options.defaultConnector || {},
      T = v.filter(function (U, nt) {
        var g = U.get('connector') || N
        return xe(h).includes(g.name) ? !1 : nt > w ? g.name !== 'jumpover' : !0
      }),
      z = T.map(function (U) {
        return p.findViewByModel(U)
      }),
      R = np(t, e, n),
      B = z.map(function (U) {
        return U == null ? [] : U === this ? R : np(U.sourcePoint, U.targetPoint, U.route)
      }, this),
      H = R.reduce(function (U, nt) {
        var g = T.reduce(function (S, M, _) {
          if (M !== C) {
            const W = B[_].slice(),
              $ = W.findIndex(Ct => RD(nt, Ct))
            $ > -1 && nt.containsPoint(W[$].end) && W.splice($ + 1, 1)
            const X = BD(nt, W)
            S.push.apply(S, X)
          }
          return S
        }, []).sort(function (S, M) {
          return $b(nt.start, S) - $b(nt.start, M)
        })
        return (g.length > 0 ? U.push.apply(U, jD(nt, g, o)) : U.push(nt), U)
      }, []),
      Z = tI(H, o, u, c)
    return s ? Z : Z.serialize()
  },
  ZD = function (t, e, n = [], i = {}) {
    const { raw: s } = i
    return Ym(t, e, n, { cornerType: 'point', raw: s })
  },
  UD = 10,
  YD = 0,
  HD = function (t, e, n = [], i = {}) {
    const { radius: s = UD, raw: o } = i
    return Ym(t, e, n, { cornerType: 'cubic', cornerRadius: s, precision: YD, raw: o })
  },
  VD = function (t, e, n, i) {
    var s = i && i.raw,
      o
    if (n && n.length !== 0) {
      var u = [t].concat(n).concat([e]),
        c = Be.throughPoints(u)
      o = new Jt(c)
    } else {
      o = new Jt()
      var h
      if (
        ((h = Jt.createSegment('M', t)),
        o.appendSegment(h),
        Math.abs(t.x - e.x) >= Math.abs(t.y - e.y))
      ) {
        var p = (t.x + e.x) / 2
        ;((h = Jt.createSegment('C', p, t.y, p, e.y, e.x, e.y)), o.appendSegment(h))
      } else {
        var y = (t.y + e.y) / 2
        ;((h = Jt.createSegment('C', t.x, y, e.x, y, e.x, e.y)), o.appendSegment(h))
      }
    }
    return s ? o : o.serialize()
  },
  ar = {
    AUTO: 'auto',
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical',
    CLOSEST_POINT: 'closest-point',
    OUTWARDS: 'outwards',
  },
  si = {
    UP: 'up',
    DOWN: 'down',
    LEFT: 'left',
    RIGHT: 'right',
    AUTO: 'auto',
    CLOSEST_POINT: 'closest-point',
    OUTWARDS: 'outwards',
  },
  Hm = function (t, e, n = [], i = {}, s) {
    const o = !!i.raw,
      { direction: u = ar.AUTO, precision: c = 3 } = i,
      h = {
        coeff: i.distanceCoefficient || 0.6,
        angleTangentCoefficient: i.angleTangentCoefficient || 80,
        tau: i.tension || 0.5,
        sourceTangent: i.sourceTangent ? new et(i.sourceTangent) : null,
        targetTangent: i.targetTangent ? new et(i.targetTangent) : null,
        rotate: !!i.rotate,
      }
    ;(typeof i.sourceDirection == 'string'
      ? (h.sourceDirection = i.sourceDirection)
      : typeof i.sourceDirection == 'number'
        ? (h.sourceDirection = new et(1, 0).rotate(null, i.sourceDirection))
        : (h.sourceDirection = i.sourceDirection ? new et(i.sourceDirection).normalize() : null),
      typeof i.targetDirection == 'string'
        ? (h.targetDirection = i.targetDirection)
        : typeof i.targetDirection == 'number'
          ? (h.targetDirection = new et(1, 0).rotate(null, i.targetDirection))
          : (h.targetDirection = i.targetDirection ? new et(i.targetDirection).normalize() : null))
    const p = [t, ...n, e].map(T => new et(T))
    let y
    if (h.sourceTangent) y = h.sourceTangent
    else {
      const T = qD(s, p, u, h),
        z = p[0].distance(p[1]) * h.coeff,
        R = p[1].difference(p[0]).normalize(),
        B = wv(T, R)
      if (B > Math.PI / 4) {
        const H = z + (B - Math.PI / 4) * h.angleTangentCoefficient
        y = T.clone().scale(H, H)
      } else y = T.clone().scale(z, z)
    }
    let v
    if (h.targetTangent) v = h.targetTangent
    else {
      const T = QD(s, p, u, h),
        z = p.length - 1,
        R = p[z - 1].distance(p[z]) * h.coeff,
        B = p[z - 1].difference(p[z]).normalize(),
        H = wv(T, B)
      if (H > Math.PI / 4) {
        const Z = R + (H - Math.PI / 4) * h.angleTangentCoefficient
        v = T.clone().scale(Z, Z)
      } else v = T.clone().scale(R, R)
    }
    const w = $D(p, y, v, h).map(T => tO(T, h)),
      N = new Jt(w).round(c)
    return o ? N : N.serialize()
  }
Hm.Directions = ar
Hm.TangentDirections = si
function XD(t, e, n) {
  const { sourceBBox: i } = t
  let s, o
  if (!t.sourceView) i.x > e[1].x ? (s = 'right') : (s = 'left')
  else if (((o = t.sourceView.model.angle()), n.rotate && o)) {
    const c = t.sourceView.getNodeUnrotatedBBox(t.sourceView.el),
      h = e[0].clone()
    ;(h.rotate(i.center(), o), (s = c.sideNearestToPoint(h)))
  } else s = i.sideNearestToPoint(e[0])
  let u
  switch (s) {
    case 'left':
      u = new et(-1, 0)
      break
    case 'right':
    default:
      u = new et(1, 0)
      break
  }
  return (n.rotate && o && u.rotate(null, -o), u)
}
function WD(t, e, n) {
  const { targetBBox: i } = t
  let s, o
  if (!t.targetView) i.x > e[e.length - 2].x ? (s = 'left') : (s = 'right')
  else if (((o = t.targetView.model.angle()), n.rotate && o)) {
    const c = t.targetView.getNodeUnrotatedBBox(t.targetView.el),
      h = e[e.length - 1].clone()
    ;(h.rotate(i.center(), o), (s = c.sideNearestToPoint(h)))
  } else s = i.sideNearestToPoint(e[e.length - 1])
  let u
  switch (s) {
    case 'left':
      u = new et(-1, 0)
      break
    case 'right':
    default:
      u = new et(1, 0)
      break
  }
  return (n.rotate && o && u.rotate(null, -o), u)
}
function FD(t, e, n) {
  const { sourceBBox: i } = t
  let s, o
  if (!t.sourceView) i.y > e[1].y ? (s = 'bottom') : (s = 'top')
  else if (((o = t.sourceView.model.angle()), n.rotate && o)) {
    const c = t.sourceView.getNodeUnrotatedBBox(t.sourceView.el),
      h = e[0].clone()
    ;(h.rotate(i.center(), o), (s = c.sideNearestToPoint(h)))
  } else s = i.sideNearestToPoint(e[0])
  let u
  switch (s) {
    case 'top':
      u = new et(0, -1)
      break
    case 'bottom':
    default:
      u = new et(0, 1)
      break
  }
  return (n.rotate && o && u.rotate(null, -o), u)
}
function JD(t, e, n) {
  const { targetBBox: i } = t
  let s, o
  if (!t.targetView) i.y > e[e.length - 2].y ? (s = 'top') : (s = 'bottom')
  else if (((o = t.targetView.model.angle()), n.rotate && o)) {
    const c = t.targetView.getNodeUnrotatedBBox(t.targetView.el),
      h = e[e.length - 1].clone()
    ;(h.rotate(i.center(), o), (s = c.sideNearestToPoint(h)))
  } else s = i.sideNearestToPoint(e[e.length - 1])
  let u
  switch (s) {
    case 'top':
      u = new et(0, -1)
      break
    case 'bottom':
    default:
      u = new et(0, 1)
      break
  }
  return (n.rotate && o && u.rotate(null, -o), u)
}
function eI(t, e, n) {
  const { sourceBBox: i } = t
  let s, o
  if (!t.sourceView) s = i.sideNearestToPoint(e[1])
  else if (((o = t.sourceView.model.angle()), n.rotate && o)) {
    const c = t.sourceView.getNodeUnrotatedBBox(t.sourceView.el),
      h = e[0].clone()
    ;(h.rotate(i.center(), o), (s = c.sideNearestToPoint(h)))
  } else s = i.sideNearestToPoint(e[0])
  let u
  switch (s) {
    case 'top':
      u = new et(0, -1)
      break
    case 'bottom':
      u = new et(0, 1)
      break
    case 'right':
      u = new et(1, 0)
      break
    case 'left':
      u = new et(-1, 0)
      break
  }
  return (n.rotate && o && u.rotate(null, -o), u)
}
function nI(t, e, n) {
  const { targetBBox: i } = t
  let s, o
  if (!t.targetView) s = i.sideNearestToPoint(e[e.length - 2])
  else if (((o = t.targetView.model.angle()), n.rotate && o)) {
    const c = t.targetView.getNodeUnrotatedBBox(t.targetView.el),
      h = e[e.length - 1].clone()
    ;(h.rotate(i.center(), o), (s = c.sideNearestToPoint(h)))
  } else s = i.sideNearestToPoint(e[e.length - 1])
  let u
  switch (s) {
    case 'top':
      u = new et(0, -1)
      break
    case 'bottom':
      u = new et(0, 1)
      break
    case 'right':
      u = new et(1, 0)
      break
    case 'left':
      u = new et(-1, 0)
      break
  }
  return (n.rotate && o && u.rotate(null, -o), u)
}
function iI(t, e, n) {
  return e[1].difference(e[0]).normalize()
}
function rI(t, e, n) {
  const i = e.length - 1
  return e[i - 1].difference(e[i]).normalize()
}
function aI(t, e, n) {
  const { sourceBBox: i } = t,
    s = i.center()
  return e[0].difference(s).normalize()
}
function sI(t, e, n) {
  const { targetBBox: i } = t,
    s = i.center()
  return e[e.length - 1].difference(s).normalize()
}
function qD(t, e, n, i) {
  if (i.sourceDirection)
    switch (i.sourceDirection) {
      case si.UP:
        return new et(0, -1)
      case si.DOWN:
        return new et(0, 1)
      case si.LEFT:
        return new et(-1, 0)
      case si.RIGHT:
        return new et(1, 0)
      case si.AUTO:
        return eI(t, e, i)
      case si.CLOSEST_POINT:
        return iI(t, e)
      case si.OUTWARDS:
        return aI(t, e)
      default:
        return i.sourceDirection
    }
  switch (n) {
    case ar.HORIZONTAL:
      return XD(t, e, i)
    case ar.VERTICAL:
      return FD(t, e, i)
    case ar.CLOSEST_POINT:
      return iI(t, e)
    case ar.OUTWARDS:
      return aI(t, e)
    case ar.AUTO:
    default:
      return eI(t, e, i)
  }
}
function QD(t, e, n, i) {
  if (i.targetDirection)
    switch (i.targetDirection) {
      case si.UP:
        return new et(0, -1)
      case si.DOWN:
        return new et(0, 1)
      case si.LEFT:
        return new et(-1, 0)
      case si.RIGHT:
        return new et(1, 0)
      case si.AUTO:
        return nI(t, e, i)
      case si.CLOSEST_POINT:
        return rI(t, e)
      case si.OUTWARDS:
        return sI(t, e)
      default:
        return i.targetDirection
    }
  switch (n) {
    case ar.HORIZONTAL:
      return WD(t, e, i)
    case ar.VERTICAL:
      return JD(t, e, i)
    case ar.CLOSEST_POINT:
      return rI(t, e)
    case ar.OUTWARDS:
      return sI(t, e)
    case ar.AUTO:
    default:
      return nI(t, e, i)
  }
}
function KD(t, e) {
  const n = Math.cos(e),
    i = Math.sin(e),
    s = n * t.x - i * t.y,
    o = i * t.x + n * t.y
  ;((t.x = s), (t.y = o))
}
function wv(t, e) {
  let n = t.dot(e) / (t.magnitude() * e.magnitude())
  return (n < -1 && (n = -1), n > 1 && (n = 1), Math.acos(n))
}
function oI(t, e) {
  return t.x * e.y - t.y * e.x
}
function $D(t, e, n, i) {
  const { tau: s, coeff: o } = i,
    u = [],
    c = [],
    h = [],
    p = t.length - 1
  for (let y = 0; y < p; y++) u[y] = t[y].distance(t[y + 1])
  ;((c[0] = e), (c[p] = n))
  for (let y = 1; y < p; y++) {
    let v, C
    ;(y === 1 ? (v = t[y - 1].clone().offset(c[y - 1].x, c[y - 1].y)) : (v = t[y - 1].clone()),
      y === p - 1 ? (C = t[y + 1].clone().offset(c[y + 1].x, c[y + 1].y)) : (C = t[y + 1].clone()))
    const w = v.difference(t[y]).normalize(),
      N = C.difference(t[y]).normalize(),
      T = wv(w, N)
    let z = (Math.PI - T) / 2,
      R
    const B = oI(w, N)
    let H
    ;((H = oI(t[y].difference(t[y + 1]), t[y].difference(t[y - 1]))),
      B < 0 && (z = -z),
      T < Math.PI / 2 && ((z < 0 && H < 0) || (z > 0 && H > 0)) && (z = z - Math.PI),
      (R = N.clone()),
      KD(R, z))
    const Z = R.clone(),
      U = R.clone(),
      nt = u[y - 1] * o,
      g = u[y] * o
    ;(Z.scale(nt, nt), U.scale(g, g), (c[y] = [Z, U]))
  }
  for (let y = 0; y < p; y++) {
    let v, C
    ;(y === 0
      ? (v = t[y + 1].difference(c[y].x / s, c[y].y / s))
      : (v = t[y + 1].difference(c[y][1].x / s, c[y][1].y / s)),
      y === p - 1
        ? (C = t[y].clone().offset(c[y + 1].x / s, c[y + 1].y / s))
        : (C = t[y].difference(c[y + 1][0].x / s, c[y + 1][0].y / s)),
      (h[y] = [v, t[y], t[y + 1], C]))
  }
  return h
}
function tO(t, e) {
  const { tau: n } = e,
    i = new et()
  ;((i.x = t[1].x + (t[2].x - t[0].x) / (6 * n)), (i.y = t[1].y + (t[2].y - t[0].y) / (6 * n)))
  const s = new et()
  return (
    (s.x = t[2].x + (t[3].x - t[1].x) / (6 * n)),
    (s.y = t[2].y + (t[3].y - t[1].y) / (6 * n)),
    new Be(t[1], i, s, t[2])
  )
}
const lS = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        curve: Hm,
        jumpover: GD,
        normal: ZD,
        rounded: HD,
        smooth: VD,
        straight: Ym,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  ue = {
    TOOLS: Ae.Flags.TOOLS,
    RENDER: 'RENDER',
    UPDATE: 'UPDATE',
    LEGACY_TOOLS: 'LEGACY_TOOLS',
    LABELS: 'LABELS',
    VERTICES: 'VERTICES',
    SOURCE: 'SOURCE',
    TARGET: 'TARGET',
    CONNECTOR: 'CONNECTOR',
  },
  cl = Ae.extend(
    {
      className: function () {
        var t = Ae.prototype.className.apply(this).split(' ')
        return (t.push('link'), t.join(' '))
      },
      options: {
        shortLinkLength: 105,
        doubleLinkTools: !1,
        longLinkLength: 155,
        linkToolsOffset: 40,
        doubleLinkToolsOffset: 65,
        sampleInterval: 50,
      },
      _labelCache: null,
      _labelSelectors: null,
      _markerCache: null,
      _V: null,
      _dragData: null,
      metrics: null,
      decimalsRounding: 2,
      initialize: function () {
        ;(Ae.prototype.initialize.apply(this, arguments),
          (this._labelCache = {}),
          (this._labelSelectors = {}),
          (this._markerCache = {}),
          (this._V = {}),
          this.cleanNodesCache())
      },
      presentationAttributes: {
        markup: [ue.RENDER],
        attrs: [ue.UPDATE],
        router: [ue.UPDATE],
        connector: [ue.CONNECTOR],
        smooth: [ue.UPDATE],
        manhattan: [ue.UPDATE],
        toolMarkup: [ue.LEGACY_TOOLS],
        labels: [ue.LABELS],
        labelMarkup: [ue.LABELS],
        vertices: [ue.VERTICES, ue.UPDATE],
        vertexMarkup: [ue.VERTICES],
        source: [ue.SOURCE, ue.UPDATE],
        target: [ue.TARGET, ue.UPDATE],
      },
      initFlag: [ue.RENDER, ue.SOURCE, ue.TARGET, ue.TOOLS],
      UPDATE_PRIORITY: 1,
      confirmUpdate: function (t, e) {
        if ((e || (e = {}), this.hasFlag(t, ue.SOURCE))) {
          if (!this.updateEndProperties('source')) return t
          t = this.removeFlag(t, ue.SOURCE)
        }
        if (this.hasFlag(t, ue.TARGET)) {
          if (!this.updateEndProperties('target')) return t
          t = this.removeFlag(t, ue.TARGET)
        }
        const { paper: n, sourceView: i, targetView: s } = this
        if (n && ((i && !n.isViewMounted(i)) || (s && !n.isViewMounted(s)))) return t
        if (this.hasFlag(t, ue.RENDER))
          return (
            this.render(),
            this.updateHighlighters(!0),
            this.updateTools(e),
            (t = this.removeFlag(t, [
              ue.RENDER,
              ue.UPDATE,
              ue.VERTICES,
              ue.LABELS,
              ue.TOOLS,
              ue.LEGACY_TOOLS,
              ue.CONNECTOR,
            ])),
            t
          )
        let o = !1
        this.hasFlag(t, ue.VERTICES) &&
          (this.renderVertexMarkers(), (t = this.removeFlag(t, ue.VERTICES)))
        const { model: u } = this,
          { attributes: c } = u
        let h = this.hasFlag(t, ue.LABELS),
          p = this.hasFlag(t, ue.LEGACY_TOOLS)
        ;(h && (this.onLabelsChange(u, c.labels, e), (t = this.removeFlag(t, ue.LABELS)), (o = !0)),
          p && (this.renderTools(), (t = this.removeFlag(t, ue.LEGACY_TOOLS))))
        const y = this.hasFlag(t, ue.UPDATE),
          v = this.hasFlag(t, ue.CONNECTOR)
        return (
          (y || v) &&
            (y
              ? e.translateBy && u.isRelationshipEmbeddedIn(e.translateBy)
                ? this.translate(e.tx, e.ty)
                : this.update()
              : (this.updatePath(), this.updateDOM()),
            this.updateTools(e),
            (t = this.removeFlag(t, [ue.UPDATE, ue.TOOLS, ue.CONNECTOR])),
            (h = !1),
            (p = !1),
            (o = !0)),
          h && this.updateLabelPositions(),
          p && this.updateToolsPosition(),
          o && this.updateHighlighters(),
          this.hasFlag(t, ue.TOOLS) && (this.updateTools(e), (t = this.removeFlag(t, ue.TOOLS))),
          t
        )
      },
      requestConnectionUpdate: function (t) {
        this.requestUpdate(this.getFlag(ue.UPDATE), t)
      },
      isLabelsRenderRequired: function (t = {}) {
        const e = this.model.previous('labels')
        if (!e) return !0
        if ('propertyPathArray' in t && 'propertyValue' in t) {
          var n = t.propertyPathArray || [],
            i = n.length
          if (i > 1) {
            var s = !!e[n[1]]
            if (s) {
              if (i === 2) return 'markup' in Object(t.propertyValue)
              if (n[2] !== 'markup') return !1
            }
          }
        }
        return !0
      },
      onLabelsChange: function (t, e, n) {
        this.isLabelsRenderRequired(n) ? this.renderLabels() : this.updateLabels()
      },
      render: function () {
        return (
          this.vel.empty(),
          this.unmountLabels(),
          (this._V = {}),
          this.renderMarkup(),
          this.renderLabels(),
          this.update(),
          this
        )
      },
      renderMarkup: function () {
        var t = this.model,
          e = t.get('markup') || t.markup
        if (!e) throw new Error('dia.LinkView: markup required')
        if (Array.isArray(e)) return this.renderJSONMarkup(e)
        if (typeof e == 'string') return this.renderStringMarkup(e)
        throw new Error('dia.LinkView: invalid markup')
      },
      renderJSONMarkup: function (t) {
        var e = this.parseDOMJSON(t, this.el)
        ;((this.selectors = e.selectors), this.vel.append(e.fragment))
      },
      renderStringMarkup: function (t) {
        var e = yt(t)
        Array.isArray(e) || (e = [e])
        for (var n = this._V, i = 0, s = e.length; i < s; i++) {
          var o = e[i],
            u = o.attr('class')
          u && ((u = Nx(u)), (n[Ie.camelCase(u)] = o))
        }
        ;(this.renderTools(),
          this.renderVertexMarkers(),
          this.renderArrowheadMarkers(),
          this.vel.append(e))
      },
      _getLabelMarkup: function (t) {
        if (t) {
          if (Array.isArray(t)) return this.parseDOMJSON(t, null)
          if (typeof t == 'string') return this._getLabelStringMarkup(t)
          throw new Error('dia.linkView: invalid label markup')
        }
      },
      _getLabelStringMarkup: function (t) {
        var e = yt(t),
          n = document.createDocumentFragment()
        if (!Array.isArray(e)) n.appendChild(e.node)
        else
          for (var i = 0, s = e.length; i < s; i++) {
            var o = e[i].node
            n.appendChild(o)
          }
        return { fragment: n, selectors: {} }
      },
      _normalizeLabelMarkup: function (t) {
        if (t) {
          var e = t.fragment
          if (!(t.fragment instanceof DocumentFragment) || !t.fragment.hasChildNodes())
            throw new Error('dia.LinkView: invalid label markup.')
          var n,
            i = e.childNodes
          return (
            i.length > 1 || i[0].nodeName.toUpperCase() !== 'G'
              ? (n = yt('g').append(e))
              : (n = yt(i[0])),
            n.addClass('label'),
            { node: n.node, selectors: t.selectors }
          )
        }
      },
      renderLabels: function () {
        var t = this._V,
          e = t.labels,
          n = (this._labelCache = {}),
          i = (this._labelSelectors = {}),
          s = this.model,
          o = s.attributes.labels || [],
          u = o.length
        if (u === 0) return (e && e.remove(), this)
        e
          ? e.empty()
          : ((e = t.labels = yt('g').addClass('labels')),
            this.options.labelsLayer &&
              (e.addClass(ir(dn(this, 'className'))), e.attr('model-id', s.id)))
        for (var c = 0; c < u; c++) {
          var h = o[c],
            p = this._normalizeLabelMarkup(this._getLabelMarkup(h.markup)),
            y,
            v
          if (p) ((y = p.node), (v = p.selectors))
          else {
            var C = s._builtins.defaultLabel,
              w = this._normalizeLabelMarkup(this._getLabelMarkup(C.markup)),
              N = s._getDefaultLabel(),
              T = this._normalizeLabelMarkup(this._getLabelMarkup(N.markup)),
              z = T || w
            ;((y = z.node), (v = z.selectors))
          }
          ;(y.setAttribute('label-idx', c), e.append(y), (n[c] = y))
          var R = this.selector
          if (v[R]) throw new Error('dia.LinkView: ambiguous label root selector.')
          ;((v[R] = y), (i[c] = v))
        }
        return (e.parent() || this.mountLabels(), this.updateLabels(), this)
      },
      mountLabels: function () {
        const { el: t, paper: e, model: n, _V: i, options: s } = this,
          { labels: o } = i
        if (!o || !n.hasLabels()) return
        const { node: u } = o
        s.labelsLayer
          ? e.getLayerView(s.labelsLayer).insertSortedNode(u, n.get('z'))
          : u.parentNode !== t && t.appendChild(u)
      },
      unmountLabels: function () {
        const { options: t, _V: e } = this
        if (!e) return
        const { labels: n } = e
        n && t.labelsLayer && n.remove()
      },
      findLabelNode: function (t, e) {
        const n = this._labelCache[t]
        if (!n) return null
        const i = this._labelSelectors[t],
          [s = null] = this.findBySelector(e, n, i)
        return s
      },
      _mergeLabelAttrs: function (t, e, n, i) {
        return e === null
          ? null
          : e === void 0
            ? n === null
              ? null
              : n === void 0
                ? t
                  ? void 0
                  : i
                : t
                  ? n
                  : An({}, i, n)
            : t
              ? An({}, n, e)
              : An({}, i, n, e)
      },
      _mergeLabelSize: function (t, e) {
        return t === null
          ? null
          : t === void 0
            ? e === null
              ? null
              : e === void 0
                ? void 0
                : e
            : An({}, e, t)
      },
      updateLabels: function () {
        if (!this._V.labels) return this
        for (
          var t = this.model,
            e = t.get('labels') || [],
            n = this.can('labelMove'),
            i = t._builtins.defaultLabel,
            s = i.attrs,
            o = t._getDefaultLabel(),
            u = o.markup,
            c = o.attrs,
            h = o.size,
            p = 0,
            y = e.length;
          p < y;
          p++
        ) {
          var v = this._labelCache[p]
          v.setAttribute('cursor', n ? 'move' : 'default')
          var C = this._labelSelectors[p],
            w = e[p],
            N = w.markup,
            T = w.attrs,
            z = w.size,
            R = this._mergeLabelAttrs(N || u, T, c, s),
            B = this._mergeLabelSize(z, h)
          this.updateDOMSubtreeAttributes(v, R, { rootBBox: new Pt(B), selectors: C })
        }
        return this
      },
      renderTools: function () {
        if (!this._V.linkTools) return this
        var t = Ie(this._V.linkTools.node).empty(),
          e = $n(this.model.get('toolMarkup') || this.model.toolMarkup),
          n = yt(e())
        if ((t.append(n.node), (this._toolCache = n), this.options.doubleLinkTools)) {
          var i
          ;(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup
            ? ((e = $n(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup)),
              (i = yt(e())))
            : (i = n.clone()),
            t.append(i.node),
            (this._tool2Cache = i))
        }
        return this
      },
      renderVertexMarkers: function () {
        if (!this._V.markerVertices) return this
        var t = Ie(this._V.markerVertices.node).empty(),
          e = $n(this.model.get('vertexMarkup') || this.model.vertexMarkup)
        return (
          this.model.vertices().forEach(function (n, i) {
            t.append(yt(e(Kt({ idx: i }, n))).node)
          }),
          this
        )
      },
      renderArrowheadMarkers: function () {
        if (!this._V.markerArrowheads) return this
        var t = Ie(this._V.markerArrowheads.node)
        t.empty()
        var e = $n(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup)
        return (
          (this._V.sourceArrowhead = yt(e({ end: 'source' }))),
          (this._V.targetArrowhead = yt(e({ end: 'target' }))),
          t.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node),
          this
        )
      },
      removeRedundantLinearVertices: function (t) {
        const n = this.model,
          i = n.vertices(),
          s = [this.sourceAnchor, ...i, this.targetAnchor],
          o = s.length,
          u = new qe(s)
        u.simplify({ threshold: 0.001 })
        const c = u.points.map(p => p.toJSON()),
          h = c.length
        return o === h ? 0 : (n.vertices(c.slice(1, h - 1), t), o - h)
      },
      updateDefaultConnectionPath: function () {
        var t = this._V
        ;(t.connection && t.connection.attr('d', this.getSerializedConnection()),
          t.connectionWrap && t.connectionWrap.attr('d', this.getSerializedConnection()),
          t.markerSource &&
            t.markerTarget &&
            this._translateAndAutoOrientArrows(t.markerSource, t.markerTarget))
      },
      getEndView: function (t) {
        switch (t) {
          case 'source':
            return this.sourceView || null
          case 'target':
            return this.targetView || null
          default:
            throw new Error('dia.LinkView: type parameter required.')
        }
      },
      getEndAnchor: function (t) {
        switch (t) {
          case 'source':
            return new et(this.sourceAnchor)
          case 'target':
            return new et(this.targetAnchor)
          default:
            throw new Error('dia.LinkView: type parameter required.')
        }
      },
      getEndConnectionPoint: function (t) {
        switch (t) {
          case 'source':
            return new et(this.sourcePoint)
          case 'target':
            return new et(this.targetPoint)
          default:
            throw new Error('dia.LinkView: type parameter required.')
        }
      },
      getEndMagnet: function (t) {
        switch (t) {
          case 'source':
            var e = this.sourceView
            if (!e) break
            return this.sourceMagnet || e.el
          case 'target':
            var n = this.targetView
            if (!n) break
            return this.targetMagnet || n.el
          default:
            throw new Error('dia.LinkView: type parameter required.')
        }
        return null
      },
      update: function () {
        return (this.updateRoute(), this.updatePath(), this.updateDOM(), this)
      },
      translate: function (t = 0, e = 0) {
        const { route: n, path: i } = this
        if (!n || !i) return
        const s = new qe(n)
        ;(s.translate(t, e),
          (this.route = s.points),
          this._translateConnectionPoints(t, e),
          i.translate(t, e),
          this.updateDOM())
      },
      updateDOM() {
        const { el: t, model: e, selectors: n } = this
        ;(this.cleanNodesCache(),
          this.updateDOMSubtreeAttributes(t, e.attr(), { selectors: n }),
          this.updateDefaultConnectionPath(),
          this.updateLabelPositions(),
          this.updateToolsPosition(),
          this.updateArrowheadMarkers(),
          (this.options.perpendicular = null))
      },
      updateRoute: function () {
        const { model: t } = this,
          e = t.vertices(),
          n = this.findAnchors(e),
          i = (this.sourceAnchor = n.source),
          s = (this.targetAnchor = n.target),
          o = this.findRoute(e)
        this.route = o
        var u = this.findConnectionPoints(o, i, s)
        ;((this.sourcePoint = u.source), (this.targetPoint = u.target))
      },
      updatePath: function () {
        const { route: t, sourcePoint: e, targetPoint: n } = this,
          i = this.findMarkerPoints(t, e, n),
          s = this.findPath(t, i.source || e, i.target || n)
        this.path = s
      },
      findMarkerPoints: function (t, e, n) {
        var i = t[0],
          s = t[t.length - 1],
          o = this._markerCache,
          u,
          c
        return (
          this._V.markerSource &&
            ((o.sourceBBox = o.sourceBBox || this._V.markerSource.getBBox()),
            (u = et(e)
              .move(i || n, o.sourceBBox.width * this._V.markerSource.scale().sx * -1)
              .round())),
          this._V.markerTarget &&
            ((o.targetBBox = o.targetBBox || this._V.markerTarget.getBBox()),
            (c = et(n)
              .move(s || e, o.targetBBox.width * this._V.markerTarget.scale().sx * -1)
              .round())),
          (o.sourcePoint = u || e.clone()),
          (o.targetPoint = c || n.clone()),
          { source: u, target: c }
        )
      },
      findAnchorsOrdered: function (t, e, n, i) {
        var s,
          o,
          u,
          c,
          h = this.model,
          p = h.get(t),
          y = h.get(n),
          v = this.getEndView(t),
          C = this.getEndView(n),
          w = this.getEndMagnet(t),
          N = this.getEndMagnet(n)
        ;(v
          ? (e ? (u = new et(e)) : C ? (u = N) : (u = new et(y)),
            (s = this.getAnchor(p.anchor, v, w, u, t)))
          : (s = new et(p)),
          C ? ((c = new et(i || s)), (o = this.getAnchor(y.anchor, C, N, c, n))) : (o = new et(y)))
        var T = {}
        return ((T[t] = s), (T[n] = o), T)
      },
      findAnchors: function (t) {
        var e = this.model,
          n = t[0],
          i = t[t.length - 1]
        return e.target().priority && !e.source().priority
          ? this.findAnchorsOrdered('target', i, 'source', n)
          : this.findAnchorsOrdered('source', n, 'target', i)
      },
      findConnectionPoints: function (t, e, n) {
        var i = t[0],
          s = t[t.length - 1],
          o = this.model,
          u = o.get('source'),
          c = o.get('target'),
          h = this.sourceView,
          p = this.targetView,
          y = this.paper.options,
          v,
          C,
          w
        if (h && !h.isNodeConnection(this.sourceMagnet)) {
          v = this.sourceMagnet || h.el
          var N = u.connectionPoint || y.defaultConnectionPoint,
            T = i || n,
            z = new Ut(T, e)
          w = this.getConnectionPoint(N, h, v, z, 'source')
        } else w = e
        var R
        if (p && !p.isNodeConnection(this.targetMagnet)) {
          C = this.targetMagnet || p.el
          var B = c.connectionPoint || y.defaultConnectionPoint,
            H = s || e,
            Z = new Ut(H, n)
          R = this.getConnectionPoint(B, p, C, Z, 'target')
        } else R = n
        return { source: w, target: R }
      },
      getAnchor: function (t, e, n, i, s) {
        var o = e.isNodeConnection(n),
          u = this.paper.options
        if (
          (t ||
            (o
              ? (t = u.defaultLinkAnchor)
              : u.perpendicularLinks || this.options.perpendicular
                ? (t = { name: 'perpendicular' })
                : (t = u.defaultAnchor)),
          !t)
        )
          throw new Error('Anchor required.')
        var c
        if (typeof t == 'function') c = t
        else {
          var h = t.name,
            p = o ? 'linkAnchorNamespace' : 'anchorNamespace'
          if (((c = u[p][h]), typeof c != 'function')) throw new Error('Unknown anchor: ' + h)
        }
        var y = c.call(this, e, n, i, t.args || {}, s, this)
        return y ? y.round(this.decimalsRounding) : new et()
      },
      getConnectionPoint: function (t, e, n, i, s) {
        var o,
          u = i.end,
          c = this.paper.options
        if (typeof c.linkConnectionPoint == 'function') {
          var h = n === e.el ? void 0 : n
          if (((o = c.linkConnectionPoint(this, e, h, i.start, s)), o)) return o
        }
        if (!t) return u
        var p
        if (typeof t == 'function') p = t
        else {
          var y = t.name
          if (((p = c.connectionPointNamespace[y]), typeof p != 'function'))
            throw new Error('Unknown connection point: ' + y)
        }
        return (
          (o = p.call(this, i, e, n, t.args || {}, s, this)),
          o ? o.round(this.decimalsRounding) : u
        )
      },
      _translateConnectionPoints: function (t, e) {
        var n = this._markerCache
        ;(n.sourcePoint.offset(t, e),
          n.targetPoint.offset(t, e),
          this.sourcePoint.offset(t, e),
          this.targetPoint.offset(t, e),
          this.sourceAnchor.offset(t, e),
          this.targetAnchor.offset(t, e))
      },
      _getDefaultLabelPositionProperty: function () {
        var t = this.model,
          e = t._builtins.defaultLabel,
          n = e.position,
          i = t._getDefaultLabel(),
          s = this._normalizeLabelPosition(i.position)
        return An({}, n, s)
      },
      _normalizeLabelPosition: function (t) {
        return typeof t == 'number' ? { distance: t, offset: null, angle: 0, args: null } : t
      },
      _mergeLabelPositionProperty: function (t, e) {
        return t === null ? null : t === void 0 ? (e === null ? null : e) : An({}, e, t)
      },
      updateLabelPositions: function () {
        if (!this._V.labels) return this
        var t = this.path
        if (!t) return this
        var e = this.model,
          n = e.get('labels') || []
        if (!n.length) return this
        for (var i = this._getDefaultLabelPositionProperty(), s = 0, o = n.length; s < o; s++) {
          var u = this._labelCache[s]
          if (u) {
            var c = n[s],
              h = this._normalizeLabelPosition(c.position),
              p = this._mergeLabelPositionProperty(h, i),
              y = this._getLabelTransformationMatrix(p)
            ;(u.setAttribute('transform', yt.matrixToTransformString(y)),
              this._cleanLabelMatrices(s))
          }
        }
        return this
      },
      _cleanLabelMatrices: function (t) {
        const { metrics: e, _labelSelectors: n } = this,
          i = n[t]
        if (i)
          for (let s in i) {
            const { id: o } = i[s]
            o && o in e && delete e[o].magnetMatrix
          }
      },
      updateToolsPosition: function () {
        if (!this._V.linkTools) return this
        var t = '',
          e = this.options.linkToolsOffset,
          n = this.getConnectionLength()
        if (!Number.isNaN(n)) {
          n < this.options.shortLinkLength && ((t = 'scale(.5)'), (e /= 2))
          var i = this.getPointAtLength(e)
          if (
            (this._toolCache.attr('transform', 'translate(' + i.x + ', ' + i.y + ') ' + t),
            this.options.doubleLinkTools && n >= this.options.longLinkLength)
          ) {
            var s = this.options.doubleLinkToolsOffset || e
            ;((i = this.getPointAtLength(n - s)),
              this._tool2Cache.attr('transform', 'translate(' + i.x + ', ' + i.y + ') ' + t),
              this._tool2Cache.attr('display', 'inline'))
          } else this.options.doubleLinkTools && this._tool2Cache.attr('display', 'none')
        }
        return this
      },
      updateArrowheadMarkers: function () {
        if (!this._V.markerArrowheads) return this
        if (Ie.css(this._V.markerArrowheads.node, 'display') === 'none') return this
        var t = this.getConnectionLength() < this.options.shortLinkLength ? 0.5 : 1
        return (
          this._V.sourceArrowhead.scale(t),
          this._V.targetArrowhead.scale(t),
          this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead),
          this
        )
      },
      updateEndProperties: function (t) {
        const { model: e, paper: n } = this,
          i = `${t}View`,
          s = e.get(t),
          o = s && s.id
        if (!o) return ((this[i] = null), this.updateEndMagnet(t), !0)
        const u = n.getModelById(o)
        if (!u) throw new Error('LinkView: invalid ' + t + ' cell.')
        const c = u.findView(n)
        return c ? ((this[i] = c), this.updateEndMagnet(t), !0) : !1
      },
      updateEndMagnet: function (t) {
        const e = `${t}Magnet`,
          n = this.getEndView(t)
        if (n) {
          let i = n.getMagnetFromLinkEnd(this.model.get(t))
          ;(i === n.el && (i = null), (this[e] = i))
        } else this[e] = null
      },
      _translateAndAutoOrientArrows: function (t, e) {
        var n = xe(this.route)
        ;(t &&
          t.translateAndAutoOrient(this.sourcePoint, n[0] || this.targetPoint, this.paper.cells),
          e &&
            e.translateAndAutoOrient(
              this.targetPoint,
              n[n.length - 1] || this.sourcePoint,
              this.paper.cells
            ))
      },
      _getLabelPositionProperty: function (t) {
        return this.model.label(t).position || {}
      },
      _getLabelPositionAngle: function (t) {
        var e = this._getLabelPositionProperty(t)
        return e.angle || 0
      },
      _getLabelPositionArgs: function (t) {
        var e = this._getLabelPositionProperty(t)
        return e.args
      },
      _getDefaultLabelPositionArgs: function () {
        var t = this.model._getDefaultLabel(),
          e = t.position || {}
        return e.args
      },
      _mergeLabelPositionArgs: function (t, e) {
        return t === null ? null : t === void 0 ? (e === null ? null : e) : An({}, e, t)
      },
      addLabel: function (t, e, n, i) {
        var s,
          o,
          u = 0,
          c
        typeof t != 'number'
          ? ((s = t.x), (o = t.y), typeof e == 'number' ? ((u = e), (c = n)) : (c = e))
          : ((s = t), (o = e), typeof n == 'number' ? ((u = n), (c = i)) : (c = n))
        var h = this._getDefaultLabelPositionArgs(),
          p = c,
          y = this._mergeLabelPositionArgs(p, h),
          v = { position: this.getLabelPosition(s, o, u, y) },
          C = -1
        return (this.model.insertLabel(C, v, c), C)
      },
      addVertex: function (t, e, n) {
        var i = typeof t != 'number',
          s = i ? t.x : t,
          o = i ? t.y : e,
          u = i ? e : n,
          c = { x: s, y: o },
          h = this.getVertexIndex(s, o)
        return (this.model.insertVertex(h, c, u), h)
      },
      sendToken: function (t, e, n) {
        function i(v, C) {
          return function () {
            ;(v.remove(), typeof C == 'function' && C())
          }
        }
        var s, o, u
        ;(ze(e)
          ? ((s = e.duration), (o = e.direction === 'reverse'), (u = e.connection))
          : ((s = e), (o = !1), (u = null)),
          (s = s || 1e3))
        var c = { dur: s + 'ms', repeatCount: 1, calcMode: 'linear', fill: 'freeze' }
        o && ((c.keyPoints = '1;0'), (c.keyTimes = '0;1'))
        var h = yt(t),
          p
        if (typeof u == 'string') p = this.findBySelector(u, this.el, this.selectors)[0]
        else {
          var y = this._V
          p = y.connection ? y.connection.node : this.el.querySelector('path')
        }
        if (!(p instanceof SVGPathElement))
          throw new Error('dia.LinkView: token animation requires a valid connection path.')
        ;(h.appendTo(this.paper.cells).animateAlongPath(c, p), setTimeout(i(h, n), s))
      },
      findRoute: function (t) {
        t || (t = [])
        var e = this.paper.options.routerNamespace || oS,
          n = this.model.router(),
          i = this.paper.options.defaultRouter
        if (!n)
          if (i) n = i
          else return t.map(et)
        var s = Ze(n) ? n : e[n.name]
        if (!Ze(s)) throw new Error('dia.LinkView: unknown router: "' + n.name + '".')
        var o = n.args || {},
          u = s.call(this, t, o, this)
        return u || t.map(et)
      },
      findPath: function (t, e, n) {
        var i = this.paper.options.connectorNamespace || lS,
          s = this.model.connector(),
          o = this.paper.options.defaultConnector
        s || (s = o || {})
        var u = Ze(s) ? s : i[s.name]
        if (!Ze(u)) throw new Error('dia.LinkView: unknown connector: "' + s.name + '".')
        var c = Bi(s.args || {})
        c.raw = !0
        var h = u.call(this, e, n, t, c, this)
        return (typeof h == 'string' && (h = new Jt(yt.normalizePathData(h))), h)
      },
      getConnection: function () {
        var t = this.path
        return t ? t.clone() : null
      },
      getSerializedConnection: function () {
        var t = this.path
        if (!t) return null
        var e = this.metrics
        if (e.hasOwnProperty('data')) return e.data
        var n = t.serialize()
        return ((e.data = n), n)
      },
      getConnectionSubdivisions: function () {
        var t = this.path
        if (!t) return null
        var e = this.metrics
        if (e.hasOwnProperty('segmentSubdivisions')) return e.segmentSubdivisions
        var n = t.getSegmentSubdivisions()
        return ((e.segmentSubdivisions = n), n)
      },
      getConnectionLength: function () {
        var t = this.path
        if (!t) return 0
        var e = this.metrics
        if (e.hasOwnProperty('length')) return e.length
        var n = t.length({ segmentSubdivisions: this.getConnectionSubdivisions() })
        return ((e.length = n), n)
      },
      getPointAtLength: function (t) {
        var e = this.path
        return e
          ? e.pointAtLength(t, { segmentSubdivisions: this.getConnectionSubdivisions() })
          : null
      },
      getPointAtRatio: function (t) {
        var e = this.path
        return e
          ? (Dn(t) && (t = parseFloat(t) / 100),
            e.pointAt(t, { segmentSubdivisions: this.getConnectionSubdivisions() }))
          : null
      },
      getTangentAtLength: function (t) {
        var e = this.path
        return e
          ? e.tangentAtLength(t, { segmentSubdivisions: this.getConnectionSubdivisions() })
          : null
      },
      getTangentAtRatio: function (t) {
        var e = this.path
        return e ? e.tangentAt(t, { segmentSubdivisions: this.getConnectionSubdivisions() }) : null
      },
      getClosestPoint: function (t) {
        var e = this.path
        return e
          ? e.closestPoint(t, { segmentSubdivisions: this.getConnectionSubdivisions() })
          : null
      },
      getClosestPointLength: function (t) {
        var e = this.path
        return e
          ? e.closestPointLength(t, { segmentSubdivisions: this.getConnectionSubdivisions() })
          : null
      },
      getClosestPointRatio: function (t) {
        var e = this.path
        return e
          ? e.closestPointNormalizedLength(t, {
              segmentSubdivisions: this.getConnectionSubdivisions(),
            })
          : null
      },
      getLabelPosition: function (t, e, n, i) {
        var s = {},
          o = 0,
          u
        ;(typeof n == 'number' ? ((o = n), (u = i)) : (u = n), u && (s.args = u))
        var c = !(u && u.absoluteDistance),
          h = u && u.absoluteDistance && u.reverseDistance,
          p = u && u.absoluteOffset,
          y = this.path,
          v = { segmentSubdivisions: this.getConnectionSubdivisions() },
          C = new et(t, e),
          w = y.closestPointT(C, v),
          N = y.lengthAtT(w, v)
        ;(c && (N = N / this.getConnectionLength() || 0),
          h && (N = -1 * (this.getConnectionLength() - N) || 1),
          (s.distance = N))
        var T
        p || (T = y.tangentAtT(w))
        var z
        if (T) z = T.pointOffset(C)
        else {
          var R = y.pointAtT(w),
            B = C.difference(R)
          z = { x: B.x, y: B.y }
        }
        return ((s.offset = z), (s.angle = o), s)
      },
      _getLabelTransformationMatrix: function (t) {
        var e,
          n = 0,
          i = {}
        if (typeof t == 'number') e = t
        else if (typeof t.distance == 'number')
          ((i = t.args || {}), (e = t.distance), (n = t.angle || 0))
        else throw new Error('dia.LinkView: invalid label position distance.')
        var s = e > 0 && e <= 1,
          o = 0,
          u = { x: 0, y: 0 }
        if (t.offset) {
          var c = t.offset
          ;(typeof c == 'number' && (o = c), c.x && (u.x = c.x), c.y && (u.y = c.y))
        }
        var h = u.x !== 0 || u.y !== 0 || o === 0,
          p = i.keepGradient,
          y = i.ensureLegibility,
          v = this.path,
          C = { segmentSubdivisions: this.getConnectionSubdivisions() },
          w = s ? e * this.getConnectionLength() : e,
          N = v.tangentAtLength(w, C),
          T,
          z = n
        if (N) {
          if (h) ((T = N.start.clone()), T.offset(u))
          else {
            var R = N.clone()
            ;(R.rotate(N.start, -90), R.setLength(o), (T = R.end))
          }
          p && ((z = N.angle() + n), y && (z = Dr(((z + 90) % 180) - 90)))
        } else ((T = v.start.clone()), h && T.offset(u))
        return yt.createSVGMatrix().translate(T.x, T.y).rotate(z)
      },
      getLabelCoordinates: function (t) {
        var e = this._getLabelTransformationMatrix(t)
        return new et(e.e, e.f)
      },
      getVertexIndex: function (t, e) {
        for (
          var n = this.model,
            i = n.vertices(),
            s = this.getClosestPointLength(new et(t, e)),
            o = 0,
            u = i.length;
          o < u;
          o++
        ) {
          var c = i[o],
            h = this.getClosestPointLength(c)
          if (s < h) break
        }
        return o
      },
      notifyPointerdown(t, e, n) {
        ;(Ae.prototype.pointerdown.call(this, t, e, n), this.notify('link:pointerdown', t, e, n))
      },
      notifyPointermove(t, e, n) {
        ;(Ae.prototype.pointermove.call(this, t, e, n), this.notify('link:pointermove', t, e, n))
      },
      notifyPointerup(t, e, n) {
        ;(this.notify('link:pointerup', t, e, n), Ae.prototype.pointerup.call(this, t, e, n))
      },
      pointerdblclick: function (t, e, n) {
        ;(Ae.prototype.pointerdblclick.apply(this, arguments),
          this.notify('link:pointerdblclick', t, e, n))
      },
      pointerclick: function (t, e, n) {
        ;(Ae.prototype.pointerclick.apply(this, arguments),
          this.notify('link:pointerclick', t, e, n))
      },
      contextmenu: function (t, e, n) {
        ;(Ae.prototype.contextmenu.apply(this, arguments), this.notify('link:contextmenu', t, e, n))
      },
      pointerdown: function (t, e, n) {
        this.notifyPointerdown(t, e, n)
        var i = t.target.getAttribute('class')
        switch (i) {
          case 'marker-vertex':
            this.dragVertexStart(t, e, n)
            return
          case 'marker-vertex-remove':
          case 'marker-vertex-remove-area':
            this.dragVertexRemoveStart(t, e, n)
            return
          case 'marker-arrowhead':
            this.dragArrowheadStart(t, e, n)
            return
          case 'connection':
          case 'connection-wrap':
            this.dragConnectionStart(t, e, n)
            return
          case 'marker-source':
          case 'marker-target':
            return
        }
        this.dragStart(t, e, n)
      },
      pointermove: function (t, e, n) {
        var i = this._dragData
        i && this.eventData(t, i)
        var s = this.eventData(t)
        switch (s.action) {
          case 'vertex-move':
            this.dragVertex(t, e, n)
            break
          case 'label-move':
            this.dragLabel(t, e, n)
            break
          case 'arrowhead-move':
            this.dragArrowhead(t, e, n)
            break
          case 'move':
            this.drag(t, e, n)
            break
        }
        ;(i && Kt(i, this.eventData(t)), this.notifyPointermove(t, e, n))
      },
      pointerup: function (t, e, n) {
        var i = this._dragData
        i && (this.eventData(t, i), (this._dragData = null))
        var s = this.eventData(t)
        switch (s.action) {
          case 'vertex-move':
            this.dragVertexEnd(t, e, n)
            break
          case 'label-move':
            this.dragLabelEnd(t, e, n)
            break
          case 'arrowhead-move':
            this.dragArrowheadEnd(t, e, n)
            break
          case 'move':
            this.dragEnd(t, e, n)
        }
        ;(this.notifyPointerup(t, e, n), this.checkMouseleave(t))
      },
      mouseover: function (t) {
        ;(Ae.prototype.mouseover.apply(this, arguments), this.notify('link:mouseover', t))
      },
      mouseout: function (t) {
        ;(Ae.prototype.mouseout.apply(this, arguments), this.notify('link:mouseout', t))
      },
      mouseenter: function (t) {
        ;(Ae.prototype.mouseenter.apply(this, arguments), this.notify('link:mouseenter', t))
      },
      mouseleave: function (t) {
        ;(Ae.prototype.mouseleave.apply(this, arguments), this.notify('link:mouseleave', t))
      },
      mousewheel: function (t, e, n, i) {
        ;(Ae.prototype.mousewheel.apply(this, arguments),
          this.notify('link:mousewheel', t, e, n, i))
      },
      onevent: function (t, e, n, i) {
        var s = yt(t.target).findParentByClass('link-tool', this.el)
        if (s) {
          if ((t.stopPropagation(), this.can('useLinkTools')))
            if (e === 'remove') {
              this.model.remove({ ui: !0 })
              return
            } else this.notify(e, t, n, i)
          ;(this.notifyPointerdown(t, n, i), this.paper.delegateDragEvents(this, t.data))
        } else Ae.prototype.onevent.apply(this, arguments)
      },
      onlabel: function (t, e, n) {
        ;(this.notifyPointerdown(t, e, n), this.dragLabelStart(t, e, n))
        var i = this.eventData(t).stopPropagation
        i && t.stopPropagation()
      },
      dragConnectionStart: function (t, e, n) {
        if (this.can('vertexAdd')) {
          var i = this.addVertex({ x: e, y: n }, { ui: !0 })
          this.eventData(t, { action: 'vertex-move', vertexIdx: i })
        }
      },
      dragLabelStart: function (t, e, n) {
        if (this.can('labelMove')) {
          if (this.isDefaultInteractionPrevented(t)) return
          var i = t.currentTarget,
            s = parseInt(i.getAttribute('label-idx'), 10),
            o = this._getDefaultLabelPositionProperty(),
            u = this._normalizeLabelPosition(this._getLabelPositionProperty(s)),
            c = this._mergeLabelPositionProperty(u, o),
            h = this.getLabelCoordinates(c),
            p = h.x - e,
            y = h.y - n,
            v = this._getLabelPositionAngle(s),
            C = this._getLabelPositionArgs(s),
            w = this._getDefaultLabelPositionArgs(),
            N = this._mergeLabelPositionArgs(C, w)
          this.eventData(t, {
            action: 'label-move',
            labelIdx: s,
            dx: p,
            dy: y,
            positionAngle: v,
            positionArgs: N,
            stopPropagation: !0,
          })
        } else this.eventData(t, { stopPropagation: !0 })
        this.paper.delegateDragEvents(this, t.data)
      },
      dragVertexStart: function (t, e, n) {
        if (this.can('vertexMove')) {
          var i = t.target,
            s = parseInt(i.getAttribute('idx'), 10)
          this.eventData(t, { action: 'vertex-move', vertexIdx: s })
        }
      },
      dragVertexRemoveStart: function (t, e, n) {
        if (this.can('vertexRemove')) {
          var i = t.target,
            s = parseInt(i.getAttribute('idx'), 10)
          this.model.removeVertex(s)
        }
      },
      dragArrowheadStart: function (t, e, n) {
        if (this.can('arrowheadMove')) {
          var i = t.target,
            s = i.getAttribute('end'),
            o = this.startArrowheadMove(s, { ignoreBackwardsCompatibility: !0 })
          this.eventData(t, o)
        }
      },
      dragStart: function (t, e, n) {
        this.isDefaultInteractionPrevented(t) ||
          (this.can('linkMove') && this.eventData(t, { action: 'move', dx: e, dy: n }))
      },
      dragLabel: function (t, e, n) {
        var i = this.eventData(t),
          s = {
            position: this.getLabelPosition(e + i.dx, n + i.dy, i.positionAngle, i.positionArgs),
          }
        this.paper.options.snapLabels && delete s.position.offset
        const o = { ui: !0 }
        ;(this.paper.isAsync() && t.type === 'touchmove' && (o.async = !1),
          this.model.label(i.labelIdx, s, o))
      },
      dragVertex: function (t, e, n) {
        var i = this.eventData(t)
        this.model.vertex(i.vertexIdx, { x: e, y: n }, { ui: !0 })
      },
      dragArrowhead: function (t, e, n) {
        this.paper.options.snapLinks
          ? !this._snapArrowhead(t, e, n) &&
            this.paper.options.snapLinksSelf &&
            this._snapArrowheadSelf(t, e, n)
          : this.paper.options.snapLinksSelf
            ? this._snapArrowheadSelf(t, e, n)
            : this._connectArrowhead(this.getEventTarget(t), e, n, this.eventData(t))
      },
      drag: function (t, e, n) {
        var i = this.eventData(t)
        ;(this.model.translate(e - i.dx, n - i.dy, { ui: !0 }), this.eventData(t, { dx: e, dy: n }))
      },
      dragLabelEnd: function () {},
      dragVertexEnd: function () {},
      dragArrowheadEnd: function (t, e, n) {
        var i = this.eventData(t),
          s = this.paper
        ;(s.options.snapLinks ? this._snapArrowheadEnd(i) : this._connectArrowheadEnd(i, e, n),
          s.linkAllowed(this)
            ? (this._finishEmbedding(i), this._notifyConnectEvent(i, t))
            : this._disallow(i),
          this._afterArrowheadMove(i))
      },
      dragEnd: function () {},
      _disallow: function (t) {
        switch (t.whenNotAllowed) {
          case 'remove':
            this.model.remove({ ui: !0 })
            break
          case 'revert':
          default:
            this.model.set(t.arrowhead, t.initialEnd, { ui: !0 })
            break
        }
      },
      _finishEmbedding: function (t) {
        this.paper.options.embeddingMode && this.model.reparent() && (t.z = null)
      },
      _notifyConnectEvent: function (t, e) {
        var n = t.arrowhead,
          i = t.initialEnd,
          s = this.model.prop(n),
          o = s && !wn.endsEqual(i, s)
        if (o) {
          var u = this.paper
          ;(i.id && this.notify('link:disconnect', e, u.findViewByModel(i.id), t.initialMagnet, n),
            s.id &&
              this.notify('link:connect', e, u.findViewByModel(s.id), t.magnetUnderPointer, n))
        }
      },
      _snapToPoints: function (t, e, n) {
        let i = null,
          s = 1 / 0,
          o = null,
          u = 1 / 0,
          c = t.x,
          h = t.y
        for (let p = 0; p < e.length; p++) {
          const y = Math.abs(e[p].x - t.x)
          y < s && ((s = y), (i = e[p]))
          const v = Math.abs(e[p].y - t.y)
          v < u && ((u = v), (o = e[p]))
        }
        return (s < n && (c = i.x), u < n && (h = o.y), { x: c, y: h })
      },
      _snapArrowheadSelf: function (t, e, n) {
        const { paper: i, model: s } = this,
          { snapLinksSelf: o } = i.options,
          u = this.eventData(t),
          c = o.radius || 20,
          h = this.getEndAnchor(u.arrowhead === 'source' ? 'target' : 'source'),
          p = s.vertices(),
          y = [h, ...p],
          v = this._snapToPoints({ x: e, y: n }, y, c),
          C = i.localToClientPoint(v)
        this._connectArrowhead(document.elementFromPoint(C.x, C.y), v.x, v.y, this.eventData(t))
      },
      _snapArrowhead: function (t, e, n) {
        const { paper: i } = this,
          { snapLinks: s, connectionStrategy: o } = i.options,
          u = this.eventData(t)
        let c = !1
        var h = s.radius || 50,
          p = i.findViewsInArea({ x: e - h, y: n - h, width: 2 * h, height: 2 * h }),
          y = u.closestView || null,
          v = u.closestMagnet || null,
          C = u.magnetProxy || null
        u.closestView = u.closestMagnet = u.magnetProxy = null
        var w = Number.MAX_VALUE,
          N = new et(e, n)
        p.forEach(function (U) {
          const nt = []
          ;(U.el.getAttribute('magnet') !== 'false' &&
            nt.push({ bbox: U.model.getBBox(), magnet: U.el }),
            U.$('[magnet]')
              .toArray()
              .forEach(g => {
                nt.push({ bbox: U.getNodeBBox(g), magnet: g })
              }),
            nt.forEach(g => {
              const { magnet: S, bbox: M } = g,
                _ = M.center().squaredDistance(N)
              _ < w &&
                (v === S ||
                  i.options.validateConnection.apply(
                    i,
                    u.validateConnectionArgs(U, U.el === S ? null : S)
                  )) &&
                ((w = _), (u.closestView = U), (u.closestMagnet = S))
            }))
        }, this)
        var T,
          z = null,
          R = u.closestView,
          B = u.closestMagnet
        B && (z = u.magnetProxy = R.findProxyNode(B, 'highlighter'))
        var H = u.arrowhead,
          Z = v !== B
        if ((y && Z && y.unhighlight(C, { connecting: !0, snapping: !0 }), R)) {
          const { prevEnd: U, prevX: nt, prevY: g } = u
          if (
            ((u.prevX = e),
            (u.prevY = n),
            (c = !0),
            (!Z && (typeof o != 'function' || (nt === e && g === n))) ||
              ((T = R.getLinkEnd(B, e, n, this.model, H)), !Z && qs(U, T)))
          )
            return c
          ;((u.prevEnd = T), Z && R.highlight(z, { connecting: !0, snapping: !0 }))
        } else T = { x: e, y: n }
        return (
          this.model.set(H, T || { x: e, y: n }, { ui: !0 }),
          y && this.notify('link:snap:disconnect', t, y, v, H),
          R && this.notify('link:snap:connect', t, R, B, H),
          c
        )
      },
      _snapArrowheadEnd: function (t) {
        var e = t.closestView,
          n = t.closestMagnet
        ;(e &&
          n &&
          (e.unhighlight(t.magnetProxy, { connecting: !0, snapping: !0 }),
          (t.magnetUnderPointer = e.findMagnet(n))),
          (t.closestView = t.closestMagnet = null))
      },
      _connectArrowhead: function (t, e, n, i) {
        const { paper: s, model: o } = this
        if (i.eventTarget !== t) {
          i.magnetProxy && i.viewUnderPointer.unhighlight(i.magnetProxy, { connecting: !0 })
          const u = (i.viewUnderPointer = s.findView(t))
          if (u) {
            const c = (i.magnetUnderPointer = u.findMagnet(t)),
              h = (i.magnetProxy = u.findProxyNode(c, 'highlighter'))
            c && this.paper.options.validateConnection.apply(s, i.validateConnectionArgs(u, c))
              ? h && u.highlight(h, { connecting: !0 })
              : ((i.magnetUnderPointer = null), (i.magnetProxy = null))
          } else ((i.magnetUnderPointer = null), (i.magnetProxy = null))
        }
        ;((i.eventTarget = t), o.set(i.arrowhead, { x: e, y: n }, { ui: !0 }))
      },
      _connectArrowheadEnd: function (t = {}, e, n) {
        const { model: i } = this,
          { viewUnderPointer: s, magnetUnderPointer: o, magnetProxy: u, arrowhead: c } = t
        if (!o || !u || !s) return
        s.unhighlight(u, { connecting: !0 })
        const h = s.getLinkEnd(o, e, n, i, c)
        i.set(c, h, { ui: !0 })
      },
      _beforeArrowheadMove: function (t) {
        ;((t.z = this.model.get('z')), this.model.toFront())
        var e = this.el.style
        ;((t.pointerEvents = e.pointerEvents),
          (e.pointerEvents = 'none'),
          this.paper.options.markAvailable && this._markAvailableMagnets(t))
      },
      _afterArrowheadMove: function (t) {
        ;(t.z !== null && (this.model.set('z', t.z, { ui: !0 }), (t.z = null)),
          (this.el.style.pointerEvents = t.pointerEvents),
          this.paper.options.markAvailable && this._unmarkAvailableMagnets(t))
      },
      _createValidateConnectionArgs: function (t) {
        var e = []
        ;((e[4] = t), (e[5] = this))
        var n,
          i = 0,
          s = 0
        t === 'source' ? ((i = 2), (n = 'target')) : ((s = 2), (n = 'source'))
        var o = this.model.get(n)
        if (o.id) {
          var u = (e[i] = this.paper.findViewByModel(o.id)),
            c = u.getMagnetFromLinkEnd(o)
          ;(c === u.el && (c = void 0), (e[i + 1] = c))
        }
        function h(p, y) {
          return ((e[s] = p), (e[s + 1] = p.el === y ? void 0 : y), e)
        }
        return h
      },
      _markAvailableMagnets: function (t) {
        function e(v, C) {
          var w = v.paper,
            N = w.options.validateConnection
          return N.apply(w, this.validateConnectionArgs(v, C))
        }
        var n = this.paper,
          i = n.model.getCells()
        t.marked = {}
        for (var s = 0, o = i.length; s < o; s++) {
          var u = i[s].findView(n)
          if (u) {
            var c = Array.prototype.slice.call(u.el.querySelectorAll('[magnet]'))
            u.el.getAttribute('magnet') !== 'false' && c.push(u.el)
            var h = c.filter(e.bind(t, u))
            if (h.length > 0) {
              for (var p = 0, y = h.length; p < y; p++)
                u.highlight(h[p], { magnetAvailability: !0 })
              ;(u.highlight(null, { elementAvailability: !0 }), (t.marked[u.model.id] = h))
            }
          }
        }
      },
      _unmarkAvailableMagnets: function (t) {
        for (var e = Object.keys(t.marked), n, i, s = 0, o = e.length; s < o; s++) {
          ;((n = e[s]), (i = t.marked[n]))
          var u = this.paper.findViewByModel(n)
          if (u) {
            for (var c = 0, h = i.length; c < h; c++)
              u.unhighlight(i[c], { magnetAvailability: !0 })
            u.unhighlight(null, { elementAvailability: !0 })
          }
        }
        t.marked = null
      },
      startArrowheadMove: function (t, e) {
        e || (e = {})
        var n = {
          action: 'arrowhead-move',
          arrowhead: t,
          whenNotAllowed: e.whenNotAllowed || 'revert',
          initialMagnet: this[t + 'Magnet'] || (this[t + 'View'] ? this[t + 'View'].el : null),
          initialEnd: Bi(this.model.get(t)),
          validateConnectionArgs: this._createValidateConnectionArgs(t),
        }
        return (
          this._beforeArrowheadMove(n),
          e.ignoreBackwardsCompatibility !== !0 && (this._dragData = n),
          n
        )
      },
      onMount: function () {
        ;(Ae.prototype.onMount.apply(this, arguments), this.mountLabels())
      },
      onDetach: function () {
        ;(Ae.prototype.onDetach.apply(this, arguments), this.unmountLabels())
      },
      onRemove: function () {
        ;(Ae.prototype.onRemove.apply(this, arguments), this.unmountLabels())
      },
    },
    { Flags: ue }
  )
Object.defineProperty(cl.prototype, 'sourceBBox', {
  enumerable: !0,
  get: function () {
    var t = this.sourceView
    if (!t) {
      var e = this.model.source()
      return new Pt(e.x, e.y)
    }
    var n = this.sourceMagnet
    return t.isNodeConnection(n) ? new Pt(this.sourceAnchor) : t.getNodeBBox(n || t.el)
  },
})
Object.defineProperty(cl.prototype, 'targetBBox', {
  enumerable: !0,
  get: function () {
    var t = this.targetView
    if (!t) {
      var e = this.model.target()
      return new Pt(e.x, e.y)
    }
    var n = this.targetMagnet
    return t.isNodeConnection(n) ? new Pt(this.targetAnchor) : t.getNodeBBox(n || t.el)
  },
})
const eO = rr.extend({
    tagName: 'path',
    className: 'highlight-stroke',
    attributes: { 'pointer-events': 'none', 'vector-effect': 'non-scaling-stroke', fill: 'none' },
    options: {
      padding: 3,
      rx: 0,
      ry: 0,
      useFirstSubpath: !1,
      attrs: { 'stroke-width': 3, stroke: '#FEB663' },
    },
    getPathData(t, e) {
      const { options: n } = this,
        { useFirstSubpath: i } = n
      let s
      try {
        const o = yt(e)
        if (((s = o.convertToPathData().trim()), o.tagName() === 'PATH' && i)) {
          const u = s.search(/.M/i) + 1
          u > 0 && (s = s.substr(0, u))
        }
      } catch {
        const u = t.getNodeBoundingRect(e)
        s = yt.rectToPath(Kt({}, n, u.toJSON()))
      }
      return s
    },
    highlightConnection(t) {
      this.vel.attr('d', t.getSerializedConnection())
    },
    highlightNode(t, e) {
      const { vel: n, options: i } = this,
        { padding: s, layer: o } = i
      let u = this.getNodeMatrix(t, e)
      if (s) {
        !o && e === t.el && n.remove()
        let c = t.getNodeBoundingRect(e)
        const h = c.x + c.width / 2,
          p = c.y + c.height / 2
        c = yt.transformRect(c, u)
        const y = Math.max(c.width, 1),
          v = Math.max(c.height, 1),
          C = (y + s) / y,
          w = (v + s) / v,
          N = yt.createSVGMatrix({ a: C, b: 0, c: 0, d: w, e: h - C * h, f: p - w * p })
        u = u.multiply(N)
      }
      n.attr({ d: this.getPathData(t, e), transform: yt.matrixToTransformString(u) })
    },
    highlight(t, e) {
      const { vel: n, options: i } = this
      ;(n.attr(i.attrs),
        t.isNodeConnection(e) ? this.highlightConnection(t) : this.highlightNode(t, e))
    },
  }),
  lI = 20
function nO(t, e) {
  const n = t.children()
  for (; n.length > 0; ) {
    const i = n.shift()
    e(i) && n.push(...i.children())
  }
}
const iO = rr.extend({
    tagName: 'rect',
    className: 'highlight-mask',
    attributes: { 'pointer-events': 'none' },
    options: {
      padding: 3,
      maskClip: lI,
      deep: !1,
      attrs: {
        stroke: '#FEB663',
        'stroke-width': 3,
        'stroke-linecap': 'butt',
        'stroke-linejoin': 'miter',
      },
    },
    VISIBLE: 'white',
    INVISIBLE: 'black',
    MASK_ROOT_ATTRIBUTE_BLACKLIST: [
      'marker-start',
      'marker-end',
      'marker-mid',
      'transform',
      'stroke-dasharray',
      'class',
    ],
    MASK_CHILD_ATTRIBUTE_BLACKLIST: [
      'stroke',
      'fill',
      'stroke-width',
      'stroke-opacity',
      'stroke-dasharray',
      'fill-opacity',
      'marker-start',
      'marker-end',
      'marker-mid',
      'class',
    ],
    MASK_REPLACE_TAGS: ['FOREIGNOBJECT', 'IMAGE', 'USE', 'TEXT', 'TSPAN', 'TEXTPATH'],
    MASK_REMOVE_TAGS: ['TEXT', 'TSPAN', 'TEXTPATH'],
    transformMaskChild(t, e) {
      const { MASK_CHILD_ATTRIBUTE_BLACKLIST: n, MASK_REPLACE_TAGS: i, MASK_REMOVE_TAGS: s } = this,
        o = e.tagName()
      if (!yt.isSVGGraphicsElement(e) || s.includes(o)) return (e.remove(), !1)
      if (i.includes(o)) {
        const u = t.vel.findOne(`#${e.id}`)
        if (u) {
          const { node: c } = u
          let h = t.getNodeBoundingRect(c)
          t.model.isElement() && (h = yt.transformRect(h, t.getNodeMatrix(c)))
          const p = yt('rect', h.toJSON()),
            { x: y, y: v } = h.center(),
            { angle: C, cx: w = y, cy: N = v } = u.rotate()
          ;(C && p.rotate(C, w, N), e.parent().append(p))
        }
        return (e.remove(), !1)
      }
      return (
        n.forEach(u => {
          ;(u === 'fill' && e.attr('fill') === 'none') || e.removeAttr(u)
        }),
        !0
      )
    },
    transformMaskRoot(t, e) {
      const { MASK_ROOT_ATTRIBUTE_BLACKLIST: n } = this
      n.forEach(i => {
        e.removeAttr(i)
      })
    },
    getMaskShape(t, e) {
      const { options: n, MASK_REPLACE_TAGS: i } = this,
        { deep: s } = n,
        o = e.tagName()
      let u
      if (o === 'G') {
        if (!s) return null
        ;((u = e.clone()), nO(u, c => this.transformMaskChild(t, c)))
      } else {
        if (i.includes(o)) return null
        u = e.clone()
      }
      return (this.transformMaskRoot(t, u), u)
    },
    getMaskId() {
      return `highlight-mask-${this.cid}`
    },
    getMask(t, e) {
      const { VISIBLE: n, INVISIBLE: i, options: s } = this,
        { padding: o, attrs: u } = s,
        c = 'stroke-width' in u ? u['stroke-width'] : 1,
        h = e.attr('fill') !== 'none'
      let p = parseFloat(e.attr('stroke-width'))
      isNaN(p) && (p = 1)
      const y = p + o * 2,
        v = y + c * 2
      let C = this.getMaskShape(t, e)
      if (!C) {
        const w = t.getNodeBoundingRect(e.node)
        ;(w.inflate(w.width ? 0 : 0.5, w.height ? 0 : 0.5), (C = yt('rect', w.toJSON())))
      }
      return (
        C.attr(u),
        yt('mask', { id: this.getMaskId() }).append([
          C.clone().attr({ fill: h ? n : 'none', stroke: n, 'stroke-width': v }),
          C.clone().attr({ fill: h ? i : 'none', stroke: i, 'stroke-width': y }),
        ])
      )
    },
    removeMask(t) {
      const e = t.svg.getElementById(this.getMaskId())
      e && t.defs.removeChild(e)
    },
    addMask(t, e) {
      t.defs.appendChild(e.node)
    },
    highlight(t, e) {
      const { options: n, vel: i } = this,
        { padding: s, attrs: o, maskClip: u = lI, layer: c } = n,
        h = 'stroke' in o ? o.stroke : '#000000'
      !c && e === t.el && i.remove()
      const p = t.getNodeBoundingRect(e).inflate(s + u),
        y = this.getNodeMatrix(t, e),
        v = this.getMask(t, yt(e))
      ;(this.addMask(t.paper, v),
        i.attr(p.toJSON()),
        i.attr({ transform: yt.matrixToTransformString(y), mask: `url(#${v.id})`, fill: h }))
    },
    unhighlight(t) {
      this.removeMask(t.paper)
    },
  }),
  rO = rr.extend({
    UPDATABLE: !1,
    MOUNTABLE: !1,
    opacityClassName: ir('highlight-opacity'),
    highlight: function (t, e) {
      yt(e).addClass(this.opacityClassName)
    },
    unhighlight: function (t, e) {
      yt(e).removeClass(this.opacityClassName)
    },
  }),
  uI = ir('highlighted'),
  aO = rr.extend(
    {
      UPDATABLE: !1,
      MOUNTABLE: !1,
      options: { className: uI },
      highlight: function (t, e) {
        yt(e).addClass(this.options.className)
      },
      unhighlight: function (t, e) {
        yt(e).removeClass(this.options.className)
      },
    },
    { className: uI }
  ),
  ip = { ROW: 'row', COLUMN: 'column' },
  sO = rr.extend(
    {
      tagName: 'g',
      MOUNTABLE: !0,
      UPDATE_ATTRIBUTES: function () {
        return [this.options.attribute]
      },
      _prevItems: null,
      highlight(t, e) {
        const n = t.model,
          { attribute: i, size: s = 20, gap: o = 5, direction: u = ip.ROW } = this.options
        if (!i) throw new Error('List: attribute is required')
        const c = typeof s == 'number' ? { width: s, height: s } : s,
          h = u === ip.ROW,
          p = h ? c.width : c.height
        let y = n.get(i)
        Array.isArray(y) || (y = [])
        const v = this._prevItems || [],
          C = y.map((z, R) => qs(v[R], y[R]))
        if (v.length !== y.length || C.some(z => !z)) {
          const z = this.vel.children(),
            R = y.map((B, H) => {
              const Z = H in z ? z[H].node : null
              if (C[H]) return Z
              const U = this.createListItem(B, c, Z)
              if (!U) return null
              if (!(U instanceof SVGElement)) throw new Error('List: item must be an SVGElement')
              ;((U.dataset.index = H), (U.dataset.attribute = i))
              const nt = H * (p + o)
              return (
                U.setAttribute('transform', h ? `translate(${nt}, 0)` : `translate(0, ${nt})`),
                U
              )
            })
          ;(this.vel.empty().append(R), (this._prevItems = y))
        }
        const w = y.length,
          N = w === 0 ? 0 : w * p + (w - 1) * o,
          T = h ? { width: N, height: c.height } : { width: c.width, height: N }
        this.position(n, T)
      },
      position(t, e) {
        const { vel: n, options: i } = this,
          { margin: s = 5, position: o = 'top-left' } = i,
          { width: u, height: c } = t.size(),
          { left: h, right: p, top: y, bottom: v } = Ia(s),
          C = new Pt(h, y, u - (h + p), c - (y + v))
        let { x: w, y: N } = Gm(C, o)
        switch (o) {
          case fn.CENTER:
          case fn.TOP:
          case fn.BOTTOM: {
            w -= e.width / 2
            break
          }
          case fn.RIGHT:
          case fn.BOTTOM_RIGHT:
          case fn.TOP_RIGHT: {
            w -= e.width
            break
          }
        }
        switch (o) {
          case fn.CENTER:
          case fn.RIGHT:
          case fn.LEFT: {
            N -= e.height / 2
            break
          }
          case fn.BOTTOM:
          case fn.BOTTOM_RIGHT:
          case fn.BOTTOM_LEFT: {
            N -= e.height
            break
          }
        }
        n.attr('transform', `translate(${w}, ${N})`)
      },
    },
    { Directions: ip, Positions: fn }
  ),
  uS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, addClass: aO, list: sO, mask: iO, opacity: rO, stroke: eO },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function oO(t, e, n, i) {
  var s = 'ratio' in i ? i.ratio : 0.5
  return t.getPointAtRatio(s)
}
function lO(t, e, n, i) {
  var s = 'length' in i ? i.length : 20
  return t.getPointAtLength(s)
}
function uO(t, e, n, i) {
  var s = 1e6,
    o = t.getConnection(),
    u = t.getConnectionSubdivisions(),
    c = new Ut(n.clone().offset(0, s), n.clone().offset(0, -s)),
    h = new Ut(n.clone().offset(s, 0), n.clone().offset(-s, 0)),
    p = c.intersect(o, { segmentSubdivisions: u }),
    y = h.intersect(o, { segmentSubdivisions: u }),
    v = []
  return (
    p && Array.prototype.push.apply(v, p),
    y && Array.prototype.push.apply(v, y),
    v.length > 0 ? n.chooseClosest(v) : 'fallbackAt' in i ? cS(t, i.fallbackAt) : fS(t, e, n, i)
  )
}
function cO(t, e, n, i) {
  var s = t.getClosestPoint(n)
  return s || new et()
}
function nc(t) {
  return function (e, n, i, s) {
    if (i instanceof Element) {
      var o = this.paper.findView(i),
        u
      if (o)
        if (o.isNodeConnection(i)) {
          var c = 'fixedAt' in s ? s.fixedAt : '50%'
          u = cS(o, c)
        } else u = o.getNodeBBox(i).center()
      else u = new et()
      return t.call(this, e, n, u, s)
    }
    return t.apply(this, arguments)
  }
}
function cS(t, e) {
  var n = parseFloat(e)
  return Dn(e) ? t.getPointAtRatio(n / 100) : t.getPointAtLength(n)
}
const fO = nc(uO),
  fS = nc(cO),
  hS = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        connectionClosest: fS,
        connectionLength: lO,
        connectionPerpendicular: fO,
        connectionRatio: oO,
        resolveRef: nc,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function Bh(t, e, n) {
  if (hn(n)) {
    const { x: s, y: o } = n
    if (isFinite(o)) {
      const u = new Ut(e, t),
        { start: c, end: h } = u.parallel(o)
      ;((e = c), (t = h))
    }
    n = s
  }
  if (!isFinite(n)) return t
  var i = t.distance(e)
  return n === 0 && i > 0 ? t : t.move(e, -Math.min(n, i - 1))
}
function Vm(t) {
  var e = t.getAttribute('stroke-width')
  return e === null ? 0 : parseFloat(e) || 0
}
function hO(t, e, n = 0) {
  let i, s, o, u
  const { start: c, end: h } = t
  switch (e) {
    case 'left':
      ;((i = 'x'), (s = h), (o = c), (u = -1))
      break
    case 'right':
      ;((i = 'x'), (s = c), (o = h), (u = 1))
      break
    case 'top':
      ;((i = 'y'), (s = h), (o = c), (u = -1))
      break
    case 'bottom':
      ;((i = 'y'), (s = c), (o = h), (u = 1))
      break
    default:
      return
  }
  ;(c[i] < h[i] ? (s[i] = o[i]) : (o[i] = s[i]), isFinite(n) && ((s[i] += u * n), (o[i] += u * n)))
}
function dO(t, e, n, i) {
  let { offset: s, alignOffset: o, align: u } = i
  return (u && hO(t, u, o), Bh(t.end, t.start, s))
}
function dS(t, e, n, i) {
  var s = e.getNodeBBox(n)
  i.stroke && s.inflate(Vm(n) / 2)
  var o = t.intersect(s),
    u = o ? t.start.chooseClosest(o) : t.end
  return Bh(u, t.start, i.offset)
}
function gO(t, e, n, i) {
  var s = e.model.angle()
  if (s === 0) return dS(t, e, n, i)
  var o = e.getNodeUnrotatedBBox(n)
  i.stroke && o.inflate(Vm(n) / 2)
  var u = o.center(),
    c = t.clone().rotate(u, s),
    h = c.setLength(1e6).intersect(o),
    p = h ? c.start.chooseClosest(h).rotate(u, -s) : t.end
  return Bh(p, t.start, i.offset)
}
function pO(t) {
  if (!t) return null
  var e = t
  do {
    var n = e.tagName
    if (typeof n != 'string') return null
    if (((n = n.toUpperCase()), n === 'G')) e = e.firstElementChild
    else if (n === 'TITLE') e = e.nextElementSibling
    else break
  } while (e)
  return e
}
var rp = 'segmentSubdivisons',
  ap = 'shapeBBox'
function vO(t, e, n, i) {
  var s,
    o,
    u = i.selector,
    c = t.end
  if (
    (typeof u == 'string'
      ? (s = e.findBySelector(u)[0])
      : u === !1
        ? (s = n)
        : Array.isArray(u)
          ? (s = vl(n, u))
          : (s = pO(n)),
    !yt.isSVGGraphicsElement(s))
  ) {
    if (s === n || !yt.isSVGGraphicsElement(n)) return c
    s = n
  }
  var h = e.getNodeShape(s),
    p = e.getNodeMatrix(s),
    y = e.getRootTranslateMatrix(),
    v = e.getRootRotateMatrix(),
    C = y.multiply(v).multiply(p),
    w = C.inverse(),
    N = yt.transformLine(t, w),
    T = N.start.clone(),
    z = e.getNodeData(s)
  if (i.insideout === !1) {
    z[ap] || (z[ap] = h.bbox())
    var R = z[ap]
    if (R.containsPoint(T)) return c
  }
  var B
  if (h instanceof Jt) {
    var H = i.precision || 2
    ;(z[rp] || (z[rp] = h.getSegmentSubdivisions({ precision: H })),
      (B = { precision: H, segmentSubdivisions: z[rp] }))
  }
  ;(i.extrapolate === !0 && N.setLength(1e6),
    (o = N.intersect(h, B)),
    o
      ? yt.isArray(o) && (o = T.chooseClosest(o))
      : i.sticky === !0 &&
        (h instanceof Pt
          ? (o = h.pointNearestToPoint(T))
          : h instanceof li
            ? (o = h.intersectionWithLineFromCenterToPoint(T))
            : (o = h.closestPoint(T, B))))
  var Z = o ? yt.transformPoint(o, C) : c,
    U = i.offset || 0
  return (i.stroke && (U += Vm(s) / 2), Bh(Z, t.start, U))
}
const mO = dO,
  yO = dS,
  AO = gO,
  bO = vO,
  gS = Object.freeze(
    Object.defineProperty(
      { __proto__: null, anchor: mO, bbox: yO, boundary: bO, rectangle: AO },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function wa(t) {
  return function (e, n, i, s) {
    var o = !!s.rotate,
      u = o ? e.getNodeUnrotatedBBox(n) : e.getNodeBBox(n),
      c = u[t](),
      h = s.dx
    if (h) {
      var p = Dn(h)
      ;((h = parseFloat(h)), isFinite(h) && (p && ((h /= 100), (h *= u.width)), (c.x += h)))
    }
    var y = s.dy
    if (y) {
      var v = Dn(y)
      ;((y = parseFloat(y)), isFinite(y) && (v && ((y /= 100), (y *= u.height)), (c.y += y)))
    }
    return o ? c.rotate(e.model.getBBox().center(), -e.model.angle()) : c
  }
}
function IO(t, e, n, i) {
  var s = t.model.angle(),
    o = t.getNodeBBox(e),
    u = o.center(),
    c = o.origin(),
    h = o.corner(),
    p = i.padding
  if ((isFinite(p) || (p = 0), c.y + p <= n.y && n.y <= h.y - p)) {
    var y = n.y - u.y
    ;((u.x += s === 0 || s === 180 ? 0 : (y * 1) / Math.tan(Ai(s))), (u.y += y))
  } else if (c.x + p <= n.x && n.x <= h.x - p) {
    var v = n.x - u.x
    ;((u.y += s === 90 || s === 270 ? 0 : v * Math.tan(Ai(s))), (u.x += v))
  }
  return u
}
function CO(t, e, n, i) {
  var s = !!i.rotate,
    o,
    u,
    c
  s
    ? ((o = t.getNodeUnrotatedBBox(e)), (c = t.model.getBBox().center()), (u = t.model.angle()))
    : (o = t.getNodeBBox(e))
  var h = i.padding
  ;(isFinite(h) && o.inflate(h), s && n.rotate(c, u))
  var p = o.sideNearestToPoint(n),
    y
  switch (p) {
    case 'left':
      y = o.leftMiddle()
      break
    case 'right':
      y = o.rightMiddle()
      break
    case 'top':
      y = o.topMiddle()
      break
    case 'bottom':
      y = o.bottomMiddle()
      break
  }
  return s ? y.rotate(c, -u) : y
}
function wO(t, e, n, i, s) {
  return t.model.getPointFromConnectedLink(this.model, s).offset(i.dx, i.dy)
}
const xO = wa('center'),
  SO = wa('topMiddle'),
  NO = wa('bottomMiddle'),
  TO = wa('leftMiddle'),
  MO = wa('rightMiddle'),
  EO = wa('origin'),
  DO = wa('topRight'),
  OO = wa('bottomLeft'),
  LO = wa('corner'),
  zO = nc(IO),
  RO = nc(CO),
  kO = wO,
  pS = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        bottom: NO,
        bottomLeft: OO,
        bottomRight: LO,
        center: xO,
        left: TO,
        midSide: RO,
        modelCenter: kO,
        perpendicular: zO,
        right: MO,
        top: SO,
        topLeft: EO,
        topRight: DO,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  el = { NONE: 'sorting-none', APPROX: 'sorting-approximate', EXACT: 'sorting-exact' },
  _O = 50,
  cI = 20,
  fI = 1e3,
  BO = 1 / 0,
  _f = 9007199254740991,
  sp = Ae.Highlighting,
  hI = {
    [sp.DEFAULT]: { name: 'stroke', options: { padding: 3 } },
    [sp.MAGNET_AVAILABILITY]: { name: 'addClass', options: { className: 'available-magnet' } },
    [sp.ELEMENT_AVAILABILITY]: { name: 'addClass', options: { className: 'available-cell' } },
  },
  jO = [
    { name: Pi.BACK },
    { name: Pi.CELLS },
    { name: Pi.LABELS },
    { name: Pi.FRONT },
    { name: Pi.TOOLS },
  ],
  vS = or.extend(
    {
      className: 'paper',
      options: {
        width: 800,
        height: 600,
        origin: { x: 0, y: 0 },
        gridSize: 1,
        drawGrid: !1,
        drawGridSize: null,
        background: !1,
        perpendicularLinks: !1,
        elementView: bn,
        linkView: cl,
        snapLabels: !1,
        snapLinks: !1,
        snapLinksSelf: !1,
        labelsLayer: !1,
        multiLinks: !0,
        guard: function (t, e) {
          return !1
        },
        highlighting: hI,
        preventContextMenu: !0,
        preventDefaultBlankAction: !0,
        preventDefaultViewAction: !0,
        restrictTranslate: !1,
        markAvailable: !1,
        defaultLink: new wn(),
        defaultConnector: { name: 'normal' },
        defaultRouter: { name: 'normal' },
        defaultAnchor: { name: 'center' },
        defaultLinkAnchor: { name: 'connectionRatio' },
        defaultConnectionPoint: { name: 'bbox' },
        connectionStrategy: null,
        validateMagnet: function (t, e, n) {
          return e.getAttribute('magnet') !== 'passive'
        },
        validateConnection: function (t, e, n, i, s, o) {
          return (s === 'target' ? n : t) instanceof bn
        },
        embeddingMode: !1,
        validateEmbedding: function (t, e) {
          return !0
        },
        validateUnembedding: function (t) {
          return !0
        },
        findParentBy: 'bbox',
        frontParentOnly: !0,
        interactive: { labelMove: !1 },
        linkPinning: !0,
        allowLink: null,
        clickThreshold: 0,
        moveThreshold: 0,
        magnetThreshold: 0,
        sorting: el.EXACT,
        frozen: !1,
        autoFreeze: !1,
        onViewUpdate: function (t, e, n, i, s) {
          e & (t.FLAG_INSERT | t.FLAG_REMOVE) ||
            i.mounting ||
            i.isolate ||
            s.requestConnectedLinksUpdate(t, n, i)
        },
        onViewPostponed: function (t, e, n) {
          return n.forcePostponedViewUpdate(t, e)
        },
        beforeRender: null,
        afterRender: null,
        viewport: null,
        cellViewNamespace: null,
        routerNamespace: null,
        connectorNamespace: null,
        highlighterNamespace: uS,
        anchorNamespace: pS,
        linkAnchorNamespace: hS,
        connectionPointNamespace: gS,
        overflow: !1,
      },
      events: {
        dblclick: 'pointerdblclick',
        dbltap: 'pointerdblclick',
        contextmenu: 'contextmenu',
        mousedown: 'pointerdown',
        touchstart: 'pointerdown',
        mouseover: 'mouseover',
        mouseout: 'mouseout',
        mouseenter: 'mouseenter',
        mouseleave: 'mouseleave',
        wheel: 'mousewheel',
        'mouseenter .joint-cell': 'mouseenter',
        'mouseleave .joint-cell': 'mouseleave',
        'mouseenter .joint-tools': 'mouseenter',
        'mouseleave .joint-tools': 'mouseleave',
        'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',
        'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',
        'mousedown .joint-link .label': 'onlabel',
        'touchstart .joint-link .label': 'onlabel',
        'dragstart .joint-cell image': 'onImageDragStart',
      },
      documentEvents: {
        mousemove: 'pointermove',
        touchmove: 'pointermove',
        mouseup: 'pointerup',
        touchend: 'pointerup',
        touchcancel: 'pointerup',
      },
      svg: null,
      viewport: null,
      defs: null,
      tools: null,
      $background: null,
      layers: null,
      $grid: null,
      $document: null,
      _viewportMatrix: null,
      _viewportTransformString: null,
      _updates: null,
      _layers: null,
      SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],
      UPDATE_DELAYING_BATCHES: ['translate'],
      FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'],
      GUARDED_TAG_NAMES: ['SELECT'],
      MIN_SCALE: 1e-6,
      init: function () {
        const { options: t, el: e } = this
        t.cellViewNamespace ||
          (t.cellViewNamespace = typeof joint < 'u' && Mr(joint, 'shapes') ? joint.shapes : null)
        const n = (this.model = t.model || new Vr())
        ;((this._layers = {}),
          this.setGrid(t.drawGrid),
          this.cloneOptions(),
          this.render(),
          this._setDimensions(),
          this.startListening(),
          (this._views = {}),
          (this._mw_evt_buffer = { event: null, deltas: [] }),
          (this.$document = Ie(e.ownerDocument)),
          this.resetViews(n.attributes.cells.models),
          !this.isFrozen() && this.isAsync() && this.updateViewsAsync())
      },
      _resetUpdates: function () {
        return (this._updates = {
          id: null,
          priorities: [{}, {}, {}],
          unmountedCids: [],
          mountedCids: [],
          unmounted: {},
          mounted: {},
          count: 0,
          keyFrozen: !1,
          freezeKey: null,
          sort: !1,
          disabled: !1,
          idle: !1,
        })
      },
      startListening: function () {
        var t = this.model
        ;(this.listenTo(t, 'add', this.onCellAdded)
          .listenTo(t, 'remove', this.onCellRemoved)
          .listenTo(t, 'change', this.onCellChange)
          .listenTo(t, 'reset', this.onGraphReset)
          .listenTo(t, 'sort', this.onGraphSort)
          .listenTo(t, 'batch:stop', this.onGraphBatchStop),
          this.on('cell:highlight', this.onCellHighlight)
            .on('cell:unhighlight', this.onCellUnhighlight)
            .on('scale translate', this.update))
      },
      onCellAdded: function (t, e, n) {
        var i = n.position
        this.isAsync() || !ai(i)
          ? this.renderView(t, n)
          : (n.maxPosition === i && this.freeze({ key: 'addCells' }),
            this.renderView(t, n),
            i === 0 && this.unfreeze({ key: 'addCells' }))
      },
      onCellRemoved: function (t, e, n) {
        const i = this.findViewByModel(t)
        i && this.requestViewUpdate(i, i.FLAG_REMOVE, i.UPDATE_PRIORITY, n)
      },
      onCellChange: function (t, e) {
        if (
          t !== this.model.attributes.cells &&
          t.hasChanged('z') &&
          this.options.sorting === el.APPROX
        ) {
          const n = this.findViewByModel(t)
          n && this.requestViewUpdate(n, n.FLAG_INSERT, n.UPDATE_PRIORITY, e)
        }
      },
      onGraphReset: function (t, e) {
        ;(this.resetLayers(), this.resetViews(t.models, e))
      },
      onGraphSort: function () {
        this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES) || this.sortViews()
      },
      onGraphBatchStop: function (t) {
        if (!this.isFrozen()) {
          var e = t && t.batchName,
            n = this.model
          if (!this.isAsync()) {
            var i = this.UPDATE_DELAYING_BATCHES
            i.includes(e) && !n.hasActiveBatch(i) && this.updateViews(t)
          }
          var s = this.SORT_DELAYING_BATCHES
          s.includes(e) && !n.hasActiveBatch(s) && this.sortViews()
        }
      },
      cloneOptions: function () {
        const { options: t } = this,
          {
            defaultConnector: e,
            defaultRouter: n,
            defaultConnectionPoint: i,
            defaultAnchor: s,
            defaultLinkAnchor: o,
            origin: u,
            highlighting: c,
            cellViewNamespace: h,
            interactive: p,
          } = t
        ;(!h && typeof joint < 'u' && Mr(joint, 'shapes') && (t.cellViewNamespace = joint.shapes),
          Ze(e) || (t.defaultConnector = ti(e)),
          Ze(n) || (t.defaultRouter = ti(n)),
          Ze(i) || (t.defaultConnectionPoint = ti(i)),
          Ze(s) || (t.defaultAnchor = ti(s)),
          Ze(o) || (t.defaultLinkAnchor = ti(o)),
          hn(p) && (t.interactive = Kt({}, p)),
          hn(c) && (t.highlighting = _h({}, c, hI)),
          (t.origin = Kt({}, u)))
      },
      children: function () {
        var t = yt.namespace
        return [
          {
            namespaceURI: t.xhtml,
            tagName: 'div',
            className: ir('paper-background'),
            selector: 'background',
          },
          { namespaceURI: t.xhtml, tagName: 'div', className: ir('paper-grid'), selector: 'grid' },
          {
            namespaceURI: t.svg,
            tagName: 'svg',
            attributes: { width: '100%', height: '100%', 'xmlns:xlink': t.xlink },
            selector: 'svg',
            children: [
              { tagName: 'defs', selector: 'defs' },
              { tagName: 'g', className: ir('layers'), selector: 'layers' },
            ],
          },
        ]
      },
      hasLayerView(t) {
        return t in this._layers
      },
      getLayerView(t) {
        const { _layers: e } = this
        if (t in e) return e[t]
        throw new Error(`dia.Paper: Unknown layer "${t}"`)
      },
      getLayerNode(t) {
        return this.getLayerView(t).el
      },
      render: function () {
        this.renderChildren()
        const { childNodes: t, options: e } = this,
          { svg: n, defs: i, layers: s, background: o, grid: u } = t
        return (
          (n.style.overflow = e.overflow ? 'visible' : 'hidden'),
          (this.svg = n),
          (this.defs = i),
          (this.layers = s),
          (this.$background = Ie(o)),
          (this.$grid = Ie(u)),
          this.renderLayers(),
          yt.ensureId(n),
          e.background && this.drawBackground(e.background),
          e.drawGrid && this.drawGrid(),
          this
        )
      },
      renderLayers: function (t = jO) {
        ;(this.removeLayers(),
          t.forEach(({ name: s, sorted: o }) => {
            const u = new Kx({ name: s })
            ;(this.layers.appendChild(u.el), (this._layers[s] = u))
          }))
        const e = this.getLayerView(Pi.CELLS),
          n = this.getLayerView(Pi.TOOLS),
          i = this.getLayerView(Pi.LABELS)
        ;((this.tools = n.el),
          (this.cells = this.viewport = e.el),
          e.vel.addClass(ir('viewport')),
          i.vel.addClass(ir('viewport')))
      },
      removeLayers: function () {
        const { _layers: t } = this
        Object.keys(t).forEach(e => {
          ;(t[e].remove(), delete t[e])
        })
      },
      resetLayers: function () {
        const { _layers: t } = this
        Object.keys(t).forEach(e => {
          t[e].removePivots()
        })
      },
      update: function () {
        return (
          this.options.drawGrid && this.drawGrid(),
          this._background && this.updateBackgroundImage(this._background),
          this
        )
      },
      matrix: function (t) {
        var e = this.layers
        if (t === void 0) {
          var n = e.getAttribute('transform')
          return (
            (this._viewportTransformString || null) === n
              ? (t = this._viewportMatrix)
              : ((t = e.getCTM()), (this._viewportMatrix = t), (this._viewportTransformString = n)),
            yt.createSVGMatrix(t)
          )
        }
        t = yt.createSVGMatrix(t)
        var i = yt.matrixToTransformString(t)
        return (
          e.setAttribute('transform', i),
          (this._viewportMatrix = t),
          (this._viewportTransformString = e.getAttribute('transform')),
          this
        )
      },
      clientMatrix: function () {
        return yt.createSVGMatrix(this.cells.getScreenCTM())
      },
      requestConnectedLinksUpdate: function (t, e, n) {
        if (t instanceof Ae)
          for (
            var i = t.model, s = this.model.getConnectedLinks(i), o = 0, u = s.length;
            o < u;
            o++
          ) {
            var c = s[o],
              h = this.findViewByModel(c)
            if (h) {
              var p = ['UPDATE']
              ;(c.getTargetCell() === i && p.push('TARGET'),
                c.getSourceCell() === i && p.push('SOURCE'))
              var y = Math.max(e + 1, h.UPDATE_PRIORITY)
              this.scheduleViewUpdate(h, h.getFlag(p), y, n)
            }
          }
      },
      forcePostponedViewUpdate: function (t, e) {
        if (!t || !(t instanceof Ae)) return !1
        var n = t.model
        if (n.isElement()) return !1
        if ((e & t.getFlag(['SOURCE', 'TARGET'])) === 0) {
          var i = { silent: !0 },
            s = 0,
            o = this.findViewByModel(n.getSourceCell())
          o && !this.isViewMounted(o) && ((s = this.dumpView(o, i)), t.updateEndMagnet('source'))
          var u = 0,
            c = this.findViewByModel(n.getTargetCell())
          if (
            (c &&
              !this.isViewMounted(c) &&
              ((u = this.dumpView(c, i)), t.updateEndMagnet('target')),
            s === 0 && u === 0)
          )
            return !this.dumpView(t, i)
        }
        return !1
      },
      requestViewUpdate: function (t, e, n, i) {
        ;(i || (i = {}), this.scheduleViewUpdate(t, e, n, i))
        var s = this.isAsync()
        if (
          !(this.isFrozen() || (s && i.async !== !1)) &&
          !this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)
        ) {
          var o = this.updateViews(i)
          s && this.notifyAfterRender(o, i)
        }
      },
      scheduleViewUpdate: function (t, e, n, i) {
        const { _updates: s, options: o } = this
        s.idle && o.autoFreeze && ((s.idle = !1), this.unfreeze())
        const { FLAG_REMOVE: u, FLAG_INSERT: c, UPDATE_PRIORITY: h, cid: p } = t
        let y = s.priorities[n]
        if ((y || (y = s.priorities[n] = {}), n > h))
          for (let w = n - 1; w >= h; w--) {
            const N = s.priorities[w]
            !N || !(p in N) || ((y[p] |= N[p]), delete N[p])
          }
        let v = y[p] || 0
        if ((v & e) === e) return
        ;(v || s.count++, e & u && v & c ? (y[p] ^= c) : e & c && v & u && (y[p] ^= u), (y[p] |= e))
        const C = o.onViewUpdate
        typeof C == 'function' && C.call(this, t, e, n, i || {}, this)
      },
      dumpViewUpdate: function (t) {
        if (!t) return 0
        var e = this._updates,
          n = t.cid,
          i = e.priorities[t.UPDATE_PRIORITY],
          s = this.registerMountedView(t) | i[n]
        return (delete i[n], s)
      },
      dumpView: function (t, e = {}) {
        const n = this.dumpViewUpdate(t)
        if (!n) return 0
        const i = !e.silent
        i && this.notifyBeforeRender(e)
        const s = this.updateView(t, n, e)
        if (i) {
          const o = { updated: 1, priority: t.UPDATE_PRIORITY }
          this.notifyAfterRender(o, e)
        }
        return s
      },
      updateView: function (t, e, n) {
        if (!t) return 0
        const { FLAG_REMOVE: i, FLAG_INSERT: s, FLAG_INIT: o, model: u } = t
        if (t instanceof Ae) {
          if (e & i) return (this.removeView(u), 0)
          if (e & s) {
            const c = !!(e & o)
            ;(c && (e ^= o), this.insertView(t, c), (e ^= s))
          }
        }
        return e ? t.confirmUpdate(e, n || {}) : 0
      },
      requireView: function (t, e) {
        var n = this.findViewByModel(t)
        return n ? (this.dumpView(n, e), n) : null
      },
      registerUnmountedView: function (t) {
        var e = t.cid,
          n = this._updates
        if (e in n.unmounted) return 0
        var i = (n.unmounted[e] |= t.FLAG_INSERT)
        return (n.unmountedCids.push(e), delete n.mounted[e], i)
      },
      registerMountedView: function (t) {
        var e = t.cid,
          n = this._updates
        if (e in n.mounted) return 0
        ;((n.mounted[e] = !0), n.mountedCids.push(e))
        var i = n.unmounted[e] || 0
        return (delete n.unmounted[e], i)
      },
      isViewMounted: function (t) {
        if (!t) return !1
        var e = t.cid,
          n = this._updates
        return e in n.mounted
      },
      dumpViews: function (t) {
        var e = mi({}, t, { viewport: null })
        ;(this.checkViewport(e), this.updateViews(e))
      },
      updateViews: function (t) {
        this.notifyBeforeRender(t)
        let e,
          n = 0,
          i = 0,
          s = _f
        do (i++, (e = this.updateViewsBatch(t)), (n += e.updated), (s = Math.min(e.priority, s)))
        while (!e.empty)
        const o = { updated: n, batches: i, priority: s }
        return (this.notifyAfterRender(o, t), o)
      },
      hasScheduledUpdates: function () {
        const t = this._updates.priorities,
          e = Object.keys(t)
        let n = e.length
        for (; n > 0 && n--; ) for (let i in t[e[n]]) return !0
        return !1
      },
      updateViewsAsync: function (t, e) {
        ;(t || (t = {}), e || (e = { processed: 0, priority: _f }))
        const { _updates: n, options: i } = this,
          s = n.id
        if (s) {
          ;(ah(s), e.processed === 0 && this.hasScheduledUpdates() && this.notifyBeforeRender(t))
          const o = this.updateViewsBatch(t),
            u = mi({}, t, { mountBatchSize: fI - o.mounted, unmountBatchSize: fI - o.unmounted }),
            c = this.checkViewport(u),
            h = c.unmounted,
            p = c.mounted
          let y = e.processed
          const v = n.count
          o.updated > 0
            ? ((y += o.updated + o.unmounted),
              (o.processed = y),
              (e.priority = Math.min(o.priority, e.priority)),
              o.empty && p === 0
                ? ((o.unmounted += h),
                  (o.mounted += p),
                  (o.priority = e.priority),
                  this.notifyAfterRender(o, t),
                  (e.processed = 0),
                  (e.priority = _f),
                  (n.count = 0))
                : (e.processed = y))
            : n.idle ||
              (i.autoFreeze && (this.freeze(), (n.idle = !0), this.trigger('render:idle', t)))
          const C = t.progress
          if ((v && typeof C == 'function' && C.call(this, o.empty, y, v, o, this), n.id !== s))
            return
        }
        if (n.disabled)
          throw new Error('dia.Paper: can not unfreeze the paper after it was removed')
        n.id = rh(this.updateViewsAsync, this, t, e)
      },
      notifyBeforeRender: function (t = {}) {
        let e = t.beforeRender
        ;(typeof e != 'function' && ((e = this.options.beforeRender), typeof e != 'function')) ||
          e.call(this, t, this)
      },
      notifyAfterRender: function (t, e = {}) {
        let n = e.afterRender
        ;(typeof n != 'function' && (n = this.options.afterRender),
          typeof n == 'function' && n.call(this, t, e, this),
          this.trigger('render:done', t, e))
      },
      updateViewsBatch: function (t) {
        t || (t = {})
        var e = t.batchSize || BO,
          n = this._updates,
          i = 0,
          s = 0,
          o = 0,
          u = 0,
          c = _f,
          h = !0,
          p = this.options,
          y = n.priorities,
          v = 'viewport' in t ? t.viewport : p.viewport
        typeof v != 'function' && (v = null)
        var C = p.onViewPostponed
        typeof C != 'function' && (C = null)
        var w = Object.keys(y)
        t: for (var N = 0, T = w.length; N < T; N++) {
          var z = +w[N],
            R = y[z]
          for (var B in R) {
            if (i >= e) {
              h = !1
              break t
            }
            var H = ya[B]
            if (!H) {
              delete R[B]
              continue
            }
            var Z = R[B]
            if ((Z & H.FLAG_REMOVE) === 0) {
              var U = B in n.unmounted
              if (H.DETACHABLE && v && !v.call(this, H, !U, this)) {
                ;(U || (this.registerUnmountedView(H), this.detachView(H)),
                  (n.unmounted[B] |= Z),
                  delete R[B],
                  o++)
                continue
              }
              ;(U && ((Z |= H.FLAG_INSERT), u++), (Z |= this.registerMountedView(H)))
            }
            var nt = this.updateView(H, Z, t)
            if (nt > 0 && ((R[B] = nt), !C || !C.call(this, H, nt, this) || R[B])) {
              ;(s++, (h = !1))
              continue
            }
            ;(c > z && (c = z), i++, delete R[B])
          }
        }
        return { priority: c, updated: i, postponed: s, unmounted: o, mounted: u, empty: h }
      },
      getUnmountedViews: function () {
        const t = this._updates,
          e = Object.keys(t.unmounted),
          n = e.length,
          i = new Array(n)
        for (var s = 0; s < n; s++) i[s] = ya[e[s]]
        return i
      },
      getMountedViews: function () {
        const t = this._updates,
          e = Object.keys(t.mounted),
          n = e.length,
          i = new Array(n)
        for (var s = 0; s < n; s++) i[s] = ya[e[s]]
        return i
      },
      checkUnmountedViews: function (t, e) {
        e || (e = {})
        var n = 0
        typeof t != 'function' && (t = null)
        for (
          var i = ('mountBatchSize' in e) ? e.mountBatchSize : 1 / 0,
            s = this._updates,
            o = s.unmountedCids,
            u = s.unmounted,
            c = 0,
            h = Math.min(o.length, i);
          c < h;
          c++
        ) {
          var p = o[c]
          if (p in u) {
            var y = ya[p]
            if (y) {
              if (y.DETACHABLE && t && !t.call(this, y, !1, this)) {
                o.push(p)
                continue
              }
              n++
              var v = this.registerMountedView(y)
              v && this.scheduleViewUpdate(y, v, y.UPDATE_PRIORITY, { mounting: !0 })
            }
          }
        }
        return (o.splice(0, c), n)
      },
      checkMountedViews: function (t, e) {
        e || (e = {})
        var n = 0
        if (typeof t != 'function') return n
        for (
          var i = ('unmountBatchSize' in e) ? e.unmountBatchSize : 1 / 0,
            s = this._updates,
            o = s.mountedCids,
            u = s.mounted,
            c = 0,
            h = Math.min(o.length, i);
          c < h;
          c++
        ) {
          var p = o[c]
          if (p in u) {
            var y = ya[p]
            if (y) {
              if (!y.DETACHABLE || t.call(this, y, !0, this)) {
                o.push(p)
                continue
              }
              n++
              var v = this.registerUnmountedView(y)
              v && this.detachView(y)
            }
          }
        }
        return (o.splice(0, c), n)
      },
      checkViewVisibility: function (t, e = {}) {
        let n = 'viewport' in e ? e.viewport : this.options.viewport
        typeof n != 'function' && (n = null)
        const i = this._updates,
          { mounted: s, unmounted: o } = i,
          u = !t.DETACHABLE || !n || n.call(this, t, !1, this)
        let c = !1,
          h = !1
        if (t.cid in s && !u) {
          this.registerUnmountedView(t) && this.detachView(t)
          const v = i.mountedCids.indexOf(t.cid)
          ;(i.mountedCids.splice(v, 1), (c = !0))
        }
        if (!c && t.cid in o && u) {
          const y = i.unmountedCids.indexOf(t.cid)
          i.unmountedCids.splice(y, 1)
          var p = this.registerMountedView(t)
          ;(p && this.scheduleViewUpdate(t, p, t.UPDATE_PRIORITY, { mounting: !0 }), (h = !0))
        }
        return { mounted: h ? 1 : 0, unmounted: c ? 1 : 0 }
      },
      checkViewport: function (t) {
        var e = mi({}, t, { mountBatchSize: 1 / 0, unmountBatchSize: 1 / 0 }),
          n = 'viewport' in e ? e.viewport : this.options.viewport,
          i = this.checkMountedViews(n, e)
        if (i > 0) {
          var s = this._updates.unmountedCids
          e.mountBatchSize = Math.min(s.length - i, e.mountBatchSize)
        }
        var o = this.checkUnmountedViews(n, e)
        return { mounted: o, unmounted: i }
      },
      freeze: function (t) {
        t || (t = {})
        var e = this._updates,
          n = t.key,
          i = this.options.frozen,
          s = e.freezeKey
        if (n && n !== s) {
          if (i && s) return
          ;((e.freezeKey = n), (e.keyFrozen = i))
        }
        this.options.frozen = !0
        var o = e.id
        ;((e.id = null), this.isAsync() && o && ah(o))
      },
      unfreeze: function (t) {
        t || (t = {})
        var e = this._updates,
          n = t.key,
          i = e.freezeKey
        ;(n && i && n !== i) ||
          ((e.freezeKey = null),
          !(n && n === i && e.keyFrozen) &&
            (this.isAsync() ? (this.freeze(), this.updateViewsAsync(t)) : this.updateViews(t),
            (this.options.frozen = e.keyFrozen = !1),
            e.sort && (this.sortViews(), (e.sort = !1))))
      },
      isAsync: function () {
        return !!this.options.async
      },
      isFrozen: function () {
        return !!this.options.frozen
      },
      isExactSorting: function () {
        return this.options.sorting === el.EXACT
      },
      onRemove: function () {
        ;(this.freeze(), (this._updates.disabled = !0), this.removeLayers(), this.removeViews())
      },
      getComputedSize: function () {
        var t = this.options,
          e = t.width,
          n = t.height
        return (
          ai(e) || (e = this.el.clientWidth),
          ai(n) || (n = this.el.clientHeight),
          { width: e, height: n }
        )
      },
      setDimensions: function (t, e) {
        const { options: n } = this,
          { width: i, height: s } = n
        let o = t === void 0 ? i : t,
          u = e === void 0 ? s : e
        if (i === o && s === u) return
        ;((n.width = o), (n.height = u), this._setDimensions())
        const c = this.getComputedSize()
        this.trigger('resize', c.width, c.height)
      },
      _setDimensions: function () {
        const { options: t } = this
        let e = t.width,
          n = t.height
        ;(ai(e) && (e = Math.round(e)),
          ai(n) && (n = Math.round(n)),
          this.$el.css({ width: e === null ? '' : e, height: n === null ? '' : n }))
      },
      setOrigin: function (t, e) {
        return this.translate(t || 0, e || 0)
      },
      fitToContent: function (t, e, n, i) {
        ze(t) ? (i = t) : (i = Kt({ gridWidth: t, gridHeight: e, padding: n }, i))
        const { x: s, y: o, width: u, height: c } = this.getFitToContentArea(i),
          { sx: h, sy: p } = this.scale()
        return (
          this.setOrigin(-s * h, -o * p),
          this.setDimensions(u * h, c * p),
          new Pt(s, o, u, c)
        )
      },
      getFitToContentArea: function (t = {}) {
        const e = t.gridWidth || 1,
          n = t.gridHeight || 1,
          i = Ia(t.padding || 0),
          s = Math.max(t.minWidth || 0, e),
          o = Math.max(t.minHeight || 0, n),
          u = t.maxWidth || Number.MAX_VALUE,
          c = t.maxHeight || Number.MAX_VALUE,
          h = t.allowNewOrigin,
          p = 'contentArea' in t ? new Pt(t.contentArea) : this.getContentArea(t),
          { sx: y, sy: v } = this.scale()
        ;((p.x *= y), (p.y *= v), (p.width *= y), (p.height *= v))
        let C = Math.ceil((p.width + p.x) / e),
          w = Math.ceil((p.height + p.y) / n)
        ;(t.allowNegativeBottomRight || ((C = Math.max(C, 1)), (w = Math.max(w, 1))),
          (C *= e),
          (w *= n))
        let N = 0
        ;((h === 'negative' && p.x < 0) || (h === 'positive' && p.x >= 0) || h === 'any') &&
          ((N = Math.ceil(-p.x / e) * e), (N += i.left), (C += N))
        let T = 0
        return (
          ((h === 'negative' && p.y < 0) || (h === 'positive' && p.y >= 0) || h === 'any') &&
            ((T = Math.ceil(-p.y / n) * n), (T += i.top), (w += T)),
          (C += i.right),
          (w += i.bottom),
          (C = Math.max(C, s)),
          (w = Math.max(w, o)),
          (C = Math.min(C, u)),
          (w = Math.min(w, c)),
          new Pt(-N / y, -T / v, C / y, w / v)
        )
      },
      transformToFitContent: function (t) {
        t || (t = {})
        let e, n
        if ('contentArea' in t) {
          const z = t.contentArea
          ;((e = this.localToPaperRect(z)), (n = new et(z)))
        } else ((e = this.getContentBBox(t)), (n = this.paperToLocalPoint(e)))
        if (!e.width || !e.height) return
        mi(t, {
          padding: 0,
          preserveAspectRatio: !0,
          scaleGrid: null,
          minScale: 0,
          maxScale: Number.MAX_VALUE,
          verticalAlign: 'top',
          horizontalAlign: 'left',
        })
        const i = Ia(t.padding),
          s = t.minScaleX || t.minScale,
          o = t.maxScaleX || t.maxScale,
          u = t.minScaleY || t.minScale,
          c = t.maxScaleY || t.maxScale
        let h
        if (t.fittingBBox) h = t.fittingBBox
        else {
          const z = this.translate(),
            R = this.getComputedSize()
          h = { x: z.tx, y: z.ty, width: R.width, height: R.height }
        }
        h = new Pt(h).moveAndExpand({
          x: i.left,
          y: i.top,
          width: -i.left - i.right,
          height: -i.top - i.bottom,
        })
        const p = this.scale()
        let y = (h.width / e.width) * p.sx,
          v = (h.height / e.height) * p.sy
        if ((t.preserveAspectRatio && (y = v = Math.min(y, v)), t.scaleGrid)) {
          const z = t.scaleGrid
          ;((y = z * Math.floor(y / z)), (v = z * Math.floor(v / z)))
        }
        ;((y = Math.min(o, Math.max(s, y))), (v = Math.min(c, Math.max(u, v))))
        const C = { x: y / p.sx, y: v / p.sy },
          w = this.options.origin
        let N = h.x - n.x * y - w.x,
          T = h.y - n.y * v - w.y
        switch (t.verticalAlign) {
          case 'middle':
            T = T + (h.height - e.height * C.y) / 2
            break
          case 'bottom':
            T = T + (h.height - e.height * C.y)
            break
        }
        switch (t.horizontalAlign) {
          case 'middle':
            N = N + (h.width - e.width * C.x) / 2
            break
          case 'right':
            N = N + (h.width - e.width * C.x)
            break
        }
        ;(this.scale(y, v), this.translate(N, T))
      },
      scaleContentToFit: function (t) {
        this.transformToFitContent(t)
      },
      getContentArea: function (t) {
        return t && t.useModelGeometry ? this.model.getBBox() || new Pt() : yt(this.cells).getBBox()
      },
      getContentBBox: function (t) {
        return this.localToPaperRect(this.getContentArea(t))
      },
      getArea: function () {
        return this.paperToLocalRect(this.getComputedSize())
      },
      getRestrictedArea: function (...t) {
        const { restrictTranslate: e } = this.options
        let n
        return (
          Ze(e)
            ? (n = e.apply(this, t))
            : e === !0
              ? (n = this.getArea())
              : e
                ? (n = new Pt(e))
                : (n = null),
          n
        )
      },
      createViewForModel: function (t) {
        const { options: e } = this
        var n,
          i,
          s = e.cellViewNamespace,
          o = t.get('type') + 'View',
          u = vl(s, o, '.')
        t.isLink() ? ((n = e.linkView), (i = cl)) : ((n = e.elementView), (i = bn))
        var c = n.prototype instanceof En.View ? u || n : n.call(this, t) || u || i
        return new c({
          model: t,
          interactive: e.interactive,
          labelsLayer: e.labelsLayer === !0 ? Pi.LABELS : e.labelsLayer,
        })
      },
      removeView: function (t) {
        const { id: e } = t,
          { _views: n, _updates: i } = this,
          s = n[e]
        if (s) {
          var { cid: o } = s
          const { mounted: u, unmounted: c } = i
          ;(s.remove(), delete n[e], delete u[o], delete c[o])
        }
        return s
      },
      renderView: function (t, e) {
        const { id: n } = t,
          i = this._views
        let s,
          o,
          u = !0
        return (
          n in i &&
            ((s = i[n]), s.model === t ? ((o = s.FLAG_INSERT), (u = !1)) : this.removeView(t)),
          u &&
            ((s = i[n] = this.createViewForModel(t)),
            (s.paper = this),
            (o = this.registerUnmountedView(s) | this.FLAG_INIT | s.getFlag(dn(s, 'initFlag')))),
          this.requestViewUpdate(s, o, s.UPDATE_PRIORITY, e),
          s
        )
      },
      onImageDragStart: function () {
        return !1
      },
      resetViews: function (t, e) {
        ;(e || (e = {}), t || (t = []), this._resetUpdates(), this.removeViews())
        const n = this.options.autoFreeze ? null : 'reset'
        this.freeze({ key: n })
        for (var i = 0, s = t.length; i < s; i++) this.renderView(t[i], e)
        ;(this.unfreeze({ key: n }), this.sortViews())
      },
      removeViews: function () {
        ;(Ui(this._views, 'remove'), (this._views = {}))
      },
      sortViews: function () {
        if (this.isExactSorting()) {
          if (this.isFrozen()) {
            this._updates.sort = !0
            return
          }
          this.sortViewsExact()
        }
      },
      sortViewsExact: function () {
        var t = Ie(this.cells).children('[model-id]'),
          e = this.model.get('cells')
        Bx(t, function (n, i) {
          var s = e.get(n.getAttribute('model-id')),
            o = e.get(i.getAttribute('model-id')),
            u = s.attributes.z || 0,
            c = o.attributes.z || 0
          return u === c ? 0 : u < c ? -1 : 1
        })
      },
      insertView: function (t, e) {
        const n = this.getLayerView(Pi.CELLS),
          { el: i, model: s } = t
        switch (this.options.sorting) {
          case el.APPROX:
            n.insertSortedNode(i, s.get('z'))
            break
          case el.EXACT:
          default:
            n.insertNode(i)
            break
        }
        t.onMount(e)
      },
      detachView(t) {
        ;(t.unmount(), t.onDetach())
      },
      scale: function (t, e, n, i) {
        if (t === void 0) return yt.matrixToScale(this.matrix())
        ;(e === void 0 && (e = t), n === void 0 && ((n = 0), (i = 0)))
        var s = this.translate()
        if (n || i || s.tx || s.ty) {
          var o = s.tx - n * (t - 1),
            u = s.ty - i * (e - 1)
          this.translate(o, u)
        }
        ;((t = Math.max(t || 0, this.MIN_SCALE)), (e = Math.max(e || 0, this.MIN_SCALE)))
        var c = this.matrix()
        return ((c.a = t), (c.d = e), this.matrix(c), this.trigger('scale', t, e, n, i), this)
      },
      rotate: function (t, e, n) {
        if (t === void 0) return yt.matrixToRotate(this.matrix())
        if (e === void 0) {
          var i = this.cells.getBBox()
          ;((e = i.width / 2), (n = i.height / 2))
        }
        var s = this.matrix().translate(e, n).rotate(t).translate(-e, -n)
        return (this.matrix(s), this)
      },
      translate: function (t, e) {
        if (t === void 0) return yt.matrixToTranslate(this.matrix())
        const { options: n } = this,
          { origin: i, drawGrid: s } = n
        ;(t || (t = 0), e || (e = 0))
        const o = this.matrix()
        if (o.e === t && o.f === e) return this
        ;((o.e = t), (o.f = e), this.matrix(o))
        const { tx: u, ty: c } = this.translate()
        return ((i.x = u), (i.y = c), this.trigger('translate', u, c), s && this.drawGrid(), this)
      },
      findView: function (t) {
        var e = Wn(t) ? this.cells.querySelector(t) : t instanceof Ie ? t[0] : t,
          n = this.findAttribute('model-id', e)
        if (n) return this._views[n]
      },
      findViewByModel: function (t) {
        var e = Wn(t) || ai(t) ? t : t && t.id
        return this._views[e]
      },
      findViewsFromPoint: function (t) {
        t = new et(t)
        var e = this.model.getElements().map(this.findViewByModel, this)
        return e.filter(function (n) {
          return n && n.vel.getBBox({ target: this.cells }).containsPoint(t)
        }, this)
      },
      findViewsInArea: function (t, e) {
        ;((e = mi(e || {}, { strict: !1 })), (t = new Pt(t)))
        var n = this.model.getElements().map(this.findViewByModel, this),
          i = e.strict ? 'containsRect' : 'intersect'
        return n.filter(function (s) {
          return s && t[i](s.vel.getBBox({ target: this.cells }))
        }, this)
      },
      removeTools: function () {
        return (this.dispatchToolsEvent('remove'), this)
      },
      hideTools: function () {
        return (this.dispatchToolsEvent('hide'), this)
      },
      showTools: function () {
        return (this.dispatchToolsEvent('show'), this)
      },
      dispatchToolsEvent: function (t, ...e) {
        typeof t == 'string' && this.trigger('tools:event', t, ...e)
      },
      getModelById: function (t) {
        return this.model.getCell(t)
      },
      snapToGrid: function (t, e) {
        return this.clientToLocalPoint(t, e).snapToGrid(this.options.gridSize)
      },
      localToPaperPoint: function (t, e) {
        var n = new et(t, e),
          i = yt.transformPoint(n, this.matrix())
        return i
      },
      localToPaperRect: function (t, e, n, i) {
        var s = new Pt(t, e, n, i),
          o = yt.transformRect(s, this.matrix())
        return o
      },
      paperToLocalPoint: function (t, e) {
        var n = new et(t, e),
          i = yt.transformPoint(n, this.matrix().inverse())
        return i
      },
      paperToLocalRect: function (t, e, n, i) {
        var s = new Pt(t, e, n, i),
          o = yt.transformRect(s, this.matrix().inverse())
        return o
      },
      localToClientPoint: function (t, e) {
        var n = new et(t, e),
          i = yt.transformPoint(n, this.clientMatrix())
        return i
      },
      localToClientRect: function (t, e, n, i) {
        var s = new Pt(t, e, n, i),
          o = yt.transformRect(s, this.clientMatrix())
        return o
      },
      clientToLocalPoint: function (t, e) {
        var n = new et(t, e),
          i = yt.transformPoint(n, this.clientMatrix().inverse())
        return i
      },
      clientToLocalRect: function (t, e, n, i) {
        var s = new Pt(t, e, n, i),
          o = yt.transformRect(s, this.clientMatrix().inverse())
        return o
      },
      localToPagePoint: function (t, e) {
        return this.localToPaperPoint(t, e).offset(this.pageOffset())
      },
      localToPageRect: function (t, e, n, i) {
        return this.localToPaperRect(t, e, n, i).offset(this.pageOffset())
      },
      pageToLocalPoint: function (t, e) {
        var n = new et(t, e),
          i = n.difference(this.pageOffset())
        return this.paperToLocalPoint(i)
      },
      pageToLocalRect: function (t, e, n, i) {
        var s = this.pageOffset(),
          o = new Pt(t, e, n, i)
        return ((o.x -= s.x), (o.y -= s.y), this.paperToLocalRect(o))
      },
      clientOffset: function () {
        var t = this.svg.getBoundingClientRect()
        return new et(t.left, t.top)
      },
      pageOffset: function () {
        return this.clientOffset().offset(window.scrollX, window.scrollY)
      },
      linkAllowed: function (t) {
        if (!(t instanceof cl)) throw new Error('Must provide a linkView.')
        var e = t.model,
          n = this.options,
          i = this.model,
          s = i.constructor.validations
        return !(
          (!n.multiLinks && !s.multiLinks.call(this, i, e)) ||
          (!n.linkPinning && !s.linkPinning.call(this, i, e)) ||
          (typeof n.allowLink == 'function' && !n.allowLink.call(this, t, this))
        )
      },
      getDefaultLink: function (t, e) {
        return Ze(this.options.defaultLink)
          ? this.options.defaultLink.call(this, t, e)
          : this.options.defaultLink.clone()
      },
      resolveHighlighter: function (t = {}) {
        let { highlighter: e, type: n } = t
        const { highlighting: i, highlighterNamespace: s } = this.options
        if (e === void 0) {
          if (!i || (n && ((e = i[n]), e === !1))) return !1
          e || (e = i.default)
        }
        if (!e) return !1
        Wn(e) && (e = { name: e })
        const o = e.name,
          u = s[o]
        if (!u) throw new Error('Unknown highlighter ("' + o + '")')
        if (typeof u.highlight != 'function')
          throw new Error('Highlighter ("' + o + '") is missing required highlight() method')
        if (typeof u.unhighlight != 'function')
          throw new Error('Highlighter ("' + o + '") is missing required unhighlight() method')
        return { highlighter: u, options: e.options || {}, name: o }
      },
      onCellHighlight: function (t, e, n) {
        const i = this.resolveHighlighter(n)
        if (!i) return
        const { highlighter: s, options: o } = i
        s.highlight(t, e, o)
      },
      onCellUnhighlight: function (t, e, n) {
        const i = this.resolveHighlighter(n)
        if (!i) return
        const { highlighter: s, options: o } = i
        s.unhighlight(t, e, o)
      },
      pointerdblclick: function (t) {
        ;(t.preventDefault(), (t = Ge(t)))
        var e = this.findView(t.target)
        if (!this.guard(t, e)) {
          var n = this.snapToGrid(t.clientX, t.clientY)
          e ? e.pointerdblclick(t, n.x, n.y) : this.trigger('blank:pointerdblclick', t, n.x, n.y)
        }
      },
      pointerclick: function (t) {
        var e = this.eventData(t)
        if (e.mousemoved <= this.options.clickThreshold) {
          t = Ge(t)
          var n = this.findView(t.target)
          if (this.guard(t, n)) return
          var i = this.snapToGrid(t.clientX, t.clientY)
          n ? n.pointerclick(t, i.x, i.y) : this.trigger('blank:pointerclick', t, i.x, i.y)
        }
      },
      contextmenu: function (t) {
        if ((this.options.preventContextMenu && t.preventDefault(), this.contextMenuFired)) {
          this.contextMenuFired = !1
          return
        }
        ;((t = Ge(t)), this.contextMenuTrigger(t))
      },
      contextMenuTrigger: function (t) {
        var e = this.findView(t.target)
        if (!this.guard(t, e)) {
          var n = this.snapToGrid(t.clientX, t.clientY)
          e ? e.contextmenu(t, n.x, n.y) : this.trigger('blank:contextmenu', t, n.x, n.y)
        }
      },
      pointerdown: function (t) {
        t = Ge(t)
        const { target: e, button: n } = t,
          i = this.findView(e),
          s = n === 2
        if (i) {
          if (!s && this.guard(t, i)) return
          const o = this.FORM_CONTROL_TAG_NAMES.includes(e.tagName)
          ;(this.options.preventDefaultViewAction && !o && t.preventDefault(),
            o && i.preventDefaultInteraction(t))
          const u = this.customEventTrigger(t, i)
          if (u) {
            if (u.isPropagationStopped()) return
            t.data = u.data
          }
          const c = e.closest('[magnet]')
          if (c && i.el !== c && i.el.contains(c)) {
            const h = Ge(Ie.Event(t.originalEvent, { data: t.data, currentTarget: c }))
            if (
              (this.onmagnet(h),
              h.isDefaultPrevented() && t.preventDefault(),
              h.isPropagationStopped())
            ) {
              if (s) return
              this.delegateDragEvents(i, h.data)
              return
            }
            t.data = h.data
          }
        }
        if (s) {
          this.contextMenuFired = !0
          const o = Ie.Event(t.originalEvent, { type: 'contextmenu', data: t.data })
          this.contextMenuTrigger(o)
        } else {
          const o = this.snapToGrid(t.clientX, t.clientY)
          ;(i
            ? i.pointerdown(t, o.x, o.y)
            : (this.options.preventDefaultBlankAction && t.preventDefault(),
              this.trigger('blank:pointerdown', t, o.x, o.y)),
            this.delegateDragEvents(i, t.data))
        }
      },
      pointermove: function (t) {
        var e = this.eventData(t)
        e.mousemoved || ((e.mousemoved = 0), this.undelegateEvents())
        var n = ++e.mousemoved
        if (!(n <= this.options.moveThreshold)) {
          t = Ge(t)
          var i = this.snapToGrid(t.clientX, t.clientY),
            s = e.sourceView
          ;(s ? s.pointermove(t, i.x, i.y) : this.trigger('blank:pointermove', t, i.x, i.y),
            this.eventData(t, e))
        }
      },
      pointerup: function (t) {
        this.undelegateDocumentEvents()
        var e = Ge(t),
          n = this.snapToGrid(e.clientX, e.clientY),
          i = this.eventData(t).sourceView
        ;(i ? i.pointerup(e, n.x, n.y) : this.trigger('blank:pointerup', e, n.x, n.y),
          e.isPropagationStopped() ||
            this.pointerclick(Ie.Event(t.originalEvent, { type: 'click', data: t.data })),
          this.delegateEvents())
      },
      mouseover: function (t) {
        t = Ge(t)
        var e = this.findView(t.target)
        if (!this.guard(t, e))
          if (e) e.mouseover(t)
          else {
            if (this.el === t.target) return
            this.trigger('blank:mouseover', t)
          }
      },
      mouseout: function (t) {
        t = Ge(t)
        var e = this.findView(t.target)
        if (!this.guard(t, e))
          if (e) e.mouseout(t)
          else {
            if (this.el === t.target) return
            this.trigger('blank:mouseout', t)
          }
      },
      mouseenter: function (t) {
        t = Ge(t)
        const { target: e, relatedTarget: n, currentTarget: i } = t,
          s = this.findView(e)
        if (this.guard(t, s)) return
        const o = this.findView(n)
        ;(s && (o === s || (s.mouseenter(t), this.el.contains(n)))) ||
          o ||
          (i === this.el && this.trigger('paper:mouseenter', t))
      },
      mouseleave: function (t) {
        t = Ge(t)
        const { target: e, relatedTarget: n, currentTarget: i } = t,
          s = this.findView(e)
        if (this.guard(t, s)) return
        const o = this.findView(n)
        ;(s && (o === s || (s.mouseleave(t), this.el.contains(n)))) ||
          o ||
          (i === this.el && this.trigger('paper:mouseleave', t))
      },
      _processMouseWheelEvtBuf: bx(
        function () {
          const { event: t, deltas: e } = this._mw_evt_buffer,
            n = e.reduce((u, c) => u + Lx(c, _O), 0),
            i = Math.pow(0.995, n),
            { x: s, y: o } = this.clientToLocalPoint(t.clientX, t.clientY)
          ;(this.trigger('paper:pinch', t, s, o, i),
            (this._mw_evt_buffer = { event: null, deltas: [] }))
        },
        cI,
        { maxWait: cI }
      ),
      mousewheel: function (t) {
        t = Ge(t)
        const e = this.findView(t.target)
        if (this.guard(t, e)) return
        const n = t.originalEvent,
          i = this.snapToGrid(n.clientX, n.clientY),
          { deltaX: s, deltaY: o } = Ox(n),
          u = this._events['paper:pinch']
        if (t.ctrlKey && u && u.length > 0)
          (n.preventDefault(),
            (this._mw_evt_buffer.event = n),
            this._mw_evt_buffer.deltas.push(o),
            this._processMouseWheelEvtBuf())
        else {
          const c = Math.max(-1, Math.min(1, n.wheelDelta))
          ;(e ? e.mousewheel(t, i.x, i.y, c) : this.trigger('blank:mousewheel', t, i.x, i.y, c),
            this.trigger('paper:pan', t, s, o))
        }
      },
      onevent: function (t) {
        var e = t.currentTarget,
          n = e.getAttribute('event')
        if (n) {
          var i = this.findView(e)
          if (i) {
            if (((t = Ge(t)), this.guard(t, i))) return
            var s = this.snapToGrid(t.clientX, t.clientY)
            i.onevent(t, n, s.x, s.y)
          }
        }
      },
      magnetEvent: function (t, e) {
        var n = t.currentTarget,
          i = n.getAttribute('magnet')
        if (i) {
          var s = this.findView(n)
          if (s) {
            if (((t = Ge(t)), this.guard(t, s))) return
            var o = this.snapToGrid(t.clientX, t.clientY)
            e.call(this, s, t, n, o.x, o.y)
          }
        }
      },
      onmagnet: function (t) {
        if (t.button === 2) {
          ;((this.contextMenuFired = !0), (this.magnetContextMenuFired = !0))
          const e = Ie.Event(t.originalEvent, {
            type: 'contextmenu',
            data: t.data,
            currentTarget: t.currentTarget,
          })
          ;(this.magnetContextMenuTrigger(e), e.isPropagationStopped() && t.stopPropagation())
        } else
          this.magnetEvent(t, function (e, n, i, s, o) {
            e.onmagnet(n, s, o)
          })
      },
      magnetpointerdblclick: function (t) {
        this.magnetEvent(t, function (e, n, i, s, o) {
          e.magnetpointerdblclick(n, i, s, o)
        })
      },
      magnetcontextmenu: function (t) {
        if ((this.options.preventContextMenu && t.preventDefault(), this.magnetContextMenuFired)) {
          this.magnetContextMenuFired = !1
          return
        }
        this.magnetContextMenuTrigger(t)
      },
      magnetContextMenuTrigger: function (t) {
        this.magnetEvent(t, function (e, n, i, s, o) {
          e.magnetcontextmenu(n, i, s, o)
        })
      },
      onlabel: function (t) {
        var e = t.currentTarget,
          n = this.findView(e)
        if (!n || ((t = Ge(t)), this.guard(t, n))) return
        const i = this.customEventTrigger(t, n, e)
        if (i) {
          if (i.isPropagationStopped()) return
          t.data = i.data
        }
        var s = this.snapToGrid(t.clientX, t.clientY)
        n.onlabel(t, s.x, s.y)
      },
      getPointerArgs(t) {
        const e = Ge(t),
          { x: n, y: i } = this.snapToGrid(e.clientX, e.clientY)
        return [e, n, i]
      },
      delegateDragEvents: function (t, e) {
        ;(e || (e = {}),
          this.eventData({ data: e }, { sourceView: t || null, mousemoved: 0 }),
          this.delegateDocumentEvents(null, e))
      },
      guard: function (t, e) {
        if (
          (t.type === 'mousedown' && t.button === 2) ||
          (this.options.guard && this.options.guard(t, e))
        )
          return !0
        if (t.data && t.data.guarded !== void 0) return t.data.guarded
        const { target: n } = t
        return this.GUARDED_TAG_NAMES.includes(n.tagName)
          ? !0
          : !(
              (e && e.model && e.model instanceof Er) ||
              this.svg === n ||
              this.el === n ||
              Ie.contains(this.svg, n)
            )
      },
      setGridSize: function (t) {
        const { options: e } = this
        return ((e.gridSize = t), e.drawGrid && !e.drawGridSize && this.drawGrid(), this)
      },
      clearGrid: function () {
        return (this.$grid && this.$grid.css('backgroundImage', 'none'), this)
      },
      _getGridRefs: function () {
        return (
          this._gridCache ||
            (this._gridCache = {
              root: yt('svg', { width: '100%', height: '100%' }, yt('defs')),
              patterns: {},
              add: function (t, e) {
                ;(yt(this.root.node.childNodes[0]).append(e),
                  (this.patterns[t] = e),
                  this.root.append(
                    yt('rect', { width: '100%', height: '100%', fill: 'url(#' + t + ')' })
                  ))
              },
              get: function (t) {
                return this.patterns[t]
              },
              exist: function (t) {
                return this.patterns[t] !== void 0
              },
            }),
          this._gridCache
        )
      },
      setGrid: function (t) {
        ;(this.clearGrid(), (this._gridCache = null), (this._gridSettings = []))
        var e = Array.isArray(t) ? t : [t || {}]
        return (
          e.forEach(function (n) {
            this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(n))
          }, this),
          this
        )
      },
      _resolveDrawGridOption: function (t) {
        var e = this.constructor.gridPatterns
        if (Wn(t) && Array.isArray(e[t]))
          return e[t].map(function (h) {
            return Kt({}, h)
          })
        var n = t || { args: [{}] },
          i = Array.isArray(n),
          s = n.name
        if ((!i && !s && !n.markup && (s = 'dot'), s && Array.isArray(e[s]))) {
          var o = e[s].map(function (h) {
              return Kt({}, h)
            }),
            u = Array.isArray(n.args) ? n.args : [n.args || {}]
          mi(u[0], ba(t, 'args'))
          for (var c = 0; c < u.length; c++) o[c] && Kt(o[c], u[c])
          return o
        }
        return i ? n : [n]
      },
      drawGrid: function (t) {
        const e = this.options.drawGridSize || this.options.gridSize
        if (e <= 1) return this.clearGrid()
        var n = Array.isArray(t) ? t : [t],
          i = this.matrix(),
          s = this._getGridRefs()
        this._gridSettings.forEach(function (u, c) {
          var h = 'pattern_' + c,
            p = An(u, n[c], { sx: i.a || 1, sy: i.d || 1, ox: i.e || 0, oy: i.f || 0 })
          ;((p.width = e * (i.a || 1) * (p.scaleFactor || 1)),
            (p.height = e * (i.d || 1) * (p.scaleFactor || 1)),
            s.exist(h) ||
              s.add(h, yt('pattern', { id: h, patternUnits: 'userSpaceOnUse' }, yt(p.markup))))
          var y = s.get(h)
          Ze(p.update) && p.update(y.node.childNodes[0], p)
          var v = p.ox % p.width
          v < 0 && (v += p.width)
          var C = p.oy % p.height
          ;(C < 0 && (C += p.height), y.attr({ x: v, y: C, width: p.width, height: p.height }))
        })
        var o = new XMLSerializer().serializeToString(s.root.node)
        return (
          (o = 'url(data:image/svg+xml;base64,' + btoa(o) + ')'),
          this.$grid.css('backgroundImage', o),
          this
        )
      },
      updateBackgroundImage: function (t) {
        t = t || {}
        var e = t.position || 'center',
          n = t.size || 'auto auto',
          i = this.scale(),
          s = this.translate()
        if (ze(e)) {
          var o = s.tx + i.sx * (e.x || 0),
            u = s.ty + i.sy * (e.y || 0)
          e = o + 'px ' + u + 'px'
        }
        ;(ze(n) && ((n = new Pt(n).scale(i.sx, i.sy)), (n = n.width + 'px ' + n.height + 'px')),
          this.$background.css({ backgroundSize: n, backgroundPosition: e }))
      },
      drawBackgroundImage: function (t, e) {
        if (!(t instanceof HTMLImageElement)) {
          this.$background.css('backgroundImage', '')
          return
        }
        if (!(!this._background || this._background.id !== e.id)) {
          e = e || {}
          var n,
            i = e.size,
            s = e.repeat || 'no-repeat',
            o = e.opacity || 1,
            u = Math.abs(e.quality) || 1,
            c = this.constructor.backgroundPatterns[xx(s)]
          if (Ze(c)) {
            ;((t.width *= u), (t.height *= u))
            var h = c(t, e)
            if (!(h instanceof HTMLCanvasElement))
              throw new Error('dia.Paper: background pattern must return an HTML Canvas instance')
            ;((n = h.toDataURL('image/png')),
              (s = 'repeat'),
              ze(i)
                ? ((i.width *= h.width / t.width), (i.height *= h.height / t.height))
                : i === void 0 && (e.size = { width: h.width / u, height: h.height / u }))
          } else ((n = t.src), i === void 0 && (e.size = { width: t.width, height: t.height }))
          ;(this.$background.css({
            opacity: o,
            backgroundRepeat: s,
            backgroundImage: 'url(' + n + ')',
          }),
            this.updateBackgroundImage(e))
        }
      },
      updateBackgroundColor: function (t) {
        this.$el.css('backgroundColor', t || '')
      },
      drawBackground: function (t) {
        if (((t = t || {}), this.updateBackgroundColor(t.color), t.image)) {
          ;((t = this._background = ti(t)), Qs(t))
          var e = document.createElement('img')
          ;((e.onload = this.drawBackgroundImage.bind(this, e, t)), (e.src = t.image))
        } else (this.drawBackgroundImage(null), (this._background = null))
        return this
      },
      setInteractivity: function (t) {
        ;((this.options.interactive = t), Ui(this._views, 'setInteractivity', t))
      },
      isDefined: function (t) {
        return !!this.svg.getElementById(t)
      },
      defineFilter: function (t) {
        if (!ze(t))
          throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.')
        var e = t.id,
          n = t.name
        if ((e || (e = n + this.svg.id + Su(JSON.stringify(t))), !this.isDefined(e))) {
          var i = Px,
            s = i[n] && i[n](t.args || {})
          if (!s) throw new Error('Non-existing filter ' + n)
          var o = Kt(
            { filterUnits: 'objectBoundingBox', x: -1, y: -1, width: 3, height: 3 },
            t.attrs,
            { id: e }
          )
          yt(s, o).appendTo(this.defs)
        }
        return e
      },
      defineGradient: function (t) {
        if (!ze(t))
          throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.')
        const { svg: e, defs: n } = this,
          { type: i, id: s = i + e.id + Su(JSON.stringify(t)), stops: o, attrs: u = {} } = t
        if (this.isDefined(s)) return s
        const c = xe(o).map(({ offset: p, color: y, opacity: v }) =>
            yt('stop').attr({
              offset: p,
              'stop-color': y,
              'stop-opacity': Number.isFinite(v) ? v : 1,
            })
          ),
          h = yt(i, u, c)
        return ((h.id = s), h.appendTo(n), s)
      },
      definePattern: function (t) {
        if (!ze(t))
          throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.')
        const { svg: e, defs: n } = this,
          { id: i = e.id + Su(JSON.stringify(t)), markup: s, attrs: o = {} } = t
        if (!s) throw new TypeError('dia.Paper: definePattern() requires markup.')
        if (this.isDefined(i)) return i
        const u = yt('pattern', { patternUnits: 'userSpaceOnUse' })
        if (((u.id = i), u.attr(o), typeof s == 'string')) u.append(yt(s))
        else {
          const { fragment: c } = Gu(s)
          u.append(c)
        }
        return (u.appendTo(n), i)
      },
      defineMarker: function (t) {
        if (!ze(t))
          throw new TypeError(
            'dia.Paper: defineMarker() requires the first argument to be an object.'
          )
        const { svg: e, defs: n } = this,
          {
            id: i = e.id + Su(JSON.stringify(t)),
            markup: s,
            attrs: o = {},
            markerUnits: u = 'userSpaceOnUse',
          } = t
        if (this.isDefined(i)) return i
        const c = yt('marker', { orient: 'auto', overflow: 'visible', markerUnits: u })
        ;((c.id = i), c.attr(o))
        let h
        if (s) {
          let v
          if (typeof s == 'string') ((v = yt(s)), (v = Array.isArray(v) ? v : [v]))
          else {
            const { fragment: C } = Gu(s)
            v = yt(C).children()
          }
          v.length > 1 ? (h = yt('g').append(v)) : (h = v[0])
        } else {
          const { type: v = 'path' } = t
          h = yt(v)
        }
        const p = ba(t, 'type', 'id', 'markup', 'attrs', 'markerUnits')
        return (
          Object.keys(p).forEach(v => {
            const C = p[v],
              w = h.attr(v)
            if (w == null) h.attr(v, C)
            else
              switch (v) {
                case 'transform':
                  h.attr(v, C + ' ' + w)
                  break
              }
          }),
          h.appendTo(c),
          c.appendTo(n),
          i
        )
      },
      customEventTrigger: function (t, e, n = e.el) {
        const i = t.target.closest('[event]')
        if (i && n !== i && e.el.contains(i)) {
          const s = Ge(Ie.Event(t.originalEvent, { data: t.data, currentTarget: i }))
          return (this.onevent(s), s.isDefaultPrevented() && t.preventDefault(), s)
        }
        return null
      },
    },
    {
      sorting: el,
      Layers: Pi,
      backgroundPatterns: {
        flipXy: function (t) {
          var e = document.createElement('canvas'),
            n = t.width,
            i = t.height
          ;((e.width = 2 * n), (e.height = 2 * i))
          var s = e.getContext('2d')
          return (
            s.drawImage(t, 0, 0, n, i),
            s.setTransform(-1, 0, 0, -1, e.width, e.height),
            s.drawImage(t, 0, 0, n, i),
            s.setTransform(-1, 0, 0, 1, e.width, 0),
            s.drawImage(t, 0, 0, n, i),
            s.setTransform(1, 0, 0, -1, 0, e.height),
            s.drawImage(t, 0, 0, n, i),
            e
          )
        },
        flipX: function (t) {
          var e = document.createElement('canvas'),
            n = t.width,
            i = t.height
          ;((e.width = n * 2), (e.height = i))
          var s = e.getContext('2d')
          return (
            s.drawImage(t, 0, 0, n, i),
            s.translate(2 * n, 0),
            s.scale(-1, 1),
            s.drawImage(t, 0, 0, n, i),
            e
          )
        },
        flipY: function (t) {
          var e = document.createElement('canvas'),
            n = t.width,
            i = t.height
          ;((e.width = n), (e.height = i * 2))
          var s = e.getContext('2d')
          return (
            s.drawImage(t, 0, 0, n, i),
            s.translate(0, 2 * i),
            s.scale(1, -1),
            s.drawImage(t, 0, 0, n, i),
            e
          )
        },
        watermark: function (t, e) {
          e = e || {}
          var n = t.width,
            i = t.height,
            s = document.createElement('canvas')
          ;((s.width = n * 3), (s.height = i * 3))
          for (
            var o = s.getContext('2d'),
              u = ai(e.watermarkAngle) ? -e.watermarkAngle : -20,
              c = Ai(u),
              h = s.width / 4,
              p = s.height / 4,
              y = 0;
            y < 4;
            y++
          )
            for (var v = 0; v < 4; v++)
              (y + v) % 2 > 0 &&
                (o.setTransform(1, 0, 0, 1, (2 * y - 1) * h, (2 * v - 1) * p),
                o.rotate(c),
                o.drawImage(t, -n / 2, -i / 2, n, i))
          return s
        },
      },
      gridPatterns: {
        dot: [
          {
            color: '#AAAAAA',
            thickness: 1,
            markup: 'rect',
            update: function (t, e) {
              yt(t).attr({ width: e.thickness * e.sx, height: e.thickness * e.sy, fill: e.color })
            },
          },
        ],
        fixedDot: [
          {
            color: '#AAAAAA',
            thickness: 1,
            markup: 'rect',
            update: function (t, e) {
              var n = e.sx <= 1 ? e.thickness * e.sx : e.thickness
              yt(t).attr({ width: n, height: n, fill: e.color })
            },
          },
        ],
        mesh: [
          {
            color: '#AAAAAA',
            thickness: 1,
            markup: 'path',
            update: function (t, e) {
              var n,
                i = e.width,
                s = e.height,
                o = e.thickness
              ;(i - o >= 0 && s - o >= 0
                ? (n = ['M', i, 0, 'H0 M0 0 V0', s].join(' '))
                : (n = 'M 0 0 0 0'),
                yt(t).attr({ d: n, stroke: e.color, 'stroke-width': e.thickness }))
            },
          },
        ],
        doubleMesh: [
          {
            color: '#AAAAAA',
            thickness: 1,
            markup: 'path',
            update: function (t, e) {
              var n,
                i = e.width,
                s = e.height,
                o = e.thickness
              ;(i - o >= 0 && s - o >= 0
                ? (n = ['M', i, 0, 'H0 M0 0 V0', s].join(' '))
                : (n = 'M 0 0 0 0'),
                yt(t).attr({ d: n, stroke: e.color, 'stroke-width': e.thickness }))
            },
          },
          {
            color: '#000000',
            thickness: 3,
            scaleFactor: 4,
            markup: 'path',
            update: function (t, e) {
              var n,
                i = e.width,
                s = e.height,
                o = e.thickness
              ;(i - o >= 0 && s - o >= 0
                ? (n = ['M', i, 0, 'H0 M0 0 V0', s].join(' '))
                : (n = 'M 0 0 0 0'),
                yt(t).attr({ d: n, stroke: e.color, 'stroke-width': e.thickness }))
            },
          },
        ],
      },
    }
  ),
  xa = or.extend({
    name: null,
    tagName: 'g',
    className: 'tool',
    svgElement: !0,
    _visible: !0,
    init: function () {
      var t = this.name
      t && this.vel.attr('data-tool-name', t)
    },
    configure: function (t, e) {
      return (
        (this.relatedView = t),
        (this.paper = t.paper),
        (this.parentView = e),
        this.simulateRelatedView(this.el),
        this.delegateEvents(),
        this
      )
    },
    simulateRelatedView: function (t) {
      t && t.setAttribute('model-id', this.relatedView.model.id)
    },
    getName: function () {
      return this.name
    },
    show: function () {
      ;((this.el.style.display = ''), (this._visible = !0))
    },
    hide: function () {
      ;((this.el.style.display = 'none'), (this._visible = !1))
    },
    isVisible: function () {
      return !!this._visible
    },
    focus: function () {
      var t = this.options.focusOpacity
      ;(isFinite(t) && (this.el.style.opacity = t), this.parentView.focusTool(this))
    },
    blur: function () {
      ;((this.el.style.opacity = ''), this.parentView.blurTool(this))
    },
    update: function () {},
    guard: function (t) {
      const { paper: e, relatedView: n } = this
      return !e || !n ? !0 : e.guard(t, n)
    },
  }),
  PO = or.extend({
    tagName: 'g',
    className: 'tools',
    svgElement: !0,
    tools: null,
    isRendered: !1,
    options: { tools: null, relatedView: null, name: null },
    configure: function (t) {
      t = Kt(this.options, t)
      var e = t.tools
      if (!Array.isArray(e)) return this
      var n = t.relatedView
      if (!(n instanceof Ae)) return this
      for (var i = (this.tools = []), s = 0, o = e.length; s < o; s++) {
        var u = e[s]
        u instanceof xa && (u.configure(n, this), this.vel.append(u.el), i.push(u))
      }
      return ((this.isRendered = !1), n.requestUpdate(n.getFlag('TOOLS')), this)
    },
    getName: function () {
      return this.options.name
    },
    update: function (t) {
      t || (t = {})
      var e = this.tools
      if (!e) return this
      for (var n = this.isRendered, i = 0, s = e.length; i < s; i++) {
        var o = e[i]
        n ? t.tool !== o.cid && o.isVisible() && o.update() : o.render()
      }
      return (
        this.isMounted() || this.mount(),
        n || (this.blurTool(), (this.isRendered = !0)),
        this
      )
    },
    focusTool: function (t) {
      var e = this.tools
      if (!e) return this
      for (var n = 0, i = e.length; n < i; n++) {
        var s = e[n]
        t === s ? s.show() : s.hide()
      }
      return this
    },
    blurTool: function (t) {
      var e = this.tools
      if (!e) return this
      for (var n = 0, i = e.length; n < i; n++) {
        var s = e[n]
        s !== t && !s.isVisible() && (s.show(), s.update())
      }
      return this
    },
    hide: function () {
      return this.focusTool(null)
    },
    show: function () {
      return this.blurTool(null)
    },
    onRemove: function () {
      var t = this.tools
      if (!t) return this
      for (var e = 0, n = t.length; e < n; e++) t[e].remove()
      this.tools = null
    },
    mount: function () {
      const { options: t, el: e } = this,
        { relatedView: n, layer: i = Pi.TOOLS, z: s } = t
      return (n && (i ? n.paper.getLayerView(i).insertSortedNode(e, s) : n.el.appendChild(e)), this)
    },
  }),
  GO = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Cell: Er,
        CellView: Ae,
        Element: an,
        ElementView: bn,
        Graph: Vr,
        HighlighterView: rr,
        LayersNames: Pi,
        Link: wn,
        LinkView: cl,
        Paper: vS,
        PaperLayer: Kx,
        ToolView: xa,
        ToolsView: PO,
        attributes: Pm,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Zu = {
    exportElement: function (t) {
      return t.size()
    },
    exportLink: function (t) {
      var e = t.get('labelSize') || {},
        n = {
          minLen: t.get('minLen') || 1,
          weight: t.get('weight') || 1,
          labelpos: t.get('labelPosition') || 'c',
          labeloffset: t.get('labelOffset') || 0,
          width: e.width || 0,
          height: e.height || 0,
        }
      return n
    },
    importElement: function (t, e, n) {
      var i = this.getCell(e),
        s = n.node(e)
      t.setPosition
        ? t.setPosition(i, s)
        : i.set('position', { x: s.x - s.width / 2, y: s.y - s.height / 2 })
    },
    importLink: function (t, e, n) {
      const s = this.getCell(e.name),
        o = n.edge(e),
        u = o.points || [],
        c = new qe(u)
      if (t.setVertices || t.setLinkVertices)
        if (Ze(t.setVertices)) t.setVertices(s, u)
        else {
          c.simplify({ threshold: 0.001 })
          const h = c.points.map(y => y.toJSON()),
            p = h.length
          s.set('vertices', h.slice(1, p - 1))
        }
      if (t.setLabels && 'x' in o && 'y' in o) {
        const h = { x: o.x, y: o.y }
        if (Ze(t.setLabels)) t.setLabels(s, h, u)
        else {
          const p = c.closestPointLength(h),
            y = c.pointAtLength(p),
            v = p / c.length(),
            C = new et(h).difference(y).toJSON()
          s.label(0, { position: { distance: v, offset: C } })
        }
      }
    },
    layout: function (t, e) {
      var n
      ;(t instanceof Vr ? (n = t) : (n = new Vr().resetCells(t, { dry: !0, sort: !1 })),
        (t = null),
        (e = mi(e || {}, {
          resizeClusters: !0,
          clusterPadding: 10,
          exportElement: this.exportElement,
          exportLink: this.exportLink,
        })))
      const i = e.dagre || (typeof dagre < 'u' ? dagre : void 0)
      if (i === void 0) throw new Error('The the "dagre" utility is a mandatory dependency.')
      var s = Zu.toGraphLib(n, {
          graphlib: e.graphlib,
          directed: !0,
          multigraph: !0,
          compound: !0,
          setNodeLabel: e.exportElement,
          setEdgeLabel: e.exportLink,
          setEdgeName: function (y) {
            return y.id
          },
        }),
        o = {},
        u = e.marginX || 0,
        c = e.marginY || 0
      if (
        (e.rankDir && (o.rankdir = e.rankDir),
        e.align && (o.align = e.align),
        e.nodeSep && (o.nodesep = e.nodeSep),
        e.edgeSep && (o.edgesep = e.edgeSep),
        e.rankSep && (o.ranksep = e.rankSep),
        e.ranker && (o.ranker = e.ranker),
        u && (o.marginx = u),
        c && (o.marginy = c),
        s.setGraph(o),
        i.layout(s, { debugTiming: !!e.debugTiming }),
        n.startBatch('layout'),
        Zu.fromGraphLib(s, {
          importNode: this.importElement.bind(n, e),
          importEdge: this.importLink.bind(n, e),
        }),
        e.resizeClusters)
      ) {
        var h = s
          .nodes()
          .filter(function (y) {
            return s.children(y).length > 0
          })
          .map(n.getCell.bind(n))
          .sort(function (y, v) {
            return v.getAncestors().length - y.getAncestors().length
          })
        Ui(h, 'fitToChildren', { padding: e.clusterPadding })
      }
      n.stopBatch('layout')
      var p = s.graph()
      return new Pt(u, c, Math.abs(p.width - 2 * u), Math.abs(p.height - 2 * c))
    },
    fromGraphLib: function (t, e) {
      e = e || {}
      var n = e.importNode || Ws,
        i = e.importEdge || Ws,
        s = this instanceof Vr ? this : new Vr()
      return (
        t.nodes().forEach(function (o) {
          n.call(s, o, t, s, e)
        }),
        t.edges().forEach(function (o) {
          i.call(s, o, t, s, e)
        }),
        s
      )
    },
    toGraphLib: function (t, e) {
      e = e || {}
      const n = e.graphlib || (typeof graphlib < 'u' ? graphlib : void 0)
      if (n === void 0) throw new Error('The the "graphlib" utility is a mandatory dependency.')
      for (
        var i = wx(e, 'directed', 'compound', 'multigraph'),
          s = new n.Graph(i),
          o = e.setNodeLabel || Ws,
          u = e.setEdgeLabel || Ws,
          c = e.setEdgeName || Ws,
          h = t.get('cells'),
          p = 0,
          y = h.length;
        p < y;
        p++
      ) {
        var v = h.at(p)
        if (v.isLink()) {
          var C = v.get('source'),
            w = v.get('target')
          if (!C.id || !w.id) break
          s.setEdge(C.id, w.id, u(v), c(v))
        } else if ((s.setNode(v.id, o(v)), s.isCompound() && v.has('parent'))) {
          var N = v.get('parent')
          h.has(N) && s.setParent(v.id, N)
        }
      }
      return s
    },
  }
Vr.prototype.toGraphLib = function (t) {
  return Zu.toGraphLib(this, t)
}
Vr.prototype.fromGraphLib = function (t, e) {
  return Zu.fromGraphLib.call(this, t, e)
}
const ZO = Object.freeze(
    Object.defineProperty(
      { __proto__: null, DirectedGraph: Zu, Port: Vx, PortLabel: qx },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Xm = {
    _results: {},
    _tests: {
      svgforeignobject: function () {
        return (
          !!document.createElementNS &&
          /SVGForeignObject/.test(
            {}.toString.call(
              document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')
            )
          )
        )
      },
    },
    addTest: function (t, e) {
      return (this._tests[t] = e)
    },
    test: function (t) {
      var e = this._tests[t]
      if (!e)
        throw new Error(
          'Test not defined ("' + t + '"). Use `joint.env.addTest(name, fn) to add a new test.`'
        )
      var n = this._results[t]
      if (typeof n < 'u') return n
      try {
        n = e()
      } catch {
        n = !1
      }
      return ((this._results[t] = n), n)
    },
  },
  ke = an.define('basic.Generic', { attrs: { '.': { fill: '#ffffff', stroke: 'none' } } }),
  UO = ke.define(
    'basic.Rect',
    {
      attrs: {
        rect: { fill: '#ffffff', stroke: '#000000', width: 100, height: 60 },
        text: {
          fill: '#000000',
          text: '',
          'font-size': 14,
          'ref-x': 0.5,
          'ref-y': 0.5,
          'text-anchor': 'middle',
          'y-alignment': 'middle',
          'font-family': 'Arial, helvetica, sans-serif',
        },
      },
    },
    { markup: '<g class="rotatable"><g class="scalable"><rect/></g><text/></g>' }
  ),
  YO = bn.extend({
    presentationAttributes: bn.addPresentationAttributes({ attrs: ['SCALE'] }),
    confirmUpdate: function () {
      var t = bn.prototype.confirmUpdate.apply(this, arguments)
      return (this.hasFlag(t, 'SCALE') && (this.resize(), (t = this.removeFlag(t, 'SCALE'))), t)
    },
  }),
  HO = ke.define(
    'basic.Text',
    { attrs: { text: { 'font-size': 18, fill: '#000000' } } },
    { markup: '<g class="rotatable"><g class="scalable"><text/></g></g>' }
  ),
  Wm = ke.define(
    'basic.Circle',
    {
      size: { width: 60, height: 60 },
      attrs: {
        circle: { fill: '#ffffff', stroke: '#000000', r: 30, cx: 30, cy: 30 },
        text: {
          'font-size': 14,
          text: '',
          'text-anchor': 'middle',
          'ref-x': 0.5,
          'ref-y': 0.5,
          'y-alignment': 'middle',
          fill: '#000000',
          'font-family': 'Arial, helvetica, sans-serif',
        },
      },
    },
    { markup: '<g class="rotatable"><g class="scalable"><circle/></g><text/></g>' }
  ),
  VO = ke.define(
    'basic.Ellipse',
    {
      size: { width: 60, height: 40 },
      attrs: {
        ellipse: { fill: '#ffffff', stroke: '#000000', rx: 30, ry: 20, cx: 30, cy: 20 },
        text: {
          'font-size': 14,
          text: '',
          'text-anchor': 'middle',
          'ref-x': 0.5,
          'ref-y': 0.5,
          'y-alignment': 'middle',
          fill: '#000000',
          'font-family': 'Arial, helvetica, sans-serif',
        },
      },
    },
    { markup: '<g class="rotatable"><g class="scalable"><ellipse/></g><text/></g>' }
  ),
  XO = ke.define(
    'basic.Polygon',
    {
      size: { width: 60, height: 40 },
      attrs: {
        polygon: { fill: '#ffffff', stroke: '#000000' },
        text: {
          'font-size': 14,
          text: '',
          'text-anchor': 'middle',
          'ref-x': 0.5,
          'ref-dy': 20,
          'y-alignment': 'middle',
          fill: '#000000',
          'font-family': 'Arial, helvetica, sans-serif',
        },
      },
    },
    { markup: '<g class="rotatable"><g class="scalable"><polygon/></g><text/></g>' }
  ),
  WO = ke.define(
    'basic.Polyline',
    {
      size: { width: 60, height: 40 },
      attrs: {
        polyline: { fill: '#ffffff', stroke: '#000000' },
        text: {
          'font-size': 14,
          text: '',
          'text-anchor': 'middle',
          'ref-x': 0.5,
          'ref-dy': 20,
          'y-alignment': 'middle',
          fill: '#000000',
          'font-family': 'Arial, helvetica, sans-serif',
        },
      },
    },
    { markup: '<g class="rotatable"><g class="scalable"><polyline/></g><text/></g>' }
  ),
  FO = ke.define(
    'basic.Image',
    {
      attrs: {
        text: {
          'font-size': 14,
          text: '',
          'text-anchor': 'middle',
          'ref-x': 0.5,
          'ref-dy': 20,
          'y-alignment': 'middle',
          fill: '#000000',
          'font-family': 'Arial, helvetica, sans-serif',
        },
      },
    },
    { markup: '<g class="rotatable"><g class="scalable"><image/></g><text/></g>' }
  ),
  mS = ke.define(
    'basic.Path',
    {
      size: { width: 60, height: 60 },
      attrs: {
        path: { fill: '#ffffff', stroke: '#000000' },
        text: {
          'font-size': 14,
          text: '',
          'text-anchor': 'middle',
          ref: 'path',
          'ref-x': 0.5,
          'ref-dy': 10,
          fill: '#000000',
          'font-family': 'Arial, helvetica, sans-serif',
        },
      },
    },
    { markup: '<g class="rotatable"><g class="scalable"><path/></g><text/></g>' }
  ),
  JO = mS.define('basic.Rhombus', {
    attrs: {
      path: { d: 'M 30 0 L 60 30 30 60 0 30 z' },
      text: { 'ref-y': 0.5, 'ref-dy': null, 'y-alignment': 'middle' },
    },
  }),
  ch = Xm.test('svgforeignobject'),
  qO = ke.define(
    'basic.TextBlock',
    {
      attrs: {
        rect: { fill: '#ffffff', stroke: '#000000', width: 80, height: 100 },
        text: { fill: '#000000', 'font-size': 14, 'font-family': 'Arial, helvetica, sans-serif' },
        '.content': {
          text: '',
          'ref-x': 0.5,
          'ref-y': 0.5,
          'y-alignment': 'middle',
          'x-alignment': 'middle',
        },
      },
      content: '',
    },
    {
      markup: [
        '<g class="rotatable">',
        '<g class="scalable"><rect/></g>',
        ch
          ? '<foreignObject class="fobj"><body xmlns="http://www.w3.org/1999/xhtml"><div class="content"/></body></foreignObject>'
          : '<text class="content"/>',
        '</g>',
      ].join(''),
      initialize: function () {
        ;(this.listenTo(this, 'change:size', this.updateSize),
          this.listenTo(this, 'change:content', this.updateContent),
          this.updateSize(this, this.get('size')),
          this.updateContent(this, this.get('content')),
          ke.prototype.initialize.apply(this, arguments))
      },
      updateSize: function (t, e) {
        this.attr({ '.fobj': Kt({}, e), div: { style: Kt({}, e) } })
      },
      updateContent: function (t, e) {
        ch ? this.attr({ '.content': { html: Rx(e) } }) : this.attr({ '.content': { text: e } })
      },
      setForeignObjectSize: function () {
        this.updateSize.apply(this, arguments)
      },
      setDivContent: function () {
        this.updateContent.apply(this, arguments)
      },
    }
  ),
  QO = bn.extend({
    presentationAttributes: ch
      ? bn.prototype.presentationAttributes
      : bn.addPresentationAttributes({ content: ['CONTENT'], size: ['CONTENT'] }),
    initFlag: ['RENDER', 'CONTENT'],
    confirmUpdate: function () {
      var t = bn.prototype.confirmUpdate.apply(this, arguments)
      return (
        this.hasFlag(t, 'CONTENT') &&
          (this.updateContent(this.model), (t = this.removeFlag(t, 'CONTENT'))),
        t
      )
    },
    update: function (t, e) {
      var n = this.model
      if (ch) bn.prototype.update.call(this, n, e)
      else {
        var i = ba(e || n.get('attrs'), '.content')
        ;(bn.prototype.update.call(this, n, i),
          (!e || Mr(e, '.content')) && this.updateContent(n, e))
      }
    },
    updateContent: function (t, e) {
      var n = An({}, (e || t.get('attrs'))['.content'])
      n = ba(n, 'text')
      var i = _m(t.get('content'), t.get('size'), n, { svgDocument: this.paper.svg }),
        s = ih({}, '.content', n, '/')
      ;((s['.content'].text = i), bn.prototype.update.call(this, t, s))
    },
  }),
  KO = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Circle: Wm,
        Ellipse: VO,
        Generic: ke,
        Image: FO,
        Path: mS,
        Polygon: XO,
        Polyline: WO,
        Rect: UO,
        Rhombus: JO,
        Text: HO,
        TextBlock: qO,
        TextBlockView: QO,
        TextView: YO,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  yS = an.define(
    'standard.Rectangle',
    {
      attrs: {
        body: {
          refWidth: '100%',
          refHeight: '100%',
          strokeWidth: 2,
          stroke: '#000000',
          fill: '#FFFFFF',
        },
        label: {
          textVerticalAnchor: 'middle',
          textAnchor: 'middle',
          refX: '50%',
          refY: '50%',
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'rect', selector: 'body' },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  $O = an.define(
    'standard.Circle',
    {
      attrs: {
        body: {
          refCx: '50%',
          refCy: '50%',
          refR: '50%',
          strokeWidth: 2,
          stroke: '#333333',
          fill: '#FFFFFF',
        },
        label: {
          textVerticalAnchor: 'middle',
          textAnchor: 'middle',
          refX: '50%',
          refY: '50%',
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'circle', selector: 'body' },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  tL = an.define(
    'standard.Ellipse',
    {
      attrs: {
        body: {
          refCx: '50%',
          refCy: '50%',
          refRx: '50%',
          refRy: '50%',
          strokeWidth: 2,
          stroke: '#333333',
          fill: '#FFFFFF',
        },
        label: {
          textVerticalAnchor: 'middle',
          textAnchor: 'middle',
          refX: '50%',
          refY: '50%',
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'ellipse', selector: 'body' },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  eL = an.define(
    'standard.Path',
    {
      attrs: {
        body: {
          refD: 'M 0 0 L 10 0 10 10 0 10 Z',
          strokeWidth: 2,
          stroke: '#333333',
          fill: '#FFFFFF',
        },
        label: {
          textVerticalAnchor: 'middle',
          textAnchor: 'middle',
          refX: '50%',
          refY: '50%',
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'path', selector: 'body' },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  nL = an.define(
    'standard.Polygon',
    {
      attrs: {
        body: {
          refPoints: '0 0 10 0 10 10 0 10',
          strokeWidth: 2,
          stroke: '#333333',
          fill: '#FFFFFF',
        },
        label: {
          textVerticalAnchor: 'middle',
          textAnchor: 'middle',
          refX: '50%',
          refY: '50%',
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'polygon', selector: 'body' },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  iL = an.define(
    'standard.Polyline',
    {
      attrs: {
        body: {
          refPoints: '0 0 10 0 10 10 0 10 0 0',
          strokeWidth: 2,
          stroke: '#333333',
          fill: '#FFFFFF',
        },
        label: {
          textVerticalAnchor: 'middle',
          textAnchor: 'middle',
          refX: '50%',
          refY: '50%',
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'polyline', selector: 'body' },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  rL = an.define(
    'standard.Image',
    {
      attrs: {
        image: { refWidth: '100%', refHeight: '100%' },
        label: {
          textVerticalAnchor: 'top',
          textAnchor: 'middle',
          refX: '50%',
          refY: '100%',
          refY2: 10,
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'image', selector: 'image' },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  aL = an.define(
    'standard.BorderedImage',
    {
      attrs: {
        border: { refWidth: '100%', refHeight: '100%', stroke: '#333333', strokeWidth: 2 },
        background: { refWidth: -1, refHeight: -1, x: 0.5, y: 0.5, fill: '#FFFFFF' },
        image: { refWidth: -1, refHeight: -1, x: 0.5, y: 0.5 },
        label: {
          textVerticalAnchor: 'top',
          textAnchor: 'middle',
          refX: '50%',
          refY: '100%',
          refY2: 10,
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'rect', selector: 'background', attributes: { stroke: 'none' } },
        { tagName: 'image', selector: 'image' },
        { tagName: 'rect', selector: 'border', attributes: { fill: 'none' } },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  sL = an.define(
    'standard.EmbeddedImage',
    {
      attrs: {
        body: {
          refWidth: '100%',
          refHeight: '100%',
          stroke: '#333333',
          fill: '#FFFFFF',
          strokeWidth: 2,
        },
        image: { refWidth: '30%', refHeight: -20, x: 10, y: 10, preserveAspectRatio: 'xMidYMin' },
        label: {
          textVerticalAnchor: 'top',
          textAnchor: 'left',
          refX: '30%',
          refX2: 20,
          refY: 10,
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'rect', selector: 'body' },
        { tagName: 'image', selector: 'image' },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  oL = an.define(
    'standard.InscribedImage',
    {
      attrs: {
        border: {
          refRx: '50%',
          refRy: '50%',
          refCx: '50%',
          refCy: '50%',
          stroke: '#333333',
          strokeWidth: 2,
        },
        background: { refRx: '50%', refRy: '50%', refCx: '50%', refCy: '50%', fill: '#FFFFFF' },
        image: {
          refWidth: '68%',
          refHeight: '68%',
          refX: '16%',
          refY: '16%',
          preserveAspectRatio: 'xMidYMid',
        },
        label: {
          textVerticalAnchor: 'top',
          textAnchor: 'middle',
          refX: '50%',
          refY: '100%',
          refY2: 10,
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'ellipse', selector: 'background' },
        { tagName: 'image', selector: 'image' },
        { tagName: 'ellipse', selector: 'border', attributes: { fill: 'none' } },
        { tagName: 'text', selector: 'label' },
      ],
    }
  ),
  lL = an.define(
    'standard.HeaderedRectangle',
    {
      attrs: {
        body: {
          refWidth: '100%',
          refHeight: '100%',
          strokeWidth: 2,
          stroke: '#000000',
          fill: '#FFFFFF',
        },
        header: {
          refWidth: '100%',
          height: 30,
          strokeWidth: 2,
          stroke: '#000000',
          fill: '#FFFFFF',
        },
        headerText: {
          textVerticalAnchor: 'middle',
          textAnchor: 'middle',
          refX: '50%',
          refY: 15,
          fontSize: 16,
          fill: '#333333',
        },
        bodyText: {
          textVerticalAnchor: 'middle',
          textAnchor: 'middle',
          refX: '50%',
          refY: '50%',
          refY2: 15,
          fontSize: 14,
          fill: '#333333',
        },
      },
    },
    {
      markup: [
        { tagName: 'rect', selector: 'body' },
        { tagName: 'rect', selector: 'header' },
        { tagName: 'text', selector: 'headerText' },
        { tagName: 'text', selector: 'bodyText' },
      ],
    }
  )
var op = 10
const uL = an.define(
  'standard.Cylinder',
  {
    attrs: {
      body: { lateralArea: op, fill: '#FFFFFF', stroke: '#333333', strokeWidth: 2 },
      top: {
        refCx: '50%',
        cy: op,
        refRx: '50%',
        ry: op,
        fill: '#FFFFFF',
        stroke: '#333333',
        strokeWidth: 2,
      },
      label: {
        textVerticalAnchor: 'middle',
        textAnchor: 'middle',
        refX: '50%',
        refY: '100%',
        refY2: 15,
        fontSize: 14,
        fill: '#333333',
      },
    },
  },
  {
    markup: [
      { tagName: 'path', selector: 'body' },
      { tagName: 'ellipse', selector: 'top' },
      { tagName: 'text', selector: 'label' },
    ],
    topRy: function (t, e) {
      if (t === void 0) return this.attr('body/lateralArea')
      var n = Dn(t),
        i = { lateralArea: t },
        s = n
          ? { refCy: t, refRy: t, cy: null, ry: null }
          : { refCy: null, refRy: null, cy: t, ry: t }
      return this.attr({ body: i, top: s }, e)
    },
  },
  {
    attributes: {
      lateralArea: {
        set: function (t, e) {
          var n = Dn(t)
          n && (t = parseFloat(t) / 100)
          var i = e.x,
            s = e.y,
            o = e.width,
            u = e.height,
            c = o / 2,
            h = n ? u * t : t,
            p = yt.KAPPA,
            y = p * c,
            v = p * (n ? u * t : t),
            C = i,
            w = i + o / 2,
            N = i + o,
            T = s + h,
            z = T - h,
            R = s + u - h,
            B = s + u,
            H = [
              'M',
              C,
              T,
              'L',
              C,
              R,
              'C',
              i,
              R + v,
              w - y,
              B,
              w,
              B,
              'C',
              w + y,
              B,
              N,
              R + v,
              N,
              R,
              'L',
              N,
              T,
              'C',
              N,
              T - v,
              w + y,
              z,
              w,
              z,
              'C',
              w - y,
              z,
              C,
              T - v,
              C,
              T,
              'Z',
            ]
          return { d: H.join(' ') }
        },
      },
    },
  }
)
var cL = {
    tagName: 'foreignObject',
    selector: 'foreignObject',
    attributes: { overflow: 'hidden' },
    children: [
      {
        tagName: 'div',
        namespaceURI: 'http://www.w3.org/1999/xhtml',
        selector: 'label',
        style: {
          width: '100%',
          height: '100%',
          position: 'static',
          backgroundColor: 'transparent',
          textAlign: 'center',
          margin: 0,
          padding: '0px 5px',
          boxSizing: 'border-box',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        },
      },
    ],
  },
  fL = { tagName: 'text', selector: 'label', attributes: { 'text-anchor': 'middle' } },
  hL = Xm.test('svgforeignobject') ? cL : fL
const dL = an.define(
    'standard.TextBlock',
    {
      attrs: {
        body: {
          refWidth: '100%',
          refHeight: '100%',
          stroke: '#333333',
          fill: '#ffffff',
          strokeWidth: 2,
        },
        foreignObject: { refWidth: '100%', refHeight: '100%' },
        label: { style: { fontSize: 14 } },
      },
    },
    { markup: [{ tagName: 'rect', selector: 'body' }, hL] },
    {
      attributes: {
        text: {
          set: function (t, e, n, i) {
            if (n instanceof HTMLElement) n.textContent = t
            else {
              var s = i.style || {},
                o = { text: t, width: -5, height: '100%' },
                u = Kt({ textVerticalAnchor: 'middle' }, s)
              return (Pm.textWrap.set.call(this, o, e, n, u), { fill: s.color || null })
            }
          },
          position: function (t, e, n) {
            if (n instanceof SVGElement) return e.center()
          },
        },
      },
    }
  ),
  AS = wn.define(
    'standard.Link',
    {
      attrs: {
        line: {
          connection: !0,
          stroke: '#333333',
          strokeWidth: 2,
          strokeLinejoin: 'round',
          targetMarker: { type: 'path', d: 'M 10 -5 0 0 10 5 z' },
        },
        wrapper: { connection: !0, strokeWidth: 10, strokeLinejoin: 'round' },
      },
    },
    {
      markup: [
        {
          tagName: 'path',
          selector: 'wrapper',
          attributes: {
            fill: 'none',
            cursor: 'pointer',
            stroke: 'transparent',
            'stroke-linecap': 'round',
          },
        },
        {
          tagName: 'path',
          selector: 'line',
          attributes: { fill: 'none', 'pointer-events': 'none' },
        },
      ],
    }
  ),
  gL = wn.define(
    'standard.DoubleLink',
    {
      attrs: {
        line: {
          connection: !0,
          stroke: '#DDDDDD',
          strokeWidth: 4,
          strokeLinejoin: 'round',
          targetMarker: { type: 'path', stroke: '#000000', d: 'M 10 -3 10 -10 -2 0 10 10 10 3' },
        },
        outline: { connection: !0, stroke: '#000000', strokeWidth: 6, strokeLinejoin: 'round' },
      },
    },
    {
      markup: [
        { tagName: 'path', selector: 'outline', attributes: { fill: 'none', cursor: 'pointer' } },
        {
          tagName: 'path',
          selector: 'line',
          attributes: { fill: 'none', 'pointer-events': 'none' },
        },
      ],
    }
  ),
  pL = wn.define(
    'standard.ShadowLink',
    {
      attrs: {
        line: {
          connection: !0,
          stroke: '#FF0000',
          strokeWidth: 20,
          strokeLinejoin: 'round',
          targetMarker: { type: 'path', stroke: 'none', d: 'M 0 -10 -10 0 0 10 z' },
          sourceMarker: { type: 'path', stroke: 'none', d: 'M -10 -10 0 0 -10 10 0 10 0 -10 z' },
        },
        shadow: {
          connection: !0,
          refX: 3,
          refY: 6,
          stroke: '#000000',
          strokeOpacity: 0.2,
          strokeWidth: 20,
          strokeLinejoin: 'round',
          targetMarker: { type: 'path', d: 'M 0 -10 -10 0 0 10 z', stroke: 'none' },
          sourceMarker: { type: 'path', stroke: 'none', d: 'M -10 -10 0 0 -10 10 0 10 0 -10 z' },
        },
      },
    },
    {
      markup: [
        {
          tagName: 'path',
          selector: 'shadow',
          attributes: { fill: 'none', 'pointer-events': 'none' },
        },
        { tagName: 'path', selector: 'line', attributes: { fill: 'none', cursor: 'pointer' } },
      ],
    }
  ),
  vL = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        BorderedImage: aL,
        Circle: $O,
        Cylinder: uL,
        DoubleLink: gL,
        Ellipse: tL,
        EmbeddedImage: sL,
        HeaderedRectangle: lL,
        Image: rL,
        InscribedImage: oL,
        Link: AS,
        Path: eL,
        Polygon: nL,
        Polyline: iL,
        Rectangle: yS,
        ShadowLink: pL,
        TextBlock: dL,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Fm = ke.define(
    'devs.Model',
    {
      inPorts: [],
      outPorts: [],
      size: { width: 80, height: 80 },
      attrs: {
        '.': { magnet: !1 },
        '.label': {
          text: 'Model',
          'ref-x': 0.5,
          'ref-y': 10,
          'font-size': 18,
          'text-anchor': 'middle',
          fill: '#000',
        },
        '.body': { 'ref-width': '100%', 'ref-height': '100%', stroke: '#000' },
      },
      ports: {
        groups: {
          in: {
            position: { name: 'left' },
            attrs: {
              '.port-label': { fill: '#000' },
              '.port-body': { fill: '#fff', stroke: '#000', r: 10, magnet: !0 },
            },
            label: { position: { name: 'left', args: { y: 10 } } },
          },
          out: {
            position: { name: 'right' },
            attrs: {
              '.port-label': { fill: '#000' },
              '.port-body': { fill: '#fff', stroke: '#000', r: 10, magnet: !0 },
            },
            label: { position: { name: 'right', args: { y: 10 } } },
          },
        },
      },
    },
    {
      markup: '<g class="rotatable"><rect class="body"/><text class="label"/></g>',
      portMarkup: '<circle class="port-body"/>',
      portLabelMarkup: '<text class="port-label"/>',
      initialize: function () {
        ;(ke.prototype.initialize.apply(this, arguments),
          this.on('change:inPorts change:outPorts', this.updatePortItems, this),
          this.updatePortItems())
      },
      updatePortItems: function (t, e, n) {
        var i = cs(this.get('inPorts')),
          s = km(cs(this.get('outPorts')), i),
          o = this.createPortItems('in', i),
          u = this.createPortItems('out', s)
        this.prop('ports/items', o.concat(u), Kt({ rewrite: !0 }, n))
      },
      createPortItem: function (t, e) {
        return { id: e, group: t, attrs: { '.port-label': { text: e } } }
      },
      createPortItems: function (t, e) {
        return xe(e).map(this.createPortItem.bind(this, t))
      },
      _addGroupPort: function (t, e, n) {
        var i = this.get(e)
        return this.set(e, Array.isArray(i) ? i.concat(t) : [t], n)
      },
      addOutPort: function (t, e) {
        return this._addGroupPort(t, 'outPorts', e)
      },
      addInPort: function (t, e) {
        return this._addGroupPort(t, 'inPorts', e)
      },
      _removeGroupPort: function (t, e, n) {
        return this.set(e, eh(this.get(e), t), n)
      },
      removeOutPort: function (t, e) {
        return this._removeGroupPort(t, 'outPorts', e)
      },
      removeInPort: function (t, e) {
        return this._removeGroupPort(t, 'inPorts', e)
      },
      _changeGroup: function (t, e, n) {
        return this.prop('ports/groups/' + t, ze(e) ? e : {}, n)
      },
      changeInGroup: function (t, e) {
        return this._changeGroup('in', t, e)
      },
      changeOutGroup: function (t, e) {
        return this._changeGroup('out', t, e)
      },
    }
  ),
  mL = Fm.define('devs.Atomic', {
    size: { width: 80, height: 80 },
    attrs: { '.label': { text: 'Atomic' } },
  }),
  yL = Fm.define('devs.Coupled', {
    size: { width: 200, height: 300 },
    attrs: { '.label': { text: 'Coupled' } },
  }),
  AL = wn.define('devs.Link', { attrs: { '.connection': { 'stroke-width': 2 } } }),
  bL = Object.freeze(
    Object.defineProperty(
      { __proto__: null, Atomic: mL, Coupled: yL, Link: AL, Model: Fm },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  jh = ke.define(
    'logic.Gate',
    {
      size: { width: 80, height: 40 },
      attrs: {
        '.': { magnet: !1 },
        '.body': { width: 100, height: 50 },
        circle: { r: 7, stroke: 'black', fill: 'transparent', 'stroke-width': 2 },
      },
    },
    {
      operation: function () {
        return !0
      },
    }
  ),
  Jm = jh.define(
    'logic.IO',
    {
      size: { width: 60, height: 30 },
      attrs: {
        '.body': { fill: 'white', stroke: 'black', 'stroke-width': 2 },
        '.wire': { ref: '.body', 'ref-y': 0.5, stroke: 'black' },
        text: {
          fill: 'black',
          ref: '.body',
          'ref-x': 0.5,
          'ref-y': 0.5,
          'y-alignment': 'middle',
          'text-anchor': 'middle',
          'font-weight': 'bold',
          'font-variant': 'small-caps',
          'text-transform': 'capitalize',
          'font-size': '14px',
        },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><rect class="body"/></g><path class="wire"/><circle/><text/></g>',
    }
  ),
  IL = Jm.define('logic.Input', {
    attrs: {
      '.wire': { 'ref-dx': 0, d: 'M 0 0 L 23 0' },
      circle: {
        ref: '.body',
        'ref-dx': 30,
        'ref-y': 0.5,
        magnet: !0,
        class: 'output',
        port: 'out',
      },
      text: { text: 'input' },
    },
  }),
  CL = Jm.define('logic.Output', {
    attrs: {
      '.wire': { 'ref-x': 0, d: 'M 0 0 L -23 0' },
      circle: {
        ref: '.body',
        'ref-x': -30,
        'ref-y': 0.5,
        magnet: 'passive',
        class: 'input',
        port: 'in',
      },
      text: { text: 'output' },
    },
  }),
  qm = jh.define(
    'logic.Gate11',
    {
      attrs: {
        '.input': { ref: '.body', 'ref-x': -2, 'ref-y': 0.5, magnet: 'passive', port: 'in' },
        '.output': { ref: '.body', 'ref-dx': 2, 'ref-y': 0.5, magnet: !0, port: 'out' },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><image class="body"/></g><circle class="input"/><circle class="output"/></g>',
    }
  ),
  lo = jh.define(
    'logic.Gate21',
    {
      attrs: {
        '.input1': { ref: '.body', 'ref-x': -2, 'ref-y': 0.3, magnet: 'passive', port: 'in1' },
        '.input2': { ref: '.body', 'ref-x': -2, 'ref-y': 0.7, magnet: 'passive', port: 'in2' },
        '.output': { ref: '.body', 'ref-dx': 2, 'ref-y': 0.5, magnet: !0, port: 'out' },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><image class="body"/></g><circle class="input input1"/><circle  class="input input2"/><circle class="output"/></g>',
    }
  ),
  wL = qm.define(
    'logic.Repeater',
    {
      attrs: {
        image: {
          'xlink:href':
            'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzIuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICA8L2c+Cjwvc3ZnPgo=',
        },
      },
    },
    {
      operation: function (t) {
        return t
      },
    }
  ),
  xL = qm.define(
    'logic.Not',
    {
      attrs: {
        image: {
          'xlink:href':
            'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzkuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDI2NzEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzYiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA4MCwyNSBBIDQsNCAwIDEgMSA3MiwyNSBBIDQsNCAwIDEgMSA4MCwyNSB6IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEsMCkiIC8+CiAgPC9nPgo8L3N2Zz4K',
        },
      },
    },
    {
      operation: function (t) {
        return !t
      },
    }
  ),
  SL = lo.define(
    'logic.Or',
    {
      attrs: {
        image: {
          'xlink:href':
            'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik9SIEFOU0kuc3ZnIgogICBpbmtzY2FwZTpvdXRwdXRfZXh0ZW5zaW9uPSJvcmcuaW5rc2NhcGUub3V0cHV0LnN2Zy5pbmtzY2FwZSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTAgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjcxNCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iMSA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMC41IDogMC4zMzMzMzMzMyA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODA2IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODE5IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjM3Mi4wNDcyNCA6IDM1MC43ODczOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI3NDQuMDk0NDggOiA1MjYuMTgxMDkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzc3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49Ijc1IDogNDAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTUwIDogNjAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDYwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTMyNzUiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNTAgOiAzMy4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTAwIDogNTAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTU1MzMiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzIgOiAyMS4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNjQgOiAzMiA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMzIgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjU1NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDE2LjY2NjY2NyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDI1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAyNSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iNCIKICAgICBpbmtzY2FwZTpjeD0iMTEzLjAwMDM5IgogICAgIGlua3NjYXBlOmN5PSIxMi44OTM3MzEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTYwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpncmlkLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1wb2ludHM9InRydWUiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAwMDAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxMzk5IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg3NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzciCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii00IgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzAsMjUgYyAyMCwwIDI1LDAgMjUsMCIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMSwxNSA1LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzIsMzUgNSwzNSIKICAgICAgIGlkPSJwYXRoMzk0NCIgLz4KICAgIDxnCiAgICAgICBpZD0iZzI1NjAiCiAgICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjUsLTM5LjUpIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo=',
        },
      },
    },
    {
      operation: function (t, e) {
        return t || e
      },
    }
  ),
  NL = lo.define(
    'logic.And',
    {
      attrs: {
        image: {
          'xlink:href':
            'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IkFORCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI4IgogICAgIGlua3NjYXBlOmN4PSI1Ni42OTgzNDgiCiAgICAgaW5rc2NhcGU6Y3k9IjI1LjMyNjg5OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozO21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6Qml0c3RyZWFtIFZlcmEgU2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkJpdHN0cmVhbSBWZXJhIFNhbnMiCiAgICAgICBkPSJNIDMwLDUgTCAzMCw2LjQyODU3MTQgTCAzMCw0My41NzE0MjkgTCAzMCw0NSBMIDMxLjQyODU3MSw0NSBMIDUwLjQ3NjE5LDQ1IEMgNjEuNzQ0MDk4LDQ1IDcwLjQ3NjE5LDM1Ljk5OTk1NSA3MC40NzYxOSwyNSBDIDcwLjQ3NjE5LDE0LjAwMDA0NSA2MS43NDQwOTksNS4wMDAwMDAyIDUwLjQ3NjE5LDUgQyA1MC40NzYxOSw1IDUwLjQ3NjE5LDUgMzEuNDI4NTcxLDUgTCAzMCw1IHogTSAzMi44NTcxNDMsNy44NTcxNDI5IEMgNDAuODM0MjY0LDcuODU3MTQyOSA0NS45MTgzNjgsNy44NTcxNDI5IDQ4LjA5NTIzOCw3Ljg1NzE0MjkgQyA0OS4yODU3MTQsNy44NTcxNDI5IDQ5Ljg4MDk1Miw3Ljg1NzE0MjkgNTAuMTc4NTcxLDcuODU3MTQyOSBDIDUwLjMyNzM4MSw3Ljg1NzE0MjkgNTAuNDA5MjI3LDcuODU3MTQyOSA1MC40NDY0MjksNy44NTcxNDI5IEMgNTAuNDY1MDI5LDcuODU3MTQyOSA1MC40NzE1NDMsNy44NTcxNDI5IDUwLjQ3NjE5LDcuODU3MTQyOSBDIDYwLjIzNjg1Myw3Ljg1NzE0MyA2Ny4xNDI4NTcsMTUuNDk3MDk4IDY3LjE0Mjg1NywyNSBDIDY3LjE0Mjg1NywzNC41MDI5MDIgNTkuNzYwNjYyLDQyLjE0Mjg1NyA1MCw0Mi4xNDI4NTcgTCAzMi44NTcxNDMsNDIuMTQyODU3IEwgMzIuODU3MTQzLDcuODU3MTQyOSB6IgogICAgICAgaWQ9InBhdGgyODg0IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjY2NzY2NjY3Nzc3NzY2NjIiAvPgogIDwvZz4KPC9zdmc+Cg==',
        },
      },
    },
    {
      operation: function (t, e) {
        return t && e
      },
    }
  ),
  TL = lo.define(
    'logic.Nor',
    {
      attrs: {
        image: {
          'xlink:href':
            'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjEiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjY3NzY0NCIKICAgICBpbmtzY2FwZTpjeT0iMjIuMTAyMzQ0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjM3IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItNCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc5LDI1IEMgOTksMjUgOTUsMjUgOTUsMjUiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgICBpZD0icGF0aDI2MDQiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI3NSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjI1IgogICAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgICAgc29kaXBvZGk6cnk9IjQiCiAgICAgICAgIGQ9Ik0gNzksMjUgQSA0LDQgMCAxIDEgNzEsMjUgQSA0LDQgMCAxIDEgNzksMjUgeiIKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2LjUsMzkuNSkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K',
        },
      },
    },
    {
      operation: function (t, e) {
        return !(t || e)
      },
    }
  ),
  ML = lo.define(
    'logic.Nand',
    {
      attrs: {
        image: {
          'xlink:href':
            'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5BTkQgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjI4MzMwNyIKICAgICBpbmtzY2FwZTpjeT0iMTYuNDQyODQzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzksMjUgQyA5MS44LDI1IDk1LDI1IDk1LDI1IgogICAgICAgaWQ9InBhdGgzMDU5IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMxLDE1IDUsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMiwzNSA1LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MzttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OkJpdHN0cmVhbSBWZXJhIFNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpCaXRzdHJlYW0gVmVyYSBTYW5zIgogICAgICAgZD0iTSAzMCw1IEwgMzAsNi40Mjg1NzE0IEwgMzAsNDMuNTcxNDI5IEwgMzAsNDUgTCAzMS40Mjg1NzEsNDUgTCA1MC40NzYxOSw0NSBDIDYxLjc0NDA5OCw0NSA3MC40NzYxOSwzNS45OTk5NTUgNzAuNDc2MTksMjUgQyA3MC40NzYxOSwxNC4wMDAwNDUgNjEuNzQ0MDk5LDUuMDAwMDAwMiA1MC40NzYxOSw1IEMgNTAuNDc2MTksNSA1MC40NzYxOSw1IDMxLjQyODU3MSw1IEwgMzAsNSB6IE0gMzIuODU3MTQzLDcuODU3MTQyOSBDIDQwLjgzNDI2NCw3Ljg1NzE0MjkgNDUuOTE4MzY4LDcuODU3MTQyOSA0OC4wOTUyMzgsNy44NTcxNDI5IEMgNDkuMjg1NzE0LDcuODU3MTQyOSA0OS44ODA5NTIsNy44NTcxNDI5IDUwLjE3ODU3MSw3Ljg1NzE0MjkgQyA1MC4zMjczODEsNy44NTcxNDI5IDUwLjQwOTIyNyw3Ljg1NzE0MjkgNTAuNDQ2NDI5LDcuODU3MTQyOSBDIDUwLjQ2NTAyOSw3Ljg1NzE0MjkgNTAuNDcxNTQzLDcuODU3MTQyOSA1MC40NzYxOSw3Ljg1NzE0MjkgQyA2MC4yMzY4NTMsNy44NTcxNDMgNjcuMTQyODU3LDE1LjQ5NzA5OCA2Ny4xNDI4NTcsMjUgQyA2Ny4xNDI4NTcsMzQuNTAyOTAyIDU5Ljc2MDY2Miw0Mi4xNDI4NTcgNTAsNDIuMTQyODU3IEwgMzIuODU3MTQzLDQyLjE0Mjg1NyBMIDMyLjg1NzE0Myw3Ljg1NzE0MjkgeiIKICAgICAgIGlkPSJwYXRoMjg4NCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2Njc2NjY2Nzc3Nzc2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDQwMDgiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==',
        },
      },
    },
    {
      operation: function (t, e) {
        return !(t && e)
      },
    }
  ),
  EL = lo.define(
    'logic.Xor',
    {
      attrs: {
        image: {
          'xlink:href':
            'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhPUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjUuNjU2ODU0MiIKICAgICBpbmtzY2FwZTpjeD0iMjUuOTM4MTE2IgogICAgIGlua3NjYXBlOmN5PSIxNy4yMzAwNSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzAuMzg1NzE3LDE1IEwgNC45OTk5OTk4LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5NzY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEuMzYyMDkxLDM1IEwgNC45OTk5OTk4LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPGcKICAgICAgIGlkPSJnMjU2MCIKICAgICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYuNSwtMzkuNSkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM1MTYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi4yNSw4MS41MDAwMDUgQyAtMy44NDczNzQsODQuMTQ0NDA1IC00LjUsODQuNTAwMDA1IC00LjUsODQuNTAwMDA1IEwgLTguMTU2MjUsODQuNTAwMDA1IEwgLTYuMTU2MjUsODIuMDYyNTA1IEMgLTYuMTU2MjUsODIuMDYyNTA1IC0wLjUsNzUuMDYyNDUxIC0wLjUsNjQuNSBDIC0wLjUsNTMuOTM3NTQ5IC02LjE1NjI1LDQ2LjkzNzUgLTYuMTU2MjUsNDYuOTM3NSBMIC04LjE1NjI1LDQ0LjUgTCAtNC41LDQ0LjUgQyAtMy43MTg3NSw0NS40Mzc1IC0zLjA3ODEyNSw0Ni4xNTYyNSAtMi4yODEyNSw0Ny41IEMgLTAuNDA4NTMxLDUwLjU5OTgxNSAyLjUsNTYuNTI2NjQ2IDIuNSw2NC41IEMgMi41LDcyLjQ1MDY1IC0wLjM5NjY5Nyw3OC4zNzk0MjUgLTIuMjUsODEuNTAwMDA1IHoiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY3NjY2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K',
        },
      },
    },
    {
      operation: function (t, e) {
        return (!t || e) && (t || !e)
      },
    }
  ),
  DL = lo.define(
    'logic.Xnor',
    {
      attrs: {
        image: {
          'xlink:href':
            'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhOT1IgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNTU3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTYuNjY2NjY3IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDI1IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI0IgogICAgIGlua3NjYXBlOmN4PSI5NS43MjM2NiIKICAgICBpbmtzY2FwZTpjeT0iLTI2Ljc3NTAyMyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjAwMDAwMDI0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc4LjMzMzMzMiwyNSBDIDkxLjY2NjY2NiwyNSA5NSwyNSA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC4zODU3MTcsMTUgTCA0Ljk5OTk5OTgsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk3NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMS4zNjIwOTEsMzUgTCA0Ljk5OTk5OTgsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzUxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjI1LDgxLjUwMDAwNSBDIC0zLjg0NzM3NCw4NC4xNDQ0MDUgLTQuNSw4NC41MDAwMDUgLTQuNSw4NC41MDAwMDUgTCAtOC4xNTYyNSw4NC41MDAwMDUgTCAtNi4xNTYyNSw4Mi4wNjI1MDUgQyAtNi4xNTYyNSw4Mi4wNjI1MDUgLTAuNSw3NS4wNjI0NTEgLTAuNSw2NC41IEMgLTAuNSw1My45Mzc1NDkgLTYuMTU2MjUsNDYuOTM3NSAtNi4xNTYyNSw0Ni45Mzc1IEwgLTguMTU2MjUsNDQuNSBMIC00LjUsNDQuNSBDIC0zLjcxODc1LDQ1LjQzNzUgLTMuMDc4MTI1LDQ2LjE1NjI1IC0yLjI4MTI1LDQ3LjUgQyAtMC40MDg1MzEsNTAuNTk5ODE1IDIuNSw1Ni41MjY2NDYgMi41LDY0LjUgQyAyLjUsNzIuNDUwNjUgLTAuMzk2Njk3LDc4LjM3OTQyNSAtMi4yNSw4MS41MDAwMDUgeiIKICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2Njc2NjY2NzYyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDM1NTEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg==',
        },
      },
    },
    {
      operation: function (t, e) {
        return (!t || !e) && (t || e)
      },
    }
  ),
  OL = wn.define(
    'logic.Wire',
    {
      attrs: { '.connection': { 'stroke-width': 2 }, '.marker-vertex': { r: 7 } },
      router: { name: 'orthogonal' },
      connector: { name: 'rounded', args: { radius: 10 } },
    },
    {
      arrowheadMarkup: [
        '<g class="marker-arrowhead-group marker-arrowhead-group-<%= end %>">',
        '<circle class="marker-arrowhead" end="<%= end %>" r="7"/>',
        '</g>',
      ].join(''),
      vertexMarkup: [
        '<g class="marker-vertex-group" transform="translate(<%= x %>, <%= y %>)">',
        '<circle class="marker-vertex" idx="<%= idx %>" r="10" />',
        '<g class="marker-vertex-remove-group">',
        '<path class="marker-vertex-remove-area" idx="<%= idx %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>',
        '<path class="marker-vertex-remove" idx="<%= idx %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">',
        '<title>Remove vertex.</title>',
        '</path>',
        '</g>',
        '</g>',
      ].join(''),
    }
  ),
  LL = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        And: NL,
        Gate: jh,
        Gate11: qm,
        Gate21: lo,
        IO: Jm,
        Input: IL,
        Nand: ML,
        Nor: TL,
        Not: xL,
        Or: SL,
        Output: CL,
        Repeater: wL,
        Wire: OL,
        Xnor: DL,
        Xor: EL,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  zL = ke.define(
    'chess.KingWhite',
    { size: { width: 42, height: 38 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;"><path      d="M 22.5,11.63 L 22.5,6"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />    <path      d="M 20,8 L 25,8"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />    <path      d="M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25"      style="fill:#ffffff; stroke:#000000; stroke-linecap:butt; stroke-linejoin:miter;" />    <path      d="M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z "      style="fill:#ffffff; stroke:#000000;" />    <path      d="M 11.5,30 C 17,27 27,27 32.5,30"      style="fill:none; stroke:#000000;" />    <path      d="M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5"      style="fill:none; stroke:#000000;" />    <path      d="M 11.5,37 C 17,34 27,34 32.5,37"      style="fill:none; stroke:#000000;" />  </g></g></g>',
    }
  ),
  RL = ke.define(
    'chess.KingBlack',
    { size: { width: 42, height: 38 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path       d="M 22.5,11.63 L 22.5,6"       style="fill:none; stroke:#000000; stroke-linejoin:miter;"       id="path6570" />    <path       d="M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25"       style="fill:#000000;fill-opacity:1; stroke-linecap:butt; stroke-linejoin:miter;" />    <path       d="M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z "       style="fill:#000000; stroke:#000000;" />    <path       d="M 20,8 L 25,8"       style="fill:none; stroke:#000000; stroke-linejoin:miter;" />    <path       d="M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.51,26.6 L 22.5,24.5 C 20,18 9.906,14 6.997,19.85 C 4.5,25.5 11.85,28.85 11.85,28.85"       style="fill:none; stroke:#ffffff;" />    <path       d="M 11.5,30 C 17,27 27,27 32.5,30 M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5 M 11.5,37 C 17,34 27,34 32.5,37"       style="fill:none; stroke:#ffffff;" />  </g></g></g>',
    }
  ),
  kL = ke.define(
    'chess.QueenWhite',
    { size: { width: 42, height: 38 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(-1,-1)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(15.5,-5.5)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(32,-1)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(7,-4.5)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(24,-4)" />    <path      d="M 9,26 C 17.5,24.5 30,24.5 36,26 L 38,14 L 31,25 L 31,11 L 25.5,24.5 L 22.5,9.5 L 19.5,24.5 L 14,10.5 L 14,25 L 7,14 L 9,26 z "      style="stroke-linecap:butt;" />    <path      d="M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z "      style="stroke-linecap:butt;" />    <path      d="M 11.5,30 C 15,29 30,29 33.5,30"      style="fill:none;" />    <path      d="M 12,33.5 C 18,32.5 27,32.5 33,33.5"      style="fill:none;" />  </g></g></g>',
    }
  ),
  _L = ke.define(
    'chess.QueenBlack',
    { size: { width: 42, height: 38 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <g style="fill:#000000; stroke:none;">      <circle cx="6"    cy="12" r="2.75" />      <circle cx="14"   cy="9"  r="2.75" />      <circle cx="22.5" cy="8"  r="2.75" />      <circle cx="31"   cy="9"  r="2.75" />      <circle cx="39"   cy="12" r="2.75" />    </g>    <path       d="M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z"       style="stroke-linecap:butt; stroke:#000000;" />    <path       d="M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z"       style="stroke-linecap:butt;" />    <path       d="M 11,38.5 A 35,35 1 0 0 34,38.5"       style="fill:none; stroke:#000000; stroke-linecap:butt;" />    <path       d="M 11,29 A 35,35 1 0 1 34,29"       style="fill:none; stroke:#ffffff;" />    <path       d="M 12.5,31.5 L 32.5,31.5"       style="fill:none; stroke:#ffffff;" />    <path       d="M 11.5,34.5 A 35,35 1 0 0 33.5,34.5"       style="fill:none; stroke:#ffffff;" />    <path       d="M 10.5,37.5 A 35,35 1 0 0 34.5,37.5"       style="fill:none; stroke:#ffffff;" />  </g></g></g>',
    }
  ),
  BL = ke.define(
    'chess.RookWhite',
    { size: { width: 32, height: 34 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z "      style="stroke-linecap:butt;" />    <path      d="M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z "      style="stroke-linecap:butt;" />    <path      d="M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14"      style="stroke-linecap:butt;" />    <path      d="M 34,14 L 31,17 L 14,17 L 11,14" />    <path      d="M 31,17 L 31,29.5 L 14,29.5 L 14,17"      style="stroke-linecap:butt; stroke-linejoin:miter;" />    <path      d="M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5" />    <path      d="M 11,14 L 34,14"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />  </g></g></g>',
    }
  ),
  jL = ke.define(
    'chess.RookBlack',
    { size: { width: 32, height: 34 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z "      style="stroke-linecap:butt;" />    <path      d="M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z "      style="stroke-linecap:butt;" />    <path      d="M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z "      style="stroke-linecap:butt;" />    <path      d="M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z "      style="stroke-linecap:butt;stroke-linejoin:miter;" />    <path      d="M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z "      style="stroke-linecap:butt;" />    <path      d="M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z "      style="stroke-linecap:butt;" />    <path      d="M 12,35.5 L 33,35.5 L 33,35.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 13,31.5 L 32,31.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 14,29.5 L 31,29.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 14,16.5 L 31,16.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 11,14 L 34,14"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />  </g></g></g>',
    }
  ),
  PL = ke.define(
    'chess.BishopWhite',
    { size: { width: 38, height: 38 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <g style="fill:#ffffff; stroke:#000000; stroke-linecap:butt;">       <path        d="M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z" />      <path        d="M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" />      <path        d="M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" />    </g>    <path      d="M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />  </g></g></g>',
    }
  ),
  GL = ke.define(
    'chess.BishopBlack',
    { size: { width: 38, height: 38 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <g style="fill:#000000; stroke:#000000; stroke-linecap:butt;">       <path        d="M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z" />      <path        d="M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" />      <path        d="M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" />    </g>    <path       d="M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18"       style="fill:none; stroke:#ffffff; stroke-linejoin:miter;" />  </g></g></g>',
    }
  ),
  ZL = ke.define(
    'chess.KnightWhite',
    { size: { width: 38, height: 37 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18"      style="fill:#ffffff; stroke:#000000;" />    <path      d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10"      style="fill:#ffffff; stroke:#000000;" />    <path      d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z"      style="fill:#000000; stroke:#000000;" />    <path      d="M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z"      transform="matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)"      style="fill:#000000; stroke:#000000;" />  </g></g></g>',
    }
  ),
  UL = ke.define(
    'chess.KnightBlack',
    { size: { width: 38, height: 37 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18"      style="fill:#000000; stroke:#000000;" />    <path      d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10"      style="fill:#000000; stroke:#000000;" />    <path      d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z"      style="fill:#ffffff; stroke:#ffffff;" />    <path      d="M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z"      transform="matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)"      style="fill:#ffffff; stroke:#ffffff;" />    <path      d="M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z "      style="fill:#ffffff; stroke:none;" />  </g></g></g>',
    }
  ),
  YL = ke.define(
    'chess.PawnWhite',
    { size: { width: 28, height: 33 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><path d="M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z "  style="opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;" /></g></g>',
    }
  ),
  HL = ke.define(
    'chess.PawnBlack',
    { size: { width: 28, height: 33 } },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><path d="M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z "  style="opacity:1; fill:#000000; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;" /></g></g>',
    }
  ),
  VL = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        BishopBlack: GL,
        BishopWhite: PL,
        KingBlack: RL,
        KingWhite: zL,
        KnightBlack: UL,
        KnightWhite: ZL,
        PawnBlack: HL,
        PawnWhite: YL,
        QueenBlack: _L,
        QueenWhite: kL,
        RookBlack: jL,
        RookWhite: BL,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  bS = an.define(
    'erd.Entity',
    {
      size: { width: 150, height: 60 },
      attrs: {
        '.outer': {
          fill: '#2ECC71',
          stroke: '#27AE60',
          'stroke-width': 2,
          points: '100,0 100,60 0,60 0,0',
        },
        '.inner': {
          fill: '#2ECC71',
          stroke: '#27AE60',
          'stroke-width': 2,
          points: '95,5 95,55 5,55 5,5',
          display: 'none',
        },
        text: {
          text: 'Entity',
          'font-family': 'Arial',
          'font-size': 14,
          'ref-x': 0.5,
          'ref-y': 0.5,
          'y-alignment': 'middle',
          'text-anchor': 'middle',
        },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><polygon class="outer"/><polygon class="inner"/></g><text/></g>',
    }
  ),
  XL = bS.define('erd.WeakEntity', {
    attrs: { '.inner': { display: 'auto' }, text: { text: 'Weak Entity' } },
  }),
  IS = an.define(
    'erd.Relationship',
    {
      size: { width: 80, height: 80 },
      attrs: {
        '.outer': {
          fill: '#3498DB',
          stroke: '#2980B9',
          'stroke-width': 2,
          points: '40,0 80,40 40,80 0,40',
        },
        '.inner': {
          fill: '#3498DB',
          stroke: '#2980B9',
          'stroke-width': 2,
          points: '40,5 75,40 40,75 5,40',
          display: 'none',
        },
        text: {
          text: 'Relationship',
          'font-family': 'Arial',
          'font-size': 12,
          'ref-x': 0.5,
          'ref-y': 0.5,
          'y-alignment': 'middle',
          'text-anchor': 'middle',
        },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><polygon class="outer"/><polygon class="inner"/></g><text/></g>',
    }
  ),
  WL = IS.define('erd.IdentifyingRelationship', {
    attrs: { '.inner': { display: 'auto' }, text: { text: 'Identifying' } },
  }),
  ic = an.define(
    'erd.Attribute',
    {
      size: { width: 100, height: 50 },
      attrs: {
        ellipse: { transform: 'translate(50, 25)' },
        '.outer': {
          stroke: '#D35400',
          'stroke-width': 2,
          cx: 0,
          cy: 0,
          rx: 50,
          ry: 25,
          fill: '#E67E22',
        },
        '.inner': {
          stroke: '#D35400',
          'stroke-width': 2,
          cx: 0,
          cy: 0,
          rx: 45,
          ry: 20,
          fill: '#E67E22',
          display: 'none',
        },
        text: {
          'font-family': 'Arial',
          'font-size': 14,
          'ref-x': 0.5,
          'ref-y': 0.5,
          'y-alignment': 'middle',
          'text-anchor': 'middle',
        },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><ellipse class="outer"/><ellipse class="inner"/></g><text/></g>',
    }
  ),
  FL = ic.define('erd.Multivalued', {
    attrs: { '.inner': { display: 'block' }, text: { text: 'multivalued' } },
  }),
  JL = ic.define('erd.Derived', {
    attrs: { '.outer': { 'stroke-dasharray': '3,5' }, text: { text: 'derived' } },
  }),
  qL = ic.define('erd.Key', {
    attrs: {
      ellipse: { 'stroke-width': 4 },
      text: { text: 'key', 'font-weight': '800', 'text-decoration': 'underline' },
    },
  }),
  QL = ic.define('erd.Normal', { attrs: { text: { text: 'Normal' } } }),
  KL = an.define(
    'erd.ISA',
    {
      type: 'erd.ISA',
      size: { width: 100, height: 50 },
      attrs: {
        polygon: {
          points: '0,0 50,50 100,0',
          fill: '#F1C40F',
          stroke: '#F39C12',
          'stroke-width': 2,
        },
        text: {
          text: 'ISA',
          'font-size': 18,
          'ref-x': 0.5,
          'ref-y': 0.3,
          'y-alignment': 'middle',
          'text-anchor': 'middle',
        },
      },
    },
    { markup: '<g class="rotatable"><g class="scalable"><polygon/></g><text/></g>' }
  ),
  $L = wn.define(
    'erd.Line',
    {},
    {
      cardinality: function (t) {
        this.set('labels', [{ position: -20, attrs: { text: { dy: -8, text: t } } }])
      },
    }
  ),
  tz = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Attribute: ic,
        Derived: JL,
        Entity: bS,
        ISA: KL,
        IdentifyingRelationship: WL,
        Key: qL,
        Line: $L,
        Multivalued: FL,
        Normal: QL,
        Relationship: IS,
        WeakEntity: XL,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  ez = Wm.define('fsa.State', {
    attrs: { circle: { 'stroke-width': 3 }, text: { 'font-weight': '800' } },
  }),
  nz = an.define(
    'fsa.StartState',
    {
      size: { width: 20, height: 20 },
      attrs: { circle: { transform: 'translate(10, 10)', r: 10, fill: '#000000' } },
    },
    { markup: '<g class="rotatable"><g class="scalable"><circle/></g></g>' }
  ),
  iz = an.define(
    'fsa.EndState',
    {
      size: { width: 20, height: 20 },
      attrs: {
        '.outer': { transform: 'translate(10, 10)', r: 10, fill: '#ffffff', stroke: '#000000' },
        '.inner': { transform: 'translate(10, 10)', r: 6, fill: '#000000' },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><circle class="outer"/><circle class="inner"/></g></g>',
    }
  ),
  rz = wn.define('fsa.Arrow', {
    attrs: { '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z' } },
    smooth: !0,
  }),
  az = Object.freeze(
    Object.defineProperty(
      { __proto__: null, Arrow: rz, EndState: iz, StartState: nz, State: ez },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  sz = an.define(
    'org.Member',
    {
      size: { width: 180, height: 70 },
      attrs: {
        rect: { width: 170, height: 60 },
        '.card': {
          fill: '#FFFFFF',
          stroke: '#000000',
          'stroke-width': 2,
          'pointer-events': 'visiblePainted',
          rx: 10,
          ry: 10,
        },
        image: { width: 48, height: 48, ref: '.card', 'ref-x': 10, 'ref-y': 5 },
        '.rank': {
          'text-decoration': 'underline',
          ref: '.card',
          'ref-x': 0.9,
          'ref-y': 0.2,
          'font-family': 'Courier New',
          'font-size': 14,
          'text-anchor': 'end',
        },
        '.name': {
          'font-weight': '800',
          ref: '.card',
          'ref-x': 0.9,
          'ref-y': 0.6,
          'font-family': 'Courier New',
          'font-size': 14,
          'text-anchor': 'end',
        },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><rect class="card"/><image/></g><text class="rank"/><text class="name"/></g>',
    }
  ),
  oz = wn.define('org.Arrow', {
    source: { selector: '.card' },
    target: { selector: '.card' },
    attrs: { '.connection': { stroke: '#585858', 'stroke-width': 3 } },
    z: -1,
  }),
  lz = Object.freeze(
    Object.defineProperty({ __proto__: null, Arrow: oz, Member: sz }, Symbol.toStringTag, {
      value: 'Module',
    })
  ),
  uz = ke.define(
    'pn.Place',
    {
      size: { width: 50, height: 50 },
      attrs: {
        '.root': { r: 25, fill: '#ffffff', stroke: '#000000', transform: 'translate(25, 25)' },
        '.label': {
          'text-anchor': 'middle',
          'ref-x': 0.5,
          'ref-y': -20,
          ref: '.root',
          fill: '#000000',
          'font-size': 12,
        },
        '.tokens > circle': { fill: '#000000', r: 5 },
        '.tokens.one > circle': { transform: 'translate(25, 25)' },
        '.tokens.two > circle:nth-child(1)': { transform: 'translate(19, 25)' },
        '.tokens.two > circle:nth-child(2)': { transform: 'translate(31, 25)' },
        '.tokens.three > circle:nth-child(1)': { transform: 'translate(18, 29)' },
        '.tokens.three > circle:nth-child(2)': { transform: 'translate(25, 19)' },
        '.tokens.three > circle:nth-child(3)': { transform: 'translate(32, 29)' },
        '.tokens.alot > text': {
          transform: 'translate(25, 18)',
          'text-anchor': 'middle',
          fill: '#000000',
        },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><circle class="root"/><g class="tokens" /></g><text class="label"/></g>',
    }
  ),
  cz = bn.extend({
    presentationAttributes: bn.addPresentationAttributes({ tokens: ['TOKENS'] }),
    initFlag: bn.prototype.initFlag.concat(['TOKENS']),
    confirmUpdate: function (...t) {
      let e = bn.prototype.confirmUpdate.call(this, ...t)
      return (
        this.hasFlag(e, 'TOKENS') &&
          (this.renderTokens(), this.update(), (e = this.removeFlag(e, 'TOKENS'))),
        e
      )
    },
    renderTokens: function () {
      const t = this.vel.findOne('.tokens').empty()
      ;['one', 'two', 'three', 'alot'].forEach(function (n) {
        t.removeClass(n)
      })
      var e = this.model.get('tokens')
      if (e)
        switch (e) {
          case 1:
            ;(t.addClass('one'), t.append(yt('circle')))
            break
          case 2:
            ;(t.addClass('two'), t.append([yt('circle'), yt('circle')]))
            break
          case 3:
            ;(t.addClass('three'), t.append([yt('circle'), yt('circle'), yt('circle')]))
            break
          default:
            ;(t.addClass('alot'), t.append(yt('text').text(e + '')))
            break
        }
    },
  }),
  fz = ke.define(
    'pn.Transition',
    {
      size: { width: 12, height: 50 },
      attrs: {
        rect: { width: 12, height: 50, fill: '#000000', stroke: '#000000' },
        '.label': {
          'text-anchor': 'middle',
          'ref-x': 0.5,
          'ref-y': -20,
          ref: 'rect',
          fill: '#000000',
          'font-size': 12,
        },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><rect class="root"/></g></g><text class="label"/>',
    }
  ),
  hz = wn.define('pn.Link', { attrs: { '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z' } } }),
  dz = Object.freeze(
    Object.defineProperty(
      { __proto__: null, Link: hz, Place: uz, PlaceView: cz, Transition: fz },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Uu = ke.define(
    'uml.Class',
    {
      attrs: {
        rect: { width: 200 },
        '.uml-class-name-rect': { stroke: 'black', 'stroke-width': 2, fill: '#3498db' },
        '.uml-class-attrs-rect': { stroke: 'black', 'stroke-width': 2, fill: '#2980b9' },
        '.uml-class-methods-rect': { stroke: 'black', 'stroke-width': 2, fill: '#2980b9' },
        '.uml-class-name-text': {
          ref: '.uml-class-name-rect',
          'ref-y': 0.5,
          'ref-x': 0.5,
          'text-anchor': 'middle',
          'y-alignment': 'middle',
          'font-weight': 'bold',
          fill: 'black',
          'font-size': 12,
          'font-family': 'Times New Roman',
        },
        '.uml-class-attrs-text': {
          ref: '.uml-class-attrs-rect',
          'ref-y': 5,
          'ref-x': 5,
          fill: 'black',
          'font-size': 12,
          'font-family': 'Times New Roman',
        },
        '.uml-class-methods-text': {
          ref: '.uml-class-methods-rect',
          'ref-y': 5,
          'ref-x': 5,
          fill: 'black',
          'font-size': 12,
          'font-family': 'Times New Roman',
        },
      },
      name: [],
      attributes: [],
      methods: [],
    },
    {
      markup: [
        '<g class="rotatable">',
        '<g class="scalable">',
        '<rect class="uml-class-name-rect"/><rect class="uml-class-attrs-rect"/><rect class="uml-class-methods-rect"/>',
        '</g>',
        '<text class="uml-class-name-text"/><text class="uml-class-attrs-text"/><text class="uml-class-methods-text"/>',
        '</g>',
      ].join(''),
      initialize: function () {
        ;(this.on(
          'change:name change:attributes change:methods',
          function () {
            ;(this.updateRectangles(), this.trigger('uml-update'))
          },
          this
        ),
          this.updateRectangles(),
          ke.prototype.initialize.apply(this, arguments))
      },
      getClassName: function () {
        return this.get('name')
      },
      updateRectangles: function () {
        var t = this.get('attrs'),
          e = [
            { type: 'name', text: this.getClassName() },
            { type: 'attrs', text: this.get('attributes') },
            { type: 'methods', text: this.get('methods') },
          ],
          n = 0
        e.forEach(function (i) {
          var s = Array.isArray(i.text) ? i.text : [i.text],
            o = s.length * 20 + 20
          ;((t['.uml-class-' + i.type + '-text'].text = s.join(`
`)),
            (t['.uml-class-' + i.type + '-rect'].height = o),
            (t['.uml-class-' + i.type + '-rect'].transform = 'translate(0,' + n + ')'),
            (n += o))
        })
      },
    }
  ),
  Qm = bn.extend({
    initialize: function () {
      ;(bn.prototype.initialize.apply(this, arguments),
        this.listenTo(this.model, 'uml-update', function () {
          ;(this.update(), this.resize())
        }))
    },
  }),
  gz = Uu.define(
    'uml.Abstract',
    {
      attrs: {
        '.uml-class-name-rect': { fill: '#e74c3c' },
        '.uml-class-attrs-rect': { fill: '#c0392b' },
        '.uml-class-methods-rect': { fill: '#c0392b' },
      },
    },
    {
      getClassName: function () {
        return ['<<Abstract>>', this.get('name')]
      },
    }
  ),
  pz = Qm,
  vz = Uu.define(
    'uml.Interface',
    {
      attrs: {
        '.uml-class-name-rect': { fill: '#f1c40f' },
        '.uml-class-attrs-rect': { fill: '#f39c12' },
        '.uml-class-methods-rect': { fill: '#f39c12' },
      },
    },
    {
      getClassName: function () {
        return ['<<Interface>>', this.get('name')]
      },
    }
  ),
  mz = Qm,
  CS = wn.define('uml.Generalization', {
    attrs: { '.marker-target': { d: 'M 20 0 L 0 10 L 20 20 z', fill: 'white' } },
  }),
  yz = wn.define('uml.Implementation', {
    attrs: {
      '.marker-target': { d: 'M 20 0 L 0 10 L 20 20 z', fill: 'white' },
      '.connection': { 'stroke-dasharray': '3,3' },
    },
  }),
  wS = wn.define('uml.Aggregation', {
    attrs: { '.marker-target': { d: 'M 40 10 L 20 20 L 0 10 L 20 0 z', fill: 'white' } },
  }),
  xS = wn.define('uml.Composition', {
    attrs: { '.marker-target': { d: 'M 40 10 L 20 20 L 0 10 L 20 0 z', fill: 'black' } },
  }),
  SS = wn.define('uml.Association'),
  Az = ke.define(
    'uml.State',
    {
      attrs: {
        '.uml-state-body': {
          width: 200,
          height: 200,
          rx: 10,
          ry: 10,
          fill: '#ecf0f1',
          stroke: '#bdc3c7',
          'stroke-width': 3,
        },
        '.uml-state-separator': { stroke: '#bdc3c7', 'stroke-width': 2 },
        '.uml-state-name': {
          ref: '.uml-state-body',
          'ref-x': 0.5,
          'ref-y': 5,
          'text-anchor': 'middle',
          fill: '#000000',
          'font-family': 'Courier New',
          'font-size': 14,
        },
        '.uml-state-events': {
          ref: '.uml-state-separator',
          'ref-x': 5,
          'ref-y': 5,
          fill: '#000000',
          'font-family': 'Courier New',
          'font-size': 14,
        },
      },
      name: 'State',
      events: [],
    },
    {
      markup: [
        '<g class="rotatable">',
        '<g class="scalable">',
        '<rect class="uml-state-body"/>',
        '</g>',
        '<path class="uml-state-separator"/>',
        '<text class="uml-state-name"/>',
        '<text class="uml-state-events"/>',
        '</g>',
      ].join(''),
      initialize: function () {
        ;(this.on(
          {
            'change:name': this.updateName,
            'change:events': this.updateEvents,
            'change:size': this.updatePath,
          },
          this
        ),
          this.updateName(),
          this.updateEvents(),
          this.updatePath(),
          ke.prototype.initialize.apply(this, arguments))
      },
      updateName: function () {
        this.attr('.uml-state-name/text', this.get('name'))
      },
      updateEvents: function () {
        this.attr(
          '.uml-state-events/text',
          this.get('events').join(`
`)
        )
      },
      updatePath: function () {
        var t = 'M 0 20 L ' + this.get('size').width + ' 20'
        this.attr('.uml-state-separator/d', t, { silent: !0 })
      },
    }
  ),
  bz = Wm.define('uml.StartState', {
    type: 'uml.StartState',
    attrs: { circle: { fill: '#34495e', stroke: '#2c3e50', 'stroke-width': 2, rx: 1 } },
  }),
  Iz = ke.define(
    'uml.EndState',
    {
      size: { width: 20, height: 20 },
      attrs: {
        'circle.outer': {
          transform: 'translate(10, 10)',
          r: 10,
          fill: '#ffffff',
          stroke: '#2c3e50',
        },
        'circle.inner': { transform: 'translate(10, 10)', r: 6, fill: '#34495e' },
      },
    },
    {
      markup:
        '<g class="rotatable"><g class="scalable"><circle class="outer"/><circle class="inner"/></g></g>',
    }
  ),
  Cz = wn.define('uml.Transition', {
    attrs: {
      '.marker-target': { d: 'M 10 0 L 0 5 L 10 10 z', fill: '#34495e', stroke: '#2c3e50' },
      '.connection': { stroke: '#2c3e50' },
    },
  }),
  NS = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Abstract: gz,
        AbstractView: pz,
        Aggregation: wS,
        Association: SS,
        Class: Uu,
        ClassView: Qm,
        Composition: xS,
        EndState: Iz,
        Generalization: CS,
        Implementation: yz,
        Interface: vz,
        InterfaceView: mz,
        StartState: bz,
        State: Az,
        Transition: Cz,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  wz = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        basic: KO,
        chess: VL,
        devs: bL,
        erd: tz,
        fsa: az,
        logic: LL,
        org: lz,
        pn: dz,
        standard: vL,
        uml: NS,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function dI(t, e) {
  if (e === 0) return '0%'
  const n = 1e3
  return `${Math.round((t / e) * 100 * n) / n}%`
}
function TS(t) {
  return function (e, n, i, s) {
    var o = n.isNodeConnection(i) ? Sz : xz
    return o(t, e, n, i, s)
  }
}
function xz(t, e, n, i, s) {
  var o = n.model.angle(),
    u = n.getNodeUnrotatedBBox(i),
    c = n.model.getBBox().center()
  s.rotate(c, o)
  var h = s.x - u.x,
    p = s.y - u.y
  return (
    t && ((h = dI(h, u.width)), (p = dI(p, u.height))),
    (e.anchor = { name: 'topLeft', args: { dx: h, dy: p, rotate: !0 } }),
    e
  )
}
function Sz(t, e, n, i, s) {
  var o = n.getConnection()
  if (!o) return e
  var u = o.closestPointLength(s)
  if (t) {
    var c = o.length()
    e.anchor = { name: 'connectionRatio', args: { ratio: u / c } }
  } else e.anchor = { name: 'connectionLength', args: { length: u } }
  return e
}
const Nz = Ws,
  Tz = TS(!1),
  MS = TS(!0),
  Mz = Object.freeze(
    Object.defineProperty(
      { __proto__: null, pinAbsolute: Tz, pinRelative: MS, useDefaults: Nz },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
var gI = or.extend({
  tagName: 'circle',
  svgElement: !0,
  className: 'marker-vertex',
  events: {
    mousedown: 'onPointerDown',
    touchstart: 'onPointerDown',
    dblclick: 'onDoubleClick',
    dbltap: 'onDoubleClick',
  },
  documentEvents: {
    mousemove: 'onPointerMove',
    touchmove: 'onPointerMove',
    mouseup: 'onPointerUp',
    touchend: 'onPointerUp',
    touchcancel: 'onPointerUp',
  },
  attributes: { r: 6, fill: '#33334F', stroke: '#FFFFFF', 'stroke-width': 2, cursor: 'move' },
  position: function (t, e) {
    const { vel: n, options: i } = this,
      { scale: s } = i
    let o = yt.createSVGMatrix().translate(t, e)
    ;(s && (o = o.scale(s)), n.transform(o, { absolute: !0 }))
  },
  onPointerDown: function (t) {
    this.options.guard(t) ||
      (t.stopPropagation(),
      t.preventDefault(),
      this.options.paper.undelegateEvents(),
      this.delegateDocumentEvents(null, t.data),
      this.trigger('will-change', this, t))
  },
  onPointerMove: function (t) {
    this.trigger('changing', this, t)
  },
  onDoubleClick: function (t) {
    this.trigger('remove', this, t)
  },
  onPointerUp: function (t) {
    ;(this.trigger('changed', this, t),
      this.undelegateDocumentEvents(),
      this.options.paper.delegateEvents())
  },
})
const Ez = xa.extend(
  {
    name: 'vertices',
    options: {
      handleClass: gI,
      snapRadius: 20,
      redundancyRemoval: !0,
      vertexAdding: !0,
      stopPropagation: !0,
      scale: null,
    },
    children: [
      {
        tagName: 'path',
        selector: 'connection',
        className: 'joint-vertices-path',
        attributes: { fill: 'none', stroke: 'transparent', 'stroke-width': 10, cursor: 'cell' },
      },
    ],
    handles: null,
    events: {
      'mousedown .joint-vertices-path': 'onPathPointerDown',
      'touchstart .joint-vertices-path': 'onPathPointerDown',
    },
    onRender: function () {
      return (
        this.options.vertexAdding && (this.renderChildren(), this.updatePath()),
        this.resetHandles(),
        this.renderHandles(),
        this
      )
    },
    update: function () {
      var t = this.relatedView,
        e = t.model.vertices()
      return (
        e.length === this.handles.length
          ? this.updateHandles()
          : (this.resetHandles(), this.renderHandles()),
        this.options.vertexAdding && this.updatePath(),
        this
      )
    },
    resetHandles: function () {
      var t = this.handles
      if (((this.handles = []), this.stopListening(), !!Array.isArray(t)))
        for (var e = 0, n = t.length; e < n; e++) t[e].remove()
    },
    renderHandles: function () {
      for (var t = this.relatedView, e = t.model.vertices(), n = 0, i = e.length; n < i; n++) {
        var s = e[n],
          o = new this.options.handleClass({
            index: n,
            paper: this.paper,
            scale: this.options.scale,
            guard: u => this.guard(u),
          })
        ;(o.render(),
          o.position(s.x, s.y),
          this.simulateRelatedView(o.el),
          o.vel.appendTo(this.el),
          this.handles.push(o),
          this.startHandleListening(o))
      }
    },
    updateHandles: function () {
      for (var t = this.relatedView, e = t.model.vertices(), n = 0, i = e.length; n < i; n++) {
        var s = e[n],
          o = this.handles[n]
        if (!o) return
        o.position(s.x, s.y)
      }
    },
    updatePath: function () {
      var t = this.childNodes.connection
      t && t.setAttribute('d', this.relatedView.getSerializedConnection())
    },
    startHandleListening: function (t) {
      var e = this.relatedView
      ;(e.can('vertexMove') &&
        (this.listenTo(t, 'will-change', this.onHandleWillChange),
        this.listenTo(t, 'changing', this.onHandleChanging),
        this.listenTo(t, 'changed', this.onHandleChanged)),
        e.can('vertexRemove') && this.listenTo(t, 'remove', this.onHandleRemove))
    },
    getNeighborPoints: function (t) {
      var e = this.relatedView,
        n = e.model.vertices(),
        i = t > 0 ? n[t - 1] : e.sourceAnchor,
        s = t < n.length - 1 ? n[t + 1] : e.targetAnchor
      return { prev: new et(i), next: new et(s) }
    },
    onHandleWillChange: function (t, e) {
      this.focus()
      const { relatedView: n, options: i } = this
      ;(n.model.startBatch('vertex-move', { ui: !0, tool: this.cid }),
        i.stopPropagation || n.notifyPointerdown(...n.paper.getPointerArgs(e)))
    },
    onHandleChanging: function (t, e) {
      const { options: n, relatedView: i } = this
      var s = t.options.index,
        [o, u, c] = i.paper.getPointerArgs(e),
        h = { x: u, y: c }
      ;(this.snapVertex(h, s),
        i.model.vertex(s, h, { ui: !0, tool: this.cid }),
        t.position(h.x, h.y),
        n.stopPropagation || i.notifyPointermove(o, u, c))
    },
    onHandleChanged: function (t, e) {
      const { options: n, relatedView: i } = this
      if ((n.vertexAdding && this.updatePath(), !!n.redundancyRemoval)) {
        var s = i.removeRedundantLinearVertices({ ui: !0, tool: this.cid })
        ;(s && this.render(),
          this.blur(),
          i.model.stopBatch('vertex-move', { ui: !0, tool: this.cid }),
          this.eventData(e).vertexAdded &&
            i.model.stopBatch('vertex-add', { ui: !0, tool: this.cid }))
        var [o, u, c] = i.paper.getPointerArgs(e)
        ;(n.stopPropagation || i.notifyPointerup(o, u, c), i.checkMouseleave(o))
      }
    },
    snapVertex: function (t, e) {
      var n = this.options.snapRadius
      if (n > 0) {
        var i = this.getNeighborPoints(e),
          s = i.prev,
          o = i.next
        ;(Math.abs(t.x - s.x) < n ? (t.x = s.x) : Math.abs(t.x - o.x) < n && (t.x = o.x),
          Math.abs(t.y - s.y) < n ? (t.y = i.prev.y) : Math.abs(t.y - o.y) < n && (t.y = o.y))
      }
    },
    onHandleRemove: function (t, e) {
      var n = t.options.index,
        i = this.relatedView
      ;(i.model.removeVertex(n, { ui: !0 }),
        this.options.vertexAdding && this.updatePath(),
        i.checkMouseleave(Ge(e)))
    },
    onPathPointerDown: function (t) {
      if (!this.guard(t)) {
        ;(t.stopPropagation(), t.preventDefault())
        var e = Ge(t),
          n = this.paper.snapToGrid(e.clientX, e.clientY).toJSON(),
          i = this.relatedView
        i.model.startBatch('vertex-add', { ui: !0, tool: this.cid })
        var s = i.getVertexIndex(n.x, n.y)
        ;(this.snapVertex(n, s),
          i.model.insertVertex(s, n, { ui: !0, tool: this.cid }),
          this.update())
        var o = this.handles[s]
        ;(this.eventData(e, { vertexAdded: !0 }), o.onPointerDown(e))
      }
    },
    onRemove: function () {
      this.resetHandles()
    },
  },
  { VertexHandle: gI }
)
function fh(t, e) {
  const { model: n } = t
  return e ? n.getBBox() : n.isLink() ? t.getConnection().bbox() : t.getNodeUnrotatedBBox(t.el)
}
function ES(t, e, n) {
  var i = MS.call(this.paper, {}, e, n, t, this.model)
  return i.anchor
}
function Dz(t, e, n, i, s, o) {
  var u = o.options.snapRadius,
    c = i === 'source',
    h = c ? 0 : -1,
    p = this.model.vertex(h) || this.getEndAnchor(c ? 'target' : 'source')
  return (p && (Math.abs(p.x - t.x) < u && (t.x = p.x), Math.abs(p.y - t.y) < u && (t.y = p.y)), t)
}
var pI = or.extend({
  tagName: 'g',
  svgElement: !0,
  className: 'marker-segment',
  events: { mousedown: 'onPointerDown', touchstart: 'onPointerDown' },
  documentEvents: {
    mousemove: 'onPointerMove',
    touchmove: 'onPointerMove',
    mouseup: 'onPointerUp',
    touchend: 'onPointerUp',
    touchcancel: 'onPointerUp',
  },
  children: [
    {
      tagName: 'line',
      selector: 'line',
      attributes: { stroke: '#33334F', 'stroke-width': 2, fill: 'none', 'pointer-events': 'none' },
    },
    {
      tagName: 'rect',
      selector: 'handle',
      attributes: {
        width: 20,
        height: 8,
        x: -10,
        y: -4,
        rx: 4,
        ry: 4,
        fill: '#33334F',
        stroke: '#FFFFFF',
        'stroke-width': 2,
      },
    },
  ],
  onRender: function () {
    this.renderChildren()
  },
  position: function (t, e, n, i) {
    const { scale: s } = this.options
    let o = yt.createSVGMatrix().translate(t, e).rotate(n)
    s && (o = o.scale(s))
    var u = this.childNodes.handle
    ;(u.setAttribute('transform', yt.matrixToTransformString(o)),
      u.setAttribute('cursor', n % 180 === 0 ? 'row-resize' : 'col-resize'))
    var c = i.getClosestPoint(new et(t, e)),
      h = this.childNodes.line
    ;(h.setAttribute('x1', t),
      h.setAttribute('y1', e),
      h.setAttribute('x2', c.x),
      h.setAttribute('y2', c.y))
  },
  onPointerDown: function (t) {
    this.options.guard(t) ||
      (this.trigger('change:start', this, t),
      t.stopPropagation(),
      t.preventDefault(),
      this.options.paper.undelegateEvents(),
      this.delegateDocumentEvents(null, t.data))
  },
  onPointerMove: function (t) {
    this.trigger('changing', this, t)
  },
  onPointerUp: function (t) {
    ;(this.undelegateDocumentEvents(),
      this.options.paper.delegateEvents(),
      this.trigger('change:end', this, t))
  },
  show: function () {
    this.el.style.display = ''
  },
  hide: function () {
    this.el.style.display = 'none'
  },
})
const Oz = xa.extend(
    {
      name: 'segments',
      precision: 0.5,
      options: {
        handleClass: pI,
        segmentLengthThreshold: 40,
        redundancyRemoval: !0,
        anchor: ES,
        snapRadius: 10,
        snapHandle: !0,
        stopPropagation: !0,
      },
      handles: null,
      onRender: function () {
        this.resetHandles()
        var t = this.relatedView,
          e = t.model.vertices()
        ;(e.unshift(t.sourcePoint), e.push(t.targetPoint))
        for (var n = 0, i = e.length; n < i - 1; n++) {
          var s = e[n],
            o = e[n + 1],
            u = this.renderHandle(s, o)
          ;(this.simulateRelatedView(u.el), this.handles.push(u), (u.options.index = n))
        }
        return this
      },
      renderHandle: function (t, e) {
        var n = new this.options.handleClass({
          paper: this.paper,
          scale: this.options.scale,
          guard: i => this.guard(i),
        })
        return (
          n.render(),
          this.updateHandle(n, t, e),
          n.vel.appendTo(this.el),
          this.startHandleListening(n),
          n
        )
      },
      update: function () {
        return (this.render(), this)
      },
      startHandleListening: function (t) {
        ;(this.listenTo(t, 'change:start', this.onHandleChangeStart),
          this.listenTo(t, 'changing', this.onHandleChanging),
          this.listenTo(t, 'change:end', this.onHandleChangeEnd))
      },
      resetHandles: function () {
        var t = this.handles
        if (((this.handles = []), this.stopListening(), !!Array.isArray(t)))
          for (var e = 0, n = t.length; e < n; e++) t[e].remove()
      },
      shiftHandleIndexes: function (t) {
        for (var e = this.handles, n = 0, i = e.length; n < i; n++) e[n].options.index += t
      },
      resetAnchor: function (t, e) {
        var n = this.relatedView.model
        e
          ? n.prop([t, 'anchor'], e, { rewrite: !0, ui: !0, tool: this.cid })
          : n.removeProp([t, 'anchor'], { ui: !0, tool: this.cid })
      },
      snapHandle: function (t, e, n) {
        var i = t.options.index,
          s = this.relatedView,
          o = s.model,
          u = o.vertices(),
          c = t.options.axis,
          h = u[i - 2] || n.sourceAnchor,
          p = u[i + 1] || n.targetAnchor,
          y = this.options.snapRadius
        return (
          Math.abs(e[c] - h[c]) < y ? (e[c] = h[c]) : Math.abs(e[c] - p[c]) < y && (e[c] = p[c]),
          e
        )
      },
      onHandleChanging: function (t, e) {
        const { options: n } = this
        var i = this.eventData(e),
          s = this.relatedView,
          o = s.paper,
          u = t.options.index - 1,
          c = Ge(e),
          h = o.snapToGrid(c.clientX, c.clientY),
          p = this.snapHandle(t, h.clone(), i),
          y = t.options.axis,
          v = this.options.snapHandle ? 0 : h[y] - p[y],
          C = s.model,
          w = ti(C.vertices()),
          N = this.options.anchor
        typeof N != 'function' && (N = null)
        const T = t.options.index,
          z = [s.sourcePoint.clone(), ...w, s.targetPoint.clone()]
        let R = 0
        if (T - 1 >= 0) {
          const G = z[T - 1],
            Q = z[T]
          new Ut(G, Q).vector().theta() % 90 !== 0 &&
            (w.splice(T - 1, 0, i.originalVertices[T - 1]), R++, this.shiftHandleIndexes(1))
        }
        var B = w[u + R],
          H = w[u + 1 + R]
        if (T + 2 < z.length) {
          const G = z[T + 1],
            Q = z[T + 2]
          if (new Ut(G, Q).vector().theta() % 90 !== 0) {
            const st = i.originalVertices.length === 1,
              F = st ? 0 : T,
              ht = i.firstHandleShifted && !st ? 1 : 0
            let ct = 1 + R
            w.splice(T + ct, 0, i.originalVertices[F - ht])
          }
        }
        var Z = s.sourceView,
          U = s.sourceBBox,
          nt = !1,
          g = !1
        if (
          (B
            ? u === 0
              ? U.containsPoint(B)
                ? (w.shift(), this.shiftHandleIndexes(-1), (nt = !0))
                : ((B[y] = p[y]), (g = !0))
              : (B[y] = p[y])
            : ((B = s.sourceAnchor.toJSON()),
              (B[y] = p[y]),
              U.containsPoint(B)
                ? ((B[y] = p[y]), (nt = !0))
                : (w.unshift(B),
                  this.shiftHandleIndexes(1),
                  (i.firstHandleShifted = !0),
                  (g = !0))),
          N && Z)
        ) {
          if (nt) {
            var S = i.sourceAnchor.clone()
            S[y] = p[y]
            var M = N.call(s, S, Z, s.sourceMagnet || Z.el, 'source', s)
            this.resetAnchor('source', M)
          }
          g && this.resetAnchor('source', i.sourceAnchorDef)
        }
        var _ = s.targetView,
          W = s.targetBBox,
          $ = !1,
          X = !1
        if (
          (H
            ? u === w.length - 2
              ? W.containsPoint(H)
                ? (w.pop(), ($ = !0))
                : ((H[y] = p[y]), (X = !0))
              : (H[y] = p[y])
            : ((H = s.targetAnchor.toJSON()),
              (H[y] = p[y]),
              W.containsPoint(H) ? ($ = !0) : (w.push(H), (X = !0))),
          N && _)
        ) {
          if ($) {
            var Ct = i.targetAnchor.clone()
            Ct[y] = p[y]
            var Tt = N.call(s, Ct, _, s.targetMagnet || _.el, 'target', s)
            this.resetAnchor('target', Tt)
          }
          X && this.resetAnchor('target', i.targetAnchorDef)
        }
        if (w.some(G => !G)) throw new Error('Segments: incompatible router in use')
        ;(C.vertices(w, { ui: !0, tool: this.cid }),
          this.updateHandle(t, B, H, v),
          n.stopPropagation || s.notifyPointermove(c, h.x, h.y))
      },
      onHandleChangeStart: function (t, e) {
        const { options: n, handles: i, relatedView: s } = this,
          { model: o, paper: u } = s
        var c = t.options.index
        if (Array.isArray(i)) {
          for (var h = 0, p = i.length; h < p; h++) h !== c && i[h].hide()
          ;(this.focus(),
            this.eventData(e, {
              sourceAnchor: s.sourceAnchor.clone(),
              targetAnchor: s.targetAnchor.clone(),
              sourceAnchorDef: Bi(o.prop(['source', 'anchor'])),
              targetAnchorDef: Bi(o.prop(['target', 'anchor'])),
              originalVertices: ti(o.vertices()),
              firstHandleShifted: !1,
            }),
            o.startBatch('segment-move', { ui: !0, tool: this.cid }),
            n.stopPropagation || s.notifyPointerdown(...u.getPointerArgs(e)))
        }
      },
      onHandleChangeEnd: function (t, e) {
        const { options: n, relatedView: i } = this,
          { paper: s, model: o } = i
        n.redundancyRemoval && i.removeRedundantLinearVertices({ ui: !0, tool: this.cid })
        const u = Ge(e),
          c = s.snapToGrid(u.clientX, u.clientY)
        ;(this.render(),
          this.blur(),
          o.stopBatch('segment-move', { ui: !0, tool: this.cid }),
          n.stopPropagation || i.notifyPointerup(u, c.x, c.y),
          i.checkMouseleave(u))
      },
      updateHandle: function (t, e, n, i) {
        var s = Math.abs(e.x - n.x) < this.precision,
          o = Math.abs(e.y - n.y) < this.precision
        if (s || o) {
          var u = new Ut(e, n),
            c = u.length()
          if (c < this.options.segmentLengthThreshold) t.hide()
          else {
            var h = u.midpoint(),
              p = s ? 'x' : 'y'
            h[p] += i || 0
            var y = u.vector().vectorAngle(new et(1, 0))
            ;(t.position(h.x, h.y, y, this.relatedView), t.show(), (t.options.axis = p))
          }
        } else t.hide()
      },
      onRemove: function () {
        this.resetHandles()
      },
    },
    { SegmentHandle: pI }
  ),
  DS = xa.extend({
    tagName: 'path',
    xAxisVector: new et(1, 0),
    events: { mousedown: 'onPointerDown', touchstart: 'onPointerDown' },
    documentEvents: {
      mousemove: 'onPointerMove',
      touchmove: 'onPointerMove',
      mouseup: 'onPointerUp',
      touchend: 'onPointerUp',
      touchcancel: 'onPointerUp',
    },
    options: { scale: null },
    onRender: function () {
      this.update()
    },
    update: function () {
      var t = this.ratio,
        e = this.relatedView,
        n = e.getTangentAtRatio(t),
        i,
        s
      if (
        (n
          ? ((i = n.start), (s = n.vector().vectorAngle(this.xAxisVector) || 0))
          : ((i = e.getPointAtRatio(t)), (s = 0)),
        !i)
      )
        return this
      var o = yt.createSVGMatrix().translate(i.x, i.y).rotate(s)
      const { scale: u } = this.options
      return (u && (o = o.scale(u)), this.vel.transform(o, { absolute: !0 }), this)
    },
    onPointerDown: function (t) {
      if (!this.guard(t)) {
        ;(t.stopPropagation(), t.preventDefault())
        var e = this.relatedView
        ;(e.model.startBatch('arrowhead-move', { ui: !0, tool: this.cid }),
          e.can('arrowheadMove') &&
            (e.startArrowheadMove(this.arrowheadType),
            this.delegateDocumentEvents(),
            e.paper.undelegateEvents()),
          this.focus(),
          (this.el.style.pointerEvents = 'none'))
      }
    },
    onPointerMove: function (t) {
      var e = Ge(t),
        n = this.paper.snapToGrid(e.clientX, e.clientY)
      this.relatedView.pointermove(e, n.x, n.y)
    },
    onPointerUp: function (t) {
      this.undelegateDocumentEvents()
      var e = this.relatedView,
        n = e.paper,
        i = Ge(t),
        s = n.snapToGrid(i.clientX, i.clientY)
      ;(e.pointerup(i, s.x, s.y),
        n.delegateEvents(),
        this.blur(),
        (this.el.style.pointerEvents = ''),
        e.model.stopBatch('arrowhead-move', { ui: !0, tool: this.cid }))
    },
  }),
  Lz = DS.extend({
    name: 'target-arrowhead',
    ratio: 1,
    arrowheadType: 'target',
    attributes: {
      d: 'M -10 -8 10 0 -10 8 Z',
      fill: '#33334F',
      stroke: '#FFFFFF',
      'stroke-width': 2,
      cursor: 'move',
      class: 'target-arrowhead',
    },
  }),
  zz = DS.extend({
    name: 'source-arrowhead',
    ratio: 0,
    arrowheadType: 'source',
    attributes: {
      d: 'M 10 -8 -10 0 10 8 Z',
      fill: '#33334F',
      stroke: '#FFFFFF',
      'stroke-width': 2,
      cursor: 'move',
      class: 'source-arrowhead',
    },
  }),
  OS = xa.extend({
    name: 'boundary',
    tagName: 'rect',
    options: { padding: 10, useModelGeometry: !1 },
    attributes: {
      fill: 'none',
      stroke: '#33334F',
      'stroke-width': 0.5,
      'stroke-dasharray': '5, 5',
      'pointer-events': 'none',
    },
    onRender: function () {
      this.update()
    },
    update: function () {
      const { relatedView: t, options: e, vel: n } = this,
        { useModelGeometry: i, rotate: s } = e,
        o = Ia(e.padding)
      let u = fh(t, i).moveAndExpand({
        x: -o.left,
        y: -o.top,
        width: o.left + o.right,
        height: o.top + o.bottom,
      })
      var c = t.model
      if (c.isElement()) {
        var h = c.angle()
        if (h)
          if (s) {
            var p = c.getBBox().center()
            n.rotate(h, p.x, p.y, { absolute: !0 })
          } else u = u.bbox(h)
      }
      return (n.attr(u.toJSON()), this)
    },
  }),
  LS = xa.extend({
    tagName: 'g',
    type: null,
    children: [
      { tagName: 'circle', selector: 'anchor', attributes: { cursor: 'pointer' } },
      {
        tagName: 'rect',
        selector: 'area',
        attributes: {
          'pointer-events': 'none',
          fill: 'none',
          stroke: '#33334F',
          'stroke-dasharray': '2,4',
          rx: 5,
          ry: 5,
        },
      },
    ],
    events: {
      mousedown: 'onPointerDown',
      touchstart: 'onPointerDown',
      dblclick: 'onPointerDblClick',
      dbltap: 'onPointerDblClick',
    },
    documentEvents: {
      mousemove: 'onPointerMove',
      touchmove: 'onPointerMove',
      mouseup: 'onPointerUp',
      touchend: 'onPointerUp',
      touchcancel: 'onPointerUp',
    },
    options: {
      snap: Dz,
      anchor: ES,
      scale: null,
      resetAnchor: !0,
      customAnchorAttributes: { 'stroke-width': 4, stroke: '#33334F', fill: '#FFFFFF', r: 5 },
      defaultAnchorAttributes: { 'stroke-width': 2, stroke: '#FFFFFF', fill: '#33334F', r: 6 },
      areaPadding: 6,
      snapRadius: 10,
      restrictArea: !0,
      redundancyRemoval: !0,
    },
    onRender: function () {
      ;(this.renderChildren(), this.toggleArea(!1), this.update())
    },
    update: function () {
      var t = this.type,
        e = this.relatedView,
        n = e.getEndView(t)
      return (
        n
          ? (this.updateAnchor(), this.updateArea(), (this.el.style.display = ''))
          : (this.el.style.display = 'none'),
        this
      )
    },
    updateAnchor: function () {
      var t = this.childNodes
      if (!t) return
      var e = t.anchor
      if (!e) return
      var n = this.relatedView,
        i = this.type,
        s = n.getEndAnchor(i),
        o = this.options,
        u = n.model.prop([i, 'anchor'])
      let c = `translate(${s.x},${s.y})`
      ;(o.scale && (c += ` scale(${o.scale})`), e.setAttribute('transform', c))
      var h = u ? o.customAnchorAttributes : o.defaultAnchorAttributes
      for (var p in h) e.setAttribute(p, h[p])
    },
    updateArea: function () {
      var t = this.childNodes
      if (t) {
        var e = t.area
        if (e) {
          var n = this.relatedView,
            i = this.type,
            s = n.getEndView(i),
            o = s.model,
            u = n.getEndMagnet(i),
            c = this.options.areaPadding
          isFinite(c) || (c = 0)
          var h, p, y
          ;(s.isNodeConnection(u)
            ? ((h = s.getNodeBBox(u)), (p = 0), (y = h.center()))
            : ((h = s.getNodeUnrotatedBBox(u)),
              (p = o.angle()),
              (y = h.center()),
              p && y.rotate(o.getBBox().center(), -p)),
            h.inflate(c),
            e.setAttribute('x', -h.width / 2),
            e.setAttribute('y', -h.height / 2),
            e.setAttribute('width', h.width),
            e.setAttribute('height', h.height),
            e.setAttribute('transform', 'translate(' + y.x + ',' + y.y + ') rotate(' + p + ')'))
        }
      }
    },
    toggleArea: function (t) {
      var e = this.childNodes
      if (e) {
        var n = e.area
        n && (n.style.display = t ? '' : 'none')
      }
    },
    onPointerDown: function (t) {
      this.guard(t) ||
        (t.stopPropagation(),
        t.preventDefault(),
        this.paper.undelegateEvents(),
        this.delegateDocumentEvents(),
        this.focus(),
        this.toggleArea(this.options.restrictArea),
        this.relatedView.model.startBatch('anchor-move', { ui: !0, tool: this.cid }))
    },
    resetAnchor: function (t) {
      var e = this.type,
        n = this.relatedView.model
      t
        ? n.prop([e, 'anchor'], t, { rewrite: !0, ui: !0, tool: this.cid })
        : n.removeProp([e, 'anchor'], { ui: !0, tool: this.cid })
    },
    onPointerMove: function (t) {
      var e = this.relatedView,
        n = this.type,
        i = e.getEndView(n),
        s = i.model,
        o = e.getEndMagnet(n),
        u = Ge(t),
        c = this.paper.clientToLocalPoint(u.clientX, u.clientY),
        h = this.options.snap
      if (
        (typeof h == 'function' && ((c = h.call(e, c, i, o, n, e, this)), (c = new et(c))),
        this.options.restrictArea)
      )
        if (i.isNodeConnection(o)) {
          var p = i.getClosestPoint(c)
          p && (c = p)
        } else {
          var y = i.getNodeUnrotatedBBox(o),
            v = s.angle(),
            C = s.getBBox().center(),
            w = c.clone().rotate(C, v)
          y.containsPoint(w) || (c = y.pointNearestToPoint(w).rotate(C, -v))
        }
      var N,
        T = this.options.anchor
      ;(typeof T == 'function' && (N = T.call(e, c, i, o, n, e)),
        this.resetAnchor(N),
        this.update())
    },
    onPointerUp: function (t) {
      const e = Ge(t)
      ;(this.paper.delegateEvents(),
        this.undelegateDocumentEvents(),
        this.blur(),
        this.toggleArea(!1))
      var n = this.relatedView
      ;(this.options.redundancyRemoval &&
        n.removeRedundantLinearVertices({ ui: !0, tool: this.cid }),
        n.checkMouseleave(e),
        n.model.stopBatch('anchor-move', { ui: !0, tool: this.cid }))
    },
    onPointerDblClick: function () {
      var t = this.options.resetAnchor
      t !== !1 && (t === !0 && (t = null), this.resetAnchor(ti(t)), this.update())
    },
  }),
  Rz = LS.extend({ name: 'source-anchor', type: 'source' }),
  kz = LS.extend({ name: 'target-anchor', type: 'target' }),
  Ph = xa.extend({
    name: 'button',
    events: { mousedown: 'onPointerDown', touchstart: 'onPointerDown' },
    options: { distance: 0, offset: 0, scale: null, rotate: !1 },
    onRender: function () {
      ;(this.renderChildren(this.options.markup), this.update())
    },
    update: function () {
      return (this.position(), this)
    },
    position: function () {
      const { vel: t } = this
      t.transform(this.getCellMatrix(), { absolute: !0 })
    },
    getCellMatrix() {
      return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix()
    },
    getElementMatrix() {
      const { relatedView: t, options: e } = this
      let { x: n = 0, y: i = 0, offset: s = {}, useModelGeometry: o, rotate: u, scale: c } = e,
        h = fh(t, o)
      const p = t.model.angle()
      u || (h = h.bbox(p))
      const { x: y = 0, y: v = 0 } = s
      ;(Dn(n) ? (n = (parseFloat(n) / 100) * h.width) : Gi(n) && (n = Number(Zi(n, h))),
        Dn(i) ? (i = (parseFloat(i) / 100) * h.height) : Gi(i) && (i = Number(Zi(i, h))))
      let C = yt.createSVGMatrix().translate(h.x + h.width / 2, h.y + h.height / 2)
      return (
        u && (C = C.rotate(p)),
        (C = C.translate(n + y - h.width / 2, i + v - h.height / 2)),
        c && (C = C.scale(c)),
        C
      )
    },
    getLinkMatrix() {
      const { relatedView: t, options: e } = this,
        { offset: n = 0, distance: i = 0, rotate: s, scale: o } = e
      let u, c, h
      ;(Dn(i) ? (u = t.getTangentAtRatio(parseFloat(i) / 100)) : (u = t.getTangentAtLength(i)),
        u
          ? ((c = u.start), (h = u.vector().vectorAngle(new et(1, 0)) || 0))
          : ((c = t.getConnection().start), (h = 0)))
      let p = yt.createSVGMatrix().translate(c.x, c.y).rotate(h).translate(0, n)
      return (s || (p = p.rotate(-h)), o && (p = p.scale(o)), p)
    },
    onPointerDown: function (t) {
      if (!this.guard(t)) {
        ;(t.stopPropagation(), t.preventDefault())
        var e = this.options.action
        typeof e == 'function' && e.call(this.relatedView, t, this.relatedView, this)
      }
    },
  }),
  zS = Ph.extend({
    children: [
      {
        tagName: 'circle',
        selector: 'button',
        attributes: { r: 7, fill: '#FF1D00', cursor: 'pointer' },
      },
      {
        tagName: 'path',
        selector: 'icon',
        attributes: {
          d: 'M -3 -3 3 3 M -3 3 3 -3',
          fill: 'none',
          stroke: '#FFFFFF',
          'stroke-width': 2,
          'pointer-events': 'none',
        },
      },
    ],
    options: {
      distance: 60,
      offset: 0,
      action: function (t, e, n) {
        e.model.remove({ ui: !0, tool: n.cid })
      },
    },
  }),
  Ou = Ph.extend({
    name: 'connect',
    documentEvents: {
      mousemove: 'drag',
      touchmove: 'drag',
      mouseup: 'dragend',
      touchend: 'dragend',
      touchcancel: 'dragend',
    },
    children: [
      {
        tagName: 'circle',
        selector: 'button',
        attributes: { r: 7, fill: '#333333', cursor: 'pointer' },
      },
      {
        tagName: 'path',
        selector: 'icon',
        attributes: {
          d: 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',
          fill: '#FFFFFF',
          stroke: 'none',
          'stroke-width': 2,
          'pointer-events': 'none',
        },
      },
    ],
    options: { distance: 80, offset: 0, magnet: t => t.el, action: (t, e, n) => n.dragstart(t) },
    getMagnetNode: function () {
      const { options: t, relatedView: e } = this,
        { magnet: n } = t
      let i
      switch (typeof n) {
        case 'function': {
          i = n.call(this, e, this)
          break
        }
        case 'string': {
          ;[i] = e.findBySelector(n)
          break
        }
        default: {
          i = n
          break
        }
      }
      if ((i || (i = e.el), i instanceof SVGElement)) return i
      throw new Error('Connect: magnet must be an SVGElement')
    },
    dragstart: function (t) {
      const { paper: e, relatedView: n } = this,
        i = Ge(t),
        { x: s, y: o } = e.clientToLocalPoint(i.clientX, i.clientY)
      ;(n.dragLinkStart(i, this.getMagnetNode(), s, o),
        e.undelegateEvents(),
        this.delegateDocumentEvents(null, i.data),
        this.focus())
    },
    drag: function (t) {
      const { paper: e, relatedView: n } = this,
        i = Ge(t),
        { x: s, y: o } = e.snapToGrid(i.clientX, i.clientY)
      n.dragLink(i, s, o)
    },
    dragend: function (t) {
      const { paper: e, relatedView: n } = this,
        i = Ge(t),
        { x: s, y: o } = e.snapToGrid(i.clientX, i.clientY)
      ;(n.dragLinkEnd(i, s, o),
        this.undelegateDocumentEvents(),
        e.delegateEvents(),
        this.blur(),
        n.checkMouseleave(i))
    },
  }),
  RS = Ou.extend({
    name: 'hover-connect',
    defaultMarkup: [
      { tagName: 'circle', attributes: { r: 7, fill: '#333333', cursor: 'pointer' } },
      {
        tagName: 'path',
        attributes: {
          d: 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',
          fill: '#FFFFFF',
          stroke: 'none',
          'stroke-width': 2,
        },
      },
    ],
    children() {
      const { options: t, defaultMarkup: e } = this
      return [
        {
          tagName: 'path',
          selector: 'track',
          attributes: {
            fill: 'none',
            stroke: 'transparent',
            'stroke-width': t.trackWidth || 15,
            cursor: 'pointer',
          },
        },
        {
          tagName: 'g',
          selector: 'button',
          attributes: { 'pointer-events': 'none', display: 'none' },
          children: t.markup || e,
        },
      ]
    },
    events: Object.assign(
      { mousemove: 'onMousemove', mouseenter: 'onMouseenter', mouseleave: 'onMouseleave' },
      Ou.prototype.events
    ),
    onRender: function () {
      ;(this.renderChildren(), this.update())
    },
    trackPath: null,
    update() {
      const { childNodes: t } = this
      ;((this.trackPath = this.getTrackPath()),
        Ou.prototype.update.apply(this, arguments),
        t.track.setAttribute('d', this.trackPath.serialize()))
    },
    position() {
      const { el: t, childNodes: e } = this
      ;(e.button.setAttribute('transform', yt.matrixToTransformString(this.getButtonMatrix())),
        t.setAttribute('transform', yt.matrixToTransformString(this.getTrackMatrix())))
    },
    getButtonMatrix() {
      const { options: t, trackPath: e } = this,
        { offset: n = 0, distance: i = 0, rotate: s, scale: o } = t
      let u, c, h
      ;(Dn(i) ? (u = e.tangentAtRatio(parseFloat(i) / 100)) : (u = e.tangentAtLength(i)),
        u
          ? ((c = u.start), (h = u.vector().vectorAngle(new et(1, 0)) || 0))
          : ((c = e.start), (h = 0)))
      let p = yt.createSVGMatrix().translate(c.x, c.y).rotate(h).translate(0, n)
      return (s || (p = p.rotate(-h)), o && (p = p.scale(o)), p)
    },
    getTrackPath() {
      return this.relatedView.getConnection()
    },
    getTrackMatrix() {
      return yt.createSVGMatrix()
    },
    getTrackRatioFromEvent(t) {
      const { relatedView: e, trackPath: n } = this,
        i = e.paper.clientToLocalPoint(t.clientX, t.clientY),
        s = yt.transformPoint(i, this.getTrackMatrix().inverse())
      return n.closestPointLength(s)
    },
    canShowButton() {
      return Ie._data(this.paper.el, 'events')
    },
    showButton() {
      this.childNodes.button.style.display = 'block'
    },
    hideButton() {
      this.childNodes.button.style.display = ''
    },
    onMousemove(t) {
      const { trackPath: e } = this
      if (!e) return
      const { options: n } = this
      ;((n.distance = this.getTrackRatioFromEvent(t)), this.position())
    },
    onMouseenter() {
      this.canShowButton() && this.showButton()
    },
    onMouseleave() {
      this.hideButton()
    },
  }),
  _z = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Boundary: OS,
        Button: Ph,
        Connect: Ou,
        HoverConnect: RS,
        Remove: zS,
        Segments: Oz,
        SourceAnchor: Rz,
        SourceArrowhead: zz,
        TargetAnchor: kz,
        TargetArrowhead: Lz,
        Vertices: Ez,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Bz = xa.extend({
    tagName: 'g',
    children: [
      {
        tagName: 'circle',
        selector: 'handle',
        attributes: {
          cursor: 'pointer',
          'stroke-width': 2,
          stroke: '#FFFFFF',
          fill: '#33334F',
          r: 6,
        },
      },
      {
        tagName: 'rect',
        selector: 'extras',
        attributes: {
          'pointer-events': 'none',
          fill: 'none',
          stroke: '#33334F',
          'stroke-dasharray': '2,4',
          rx: 5,
          ry: 5,
        },
      },
    ],
    events: {
      mousedown: 'onPointerDown',
      touchstart: 'onPointerDown',
      dblclick: 'onPointerDblClick',
      dbltap: 'onPointerDblClick',
    },
    documentEvents: {
      mousemove: 'onPointerMove',
      touchmove: 'onPointerMove',
      mouseup: 'onPointerUp',
      touchend: 'onPointerUp',
      touchcancel: 'onPointerUp',
    },
    options: { handleAttributes: null, selector: 'root', padding: 6, scale: null },
    getPosition: function () {},
    setPosition: function () {},
    resetPosition: function () {},
    onRender: function () {
      ;(this.renderChildren(), this.toggleExtras(!1), this.update())
    },
    update: function () {
      const { handle: t, extras: e } = this.childNodes
      if (t) this.updateHandle(t)
      else throw new Error('Control: markup selector `handle` is required')
      return (e && this.updateExtras(e), this)
    },
    updateHandle: function (t) {
      const { relatedView: e, options: n } = this,
        { model: i } = e,
        s = this.getPosition(e, this),
        o = i.getAbsolutePointFromRelative(s),
        { handleAttributes: u, scale: c } = n
      let h = `translate(${o.x},${o.y})`
      if ((c && (h += ` scale(${c})`), t.setAttribute('transform', h), u))
        for (let p in u) t.setAttribute(p, u[p])
    },
    updateExtras: function (t) {
      const { relatedView: e, options: n } = this,
        { selector: i } = this.options
      if (!i) {
        this.toggleExtras(!1)
        return
      }
      const [s] = e.findBySelector(i)
      if (!s) throw new Error('Control: invalid selector.')
      let o = n.padding
      isFinite(o) || (o = 0)
      const u = e.getNodeUnrotatedBBox(s),
        c = e.model,
        h = c.angle(),
        p = u.center()
      ;(h && p.rotate(c.getBBox().center(), -h),
        u.inflate(o),
        t.setAttribute('x', -u.width / 2),
        t.setAttribute('y', -u.height / 2),
        t.setAttribute('width', u.width),
        t.setAttribute('height', u.height),
        t.setAttribute('transform', `translate(${p.x},${p.y}) rotate(${h})`))
    },
    toggleExtras: function (t) {
      const { extras: e } = this.childNodes
      e && (e.style.display = t ? '' : 'none')
    },
    onPointerDown: function (t) {
      const { relatedView: e, paper: n } = this
      this.guard(t) ||
        (t.stopPropagation(),
        t.preventDefault(),
        n.undelegateEvents(),
        this.delegateDocumentEvents(),
        this.focus(),
        this.toggleExtras(!0),
        e.model.startBatch('control-move', { ui: !0, tool: this.cid }))
    },
    onPointerMove: function (t) {
      const { relatedView: e, paper: n } = this,
        { model: i } = e,
        { clientX: s, clientY: o } = Ge(t),
        u = n.clientToLocalPoint(s, o),
        c = i.getRelativePointFromAbsolute(u)
      ;(this.setPosition(e, c, this), this.update())
    },
    onPointerUp: function (t) {
      const { relatedView: e, paper: n } = this
      ;(n.delegateEvents(),
        this.undelegateDocumentEvents(),
        this.blur(),
        this.toggleExtras(!1),
        e.model.stopBatch('control-move', { ui: !0, tool: this.cid }))
    },
    onPointerDblClick: function () {
      const { relatedView: t } = this
      ;(this.resetPosition(t, this), this.update())
    },
  }),
  jz = RS.extend({
    getTrackPath() {
      const { relatedView: t, options: e } = this
      let { useModelGeometry: n, trackPath: i = 'M 0 0 H calc(w) V calc(h) H 0 Z' } = e
      if ((typeof i == 'function' && (i = i.call(this, t)), Gi(i))) {
        const s = fh(t, n)
        i = Zi(i, s)
      }
      return new Jt(yt.normalizePathData(i))
    },
    getTrackMatrix() {
      const { relatedView: t, options: e } = this
      let { useModelGeometry: n, rotate: i } = e,
        s = fh(t, n)
      const o = t.model.angle()
      i || (s = s.bbox(o))
      let u = yt.createSVGMatrix().translate(s.x + s.width / 2, s.y + s.height / 2)
      return (i && (u = u.rotate(o)), (u = u.translate(-s.width / 2, -s.height / 2)), u)
    },
  }),
  Pz = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Boundary: OS,
        Button: Ph,
        Connect: Ou,
        Control: Bz,
        HoverConnect: jz,
        Remove: zS,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
var Gz = '3.7.7'
const Zz = yt,
  Uz = function (t, e) {
    ;((e = e || {}), Ui(ya, 'setTheme', t, e), (or.prototype.defaultTheme = t))
  },
  Yz = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        V: yt,
        Vectorizer: Zz,
        anchors: pS,
        config: Yi,
        connectionPoints: gS,
        connectionStrategies: Mz,
        connectors: lS,
        dia: GO,
        elementTools: Pz,
        env: Xm,
        g: $C,
        highlighters: uS,
        layout: ZO,
        linkAnchors: hS,
        linkTools: _z,
        mvc: $E,
        routers: oS,
        setTheme: Uz,
        shapes: wz,
        util: ME,
        version: Gz,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Hz = ce.forwardRef(function ({ onSelectionChanged: e, onLocalPatch: n, onReady: i }, s) {
    const o = ce.useRef(null),
      u = ce.useRef(null),
      c = ce.useRef(null),
      h = ce.useRef({ linkMode: null, fromElement: null, selected: null, mute: !1 }),
      p = ce.useRef({ onLocalPatch: n, onSelectionChanged: e })
    ;(ce.useEffect(() => {
      p.current.onLocalPatch = n
    }, [n]),
      ce.useEffect(() => {
        p.current.onSelectionChanged = e
      }, [e]),
      ce.useEffect(() => {
        let w = !0
        const N = o.current
        if (N)
          return (
            (async () => {
              try {
                ;((window.joint = Yz),
                  await xT(() => import('./joint.shapes.uml-BQxaorXZ.js').then(U => U.j), []))
              } catch (U) {
                console.error('No se pudo cargar joint.shapes.uml:', U)
              }
              const T = new Vr()
              u.current = T
              const z = N.clientWidth || 800,
                R = N.clientHeight || 600,
                B = new vS({
                  el: N,
                  model: T,
                  width: z,
                  height: R,
                  gridSize: 10,
                  drawGrid: !0,
                  background: { color: '#f7f7fb' },
                  interactive: !0,
                })
              ;((c.current = B), (window.__graph = u.current), (window.__paper = c.current))
              const H = new ResizeObserver(U => {
                for (const nt of U) {
                  const g = nt.contentRect
                  c.current?.setDimensions(
                    Math.max(300, Math.floor(g.width)),
                    Math.max(300, Math.floor(g.height))
                  )
                }
              })
              ;(H.observe(N),
                B.on('element:pointerdown', U => {
                  const nt = h.current,
                    g = U.model
                  if (nt.linkMode) {
                    if (!nt.fromElement) {
                      nt.fromElement = g
                      return
                    }
                    const S = nt.fromElement,
                      M = g
                    if (S.id === M.id && nt.linkMode !== 'association') {
                      ;((nt.linkMode = null), (nt.fromElement = null))
                      return
                    }
                    const { link: W, data: $ } = vI(nt.linkMode, S, M)
                    ;(W &&
                      (T.addCell(W),
                      p.current.onLocalPatch?.({
                        t: 'addLink',
                        id: W.id,
                        linkType: $.linkType,
                        source: $.source,
                        target: $.target,
                        labels: $.labels,
                      })),
                      (nt.linkMode = null),
                      (nt.fromElement = null))
                    return
                  }
                  ;((nt.selected = g), _i(p.current.onSelectionChanged, h.current))
                }),
                B.on('link:pointerdown', U => {
                  const nt = U.model
                  ;(console.log('link type:', nt.get('type'), nt.attributes),
                    (h.current.selected = nt),
                    _i(p.current.onSelectionChanged, h.current))
                }),
                T.on('remove', U => {
                  h.current.mute ||
                    (U.isLink && U.isLink() && p.current.onLocalPatch?.({ t: 'delLink', id: U.id }))
                }),
                T.on('change:source change:target', U => {
                  if (h.current.mute || !(U.isLink && U.isLink())) return
                  const nt = U.get('source')?.id || null,
                    g = U.get('target')?.id || null
                  p.current.onLocalPatch?.({ t: 'relink', id: U.id, source: nt, target: g })
                }),
                T.on('change:vertices', U => {
                  h.current.mute ||
                    !(U.isLink && U.isLink()) ||
                    p.current.onLocalPatch?.({
                      t: 'linkVerts',
                      id: U.id,
                      vertices: U.vertices() || [],
                    })
                }))
              const Z = new Map()
              return (
                T.on('change:position', U => {
                  if (!h.current.mute && U.isElement && U.isElement()) {
                    const nt = performance.now(),
                      g = Z.get(U.id) || 0
                    if (nt - g < 40) return
                    Z.set(U.id, nt)
                    const S = U.position()
                    p.current.onLocalPatch?.({ t: 'move', id: U.id, x: S.x, y: S.y })
                  }
                }),
                i?.(),
                () => {
                  w && (H.disconnect(), c.current?.remove())
                }
              )
            })(),
            () => {
              w = !1
            }
          )
      }, []))
    function y(w) {
      h.current.mute = !0
      try {
        w()
      } finally {
        h.current.mute = !1
      }
    }
    function v(w) {
      if (!u.current) return null
      const N = !!NS && !!Uu,
        T = w?.id || crypto?.randomUUID?.() || String(Date.now()),
        z = w?.name || 'NuevaClase',
        R = Number.isFinite(w?.x) ? w.x : 80 + Math.random() * 200,
        B = Number.isFinite(w?.y) ? w.y : 80 + Math.random() * 120
      let H
      if (N) {
        const Z = Uu
        H = new Z({
          id: T,
          position: { x: R, y: B },
          size: { width: 220, height: 120 },
          name: z,
          attributes: ['+ id: Long'],
          methods: [],
        })
      } else
        ((H = new yS({ id: T })),
          H.resize(220, 120),
          H.position(R, B),
          H.attr({ label: { text: z, fontWeight: '600' }, body: { stroke: '#111', fill: '#fff' } }),
          H.set('type', 'uml.Class'),
          H.set('name', z),
          H.set('attributes', ['+ id: Long']))
      return (
        u.current.addCell(H),
        (h.current.selected = H),
        _i(p.current.onSelectionChanged, h.current),
        { id: H.id, x: R, y: B, name: H.get('name') }
      )
    }
    function C(w, N, T) {
      if (w.get('type') !== 'uml.Association') return
      const z = w.labels() || []
      ;(z[0] ||
        w.appendLabel({
          attrs: { text: { text: '1' }, rect: { fill: 'white' } },
          position: { distance: 35, offset: -10 },
        }),
        z[1] ||
          w.appendLabel({
            attrs: { text: { text: '0..*' }, rect: { fill: 'white' } },
            position: { distance: -35, offset: 10 },
          }),
        w.label(N, { attrs: { text: { text: T || '' }, rect: { fill: 'white' } } }))
    }
    return (
      ce.useImperativeHandle(s, () => ({
        clear() {
          ;(u.current?.clear(),
            (h.current = { linkMode: null, fromElement: null, selected: null, mute: !1 }),
            p.current.onSelectionChanged?.(null))
        },
        addClass(w) {
          return v(w)
        },
        setLinkMode(w) {
          ;((h.current.linkMode = w), (h.current.fromElement = null))
        },
        addAttributeToSelected() {
          const w = h.current.selected
          if (!w || w.get('type') !== 'uml.Class') return
          const N = [...(w.get('attributes') || []), '+ nuevo: String']
          ;(w.set('attributes', N), _i(p.current.onSelectionChanged, h.current))
        },
        renameSelected(w) {
          const N = h.current.selected
          !N ||
            N.get('type') !== 'uml.Class' ||
            (N.set('name', w), _i(p.current.onSelectionChanged, h.current))
        },
        updateAttributeOfSelected(w, N) {
          const T = h.current.selected
          if (!T || T.get('type') !== 'uml.Class') return
          const z = [...(T.get('attributes') || [])]
          ;((z[w] = N), T.set('attributes', z), _i(p.current.onSelectionChanged, h.current))
        },
        removeAttributeOfSelected(w) {
          const N = h.current.selected
          if (!N || N.get('type') !== 'uml.Class') return
          const T = [...(N.get('attributes') || [])]
          ;(T.splice(w, 1), N.set('attributes', T), _i(p.current.onSelectionChanged, h.current))
        },
        deleteSelected() {
          const w = h.current.selected
          w &&
            (w.isElement &&
              w.isElement() &&
              (u.current.getConnectedLinks(w) || []).forEach(T => T.remove()),
            w.remove(),
            (h.current.selected = null),
            p.current.onSelectionChanged?.(null))
        },
        getGraphJSON() {
          return u.current.toJSON()
        },
        loadFromJSON(w) {
          ;(y(() => {
            u.current.fromJSON(w)
          }),
            p.current.onSelectionChanged?.(null))
        },
        updateMultiplicity(w, N) {
          const T = h.current.selected
          !T ||
            !T.isLink() ||
            T.get('type') !== 'uml.Association' ||
            (C(T, w, N), _i(e, h.current), n?.({ t: 'setMult', id: T.id, index: w, value: N }))
        },
        applyPatch(w) {
          if (!w || !u.current) return
          const N = w.t,
            T = z => u.current.getCell(z)
          switch (N) {
            case 'addClass':
              return T(w.id) ? void 0 : y(() => v({ id: w.id, name: w.name, x: w.x, y: w.y }))
            case 'delClass': {
              const z = T(w.id)
              if (!z) return
              ;(y(() => {
                ;(z.isElement &&
                  z.isElement() &&
                  (u.current.getConnectedLinks(z) || []).forEach(B => B.remove()),
                  z.remove())
              }),
                h.current.selected?.id === w.id && p.current.onSelectionChanged?.(null))
              return
            }
            case 'delLink': {
              const z = T(w.id)
              z &&
                z.isLink &&
                z.isLink() &&
                (y(() => z.remove()), h.current.selected?.id === w.id && e?.(null))
              return
            }
            case 'relink': {
              const z = T(w.id)
              if (!z || !z.isLink || !z.isLink()) return
              y(() => {
                ;(w.source && z.set('source', { id: w.source }),
                  w.target && z.set('target', { id: w.target }))
              })
              return
            }
            case 'linkVerts': {
              const z = T(w.id)
              if (!z || !z.isLink || !z.isLink()) return
              y(() => z.set('vertices', w.vertices || []))
              return
            }
            case 'rename': {
              const z = T(w.id)
              z &&
                z.get('type') === 'uml.Class' &&
                (z.set('name', w.name || z.get('name')),
                h.current.selected?.id === z.id && _i(p.current.onSelectionChanged, h.current))
              return
            }
            case 'move': {
              const z = T(w.id)
              z && z.isElement && z.isElement() && y(() => z.position(w.x, w.y))
              return
            }
            case 'addLink': {
              if (T(w.id)) return
              const z = T(w.source),
                R = T(w.target)
              if (!z || !R) return
              y(() => {
                const { link: B } = vI(w.linkType, z, R, w.id, w.labels)
                B && u.current.addCell(B)
              })
              return
            }
            case 'setMult': {
              const z = T(w.id)
              if (!z || !z.isLink()) return
              ;(y(() => C(z, w.index, w.value)),
                h.current.selected?.id === z.id && _i(p.current.onSelectionChanged, h.current))
              return
            }
            case 'addAttr': {
              const z = T(w.id)
              if (z && z.get('type') === 'uml.Class') {
                const R = [...(z.get('attributes') || [])]
                ;(R.push(w.value),
                  z.set('attributes', R),
                  h.current.selected?.id === z.id && _i(p.current.onSelectionChanged, h.current))
              }
              return
            }
            case 'updAttr': {
              const z = T(w.id)
              if (z && z.get('type') === 'uml.Class') {
                const R = [...(z.get('attributes') || [])]
                R[w.index] !== void 0 &&
                  ((R[w.index] = w.value),
                  z.set('attributes', R),
                  h.current.selected?.id === z.id && _i(p.current.onSelectionChanged, h.current))
              }
              return
            }
            case 'delAttr': {
              const z = T(w.id)
              if (z && z.get('type') === 'uml.Class') {
                const R = [...(z.get('attributes') || [])]
                R[w.index] !== void 0 &&
                  (R.splice(w.index, 1),
                  z.set('attributes', R),
                  h.current.selected?.id === z.id && _i(p.current.onSelectionChanged, h.current))
              }
              return
            }
            default:
              return
          }
        },
      })),
      Gt.jsx('div', { className: 'canvas', ref: o })
    )
  })
function vI(t, e, n, i, s = ['1', '0..*']) {
  const o = String(t || '')
      .toLowerCase()
      .replace(/^uml\./, '')
      .replace(/^custom\./, ''),
    u = { id: e.id },
    c = { id: n.id }
  let h, p
  if (o === 'association') {
    if (((p = 'uml.Association'), (h = new SS({ id: i, source: u, target: c })), e.id === n.id)) {
      const y = e.getBBox(),
        v = y.x + y.width + 40,
        C = y.y + y.height / 2
      h.set('vertices', [{ x: v, y: C }])
    }
    ;(h.appendLabel({
      attrs: { text: { text: s[0] ?? '1' }, rect: { fill: 'white' } },
      position: { distance: 35, offset: -10 },
    }),
      h.appendLabel({
        attrs: { text: { text: s[1] ?? '0..*' }, rect: { fill: 'white' } },
        position: { distance: -35, offset: 10 },
      }))
  } else if (o === 'aggregation')
    ((p = 'uml.Aggregation'), (h = new wS({ id: i, source: u, target: c })))
  else if (o === 'composition')
    ((p = 'uml.Composition'), (h = new xS({ id: i, source: u, target: c })))
  else if (o === 'generalization')
    ((p = 'uml.Generalization'), (h = new CS({ id: i, source: u, target: c })))
  else if (o === 'dependency')
    ((p = 'custom.Dependency'),
      (h = new wn({ id: i, type: 'custom.Dependency', source: u, target: c })),
      h.attr({
        '.connection': { 'stroke-dasharray': '6 4', 'stroke-width': 1.5, stroke: '#000' },
        '.marker-target': { d: 'M 8 -4 0 0 8 4', fill: 'none', stroke: '#000' },
      }))
  else if (o === 'realization')
    ((p = 'custom.Realization'),
      (h = new AS({ id: i, type: 'custom.Realization', source: u, target: c })),
      h.attr({
        line: {
          strokeDasharray: '6 4',
          strokeWidth: 1.5,
          stroke: '#000',
          targetMarker: { type: 'path', d: 'M 12 0 0 -7 0 7 z', fill: 'white', stroke: '#000' },
        },
      }))
  else return { link: null, data: null }
  return {
    link: h,
    data: {
      linkType: p,
      source: e.id,
      target: n.id,
      labels: p === 'uml.Association' ? [s[0] ?? '1', s[1] ?? '0..*'] : void 0,
    },
  }
}
function _i(t, e) {
  const n = e.selected
  if (!n) {
    t?.(null)
    return
  }
  if (n.isLink && n.isLink()) {
    const i = n.get('type')
    if (i === 'uml.Association') {
      const s = n.labels() || [],
        o = s[0]?.attrs?.text?.text || '1',
        u = s[1]?.attrs?.text?.text || '0..*'
      t?.({ id: n.id, type: i, isLink: !0, multSource: o, multTarget: u })
    } else t?.({ id: n.id, type: i, isLink: !0 })
    return
  }
  t?.({ id: n.id, type: n.get('type'), name: n.get('name'), attributes: n.get('attributes') || [] })
}
function Vz(t, e) {
  const n = new Blob([JSON.stringify(e, null, 2)], { type: 'application/json' }),
    i = URL.createObjectURL(n),
    s = document.createElement('a')
  ;((s.href = i),
    (s.download = t),
    document.body.appendChild(s),
    s.click(),
    s.remove(),
    URL.revokeObjectURL(i))
}
const Xz = {
  long: 'LONG',
  int: 'INT',
  integer: 'INT',
  bool: 'BOOLEAN',
  boolean: 'BOOLEAN',
  decimal: 'DECIMAL',
  bigdecimal: 'DECIMAL',
  localdate: 'LOCAL_DATE',
  date: 'LOCAL_DATE',
  localdatetime: 'LOCAL_DATE_TIME',
  datetime: 'LOCAL_DATE_TIME',
  string: 'STRING',
  text: 'STRING',
}
function Wz(t) {
  const e = String(t).trim().toLowerCase()
  return Xz[e] || 'STRING'
}
function Fz(t) {
  if (!t) return null
  const n = String(t)
    .trim()
    .replace(/^(\+|-|#)\s*/, '')
    .split(':')
  let i = n[0]?.trim(),
    s = n[1]?.trim() || ''
  if (!i) return null
  let o = s,
    u = ''
  const c = s.indexOf(' ')
  c !== -1 && ((o = s.slice(0, c).trim()), (u = s.slice(c + 1).trim()))
  const h = { name: i, type: Wz(o || 'STRING') }
  return (
    u &&
      u.split(/\s+/).forEach(p => {
        const [y, v] = p.split('=')
        ;(y?.toLowerCase() === 'pk' && (h.pk = !0),
          y?.toLowerCase() === 'generated' && v && (h.generated = v.toUpperCase()))
      }),
    h
  )
}
function mI(t, e = {}) {
  const {
      name: n = 'generated-app',
      version: i = '0.0.1',
      packageBase: s = 'com.jezabel.generated',
    } = e,
    o = t?.cells || [],
    u = [],
    c = new Map()
  for (const y of o) {
    if ((y.type || y.attrs?.type) !== 'uml.Class') continue
    const w = (y.name || y.attrs?.label?.text || 'Unnamed').replace(/\W+/g, '')
    c.set(y.id, w)
    const N = y.attributes || y.attrs?.attributes || [],
      T = []
    for (const z of N) {
      const R = Fz(z)
      R && T.push(R)
    }
    if (!T.some(z => z.pk)) {
      const z = T.find(R => R.name?.toLowerCase() === 'id')
      z && ((z.pk = !0), z.generated || (z.generated = 'IDENTITY'))
    }
    u.push({ name: w, attributes: T })
  }
  const h = [],
    p = new Set()
  for (const y of o) {
    const v = String(y.type || '').toLowerCase()
    if (!!!(y.source && y.target)) continue
    const w = v.replace(/^uml\./, '').replace(/^custom\./, '')
    if (
      ![
        'association',
        'aggregation',
        'composition',
        'generalization',
        'dependency',
        'realization',
      ].includes(w)
    )
      continue
    const N = c.get(y.source?.id),
      T = c.get(y.target?.id)
    if (!N || !T) continue
    let z, R
    if (w === 'association') {
      const H = y.labels || []
      ;((z = H[0]?.attrs?.text?.text || '1'), (R = H[1]?.attrs?.text?.text || '0..*'))
    }
    const B = `${w}|${N}|${T}|${z || ''}|${R || ''}`
    p.has(B) ||
      (p.add(B),
      h.push({
        type: w,
        source: N,
        target: T,
        ...(w === 'association' ? { multSource: z, multTarget: R } : {}),
      }))
  }
  return { name: n, version: i, packageBase: s, entities: u, relations: h }
}
function Jz(t, e) {
  t.terminate = function () {
    const n = () => {}
    ;((this.onerror = n), (this.onmessage = n), (this.onopen = n))
    const i = new Date(),
      s = Math.random().toString().substring(2, 8),
      o = this.onclose
    ;((this.onclose = u => {
      const c = new Date().getTime() - i.getTime()
      e(`Discarded socket (#${s})  closed after ${c}ms, with code/reason: ${u.code}/${u.reason}`)
    }),
      this.close(),
      o?.call(t, {
        code: 4001,
        reason: `Quick discarding socket (#${s}) without waiting for the shutdown sequence.`,
        wasClean: !1,
      }))
  }
}
const Mu = {
  LF: `
`,
  NULL: '\0',
}
class os {
  get body() {
    return (
      !this._body && this.isBinaryBody && (this._body = new TextDecoder().decode(this._binaryBody)),
      this._body || ''
    )
  }
  get binaryBody() {
    return (
      !this._binaryBody &&
        !this.isBinaryBody &&
        (this._binaryBody = new TextEncoder().encode(this._body)),
      this._binaryBody
    )
  }
  constructor(e) {
    const {
      command: n,
      headers: i,
      body: s,
      binaryBody: o,
      escapeHeaderValues: u,
      skipContentLengthHeader: c,
    } = e
    ;((this.command = n),
      (this.headers = Object.assign({}, i || {})),
      o
        ? ((this._binaryBody = o), (this.isBinaryBody = !0))
        : ((this._body = s || ''), (this.isBinaryBody = !1)),
      (this.escapeHeaderValues = u || !1),
      (this.skipContentLengthHeader = c || !1))
  }
  static fromRawFrame(e, n) {
    const i = {},
      s = o => o.replace(/^\s+|\s+$/g, '')
    for (const o of e.headers.reverse()) {
      o.indexOf(':')
      const u = s(o[0])
      let c = s(o[1])
      ;(n && e.command !== 'CONNECT' && e.command !== 'CONNECTED' && (c = os.hdrValueUnEscape(c)),
        (i[u] = c))
    }
    return new os({
      command: e.command,
      headers: i,
      binaryBody: e.binaryBody,
      escapeHeaderValues: n,
    })
  }
  toString() {
    return this.serializeCmdAndHeaders()
  }
  serialize() {
    const e = this.serializeCmdAndHeaders()
    return this.isBinaryBody
      ? os.toUnit8Array(e, this._binaryBody).buffer
      : e + this._body + Mu.NULL
  }
  serializeCmdAndHeaders() {
    const e = [this.command]
    this.skipContentLengthHeader && delete this.headers['content-length']
    for (const n of Object.keys(this.headers || {})) {
      const i = this.headers[n]
      this.escapeHeaderValues && this.command !== 'CONNECT' && this.command !== 'CONNECTED'
        ? e.push(`${n}:${os.hdrValueEscape(`${i}`)}`)
        : e.push(`${n}:${i}`)
    }
    return (
      (this.isBinaryBody || (!this.isBodyEmpty() && !this.skipContentLengthHeader)) &&
        e.push(`content-length:${this.bodyLength()}`),
      e.join(Mu.LF) + Mu.LF + Mu.LF
    )
  }
  isBodyEmpty() {
    return this.bodyLength() === 0
  }
  bodyLength() {
    const e = this.binaryBody
    return e ? e.length : 0
  }
  static sizeOfUTF8(e) {
    return e ? new TextEncoder().encode(e).length : 0
  }
  static toUnit8Array(e, n) {
    const i = new TextEncoder().encode(e),
      s = new Uint8Array([0]),
      o = new Uint8Array(i.length + n.length + s.length)
    return (o.set(i), o.set(n, i.length), o.set(s, i.length + n.length), o)
  }
  static marshall(e) {
    return new os(e).serialize()
  }
  static hdrValueEscape(e) {
    return e.replace(/\\/g, '\\\\').replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/:/g, '\\c')
  }
  static hdrValueUnEscape(e) {
    return e
      .replace(/\\r/g, '\r')
      .replace(
        /\\n/g,
        `
`
      )
      .replace(/\\c/g, ':')
      .replace(/\\\\/g, '\\')
  }
}
const yI = 0,
  Bf = 10,
  jf = 13,
  qz = 58
class Qz {
  constructor(e, n) {
    ;((this.onFrame = e),
      (this.onIncomingPing = n),
      (this._encoder = new TextEncoder()),
      (this._decoder = new TextDecoder()),
      (this._token = []),
      this._initState())
  }
  parseChunk(e, n = !1) {
    let i
    if (
      (typeof e == 'string' ? (i = this._encoder.encode(e)) : (i = new Uint8Array(e)),
      n && i[i.length - 1] !== 0)
    ) {
      const s = new Uint8Array(i.length + 1)
      ;(s.set(i, 0), (s[i.length] = 0), (i = s))
    }
    for (let s = 0; s < i.length; s++) {
      const o = i[s]
      this._onByte(o)
    }
  }
  _collectFrame(e) {
    if (e !== yI && e !== jf) {
      if (e === Bf) {
        this.onIncomingPing()
        return
      }
      ;((this._onByte = this._collectCommand), this._reinjectByte(e))
    }
  }
  _collectCommand(e) {
    if (e !== jf) {
      if (e === Bf) {
        ;((this._results.command = this._consumeTokenAsUTF8()),
          (this._onByte = this._collectHeaders))
        return
      }
      this._consumeByte(e)
    }
  }
  _collectHeaders(e) {
    if (e !== jf) {
      if (e === Bf) {
        this._setupCollectBody()
        return
      }
      ;((this._onByte = this._collectHeaderKey), this._reinjectByte(e))
    }
  }
  _reinjectByte(e) {
    this._onByte(e)
  }
  _collectHeaderKey(e) {
    if (e === qz) {
      ;((this._headerKey = this._consumeTokenAsUTF8()), (this._onByte = this._collectHeaderValue))
      return
    }
    this._consumeByte(e)
  }
  _collectHeaderValue(e) {
    if (e !== jf) {
      if (e === Bf) {
        ;(this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]),
          (this._headerKey = void 0),
          (this._onByte = this._collectHeaders))
        return
      }
      this._consumeByte(e)
    }
  }
  _setupCollectBody() {
    const e = this._results.headers.filter(n => n[0] === 'content-length')[0]
    e
      ? ((this._bodyBytesRemaining = parseInt(e[1], 10)),
        (this._onByte = this._collectBodyFixedSize))
      : (this._onByte = this._collectBodyNullTerminated)
  }
  _collectBodyNullTerminated(e) {
    if (e === yI) {
      this._retrievedBody()
      return
    }
    this._consumeByte(e)
  }
  _collectBodyFixedSize(e) {
    if (this._bodyBytesRemaining-- === 0) {
      this._retrievedBody()
      return
    }
    this._consumeByte(e)
  }
  _retrievedBody() {
    this._results.binaryBody = this._consumeTokenAsRaw()
    try {
      this.onFrame(this._results)
    } catch (e) {
      console.log('Ignoring an exception thrown by a frame handler. Original exception: ', e)
    }
    this._initState()
  }
  _consumeByte(e) {
    this._token.push(e)
  }
  _consumeTokenAsUTF8() {
    return this._decoder.decode(this._consumeTokenAsRaw())
  }
  _consumeTokenAsRaw() {
    const e = new Uint8Array(this._token)
    return ((this._token = []), e)
  }
  _initState() {
    ;((this._results = { command: void 0, headers: [], binaryBody: void 0 }),
      (this._token = []),
      (this._headerKey = void 0),
      (this._onByte = this._collectFrame))
  }
}
var ls
;(function (t) {
  ;((t[(t.CONNECTING = 0)] = 'CONNECTING'),
    (t[(t.OPEN = 1)] = 'OPEN'),
    (t[(t.CLOSING = 2)] = 'CLOSING'),
    (t[(t.CLOSED = 3)] = 'CLOSED'))
})(ls || (ls = {}))
var Tr
;(function (t) {
  ;((t[(t.ACTIVE = 0)] = 'ACTIVE'),
    (t[(t.DEACTIVATING = 1)] = 'DEACTIVATING'),
    (t[(t.INACTIVE = 2)] = 'INACTIVE'))
})(Tr || (Tr = {}))
var hh
;(function (t) {
  ;((t[(t.LINEAR = 0)] = 'LINEAR'), (t[(t.EXPONENTIAL = 1)] = 'EXPONENTIAL'))
})(hh || (hh = {}))
var Yu
;(function (t) {
  ;((t.Interval = 'interval'), (t.Worker = 'worker'))
})(Yu || (Yu = {}))
class Kz {
  constructor(e, n = Yu.Interval, i) {
    ;((this._interval = e),
      (this._strategy = n),
      (this._debug = i),
      (this._workerScript = `
    var startTime = Date.now();
    setInterval(function() {
        self.postMessage(Date.now() - startTime);
    }, ${this._interval});
  `))
  }
  start(e) {
    ;(this.stop(), this.shouldUseWorker() ? this.runWorker(e) : this.runInterval(e))
  }
  stop() {
    ;(this.disposeWorker(), this.disposeInterval())
  }
  shouldUseWorker() {
    return typeof Worker < 'u' && this._strategy === Yu.Worker
  }
  runWorker(e) {
    ;(this._debug('Using runWorker for outgoing pings'),
      this._worker ||
        ((this._worker = new Worker(
          URL.createObjectURL(new Blob([this._workerScript], { type: 'text/javascript' }))
        )),
        (this._worker.onmessage = n => e(n.data))))
  }
  runInterval(e) {
    if ((this._debug('Using runInterval for outgoing pings'), !this._timer)) {
      const n = Date.now()
      this._timer = setInterval(() => {
        e(Date.now() - n)
      }, this._interval)
    }
  }
  disposeWorker() {
    this._worker &&
      (this._worker.terminate(), delete this._worker, this._debug('Outgoing ping disposeWorker'))
  }
  disposeInterval() {
    this._timer &&
      (clearInterval(this._timer), delete this._timer, this._debug('Outgoing ping disposeInterval'))
  }
}
class oi {
  constructor(e) {
    this.versions = e
  }
  supportedVersions() {
    return this.versions.join(',')
  }
  protocolVersions() {
    return this.versions.map(e => `v${e.replace('.', '')}.stomp`)
  }
}
oi.V1_0 = '1.0'
oi.V1_1 = '1.1'
oi.V1_2 = '1.2'
oi.default = new oi([oi.V1_2, oi.V1_1, oi.V1_0])
class $z {
  get connectedVersion() {
    return this._connectedVersion
  }
  get connected() {
    return this._connected
  }
  constructor(e, n, i) {
    ;((this._client = e),
      (this._webSocket = n),
      (this._connected = !1),
      (this._serverFrameHandlers = {
        CONNECTED: s => {
          ;(this.debug(`connected to server ${s.headers.server}`),
            (this._connected = !0),
            (this._connectedVersion = s.headers.version),
            this._connectedVersion === oi.V1_2 && (this._escapeHeaderValues = !0),
            this._setupHeartbeat(s.headers),
            this.onConnect(s))
        },
        MESSAGE: s => {
          const o = s.headers.subscription,
            u = this._subscriptions[o] || this.onUnhandledMessage,
            c = s,
            h = this,
            p = this._connectedVersion === oi.V1_2 ? c.headers.ack : c.headers['message-id']
          ;((c.ack = (y = {}) => h.ack(p, o, y)), (c.nack = (y = {}) => h.nack(p, o, y)), u(c))
        },
        RECEIPT: s => {
          const o = this._receiptWatchers[s.headers['receipt-id']]
          o
            ? (o(s), delete this._receiptWatchers[s.headers['receipt-id']])
            : this.onUnhandledReceipt(s)
        },
        ERROR: s => {
          this.onStompError(s)
        },
      }),
      (this._counter = 0),
      (this._subscriptions = {}),
      (this._receiptWatchers = {}),
      (this._partialData = ''),
      (this._escapeHeaderValues = !1),
      (this._lastServerActivityTS = Date.now()),
      (this.debug = i.debug),
      (this.stompVersions = i.stompVersions),
      (this.connectHeaders = i.connectHeaders),
      (this.disconnectHeaders = i.disconnectHeaders),
      (this.heartbeatIncoming = i.heartbeatIncoming),
      (this.heartbeatToleranceMultiplier = i.heartbeatGracePeriods),
      (this.heartbeatOutgoing = i.heartbeatOutgoing),
      (this.splitLargeFrames = i.splitLargeFrames),
      (this.maxWebSocketChunkSize = i.maxWebSocketChunkSize),
      (this.forceBinaryWSFrames = i.forceBinaryWSFrames),
      (this.logRawCommunication = i.logRawCommunication),
      (this.appendMissingNULLonIncoming = i.appendMissingNULLonIncoming),
      (this.discardWebsocketOnCommFailure = i.discardWebsocketOnCommFailure),
      (this.onConnect = i.onConnect),
      (this.onDisconnect = i.onDisconnect),
      (this.onStompError = i.onStompError),
      (this.onWebSocketClose = i.onWebSocketClose),
      (this.onWebSocketError = i.onWebSocketError),
      (this.onUnhandledMessage = i.onUnhandledMessage),
      (this.onUnhandledReceipt = i.onUnhandledReceipt),
      (this.onUnhandledFrame = i.onUnhandledFrame),
      (this.onHeartbeatReceived = i.onHeartbeatReceived),
      (this.onHeartbeatLost = i.onHeartbeatLost))
  }
  start() {
    const e = new Qz(
      n => {
        const i = os.fromRawFrame(n, this._escapeHeaderValues)
        ;(this.logRawCommunication || this.debug(`<<< ${i}`),
          (this._serverFrameHandlers[i.command] || this.onUnhandledFrame)(i))
      },
      () => {
        ;(this.debug('<<< PONG'), this.onHeartbeatReceived())
      }
    )
    ;((this._webSocket.onmessage = n => {
      if (
        (this.debug('Received data'),
        (this._lastServerActivityTS = Date.now()),
        this.logRawCommunication)
      ) {
        const i = n.data instanceof ArrayBuffer ? new TextDecoder().decode(n.data) : n.data
        this.debug(`<<< ${i}`)
      }
      e.parseChunk(n.data, this.appendMissingNULLonIncoming)
    }),
      (this._webSocket.onclose = n => {
        ;(this.debug(`Connection closed to ${this._webSocket.url}`),
          this._cleanUp(),
          this.onWebSocketClose(n))
      }),
      (this._webSocket.onerror = n => {
        this.onWebSocketError(n)
      }),
      (this._webSocket.onopen = () => {
        const n = Object.assign({}, this.connectHeaders)
        ;(this.debug('Web Socket Opened...'),
          (n['accept-version'] = this.stompVersions.supportedVersions()),
          (n['heart-beat'] = [this.heartbeatOutgoing, this.heartbeatIncoming].join(',')),
          this._transmit({ command: 'CONNECT', headers: n }))
      }))
  }
  _setupHeartbeat(e) {
    if ((e.version !== oi.V1_1 && e.version !== oi.V1_2) || !e['heart-beat']) return
    const [n, i] = e['heart-beat'].split(',').map(s => parseInt(s, 10))
    if (this.heartbeatOutgoing !== 0 && i !== 0) {
      const s = Math.max(this.heartbeatOutgoing, i)
      ;(this.debug(`send PING every ${s}ms`),
        (this._pinger = new Kz(s, this._client.heartbeatStrategy, this.debug)),
        this._pinger.start(() => {
          this._webSocket.readyState === ls.OPEN &&
            (this._webSocket.send(Mu.LF), this.debug('>>> PING'))
        }))
    }
    if (this.heartbeatIncoming !== 0 && n !== 0) {
      const s = Math.max(this.heartbeatIncoming, n)
      ;(this.debug(`check PONG every ${s}ms`),
        (this._ponger = setInterval(() => {
          const o = Date.now() - this._lastServerActivityTS
          o > s * this.heartbeatToleranceMultiplier &&
            (this.debug(`did not receive server activity for the last ${o}ms`),
            this.onHeartbeatLost(),
            this._closeOrDiscardWebsocket())
        }, s)))
    }
  }
  _closeOrDiscardWebsocket() {
    this.discardWebsocketOnCommFailure
      ? (this.debug('Discarding websocket, the underlying socket may linger for a while'),
        this.discardWebsocket())
      : (this.debug('Issuing close on the websocket'), this._closeWebsocket())
  }
  forceDisconnect() {
    this._webSocket &&
      (this._webSocket.readyState === ls.CONNECTING || this._webSocket.readyState === ls.OPEN) &&
      this._closeOrDiscardWebsocket()
  }
  _closeWebsocket() {
    ;((this._webSocket.onmessage = () => {}), this._webSocket.close())
  }
  discardWebsocket() {
    ;(typeof this._webSocket.terminate != 'function' && Jz(this._webSocket, e => this.debug(e)),
      this._webSocket.terminate())
  }
  _transmit(e) {
    const { command: n, headers: i, body: s, binaryBody: o, skipContentLengthHeader: u } = e,
      c = new os({
        command: n,
        headers: i,
        body: s,
        binaryBody: o,
        escapeHeaderValues: this._escapeHeaderValues,
        skipContentLengthHeader: u,
      })
    let h = c.serialize()
    if (
      (this.logRawCommunication ? this.debug(`>>> ${h}`) : this.debug(`>>> ${c}`),
      this.forceBinaryWSFrames && typeof h == 'string' && (h = new TextEncoder().encode(h)),
      typeof h != 'string' || !this.splitLargeFrames)
    )
      this._webSocket.send(h)
    else {
      let p = h
      for (; p.length > 0; ) {
        const y = p.substring(0, this.maxWebSocketChunkSize)
        ;((p = p.substring(this.maxWebSocketChunkSize)),
          this._webSocket.send(y),
          this.debug(`chunk sent = ${y.length}, remaining = ${p.length}`))
      }
    }
  }
  dispose() {
    if (this.connected)
      try {
        const e = Object.assign({}, this.disconnectHeaders)
        ;(e.receipt || (e.receipt = `close-${this._counter++}`),
          this.watchForReceipt(e.receipt, n => {
            ;(this._closeWebsocket(), this._cleanUp(), this.onDisconnect(n))
          }),
          this._transmit({ command: 'DISCONNECT', headers: e }))
      } catch (e) {
        this.debug(`Ignoring error during disconnect ${e}`)
      }
    else
      (this._webSocket.readyState === ls.CONNECTING || this._webSocket.readyState === ls.OPEN) &&
        this._closeWebsocket()
  }
  _cleanUp() {
    ;((this._connected = !1),
      this._pinger && (this._pinger.stop(), (this._pinger = void 0)),
      this._ponger && (clearInterval(this._ponger), (this._ponger = void 0)))
  }
  publish(e) {
    const { destination: n, headers: i, body: s, binaryBody: o, skipContentLengthHeader: u } = e,
      c = Object.assign({ destination: n }, i)
    this._transmit({
      command: 'SEND',
      headers: c,
      body: s,
      binaryBody: o,
      skipContentLengthHeader: u,
    })
  }
  watchForReceipt(e, n) {
    this._receiptWatchers[e] = n
  }
  subscribe(e, n, i = {}) {
    ;((i = Object.assign({}, i)),
      i.id || (i.id = `sub-${this._counter++}`),
      (i.destination = e),
      (this._subscriptions[i.id] = n),
      this._transmit({ command: 'SUBSCRIBE', headers: i }))
    const s = this
    return {
      id: i.id,
      unsubscribe(o) {
        return s.unsubscribe(i.id, o)
      },
    }
  }
  unsubscribe(e, n = {}) {
    ;((n = Object.assign({}, n)),
      delete this._subscriptions[e],
      (n.id = e),
      this._transmit({ command: 'UNSUBSCRIBE', headers: n }))
  }
  begin(e) {
    const n = e || `tx-${this._counter++}`
    this._transmit({ command: 'BEGIN', headers: { transaction: n } })
    const i = this
    return {
      id: n,
      commit() {
        i.commit(n)
      },
      abort() {
        i.abort(n)
      },
    }
  }
  commit(e) {
    this._transmit({ command: 'COMMIT', headers: { transaction: e } })
  }
  abort(e) {
    this._transmit({ command: 'ABORT', headers: { transaction: e } })
  }
  ack(e, n, i = {}) {
    ;((i = Object.assign({}, i)),
      this._connectedVersion === oi.V1_2 ? (i.id = e) : (i['message-id'] = e),
      (i.subscription = n),
      this._transmit({ command: 'ACK', headers: i }))
  }
  nack(e, n, i = {}) {
    return (
      (i = Object.assign({}, i)),
      this._connectedVersion === oi.V1_2 ? (i.id = e) : (i['message-id'] = e),
      (i.subscription = n),
      this._transmit({ command: 'NACK', headers: i })
    )
  }
}
class t2 {
  get webSocket() {
    return this._stompHandler?._webSocket
  }
  get disconnectHeaders() {
    return this._disconnectHeaders
  }
  set disconnectHeaders(e) {
    ;((this._disconnectHeaders = e),
      this._stompHandler && (this._stompHandler.disconnectHeaders = this._disconnectHeaders))
  }
  get connected() {
    return !!this._stompHandler && this._stompHandler.connected
  }
  get connectedVersion() {
    return this._stompHandler ? this._stompHandler.connectedVersion : void 0
  }
  get active() {
    return this.state === Tr.ACTIVE
  }
  _changeState(e) {
    ;((this.state = e), this.onChangeState(e))
  }
  constructor(e = {}) {
    ;((this.stompVersions = oi.default),
      (this.connectionTimeout = 0),
      (this.reconnectDelay = 5e3),
      (this._nextReconnectDelay = 0),
      (this.maxReconnectDelay = 900 * 1e3),
      (this.reconnectTimeMode = hh.LINEAR),
      (this.heartbeatIncoming = 1e4),
      (this.heartbeatToleranceMultiplier = 2),
      (this.heartbeatOutgoing = 1e4),
      (this.heartbeatStrategy = Yu.Interval),
      (this.splitLargeFrames = !1),
      (this.maxWebSocketChunkSize = 8 * 1024),
      (this.forceBinaryWSFrames = !1),
      (this.appendMissingNULLonIncoming = !1),
      (this.discardWebsocketOnCommFailure = !1),
      (this.state = Tr.INACTIVE))
    const n = () => {}
    ;((this.debug = n),
      (this.beforeConnect = n),
      (this.onConnect = n),
      (this.onDisconnect = n),
      (this.onUnhandledMessage = n),
      (this.onUnhandledReceipt = n),
      (this.onUnhandledFrame = n),
      (this.onHeartbeatReceived = n),
      (this.onHeartbeatLost = n),
      (this.onStompError = n),
      (this.onWebSocketClose = n),
      (this.onWebSocketError = n),
      (this.logRawCommunication = !1),
      (this.onChangeState = n),
      (this.connectHeaders = {}),
      (this._disconnectHeaders = {}),
      this.configure(e))
  }
  configure(e) {
    ;(Object.assign(this, e),
      this.maxReconnectDelay > 0 &&
        this.maxReconnectDelay < this.reconnectDelay &&
        (this.debug(
          `Warning: maxReconnectDelay (${this.maxReconnectDelay}ms) is less than reconnectDelay (${this.reconnectDelay}ms). Using reconnectDelay as the maxReconnectDelay delay.`
        ),
        (this.maxReconnectDelay = this.reconnectDelay)))
  }
  activate() {
    const e = () => {
      if (this.active) {
        this.debug('Already ACTIVE, ignoring request to activate')
        return
      }
      ;(this._changeState(Tr.ACTIVE),
        (this._nextReconnectDelay = this.reconnectDelay),
        this._connect())
    }
    this.state === Tr.DEACTIVATING
      ? (this.debug('Waiting for deactivation to finish before activating'),
        this.deactivate().then(() => {
          e()
        }))
      : e()
  }
  async _connect() {
    if ((await this.beforeConnect(this), this._stompHandler)) {
      this.debug('There is already a stompHandler, skipping the call to connect')
      return
    }
    if (!this.active) {
      this.debug('Client has been marked inactive, will not attempt to connect')
      return
    }
    ;(this.connectionTimeout > 0 &&
      (this._connectionWatcher && clearTimeout(this._connectionWatcher),
      (this._connectionWatcher = setTimeout(() => {
        this.connected ||
          (this.debug(`Connection not established in ${this.connectionTimeout}ms, closing socket`),
          this.forceDisconnect())
      }, this.connectionTimeout))),
      this.debug('Opening Web Socket...'))
    const e = this._createWebSocket()
    ;((this._stompHandler = new $z(this, e, {
      debug: this.debug,
      stompVersions: this.stompVersions,
      connectHeaders: this.connectHeaders,
      disconnectHeaders: this._disconnectHeaders,
      heartbeatIncoming: this.heartbeatIncoming,
      heartbeatGracePeriods: this.heartbeatToleranceMultiplier,
      heartbeatOutgoing: this.heartbeatOutgoing,
      heartbeatStrategy: this.heartbeatStrategy,
      splitLargeFrames: this.splitLargeFrames,
      maxWebSocketChunkSize: this.maxWebSocketChunkSize,
      forceBinaryWSFrames: this.forceBinaryWSFrames,
      logRawCommunication: this.logRawCommunication,
      appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,
      discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure,
      onConnect: n => {
        if (
          (this._connectionWatcher &&
            (clearTimeout(this._connectionWatcher), (this._connectionWatcher = void 0)),
          !this.active)
        ) {
          ;(this.debug('STOMP got connected while deactivate was issued, will disconnect now'),
            this._disposeStompHandler())
          return
        }
        this.onConnect(n)
      },
      onDisconnect: n => {
        this.onDisconnect(n)
      },
      onStompError: n => {
        this.onStompError(n)
      },
      onWebSocketClose: n => {
        ;((this._stompHandler = void 0),
          this.state === Tr.DEACTIVATING && this._changeState(Tr.INACTIVE),
          this.onWebSocketClose(n),
          this.active && this._schedule_reconnect())
      },
      onWebSocketError: n => {
        this.onWebSocketError(n)
      },
      onUnhandledMessage: n => {
        this.onUnhandledMessage(n)
      },
      onUnhandledReceipt: n => {
        this.onUnhandledReceipt(n)
      },
      onUnhandledFrame: n => {
        this.onUnhandledFrame(n)
      },
      onHeartbeatReceived: () => {
        this.onHeartbeatReceived()
      },
      onHeartbeatLost: () => {
        this.onHeartbeatLost()
      },
    })),
      this._stompHandler.start())
  }
  _createWebSocket() {
    let e
    if (this.webSocketFactory) e = this.webSocketFactory()
    else if (this.brokerURL)
      e = new WebSocket(this.brokerURL, this.stompVersions.protocolVersions())
    else throw new Error('Either brokerURL or webSocketFactory must be provided')
    return ((e.binaryType = 'arraybuffer'), e)
  }
  _schedule_reconnect() {
    this._nextReconnectDelay > 0 &&
      (this.debug(`STOMP: scheduling reconnection in ${this._nextReconnectDelay}ms`),
      (this._reconnector = setTimeout(() => {
        ;(this.reconnectTimeMode === hh.EXPONENTIAL &&
          ((this._nextReconnectDelay = this._nextReconnectDelay * 2),
          this.maxReconnectDelay !== 0 &&
            (this._nextReconnectDelay = Math.min(
              this._nextReconnectDelay,
              this.maxReconnectDelay
            ))),
          this._connect())
      }, this._nextReconnectDelay)))
  }
  async deactivate(e = {}) {
    const n = e.force || !1,
      i = this.active
    let s
    if (this.state === Tr.INACTIVE)
      return (this.debug('Already INACTIVE, nothing more to do'), Promise.resolve())
    if (
      (this._changeState(Tr.DEACTIVATING),
      (this._nextReconnectDelay = 0),
      this._reconnector && (clearTimeout(this._reconnector), (this._reconnector = void 0)),
      this._stompHandler && this.webSocket.readyState !== ls.CLOSED)
    ) {
      const o = this._stompHandler.onWebSocketClose
      s = new Promise((u, c) => {
        this._stompHandler.onWebSocketClose = h => {
          ;(o(h), u())
        }
      })
    } else return (this._changeState(Tr.INACTIVE), Promise.resolve())
    return (n ? this._stompHandler?.discardWebsocket() : i && this._disposeStompHandler(), s)
  }
  forceDisconnect() {
    this._stompHandler && this._stompHandler.forceDisconnect()
  }
  _disposeStompHandler() {
    this._stompHandler && this._stompHandler.dispose()
  }
  publish(e) {
    ;(this._checkConnection(), this._stompHandler.publish(e))
  }
  _checkConnection() {
    if (!this.connected) throw new TypeError('There is no underlying STOMP connection')
  }
  watchForReceipt(e, n) {
    ;(this._checkConnection(), this._stompHandler.watchForReceipt(e, n))
  }
  subscribe(e, n, i = {}) {
    return (this._checkConnection(), this._stompHandler.subscribe(e, n, i))
  }
  unsubscribe(e, n = {}) {
    ;(this._checkConnection(), this._stompHandler.unsubscribe(e, n))
  }
  begin(e) {
    return (this._checkConnection(), this._stompHandler.begin(e))
  }
  commit(e) {
    ;(this._checkConnection(), this._stompHandler.commit(e))
  }
  abort(e) {
    ;(this._checkConnection(), this._stompHandler.abort(e))
  }
  ack(e, n, i = {}) {
    ;(this._checkConnection(), this._stompHandler.ack(e, n, i))
  }
  nack(e, n, i = {}) {
    ;(this._checkConnection(), this._stompHandler.nack(e, n, i))
  }
}
var lp = { exports: {} },
  Pf = {},
  AI
function e2() {
  return (
    AI ||
      ((AI = 1),
      window.crypto && window.crypto.getRandomValues
        ? (Pf.randomBytes = function (t) {
            var e = new Uint8Array(t)
            return (window.crypto.getRandomValues(e), e)
          })
        : (Pf.randomBytes = function (t) {
            for (var e = new Array(t), n = 0; n < t; n++) e[n] = Math.floor(Math.random() * 256)
            return e
          })),
    Pf
  )
}
var up, bI
function Al() {
  if (bI) return up
  bI = 1
  var t = e2(),
    e = 'abcdefghijklmnopqrstuvwxyz012345'
  return (
    (up = {
      string: function (n) {
        for (var i = e.length, s = t.randomBytes(n), o = [], u = 0; u < n; u++)
          o.push(e.substr(s[u] % i, 1))
        return o.join('')
      },
      number: function (n) {
        return Math.floor(Math.random() * n)
      },
      numberString: function (n) {
        var i = ('' + (n - 1)).length,
          s = new Array(i + 1).join('0')
        return (s + this.number(n)).slice(-i)
      },
    }),
    up
  )
}
var II
function vs() {
  return (
    II ||
      ((II = 1),
      (function (t) {
        var e = Al(),
          n = {},
          i = !1,
          s = window.chrome && window.chrome.app && window.chrome.app.runtime
        t.exports = {
          attachEvent: function (u, c) {
            typeof window.addEventListener < 'u'
              ? window.addEventListener(u, c, !1)
              : window.document &&
                window.attachEvent &&
                (window.document.attachEvent('on' + u, c), window.attachEvent('on' + u, c))
          },
          detachEvent: function (u, c) {
            typeof window.addEventListener < 'u'
              ? window.removeEventListener(u, c, !1)
              : window.document &&
                window.detachEvent &&
                (window.document.detachEvent('on' + u, c), window.detachEvent('on' + u, c))
          },
          unloadAdd: function (u) {
            if (s) return null
            var c = e.string(8)
            return ((n[c] = u), i && setTimeout(this.triggerUnloadCallbacks, 0), c)
          },
          unloadDel: function (u) {
            u in n && delete n[u]
          },
          triggerUnloadCallbacks: function () {
            for (var u in n) (n[u](), delete n[u])
          },
        }
        var o = function () {
          i || ((i = !0), t.exports.triggerUnloadCallbacks())
        }
        s || t.exports.attachEvent('unload', o)
      })(lp)),
    lp.exports
  )
}
var cp, CI
function n2() {
  return (
    CI ||
      ((CI = 1),
      (cp = function (e, n) {
        if (((n = n.split(':')[0]), (e = +e), !e)) return !1
        switch (n) {
          case 'http':
          case 'ws':
            return e !== 80
          case 'https':
          case 'wss':
            return e !== 443
          case 'ftp':
            return e !== 21
          case 'gopher':
            return e !== 70
          case 'file':
            return !1
        }
        return e !== 0
      })),
    cp
  )
}
var Gf = {},
  wI
function i2() {
  if (wI) return Gf
  wI = 1
  var t = Object.prototype.hasOwnProperty,
    e
  function n(u) {
    try {
      return decodeURIComponent(u.replace(/\+/g, ' '))
    } catch {
      return null
    }
  }
  function i(u) {
    try {
      return encodeURIComponent(u)
    } catch {
      return null
    }
  }
  function s(u) {
    for (var c = /([^=?#&]+)=?([^&]*)/g, h = {}, p; (p = c.exec(u)); ) {
      var y = n(p[1]),
        v = n(p[2])
      y === null || v === null || y in h || (h[y] = v)
    }
    return h
  }
  function o(u, c) {
    c = c || ''
    var h = [],
      p,
      y
    typeof c != 'string' && (c = '?')
    for (y in u)
      if (t.call(u, y)) {
        if (
          ((p = u[y]),
          !p && (p === null || p === e || isNaN(p)) && (p = ''),
          (y = i(y)),
          (p = i(p)),
          y === null || p === null)
        )
          continue
        h.push(y + '=' + p)
      }
    return h.length ? c + h.join('&') : ''
  }
  return ((Gf.stringify = o), (Gf.parse = s), Gf)
}
var fp, xI
function kS() {
  if (xI) return fp
  xI = 1
  var t = n2(),
    e = i2(),
    n = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/,
    i = /[\n\r\t]/g,
    s = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
    o = /:\d+$/,
    u = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i,
    c = /^[a-zA-Z]:/
  function h(B) {
    return (B || '').toString().replace(n, '')
  }
  var p = [
      ['#', 'hash'],
      ['?', 'query'],
      function (H, Z) {
        return C(Z.protocol) ? H.replace(/\\/g, '/') : H
      },
      ['/', 'pathname'],
      ['@', 'auth', 1],
      [NaN, 'host', void 0, 1, 1],
      [/:(\d*)$/, 'port', void 0, 1],
      [NaN, 'hostname', void 0, 1, 1],
    ],
    y = { hash: 1, query: 1 }
  function v(B) {
    var H
    typeof window < 'u' || typeof window < 'u'
      ? (H = window)
      : typeof self < 'u'
        ? (H = self)
        : (H = {})
    var Z = H.location || {}
    B = B || Z
    var U = {},
      nt = typeof B,
      g
    if (B.protocol === 'blob:') U = new T(unescape(B.pathname), {})
    else if (nt === 'string') {
      U = new T(B, {})
      for (g in y) delete U[g]
    } else if (nt === 'object') {
      for (g in B) g in y || (U[g] = B[g])
      U.slashes === void 0 && (U.slashes = s.test(B.href))
    }
    return U
  }
  function C(B) {
    return (
      B === 'file:' ||
      B === 'ftp:' ||
      B === 'http:' ||
      B === 'https:' ||
      B === 'ws:' ||
      B === 'wss:'
    )
  }
  function w(B, H) {
    ;((B = h(B)), (B = B.replace(i, '')), (H = H || {}))
    var Z = u.exec(B),
      U = Z[1] ? Z[1].toLowerCase() : '',
      nt = !!Z[2],
      g = !!Z[3],
      S = 0,
      M
    return (
      nt
        ? g
          ? ((M = Z[2] + Z[3] + Z[4]), (S = Z[2].length + Z[3].length))
          : ((M = Z[2] + Z[4]), (S = Z[2].length))
        : g
          ? ((M = Z[3] + Z[4]), (S = Z[3].length))
          : (M = Z[4]),
      U === 'file:'
        ? S >= 2 && (M = M.slice(2))
        : C(U)
          ? (M = Z[4])
          : U
            ? nt && (M = M.slice(2))
            : S >= 2 && C(H.protocol) && (M = Z[4]),
      { protocol: U, slashes: nt || C(U), slashesCount: S, rest: M }
    )
  }
  function N(B, H) {
    if (B === '') return H
    for (
      var Z = (H || '/').split('/').slice(0, -1).concat(B.split('/')),
        U = Z.length,
        nt = Z[U - 1],
        g = !1,
        S = 0;
      U--;

    )
      Z[U] === '.'
        ? Z.splice(U, 1)
        : Z[U] === '..'
          ? (Z.splice(U, 1), S++)
          : S && (U === 0 && (g = !0), Z.splice(U, 1), S--)
    return (g && Z.unshift(''), (nt === '.' || nt === '..') && Z.push(''), Z.join('/'))
  }
  function T(B, H, Z) {
    if (((B = h(B)), (B = B.replace(i, '')), !(this instanceof T))) return new T(B, H, Z)
    var U,
      nt,
      g,
      S,
      M,
      _,
      W = p.slice(),
      $ = typeof H,
      X = this,
      Ct = 0
    for (
      $ !== 'object' && $ !== 'string' && ((Z = H), (H = null)),
        Z && typeof Z != 'function' && (Z = e.parse),
        H = v(H),
        nt = w(B || '', H),
        U = !nt.protocol && !nt.slashes,
        X.slashes = nt.slashes || (U && H.slashes),
        X.protocol = nt.protocol || H.protocol || '',
        B = nt.rest,
        ((nt.protocol === 'file:' && (nt.slashesCount !== 2 || c.test(B))) ||
          (!nt.slashes && (nt.protocol || nt.slashesCount < 2 || !C(X.protocol)))) &&
          (W[3] = [/(.*)/, 'pathname']);
      Ct < W.length;
      Ct++
    ) {
      if (((S = W[Ct]), typeof S == 'function')) {
        B = S(B, X)
        continue
      }
      ;((g = S[0]),
        (_ = S[1]),
        g !== g
          ? (X[_] = B)
          : typeof g == 'string'
            ? ((M = g === '@' ? B.lastIndexOf(g) : B.indexOf(g)),
              ~M &&
                (typeof S[2] == 'number'
                  ? ((X[_] = B.slice(0, M)), (B = B.slice(M + S[2])))
                  : ((X[_] = B.slice(M)), (B = B.slice(0, M)))))
            : (M = g.exec(B)) && ((X[_] = M[1]), (B = B.slice(0, M.index))),
        (X[_] = X[_] || (U && S[3] && H[_]) || ''),
        S[4] && (X[_] = X[_].toLowerCase()))
    }
    ;(Z && (X.query = Z(X.query)),
      U &&
        H.slashes &&
        X.pathname.charAt(0) !== '/' &&
        (X.pathname !== '' || H.pathname !== '') &&
        (X.pathname = N(X.pathname, H.pathname)),
      X.pathname.charAt(0) !== '/' && C(X.protocol) && (X.pathname = '/' + X.pathname),
      t(X.port, X.protocol) || ((X.host = X.hostname), (X.port = '')),
      (X.username = X.password = ''),
      X.auth &&
        ((M = X.auth.indexOf(':')),
        ~M
          ? ((X.username = X.auth.slice(0, M)),
            (X.username = encodeURIComponent(decodeURIComponent(X.username))),
            (X.password = X.auth.slice(M + 1)),
            (X.password = encodeURIComponent(decodeURIComponent(X.password))))
          : (X.username = encodeURIComponent(decodeURIComponent(X.auth))),
        (X.auth = X.password ? X.username + ':' + X.password : X.username)),
      (X.origin =
        X.protocol !== 'file:' && C(X.protocol) && X.host ? X.protocol + '//' + X.host : 'null'),
      (X.href = X.toString()))
  }
  function z(B, H, Z) {
    var U = this
    switch (B) {
      case 'query':
        ;(typeof H == 'string' && H.length && (H = (Z || e.parse)(H)), (U[B] = H))
        break
      case 'port':
        ;((U[B] = H),
          t(H, U.protocol)
            ? H && (U.host = U.hostname + ':' + H)
            : ((U.host = U.hostname), (U[B] = '')))
        break
      case 'hostname':
        ;((U[B] = H), U.port && (H += ':' + U.port), (U.host = H))
        break
      case 'host':
        ;((U[B] = H),
          o.test(H)
            ? ((H = H.split(':')), (U.port = H.pop()), (U.hostname = H.join(':')))
            : ((U.hostname = H), (U.port = '')))
        break
      case 'protocol':
        ;((U.protocol = H.toLowerCase()), (U.slashes = !Z))
        break
      case 'pathname':
      case 'hash':
        if (H) {
          var nt = B === 'pathname' ? '/' : '#'
          U[B] = H.charAt(0) !== nt ? nt + H : H
        } else U[B] = H
        break
      case 'username':
      case 'password':
        U[B] = encodeURIComponent(H)
        break
      case 'auth':
        var g = H.indexOf(':')
        ~g
          ? ((U.username = H.slice(0, g)),
            (U.username = encodeURIComponent(decodeURIComponent(U.username))),
            (U.password = H.slice(g + 1)),
            (U.password = encodeURIComponent(decodeURIComponent(U.password))))
          : (U.username = encodeURIComponent(decodeURIComponent(H)))
    }
    for (var S = 0; S < p.length; S++) {
      var M = p[S]
      M[4] && (U[M[1]] = U[M[1]].toLowerCase())
    }
    return (
      (U.auth = U.password ? U.username + ':' + U.password : U.username),
      (U.origin =
        U.protocol !== 'file:' && C(U.protocol) && U.host ? U.protocol + '//' + U.host : 'null'),
      (U.href = U.toString()),
      U
    )
  }
  function R(B) {
    ;(!B || typeof B != 'function') && (B = e.stringify)
    var H,
      Z = this,
      U = Z.host,
      nt = Z.protocol
    nt && nt.charAt(nt.length - 1) !== ':' && (nt += ':')
    var g = nt + ((Z.protocol && Z.slashes) || C(Z.protocol) ? '//' : '')
    return (
      Z.username
        ? ((g += Z.username), Z.password && (g += ':' + Z.password), (g += '@'))
        : Z.password
          ? ((g += ':' + Z.password), (g += '@'))
          : Z.protocol !== 'file:' && C(Z.protocol) && !U && Z.pathname !== '/' && (g += '@'),
      (U[U.length - 1] === ':' || (o.test(Z.hostname) && !Z.port)) && (U += ':'),
      (g += U + Z.pathname),
      (H = typeof Z.query == 'object' ? B(Z.query) : Z.query),
      H && (g += H.charAt(0) !== '?' ? '?' + H : H),
      Z.hash && (g += Z.hash),
      g
    )
  }
  return (
    (T.prototype = { set: z, toString: R }),
    (T.extractProtocol = w),
    (T.location = v),
    (T.trimLeft = h),
    (T.qs = e),
    (fp = T),
    fp
  )
}
var hp, SI
function cr() {
  if (SI) return hp
  SI = 1
  var t = kS()
  return (
    (hp = {
      getOrigin: function (e) {
        if (!e) return null
        var n = new t(e)
        if (n.protocol === 'file:') return null
        var i = n.port
        return (
          i || (i = n.protocol === 'https:' ? '443' : '80'),
          n.protocol + '//' + n.hostname + ':' + i
        )
      },
      isOriginEqual: function (e, n) {
        var i = this.getOrigin(e) === this.getOrigin(n)
        return i
      },
      isSchemeEqual: function (e, n) {
        return e.split(':')[0] === n.split(':')[0]
      },
      addPath: function (e, n) {
        var i = e.split('?')
        return i[0] + n + (i[1] ? '?' + i[1] : '')
      },
      addQuery: function (e, n) {
        return e + (e.indexOf('?') === -1 ? '?' + n : '&' + n)
      },
      isLoopbackAddr: function (e) {
        return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(e) || /^\[::1\]$/.test(e)
      },
    }),
    hp
  )
}
var Zf = { exports: {} },
  NI
function Pe() {
  return (
    NI ||
      ((NI = 1),
      typeof Object.create == 'function'
        ? (Zf.exports = function (e, n) {
            n &&
              ((e.super_ = n),
              (e.prototype = Object.create(n.prototype, {
                constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 },
              })))
          })
        : (Zf.exports = function (e, n) {
            if (n) {
              e.super_ = n
              var i = function () {}
              ;((i.prototype = n.prototype), (e.prototype = new i()), (e.prototype.constructor = e))
            }
          })),
    Zf.exports
  )
}
var dp = {},
  gp,
  TI
function _S() {
  if (TI) return gp
  TI = 1
  function t() {
    this._listeners = {}
  }
  return (
    (t.prototype.addEventListener = function (e, n) {
      e in this._listeners || (this._listeners[e] = [])
      var i = this._listeners[e]
      ;(i.indexOf(n) === -1 && (i = i.concat([n])), (this._listeners[e] = i))
    }),
    (t.prototype.removeEventListener = function (e, n) {
      var i = this._listeners[e]
      if (i) {
        var s = i.indexOf(n)
        if (s !== -1) {
          i.length > 1
            ? (this._listeners[e] = i.slice(0, s).concat(i.slice(s + 1)))
            : delete this._listeners[e]
          return
        }
      }
    }),
    (t.prototype.dispatchEvent = function () {
      var e = arguments[0],
        n = e.type,
        i = arguments.length === 1 ? [e] : Array.apply(null, arguments)
      if ((this['on' + n] && this['on' + n].apply(this, i), n in this._listeners))
        for (var s = this._listeners[n], o = 0; o < s.length; o++) s[o].apply(this, i)
    }),
    (gp = t),
    gp
  )
}
var MI
function fi() {
  if (MI) return dp
  MI = 1
  var t = Pe(),
    e = _S()
  function n() {
    e.call(this)
  }
  return (
    t(n, e),
    (n.prototype.removeAllListeners = function (i) {
      i ? delete this._listeners[i] : (this._listeners = {})
    }),
    (n.prototype.once = function (i, s) {
      var o = this,
        u = !1
      function c() {
        ;(o.removeListener(i, c), u || ((u = !0), s.apply(this, arguments)))
      }
      this.on(i, c)
    }),
    (n.prototype.emit = function () {
      var i = arguments[0],
        s = this._listeners[i]
      if (s) {
        for (var o = arguments.length, u = new Array(o - 1), c = 1; c < o; c++)
          u[c - 1] = arguments[c]
        for (var h = 0; h < s.length; h++) s[h].apply(this, u)
      }
    }),
    (n.prototype.on = n.prototype.addListener = e.prototype.addEventListener),
    (n.prototype.removeListener = e.prototype.removeEventListener),
    (dp.EventEmitter = n),
    dp
  )
}
var Uf = { exports: {} },
  EI
function r2() {
  if (EI) return Uf.exports
  EI = 1
  var t = window.WebSocket || window.MozWebSocket
  return (
    t
      ? (Uf.exports = function (n) {
          return new t(n)
        })
      : (Uf.exports = void 0),
    Uf.exports
  )
}
var pp, DI
function a2() {
  if (DI) return pp
  DI = 1
  var t = vs(),
    e = cr(),
    n = Pe(),
    i = fi().EventEmitter,
    s = r2(),
    o = function () {}
  function u(c, h, p) {
    if (!u.enabled()) throw new Error('Transport created when disabled')
    i.call(this)
    var y = this,
      v = e.addPath(c, '/websocket')
    ;(v.slice(0, 5) === 'https' ? (v = 'wss' + v.slice(5)) : (v = 'ws' + v.slice(4)),
      (this.url = v),
      (this.ws = new s(this.url, [], p)),
      (this.ws.onmessage = function (C) {
        ;(o('message event', C.data), y.emit('message', C.data))
      }),
      (this.unloadRef = t.unloadAdd(function () {
        y.ws.close()
      })),
      (this.ws.onclose = function (C) {
        ;(o('close event', C.code, C.reason), y.emit('close', C.code, C.reason), y._cleanup())
      }),
      (this.ws.onerror = function (C) {
        ;(y.emit('close', 1006, 'WebSocket connection broken'), y._cleanup())
      }))
  }
  return (
    n(u, i),
    (u.prototype.send = function (c) {
      var h = '[' + c + ']'
      this.ws.send(h)
    }),
    (u.prototype.close = function () {
      var c = this.ws
      ;(this._cleanup(), c && c.close())
    }),
    (u.prototype._cleanup = function () {
      var c = this.ws
      ;(c && (c.onmessage = c.onclose = c.onerror = null),
        t.unloadDel(this.unloadRef),
        (this.unloadRef = this.ws = null),
        this.removeAllListeners())
    }),
    (u.enabled = function () {
      return !!s
    }),
    (u.transportName = 'websocket'),
    (u.roundTrips = 2),
    (pp = u),
    pp
  )
}
var vp, OI
function s2() {
  if (OI) return vp
  OI = 1
  var t = Pe(),
    e = fi().EventEmitter,
    n = function () {}
  function i(s, o) {
    ;(e.call(this), (this.sendBuffer = []), (this.sender = o), (this.url = s))
  }
  return (
    t(i, e),
    (i.prototype.send = function (s) {
      ;(this.sendBuffer.push(s), this.sendStop || this.sendSchedule())
    }),
    (i.prototype.sendScheduleWait = function () {
      var s = this,
        o
      ;((this.sendStop = function () {
        ;((s.sendStop = null), clearTimeout(o))
      }),
        (o = setTimeout(function () {
          ;((s.sendStop = null), s.sendSchedule())
        }, 25)))
    }),
    (i.prototype.sendSchedule = function () {
      n('sendSchedule', this.sendBuffer.length)
      var s = this
      if (this.sendBuffer.length > 0) {
        var o = '[' + this.sendBuffer.join(',') + ']'
        ;((this.sendStop = this.sender(this.url, o, function (u) {
          ;((s.sendStop = null),
            u
              ? (s.emit('close', u.code || 1006, 'Sending error: ' + u), s.close())
              : s.sendScheduleWait())
        })),
          (this.sendBuffer = []))
      }
    }),
    (i.prototype._cleanup = function () {
      this.removeAllListeners()
    }),
    (i.prototype.close = function () {
      ;(this._cleanup(), this.sendStop && (this.sendStop(), (this.sendStop = null)))
    }),
    (vp = i),
    vp
  )
}
var mp, LI
function o2() {
  if (LI) return mp
  LI = 1
  var t = Pe(),
    e = fi().EventEmitter,
    n = function () {}
  function i(s, o, u) {
    ;(e.call(this),
      (this.Receiver = s),
      (this.receiveUrl = o),
      (this.AjaxObject = u),
      this._scheduleReceiver())
  }
  return (
    t(i, e),
    (i.prototype._scheduleReceiver = function () {
      var s = this,
        o = (this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject))
      ;(o.on('message', function (u) {
        s.emit('message', u)
      }),
        o.once('close', function (u, c) {
          ;(n('close', u, c, s.pollIsClosing),
            (s.poll = o = null),
            s.pollIsClosing ||
              (c === 'network'
                ? s._scheduleReceiver()
                : (s.emit('close', u || 1006, c), s.removeAllListeners())))
        }))
    }),
    (i.prototype.abort = function () {
      ;(this.removeAllListeners(), (this.pollIsClosing = !0), this.poll && this.poll.abort())
    }),
    (mp = i),
    mp
  )
}
var yp, zI
function BS() {
  if (zI) return yp
  zI = 1
  var t = Pe(),
    e = cr(),
    n = s2(),
    i = o2()
  function s(o, u, c, h, p) {
    var y = e.addPath(o, u),
      v = this
    ;(n.call(this, o, c),
      (this.poll = new i(h, y, p)),
      this.poll.on('message', function (C) {
        v.emit('message', C)
      }),
      this.poll.once('close', function (C, w) {
        ;((v.poll = null), v.emit('close', C, w), v.close())
      }))
  }
  return (
    t(s, n),
    (s.prototype.close = function () {
      ;(n.prototype.close.call(this),
        this.removeAllListeners(),
        this.poll && (this.poll.abort(), (this.poll = null)))
    }),
    (yp = s),
    yp
  )
}
var Ap, RI
function bl() {
  if (RI) return Ap
  RI = 1
  var t = Pe(),
    e = cr(),
    n = BS()
  function i(o) {
    return function (u, c, h) {
      var p = {}
      typeof c == 'string' && (p.headers = { 'Content-type': 'text/plain' })
      var y = e.addPath(u, '/xhr_send'),
        v = new o('POST', y, c, p)
      return (
        v.once('finish', function (C) {
          if (((v = null), C !== 200 && C !== 204)) return h(new Error('http status ' + C))
          h()
        }),
        function () {
          ;(v.close(), (v = null))
          var C = new Error('Aborted')
          ;((C.code = 1e3), h(C))
        }
      )
    }
  }
  function s(o, u, c, h) {
    n.call(this, o, u, i(h), c, h)
  }
  return (t(s, n), (Ap = s), Ap)
}
var bp, kI
function Gh() {
  if (kI) return bp
  kI = 1
  var t = Pe(),
    e = fi().EventEmitter
  function n(i, s) {
    e.call(this)
    var o = this
    ;((this.bufferPosition = 0),
      (this.xo = new s('POST', i, null)),
      this.xo.on('chunk', this._chunkHandler.bind(this)),
      this.xo.once('finish', function (u, c) {
        ;(o._chunkHandler(u, c), (o.xo = null))
        var h = u === 200 ? 'network' : 'permanent'
        ;(o.emit('close', null, h), o._cleanup())
      }))
  }
  return (
    t(n, e),
    (n.prototype._chunkHandler = function (i, s) {
      if (!(i !== 200 || !s))
        for (var o = -1; ; this.bufferPosition += o + 1) {
          var u = s.slice(this.bufferPosition)
          if (
            ((o = u.indexOf(`
`)),
            o === -1)
          )
            break
          var c = u.slice(0, o)
          c && this.emit('message', c)
        }
    }),
    (n.prototype._cleanup = function () {
      this.removeAllListeners()
    }),
    (n.prototype.abort = function () {
      ;(this.xo && (this.xo.close(), this.emit('close', null, 'user'), (this.xo = null)),
        this._cleanup())
    }),
    (bp = n),
    bp
  )
}
var Ip, _I
function jS() {
  if (_I) return Ip
  _I = 1
  var t = fi().EventEmitter,
    e = Pe(),
    n = vs(),
    i = cr(),
    s = window.XMLHttpRequest,
    o = function () {}
  function u(p, y, v, C) {
    var w = this
    ;(t.call(this),
      setTimeout(function () {
        w._start(p, y, v, C)
      }, 0))
  }
  ;(e(u, t),
    (u.prototype._start = function (p, y, v, C) {
      var w = this
      try {
        this.xhr = new s()
      } catch {}
      if (!this.xhr) {
        ;(this.emit('finish', 0, 'no xhr support'), this._cleanup())
        return
      }
      ;((y = i.addQuery(y, 't=' + +new Date())),
        (this.unloadRef = n.unloadAdd(function () {
          w._cleanup(!0)
        })))
      try {
        ;(this.xhr.open(p, y, !0),
          this.timeout &&
            'timeout' in this.xhr &&
            ((this.xhr.timeout = this.timeout),
            (this.xhr.ontimeout = function () {
              ;(o('xhr timeout'), w.emit('finish', 0, ''), w._cleanup(!1))
            })))
      } catch {
        ;(this.emit('finish', 0, ''), this._cleanup(!1))
        return
      }
      if (
        ((!C || !C.noCredentials) && u.supportsCORS && (this.xhr.withCredentials = !0),
        C && C.headers)
      )
        for (var N in C.headers) this.xhr.setRequestHeader(N, C.headers[N])
      this.xhr.onreadystatechange = function () {
        if (w.xhr) {
          var T = w.xhr,
            z,
            R
          switch ((o('readyState', T.readyState), T.readyState)) {
            case 3:
              try {
                ;((R = T.status), (z = T.responseText))
              } catch {}
              ;(R === 1223 && (R = 204), R === 200 && z && z.length > 0 && w.emit('chunk', R, z))
              break
            case 4:
              ;((R = T.status),
                R === 1223 && (R = 204),
                (R === 12005 || R === 12029) && (R = 0),
                o('finish', R, T.responseText),
                w.emit('finish', R, T.responseText),
                w._cleanup(!1))
              break
          }
        }
      }
      try {
        w.xhr.send(v)
      } catch {
        ;(w.emit('finish', 0, ''), w._cleanup(!1))
      }
    }),
    (u.prototype._cleanup = function (p) {
      if (this.xhr) {
        if (
          (this.removeAllListeners(),
          n.unloadDel(this.unloadRef),
          (this.xhr.onreadystatechange = function () {}),
          this.xhr.ontimeout && (this.xhr.ontimeout = null),
          p)
        )
          try {
            this.xhr.abort()
          } catch {}
        this.unloadRef = this.xhr = null
      }
    }),
    (u.prototype.close = function () {
      this._cleanup(!0)
    }),
    (u.enabled = !!s))
  var c = ['Active'].concat('Object').join('X')
  !u.enabled &&
    c in window &&
    ((s = function () {
      try {
        return new window[c]('Microsoft.XMLHTTP')
      } catch {
        return null
      }
    }),
    (u.enabled = !!new s()))
  var h = !1
  try {
    h = 'withCredentials' in new s()
  } catch {}
  return ((u.supportsCORS = h), (Ip = u), Ip)
}
var Cp, BI
function Zh() {
  if (BI) return Cp
  BI = 1
  var t = Pe(),
    e = jS()
  function n(i, s, o, u) {
    e.call(this, i, s, o, u)
  }
  return (t(n, e), (n.enabled = e.enabled && e.supportsCORS), (Cp = n), Cp)
}
var wp, jI
function rc() {
  if (jI) return wp
  jI = 1
  var t = Pe(),
    e = jS()
  function n(i, s, o) {
    e.call(this, i, s, o, { noCredentials: !0 })
  }
  return (t(n, e), (n.enabled = e.enabled), (wp = n), wp)
}
var xp, PI
function ac() {
  return (
    PI ||
      ((PI = 1),
      (xp = {
        isOpera: function () {
          return window.navigator && /opera/i.test(window.navigator.userAgent)
        },
        isKonqueror: function () {
          return window.navigator && /konqueror/i.test(window.navigator.userAgent)
        },
        hasDomain: function () {
          if (!window.document) return !0
          try {
            return !!window.document.domain
          } catch {
            return !1
          }
        },
      })),
    xp
  )
}
var Sp, GI
function l2() {
  if (GI) return Sp
  GI = 1
  var t = Pe(),
    e = bl(),
    n = Gh(),
    i = Zh(),
    s = rc(),
    o = ac()
  function u(c) {
    if (!s.enabled && !i.enabled) throw new Error('Transport created when disabled')
    e.call(this, c, '/xhr_streaming', n, i)
  }
  return (
    t(u, e),
    (u.enabled = function (c) {
      return c.nullOrigin || o.isOpera() ? !1 : i.enabled
    }),
    (u.transportName = 'xhr-streaming'),
    (u.roundTrips = 2),
    (u.needBody = !!window.document),
    (Sp = u),
    Sp
  )
}
var Np, ZI
function Km() {
  if (ZI) return Np
  ZI = 1
  var t = fi().EventEmitter,
    e = Pe(),
    n = vs(),
    i = ac(),
    s = cr(),
    o = function () {}
  function u(c, h, p) {
    var y = this
    ;(t.call(this),
      setTimeout(function () {
        y._start(c, h, p)
      }, 0))
  }
  return (
    e(u, t),
    (u.prototype._start = function (c, h, p) {
      var y = this,
        v = new window.XDomainRequest()
      ;((h = s.addQuery(h, 't=' + +new Date())),
        (v.onerror = function () {
          y._error()
        }),
        (v.ontimeout = function () {
          y._error()
        }),
        (v.onprogress = function () {
          ;(o('progress', v.responseText), y.emit('chunk', 200, v.responseText))
        }),
        (v.onload = function () {
          ;(y.emit('finish', 200, v.responseText), y._cleanup(!1))
        }),
        (this.xdr = v),
        (this.unloadRef = n.unloadAdd(function () {
          y._cleanup(!0)
        })))
      try {
        ;(this.xdr.open(c, h), this.timeout && (this.xdr.timeout = this.timeout), this.xdr.send(p))
      } catch {
        this._error()
      }
    }),
    (u.prototype._error = function () {
      ;(this.emit('finish', 0, ''), this._cleanup(!1))
    }),
    (u.prototype._cleanup = function (c) {
      if (this.xdr) {
        if (
          (this.removeAllListeners(),
          n.unloadDel(this.unloadRef),
          (this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null),
          c)
        )
          try {
            this.xdr.abort()
          } catch {}
        this.unloadRef = this.xdr = null
      }
    }),
    (u.prototype.close = function () {
      this._cleanup(!0)
    }),
    (u.enabled = !!(window.XDomainRequest && i.hasDomain())),
    (Np = u),
    Np
  )
}
var Tp, UI
function PS() {
  if (UI) return Tp
  UI = 1
  var t = Pe(),
    e = bl(),
    n = Gh(),
    i = Km()
  function s(o) {
    if (!i.enabled) throw new Error('Transport created when disabled')
    e.call(this, o, '/xhr_streaming', n, i)
  }
  return (
    t(s, e),
    (s.enabled = function (o) {
      return o.cookie_needed || o.nullOrigin ? !1 : i.enabled && o.sameScheme
    }),
    (s.transportName = 'xdr-streaming'),
    (s.roundTrips = 2),
    (Tp = s),
    Tp
  )
}
var Mp, YI
function GS() {
  return (YI || ((YI = 1), (Mp = window.EventSource)), Mp)
}
var Ep, HI
function u2() {
  if (HI) return Ep
  HI = 1
  var t = Pe(),
    e = fi().EventEmitter,
    n = GS(),
    i = function () {}
  function s(o) {
    e.call(this)
    var u = this,
      c = (this.es = new n(o))
    ;((c.onmessage = function (h) {
      ;(i('message', h.data), u.emit('message', decodeURI(h.data)))
    }),
      (c.onerror = function (h) {
        i('error', c.readyState)
        var p = c.readyState !== 2 ? 'network' : 'permanent'
        ;(u._cleanup(), u._close(p))
      }))
  }
  return (
    t(s, e),
    (s.prototype.abort = function () {
      ;(this._cleanup(), this._close('user'))
    }),
    (s.prototype._cleanup = function () {
      var o = this.es
      o && ((o.onmessage = o.onerror = null), o.close(), (this.es = null))
    }),
    (s.prototype._close = function (o) {
      var u = this
      setTimeout(function () {
        ;(u.emit('close', null, o), u.removeAllListeners())
      }, 200)
    }),
    (Ep = s),
    Ep
  )
}
var Dp, VI
function XI() {
  if (VI) return Dp
  VI = 1
  var t = Pe(),
    e = bl(),
    n = u2(),
    i = Zh(),
    s = GS()
  function o(u) {
    if (!o.enabled()) throw new Error('Transport created when disabled')
    e.call(this, u, '/eventsource', n, i)
  }
  return (
    t(o, e),
    (o.enabled = function () {
      return !!s
    }),
    (o.transportName = 'eventsource'),
    (o.roundTrips = 2),
    (Dp = o),
    Dp
  )
}
var Op, WI
function ZS() {
  return (WI || ((WI = 1), (Op = '1.6.1')), Op)
}
var Lp = { exports: {} },
  FI
function sc() {
  return (
    FI ||
      ((FI = 1),
      (function (t) {
        var e = vs(),
          n = ac()
        ;((t.exports = {
          WPrefix: '_jp',
          currentWindowId: null,
          polluteGlobalNamespace: function () {
            t.exports.WPrefix in window || (window[t.exports.WPrefix] = {})
          },
          postMessage: function (i, s) {
            window.parent !== window &&
              window.parent.postMessage(
                JSON.stringify({ windowId: t.exports.currentWindowId, type: i, data: s || '' }),
                '*'
              )
          },
          createIframe: function (i, s) {
            var o = window.document.createElement('iframe'),
              u,
              c,
              h = function () {
                clearTimeout(u)
                try {
                  o.onload = null
                } catch {}
                o.onerror = null
              },
              p = function () {
                o &&
                  (h(),
                  setTimeout(function () {
                    ;(o && o.parentNode.removeChild(o), (o = null))
                  }, 0),
                  e.unloadDel(c))
              },
              y = function (C) {
                o && (p(), s(C))
              },
              v = function (C, w) {
                setTimeout(function () {
                  try {
                    o && o.contentWindow && o.contentWindow.postMessage(C, w)
                  } catch {}
                }, 0)
              }
            return (
              (o.src = i),
              (o.style.display = 'none'),
              (o.style.position = 'absolute'),
              (o.onerror = function () {
                y('onerror')
              }),
              (o.onload = function () {
                ;(clearTimeout(u),
                  (u = setTimeout(function () {
                    y('onload timeout')
                  }, 2e3)))
              }),
              window.document.body.appendChild(o),
              (u = setTimeout(function () {
                y('timeout')
              }, 15e3)),
              (c = e.unloadAdd(p)),
              { post: v, cleanup: p, loaded: h }
            )
          },
          createHtmlfile: function (i, s) {
            var o = ['Active'].concat('Object').join('X'),
              u = new window[o]('htmlfile'),
              c,
              h,
              p,
              y = function () {
                ;(clearTimeout(c), (p.onerror = null))
              },
              v = function () {
                u &&
                  (y(),
                  e.unloadDel(h),
                  p.parentNode.removeChild(p),
                  (p = u = null),
                  CollectGarbage())
              },
              C = function (T) {
                u && (v(), s(T))
              },
              w = function (T, z) {
                try {
                  setTimeout(function () {
                    p && p.contentWindow && p.contentWindow.postMessage(T, z)
                  }, 0)
                } catch {}
              }
            ;(u.open(),
              u.write(
                '<html><script>document.domain="' + window.document.domain + '";<\/script></html>'
              ),
              u.close(),
              (u.parentWindow[t.exports.WPrefix] = window[t.exports.WPrefix]))
            var N = u.createElement('div')
            return (
              u.body.appendChild(N),
              (p = u.createElement('iframe')),
              N.appendChild(p),
              (p.src = i),
              (p.onerror = function () {
                C('onerror')
              }),
              (c = setTimeout(function () {
                C('timeout')
              }, 15e3)),
              (h = e.unloadAdd(v)),
              { post: w, cleanup: v, loaded: y }
            )
          },
        }),
          (t.exports.iframeEnabled = !1),
          window.document &&
            (t.exports.iframeEnabled =
              (typeof window.postMessage == 'function' || typeof window.postMessage == 'object') &&
              !n.isKonqueror()))
      })(Lp)),
    Lp.exports
  )
}
var zp, JI
function US() {
  if (JI) return zp
  JI = 1
  var t = Pe(),
    e = fi().EventEmitter,
    n = ZS(),
    i = cr(),
    s = sc(),
    o = vs(),
    u = Al(),
    c = function () {}
  function h(p, y, v) {
    if (!h.enabled()) throw new Error('Transport created when disabled')
    e.call(this)
    var C = this
    ;((this.origin = i.getOrigin(v)),
      (this.baseUrl = v),
      (this.transUrl = y),
      (this.transport = p),
      (this.windowId = u.string(8)))
    var w = i.addPath(v, '/iframe.html') + '#' + this.windowId
    ;((this.iframeObj = s.createIframe(w, function (N) {
      ;(C.emit('close', 1006, 'Unable to load an iframe (' + N + ')'), C.close())
    })),
      (this.onmessageCallback = this._message.bind(this)),
      o.attachEvent('message', this.onmessageCallback))
  }
  return (
    t(h, e),
    (h.prototype.close = function () {
      if ((this.removeAllListeners(), this.iframeObj)) {
        o.detachEvent('message', this.onmessageCallback)
        try {
          this.postMessage('c')
        } catch {}
        ;(this.iframeObj.cleanup(),
          (this.iframeObj = null),
          (this.onmessageCallback = this.iframeObj = null))
      }
    }),
    (h.prototype._message = function (p) {
      if ((c('message', p.data), !i.isOriginEqual(p.origin, this.origin))) {
        c('not same origin', p.origin, this.origin)
        return
      }
      var y
      try {
        y = JSON.parse(p.data)
      } catch {
        c('bad json', p.data)
        return
      }
      if (y.windowId !== this.windowId) {
        c('mismatched window id', y.windowId, this.windowId)
        return
      }
      switch (y.type) {
        case 's':
          ;(this.iframeObj.loaded(),
            this.postMessage('s', JSON.stringify([n, this.transport, this.transUrl, this.baseUrl])))
          break
        case 't':
          this.emit('message', y.data)
          break
        case 'c':
          var v
          try {
            v = JSON.parse(y.data)
          } catch {
            c('bad json', y.data)
            return
          }
          ;(this.emit('close', v[0], v[1]), this.close())
          break
      }
    }),
    (h.prototype.postMessage = function (p, y) {
      this.iframeObj.post(
        JSON.stringify({ windowId: this.windowId, type: p, data: y || '' }),
        this.origin
      )
    }),
    (h.prototype.send = function (p) {
      this.postMessage('m', p)
    }),
    (h.enabled = function () {
      return s.iframeEnabled
    }),
    (h.transportName = 'iframe'),
    (h.roundTrips = 2),
    (zp = h),
    zp
  )
}
var Rp, qI
function $m() {
  return (
    qI ||
      ((qI = 1),
      (Rp = {
        isObject: function (t) {
          var e = typeof t
          return e === 'function' || (e === 'object' && !!t)
        },
        extend: function (t) {
          if (!this.isObject(t)) return t
          for (var e, n, i = 1, s = arguments.length; i < s; i++) {
            e = arguments[i]
            for (n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
          }
          return t
        },
      })),
    Rp
  )
}
var kp, QI
function _p() {
  if (QI) return kp
  QI = 1
  var t = Pe(),
    e = US(),
    n = $m()
  return (
    (kp = function (i) {
      function s(o, u) {
        e.call(this, i.transportName, o, u)
      }
      return (
        t(s, e),
        (s.enabled = function (o, u) {
          if (!window.document) return !1
          var c = n.extend({}, u)
          return ((c.sameOrigin = !0), i.enabled(c) && e.enabled())
        }),
        (s.transportName = 'iframe-' + i.transportName),
        (s.needBody = !0),
        (s.roundTrips = e.roundTrips + i.roundTrips - 1),
        (s.facadeTransport = i),
        s
      )
    }),
    kp
  )
}
var Bp, KI
function c2() {
  if (KI) return Bp
  KI = 1
  var t = Pe(),
    e = sc(),
    n = cr(),
    i = fi().EventEmitter,
    s = Al(),
    o = function () {}
  function u(h) {
    i.call(this)
    var p = this
    ;(e.polluteGlobalNamespace(),
      (this.id = 'a' + s.string(6)),
      (h = n.addQuery(h, 'c=' + decodeURIComponent(e.WPrefix + '.' + this.id))),
      o('using htmlfile', u.htmlfileEnabled))
    var y = u.htmlfileEnabled ? e.createHtmlfile : e.createIframe
    ;((window[e.WPrefix][this.id] = {
      start: function () {
        p.iframeObj.loaded()
      },
      message: function (v) {
        p.emit('message', v)
      },
      stop: function () {
        ;(p._cleanup(), p._close('network'))
      },
    }),
      (this.iframeObj = y(h, function () {
        ;(p._cleanup(), p._close('permanent'))
      })))
  }
  ;(t(u, i),
    (u.prototype.abort = function () {
      ;(this._cleanup(), this._close('user'))
    }),
    (u.prototype._cleanup = function () {
      ;(this.iframeObj && (this.iframeObj.cleanup(), (this.iframeObj = null)),
        delete window[e.WPrefix][this.id])
    }),
    (u.prototype._close = function (h) {
      ;(this.emit('close', null, h), this.removeAllListeners())
    }),
    (u.htmlfileEnabled = !1))
  var c = ['Active'].concat('Object').join('X')
  if (c in window)
    try {
      u.htmlfileEnabled = !!new window[c]('htmlfile')
    } catch {}
  return ((u.enabled = u.htmlfileEnabled || e.iframeEnabled), (Bp = u), Bp)
}
var jp, $I
function tC() {
  if ($I) return jp
  $I = 1
  var t = Pe(),
    e = c2(),
    n = rc(),
    i = bl()
  function s(o) {
    if (!e.enabled) throw new Error('Transport created when disabled')
    i.call(this, o, '/htmlfile', e, n)
  }
  return (
    t(s, i),
    (s.enabled = function (o) {
      return e.enabled && o.sameOrigin
    }),
    (s.transportName = 'htmlfile'),
    (s.roundTrips = 2),
    (jp = s),
    jp
  )
}
var Pp, eC
function nC() {
  if (eC) return Pp
  eC = 1
  var t = Pe(),
    e = bl(),
    n = Gh(),
    i = Zh(),
    s = rc()
  function o(u) {
    if (!s.enabled && !i.enabled) throw new Error('Transport created when disabled')
    e.call(this, u, '/xhr', n, i)
  }
  return (
    t(o, e),
    (o.enabled = function (u) {
      return u.nullOrigin ? !1 : s.enabled && u.sameOrigin ? !0 : i.enabled
    }),
    (o.transportName = 'xhr-polling'),
    (o.roundTrips = 2),
    (Pp = o),
    Pp
  )
}
var Gp, iC
function f2() {
  if (iC) return Gp
  iC = 1
  var t = Pe(),
    e = bl(),
    n = PS(),
    i = Gh(),
    s = Km()
  function o(u) {
    if (!s.enabled) throw new Error('Transport created when disabled')
    e.call(this, u, '/xhr', i, s)
  }
  return (
    t(o, e),
    (o.enabled = n.enabled),
    (o.transportName = 'xdr-polling'),
    (o.roundTrips = 2),
    (Gp = o),
    Gp
  )
}
var Zp, rC
function h2() {
  if (rC) return Zp
  rC = 1
  var t = sc(),
    e = Al(),
    n = ac(),
    i = cr(),
    s = Pe(),
    o = fi().EventEmitter,
    u = function () {}
  function c(h) {
    var p = this
    ;(o.call(this), t.polluteGlobalNamespace(), (this.id = 'a' + e.string(6)))
    var y = i.addQuery(h, 'c=' + encodeURIComponent(t.WPrefix + '.' + this.id))
    ;((window[t.WPrefix][this.id] = this._callback.bind(this)),
      this._createScript(y),
      (this.timeoutId = setTimeout(function () {
        p._abort(new Error('JSONP script loaded abnormally (timeout)'))
      }, c.timeout)))
  }
  return (
    s(c, o),
    (c.prototype.abort = function () {
      if (window[t.WPrefix][this.id]) {
        var h = new Error('JSONP user aborted read')
        ;((h.code = 1e3), this._abort(h))
      }
    }),
    (c.timeout = 35e3),
    (c.scriptErrorTimeout = 1e3),
    (c.prototype._callback = function (h) {
      ;(this._cleanup(),
        !this.aborting &&
          (h && this.emit('message', h),
          this.emit('close', null, 'network'),
          this.removeAllListeners()))
    }),
    (c.prototype._abort = function (h) {
      ;(this._cleanup(),
        (this.aborting = !0),
        this.emit('close', h.code, h.message),
        this.removeAllListeners())
    }),
    (c.prototype._cleanup = function () {
      if (
        (clearTimeout(this.timeoutId),
        this.script2 && (this.script2.parentNode.removeChild(this.script2), (this.script2 = null)),
        this.script)
      ) {
        var h = this.script
        ;(h.parentNode.removeChild(h),
          (h.onreadystatechange = h.onerror = h.onload = h.onclick = null),
          (this.script = null))
      }
      delete window[t.WPrefix][this.id]
    }),
    (c.prototype._scriptError = function () {
      var h = this
      this.errorTimer ||
        (this.errorTimer = setTimeout(function () {
          h.loadedOkay || h._abort(new Error('JSONP script loaded abnormally (onerror)'))
        }, c.scriptErrorTimeout))
    }),
    (c.prototype._createScript = function (h) {
      var p = this,
        y = (this.script = window.document.createElement('script')),
        v
      if (
        ((y.id = 'a' + e.string(8)),
        (y.src = h),
        (y.type = 'text/javascript'),
        (y.charset = 'UTF-8'),
        (y.onerror = this._scriptError.bind(this)),
        (y.onload = function () {
          p._abort(new Error('JSONP script loaded abnormally (onload)'))
        }),
        (y.onreadystatechange = function () {
          if ((u('onreadystatechange', y.readyState), /loaded|closed/.test(y.readyState))) {
            if (y && y.htmlFor && y.onclick) {
              p.loadedOkay = !0
              try {
                y.onclick()
              } catch {}
            }
            y && p._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'))
          }
        }),
        typeof y.async > 'u' && window.document.attachEvent)
      )
        if (n.isOpera())
          ((v = this.script2 = window.document.createElement('script')),
            (v.text =
              "try{var a = document.getElementById('" + y.id + "'); if(a)a.onerror();}catch(x){};"),
            (y.async = v.async = !1))
        else {
          try {
            ;((y.htmlFor = y.id), (y.event = 'onclick'))
          } catch {}
          y.async = !0
        }
      typeof y.async < 'u' && (y.async = !0)
      var C = window.document.getElementsByTagName('head')[0]
      ;(C.insertBefore(y, C.firstChild), v && C.insertBefore(v, C.firstChild))
    }),
    (Zp = c),
    Zp
  )
}
var Up, aC
function d2() {
  if (aC) return Up
  aC = 1
  var t = Al(),
    e = cr(),
    n = function () {},
    i,
    s
  function o(c) {
    try {
      return window.document.createElement('<iframe name="' + c + '">')
    } catch {
      var h = window.document.createElement('iframe')
      return ((h.name = c), h)
    }
  }
  function u() {
    ;((i = window.document.createElement('form')),
      (i.style.display = 'none'),
      (i.style.position = 'absolute'),
      (i.method = 'POST'),
      (i.enctype = 'application/x-www-form-urlencoded'),
      (i.acceptCharset = 'UTF-8'),
      (s = window.document.createElement('textarea')),
      (s.name = 'd'),
      i.appendChild(s),
      window.document.body.appendChild(i))
  }
  return (
    (Up = function (c, h, p) {
      i || u()
      var y = 'a' + t.string(8)
      ;((i.target = y), (i.action = e.addQuery(e.addPath(c, '/jsonp_send'), 'i=' + y)))
      var v = o(y)
      ;((v.id = y), (v.style.display = 'none'), i.appendChild(v))
      try {
        s.value = h
      } catch {}
      i.submit()
      var C = function (w) {
        v.onerror &&
          ((v.onreadystatechange = v.onerror = v.onload = null),
          setTimeout(function () {
            ;(v.parentNode.removeChild(v), (v = null))
          }, 500),
          (s.value = ''),
          p(w))
      }
      return (
        (v.onerror = function () {
          C()
        }),
        (v.onload = function () {
          C()
        }),
        (v.onreadystatechange = function (w) {
          ;(n('onreadystatechange', y, v.readyState), v.readyState === 'complete' && C())
        }),
        function () {
          C(new Error('Aborted'))
        }
      )
    }),
    Up
  )
}
var Yp, sC
function g2() {
  if (sC) return Yp
  sC = 1
  var t = Pe(),
    e = BS(),
    n = h2(),
    i = d2()
  function s(o) {
    if (!s.enabled()) throw new Error('Transport created when disabled')
    e.call(this, o, '/jsonp', i, n)
  }
  return (
    t(s, e),
    (s.enabled = function () {
      return !!window.document
    }),
    (s.transportName = 'jsonp-polling'),
    (s.roundTrips = 1),
    (s.needBody = !0),
    (Yp = s),
    Yp
  )
}
var Hp, oC
function p2() {
  return (
    oC ||
      ((oC = 1),
      (Hp = [a2(), l2(), PS(), XI(), _p()(XI()), tC(), _p()(tC()), nC(), f2(), _p()(nC()), g2()])),
    Hp
  )
}
var lC = {},
  uC
function v2() {
  if (uC) return lC
  uC = 1
  var t = Array.prototype,
    e = Object.prototype,
    n = Function.prototype,
    i = String.prototype,
    s = t.slice,
    o = e.toString,
    u = function (g) {
      return e.toString.call(g) === '[object Function]'
    },
    c = function (S) {
      return o.call(S) === '[object Array]'
    },
    h = function (S) {
      return o.call(S) === '[object String]'
    },
    p =
      Object.defineProperty &&
      (function () {
        try {
          return (Object.defineProperty({}, 'x', {}), !0)
        } catch {
          return !1
        }
      })(),
    y
  p
    ? (y = function (g, S, M, _) {
        ;(!_ && S in g) ||
          Object.defineProperty(g, S, { configurable: !0, enumerable: !1, writable: !0, value: M })
      })
    : (y = function (g, S, M, _) {
        ;(!_ && S in g) || (g[S] = M)
      })
  var v = function (g, S, M) {
      for (var _ in S) e.hasOwnProperty.call(S, _) && y(g, _, S[_], M)
    },
    C = function (g) {
      if (g == null) throw new TypeError("can't convert " + g + ' to object')
      return Object(g)
    }
  function w(g) {
    var S = +g
    return (
      S !== S
        ? (S = 0)
        : S !== 0 && S !== 1 / 0 && S !== -1 / 0 && (S = (S > 0 || -1) * Math.floor(Math.abs(S))),
      S
    )
  }
  function N(g) {
    return g >>> 0
  }
  function T() {}
  ;(v(n, {
    bind: function (S) {
      var M = this
      if (!u(M)) throw new TypeError('Function.prototype.bind called on incompatible ' + M)
      for (
        var _ = s.call(arguments, 1),
          W = function () {
            if (this instanceof Tt) {
              var G = M.apply(this, _.concat(s.call(arguments)))
              return Object(G) === G ? G : this
            } else return M.apply(S, _.concat(s.call(arguments)))
          },
          $ = Math.max(0, M.length - _.length),
          X = [],
          Ct = 0;
        Ct < $;
        Ct++
      )
        X.push('$' + Ct)
      var Tt = Function(
        'binder',
        'return function (' + X.join(',') + '){ return binder.apply(this, arguments); }'
      )(W)
      return (
        M.prototype &&
          ((T.prototype = M.prototype), (Tt.prototype = new T()), (T.prototype = null)),
        Tt
      )
    },
  }),
    v(Array, { isArray: c }))
  var z = Object('a'),
    R = z[0] !== 'a' || !(0 in z),
    B = function (S) {
      var M = !0,
        _ = !0
      return (
        S &&
          (S.call('foo', function (W, $, X) {
            typeof X != 'object' && (M = !1)
          }),
          S.call(
            [1],
            function () {
              _ = typeof this == 'string'
            },
            'x'
          )),
        !!S && M && _
      )
    }
  v(
    t,
    {
      forEach: function (S) {
        var M = C(this),
          _ = R && h(this) ? this.split('') : M,
          W = arguments[1],
          $ = -1,
          X = _.length >>> 0
        if (!u(S)) throw new TypeError()
        for (; ++$ < X; ) $ in _ && S.call(W, _[$], $, M)
      },
    },
    !B(t.forEach)
  )
  var H = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1
  v(
    t,
    {
      indexOf: function (S) {
        var M = R && h(this) ? this.split('') : C(this),
          _ = M.length >>> 0
        if (!_) return -1
        var W = 0
        for (
          arguments.length > 1 && (W = w(arguments[1])), W = W >= 0 ? W : Math.max(0, _ + W);
          W < _;
          W++
        )
          if (W in M && M[W] === S) return W
        return -1
      },
    },
    H
  )
  var Z = i.split
  'ab'.split(/(?:ab)*/).length !== 2 ||
  '.'.split(/(.?)(.?)/).length !== 4 ||
  'tesst'.split(/(s)*/)[1] === 't' ||
  'test'.split(/(?:)/, -1).length !== 4 ||
  ''.split(/.?/).length ||
  '.'.split(/()()/).length > 1
    ? (function () {
        var g = /()??/.exec('')[1] === void 0
        i.split = function (S, M) {
          var _ = this
          if (S === void 0 && M === 0) return []
          if (o.call(S) !== '[object RegExp]') return Z.call(this, S, M)
          var W = [],
            $ =
              (S.ignoreCase ? 'i' : '') +
              (S.multiline ? 'm' : '') +
              (S.extended ? 'x' : '') +
              (S.sticky ? 'y' : ''),
            X = 0,
            Ct,
            Tt,
            G,
            Q
          for (
            S = new RegExp(S.source, $ + 'g'),
              _ += '',
              g || (Ct = new RegExp('^' + S.source + '$(?!\\s)', $)),
              M = M === void 0 ? -1 >>> 0 : N(M);
            (Tt = S.exec(_)) &&
            ((G = Tt.index + Tt[0].length),
            !(
              G > X &&
              (W.push(_.slice(X, Tt.index)),
              !g &&
                Tt.length > 1 &&
                Tt[0].replace(Ct, function () {
                  for (var it = 1; it < arguments.length - 2; it++)
                    arguments[it] === void 0 && (Tt[it] = void 0)
                }),
              Tt.length > 1 && Tt.index < _.length && t.push.apply(W, Tt.slice(1)),
              (Q = Tt[0].length),
              (X = G),
              W.length >= M)
            ));

          )
            S.lastIndex === Tt.index && S.lastIndex++
          return (
            X === _.length ? (Q || !S.test('')) && W.push('') : W.push(_.slice(X)),
            W.length > M ? W.slice(0, M) : W
          )
        }
      })()
    : '0'.split(void 0, 0).length &&
      (i.split = function (S, M) {
        return S === void 0 && M === 0 ? [] : Z.call(this, S, M)
      })
  var U = i.substr,
    nt = ''.substr && '0b'.substr(-1) !== 'b'
  return (
    v(
      i,
      {
        substr: function (S, M) {
          return U.call(this, S < 0 && (S = this.length + S) < 0 ? 0 : S, M)
        },
      },
      nt
    ),
    lC
  )
}
var Vp, cC
function m2() {
  if (cC) return Vp
  cC = 1
  var t =
      /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
    e,
    n = function (i) {
      var s,
        o = {},
        u = []
      for (s = 0; s < 65536; s++) u.push(String.fromCharCode(s))
      return (
        (i.lastIndex = 0),
        u.join('').replace(i, function (c) {
          return ((o[c] = '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4)), '')
        }),
        (i.lastIndex = 0),
        o
      )
    }
  return (
    (Vp = {
      quote: function (i) {
        var s = JSON.stringify(i)
        return (
          (t.lastIndex = 0),
          t.test(s)
            ? (e || (e = n(t)),
              s.replace(t, function (o) {
                return e[o]
              }))
            : s
        )
      },
    }),
    Vp
  )
}
var Xp, fC
function y2() {
  if (fC) return Xp
  fC = 1
  var t = function () {}
  return (
    (Xp = function (e) {
      return {
        filterToEnabled: function (n, i) {
          var s = { main: [], facade: [] }
          return (
            n ? typeof n == 'string' && (n = [n]) : (n = []),
            e.forEach(function (o) {
              if (o && !(o.transportName === 'websocket' && i.websocket === !1)) {
                if (n.length && n.indexOf(o.transportName) === -1) {
                  t('not in whitelist', o.transportName)
                  return
                }
                o.enabled(i)
                  ? (t('enabled', o.transportName),
                    s.main.push(o),
                    o.facadeTransport && s.facade.push(o.facadeTransport))
                  : t('disabled', o.transportName)
              }
            }),
            s
          )
        },
      }
    }),
    Xp
  )
}
var Wp, hC
function A2() {
  if (hC) return Wp
  hC = 1
  var t = {}
  return (
    ['log', 'debug', 'warn'].forEach(function (e) {
      var n
      try {
        n = window.console && window.console[e] && window.console[e].apply
      } catch {}
      t[e] = n
        ? function () {
            return window.console[e].apply(window.console, arguments)
          }
        : e === 'log'
          ? function () {}
          : t.log
    }),
    (Wp = t),
    Wp
  )
}
var Fp, dC
function t0() {
  if (dC) return Fp
  dC = 1
  function t(e) {
    this.type = e
  }
  return (
    (t.prototype.initEvent = function (e, n, i) {
      return (
        (this.type = e),
        (this.bubbles = n),
        (this.cancelable = i),
        (this.timeStamp = +new Date()),
        this
      )
    }),
    (t.prototype.stopPropagation = function () {}),
    (t.prototype.preventDefault = function () {}),
    (t.CAPTURING_PHASE = 1),
    (t.AT_TARGET = 2),
    (t.BUBBLING_PHASE = 3),
    (Fp = t),
    Fp
  )
}
var Jp, gC
function YS() {
  return (
    gC ||
      ((gC = 1),
      (Jp = window.location || {
        origin: 'http://localhost:80',
        protocol: 'http:',
        host: 'localhost',
        port: 80,
        href: 'http://localhost/',
        hash: '',
      })),
    Jp
  )
}
var qp, pC
function b2() {
  if (pC) return qp
  pC = 1
  var t = Pe(),
    e = t0()
  function n() {
    ;(e.call(this),
      this.initEvent('close', !1, !1),
      (this.wasClean = !1),
      (this.code = 0),
      (this.reason = ''))
  }
  return (t(n, e), (qp = n), qp)
}
var Qp, vC
function I2() {
  if (vC) return Qp
  vC = 1
  var t = Pe(),
    e = t0()
  function n(i) {
    ;(e.call(this), this.initEvent('message', !1, !1), (this.data = i))
  }
  return (t(n, e), (Qp = n), Qp)
}
var Kp, mC
function C2() {
  if (mC) return Kp
  mC = 1
  var t = fi().EventEmitter,
    e = Pe()
  function n() {
    var i = this
    ;(t.call(this),
      (this.to = setTimeout(function () {
        i.emit('finish', 200, '{}')
      }, n.timeout)))
  }
  return (
    e(n, t),
    (n.prototype.close = function () {
      clearTimeout(this.to)
    }),
    (n.timeout = 2e3),
    (Kp = n),
    Kp
  )
}
var $p, yC
function HS() {
  if (yC) return $p
  yC = 1
  var t = fi().EventEmitter,
    e = Pe(),
    n = $m()
  function i(s, o) {
    t.call(this)
    var u = this,
      c = +new Date()
    ;((this.xo = new o('GET', s)),
      this.xo.once('finish', function (h, p) {
        var y, v
        if (h === 200) {
          if (((v = +new Date() - c), p))
            try {
              y = JSON.parse(p)
            } catch {}
          n.isObject(y) || (y = {})
        }
        ;(u.emit('finish', y, v), u.removeAllListeners())
      }))
  }
  return (
    e(i, t),
    (i.prototype.close = function () {
      ;(this.removeAllListeners(), this.xo.close())
    }),
    ($p = i),
    $p
  )
}
var tv, AC
function VS() {
  if (AC) return tv
  AC = 1
  var t = Pe(),
    e = fi().EventEmitter,
    n = rc(),
    i = HS()
  function s(o) {
    var u = this
    ;(e.call(this),
      (this.ir = new i(o, n)),
      this.ir.once('finish', function (c, h) {
        ;((u.ir = null), u.emit('message', JSON.stringify([c, h])))
      }))
  }
  return (
    t(s, e),
    (s.transportName = 'iframe-info-receiver'),
    (s.prototype.close = function () {
      ;(this.ir && (this.ir.close(), (this.ir = null)), this.removeAllListeners())
    }),
    (tv = s),
    tv
  )
}
var ev, bC
function w2() {
  if (bC) return ev
  bC = 1
  var t = fi().EventEmitter,
    e = Pe(),
    n = vs(),
    i = US(),
    s = VS()
  function o(u, c) {
    var h = this
    t.call(this)
    var p = function () {
      var y = (h.ifr = new i(s.transportName, c, u))
      ;(y.once('message', function (v) {
        if (v) {
          var C
          try {
            C = JSON.parse(v)
          } catch {
            ;(h.emit('finish'), h.close())
            return
          }
          var w = C[0],
            N = C[1]
          h.emit('finish', w, N)
        }
        h.close()
      }),
        y.once('close', function () {
          ;(h.emit('finish'), h.close())
        }))
    }
    window.document.body ? p() : n.attachEvent('load', p)
  }
  return (
    e(o, t),
    (o.enabled = function () {
      return i.enabled()
    }),
    (o.prototype.close = function () {
      ;(this.ifr && this.ifr.close(), this.removeAllListeners(), (this.ifr = null))
    }),
    (ev = o),
    ev
  )
}
var nv, IC
function x2() {
  if (IC) return nv
  IC = 1
  var t = fi().EventEmitter,
    e = Pe(),
    n = cr(),
    i = Km(),
    s = Zh(),
    o = rc(),
    u = C2(),
    c = w2(),
    h = HS()
  function p(y, v) {
    var C = this
    ;(t.call(this),
      setTimeout(function () {
        C.doXhr(y, v)
      }, 0))
  }
  return (
    e(p, t),
    (p._getReceiver = function (y, v, C) {
      return C.sameOrigin
        ? new h(v, o)
        : s.enabled
          ? new h(v, s)
          : i.enabled && C.sameScheme
            ? new h(v, i)
            : c.enabled()
              ? new c(y, v)
              : new h(v, u)
    }),
    (p.prototype.doXhr = function (y, v) {
      var C = this,
        w = n.addPath(y, '/info')
      ;((this.xo = p._getReceiver(y, w, v)),
        (this.timeoutRef = setTimeout(function () {
          ;(C._cleanup(!1), C.emit('finish'))
        }, p.timeout)),
        this.xo.once('finish', function (N, T) {
          ;(C._cleanup(!0), C.emit('finish', N, T))
        }))
    }),
    (p.prototype._cleanup = function (y) {
      ;(clearTimeout(this.timeoutRef),
        (this.timeoutRef = null),
        !y && this.xo && this.xo.close(),
        (this.xo = null))
    }),
    (p.prototype.close = function () {
      ;(this.removeAllListeners(), this._cleanup(!1))
    }),
    (p.timeout = 8e3),
    (nv = p),
    nv
  )
}
var iv, CC
function S2() {
  if (CC) return iv
  CC = 1
  var t = sc()
  function e(n) {
    ;((this._transport = n),
      n.on('message', this._transportMessage.bind(this)),
      n.on('close', this._transportClose.bind(this)))
  }
  return (
    (e.prototype._transportClose = function (n, i) {
      t.postMessage('c', JSON.stringify([n, i]))
    }),
    (e.prototype._transportMessage = function (n) {
      t.postMessage('t', n)
    }),
    (e.prototype._send = function (n) {
      this._transport.send(n)
    }),
    (e.prototype._close = function () {
      ;(this._transport.close(), this._transport.removeAllListeners())
    }),
    (iv = e),
    iv
  )
}
var rv, wC
function N2() {
  if (wC) return rv
  wC = 1
  var t = cr(),
    e = vs(),
    n = S2(),
    i = VS(),
    s = sc(),
    o = YS(),
    u = function () {}
  return (
    (rv = function (c, h) {
      var p = {}
      ;(h.forEach(function (v) {
        v.facadeTransport && (p[v.facadeTransport.transportName] = v.facadeTransport)
      }),
        (p[i.transportName] = i))
      var y
      c.bootstrap_iframe = function () {
        var v
        s.currentWindowId = o.hash.slice(1)
        var C = function (w) {
          if (w.source === parent && (typeof y > 'u' && (y = w.origin), w.origin === y)) {
            var N
            try {
              N = JSON.parse(w.data)
            } catch {
              u('bad json', w.data)
              return
            }
            if (N.windowId === s.currentWindowId)
              switch (N.type) {
                case 's':
                  var T
                  try {
                    T = JSON.parse(N.data)
                  } catch {
                    u('bad json', N.data)
                    break
                  }
                  var z = T[0],
                    R = T[1],
                    B = T[2],
                    H = T[3]
                  if (z !== c.version)
                    throw new Error(
                      'Incompatible SockJS! Main site uses: "' +
                        z +
                        '", the iframe: "' +
                        c.version +
                        '".'
                    )
                  if (!t.isOriginEqual(B, o.href) || !t.isOriginEqual(H, o.href))
                    throw new Error(
                      "Can't connect to different domain from within an iframe. (" +
                        o.href +
                        ', ' +
                        B +
                        ', ' +
                        H +
                        ')'
                    )
                  v = new n(new p[R](B, H))
                  break
                case 'm':
                  v._send(N.data)
                  break
                case 'c':
                  ;(v && v._close(), (v = null))
                  break
              }
          }
        }
        ;(e.attachEvent('message', C), s.postMessage('s'))
      }
    }),
    rv
  )
}
var av, xC
function T2() {
  if (xC) return av
  ;((xC = 1), v2())
  var t = kS(),
    e = Pe(),
    n = Al(),
    i = m2(),
    s = cr(),
    o = vs(),
    u = y2(),
    c = $m(),
    h = ac(),
    p = A2(),
    y = t0(),
    v = _S(),
    C = YS(),
    w = b2(),
    N = I2(),
    T = x2(),
    z = function () {},
    R
  function B(Z, U, nt) {
    if (!(this instanceof B)) return new B(Z, U, nt)
    if (arguments.length < 1)
      throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present")
    ;(v.call(this),
      (this.readyState = B.CONNECTING),
      (this.extensions = ''),
      (this.protocol = ''),
      (nt = nt || {}),
      nt.protocols_whitelist &&
        p.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead."),
      (this._transportsWhitelist = nt.transports),
      (this._transportOptions = nt.transportOptions || {}),
      (this._timeout = nt.timeout || 0))
    var g = nt.sessionId || 8
    if (typeof g == 'function') this._generateSessionId = g
    else if (typeof g == 'number')
      this._generateSessionId = function () {
        return n.string(g)
      }
    else
      throw new TypeError(
        'If sessionId is used in the options, it needs to be a number or a function.'
      )
    this._server = nt.server || n.numberString(1e3)
    var S = new t(Z)
    if (!S.host || !S.protocol) throw new SyntaxError("The URL '" + Z + "' is invalid")
    if (S.hash) throw new SyntaxError('The URL must not contain a fragment')
    if (S.protocol !== 'http:' && S.protocol !== 'https:')
      throw new SyntaxError(
        "The URL's scheme must be either 'http:' or 'https:'. '" + S.protocol + "' is not allowed."
      )
    var M = S.protocol === 'https:'
    if (C.protocol === 'https:' && !M && !s.isLoopbackAddr(S.hostname))
      throw new Error(
        'SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS'
      )
    U ? Array.isArray(U) || (U = [U]) : (U = [])
    var _ = U.sort()
    _.forEach(function ($, X) {
      if (!$) throw new SyntaxError("The protocols entry '" + $ + "' is invalid.")
      if (X < _.length - 1 && $ === _[X + 1])
        throw new SyntaxError("The protocols entry '" + $ + "' is duplicated.")
    })
    var W = s.getOrigin(C.href)
    ;((this._origin = W ? W.toLowerCase() : null),
      S.set('pathname', S.pathname.replace(/\/+$/, '')),
      (this.url = S.href),
      z('using url', this.url),
      (this._urlInfo = {
        nullOrigin: !h.hasDomain(),
        sameOrigin: s.isOriginEqual(this.url, C.href),
        sameScheme: s.isSchemeEqual(this.url, C.href),
      }),
      (this._ir = new T(this.url, this._urlInfo)),
      this._ir.once('finish', this._receiveInfo.bind(this)))
  }
  e(B, v)
  function H(Z) {
    return Z === 1e3 || (Z >= 3e3 && Z <= 4999)
  }
  return (
    (B.prototype.close = function (Z, U) {
      if (Z && !H(Z)) throw new Error('InvalidAccessError: Invalid code')
      if (U && U.length > 123) throw new SyntaxError('reason argument has an invalid length')
      if (!(this.readyState === B.CLOSING || this.readyState === B.CLOSED)) {
        var nt = !0
        this._close(Z || 1e3, U || 'Normal closure', nt)
      }
    }),
    (B.prototype.send = function (Z) {
      if ((typeof Z != 'string' && (Z = '' + Z), this.readyState === B.CONNECTING))
        throw new Error('InvalidStateError: The connection has not been established yet')
      this.readyState === B.OPEN && this._transport.send(i.quote(Z))
    }),
    (B.version = ZS()),
    (B.CONNECTING = 0),
    (B.OPEN = 1),
    (B.CLOSING = 2),
    (B.CLOSED = 3),
    (B.prototype._receiveInfo = function (Z, U) {
      if (((this._ir = null), !Z)) {
        this._close(1002, 'Cannot connect to server')
        return
      }
      ;((this._rto = this.countRTO(U)),
        (this._transUrl = Z.base_url ? Z.base_url : this.url),
        (Z = c.extend(Z, this._urlInfo)))
      var nt = R.filterToEnabled(this._transportsWhitelist, Z)
      ;((this._transports = nt.main),
        z(this._transports.length + ' enabled transports'),
        this._connect())
    }),
    (B.prototype._connect = function () {
      for (var Z = this._transports.shift(); Z; Z = this._transports.shift()) {
        if (
          (z('attempt', Z.transportName),
          Z.needBody &&
            (!window.document.body ||
              (typeof window.document.readyState < 'u' &&
                window.document.readyState !== 'complete' &&
                window.document.readyState !== 'interactive')))
        ) {
          ;(this._transports.unshift(Z), o.attachEvent('load', this._connect.bind(this)))
          return
        }
        var U = Math.max(this._timeout, this._rto * Z.roundTrips || 5e3)
        this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), U)
        var nt = s.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId()),
          g = this._transportOptions[Z.transportName],
          S = new Z(nt, this._transUrl, g)
        ;(S.on('message', this._transportMessage.bind(this)),
          S.once('close', this._transportClose.bind(this)),
          (S.transportName = Z.transportName),
          (this._transport = S))
        return
      }
      this._close(2e3, 'All transports failed', !1)
    }),
    (B.prototype._transportTimeout = function () {
      this.readyState === B.CONNECTING &&
        (this._transport && this._transport.close(),
        this._transportClose(2007, 'Transport timed out'))
    }),
    (B.prototype._transportMessage = function (Z) {
      var U = this,
        nt = Z.slice(0, 1),
        g = Z.slice(1),
        S
      switch (nt) {
        case 'o':
          this._open()
          return
        case 'h':
          ;(this.dispatchEvent(new y('heartbeat')), z('heartbeat', this.transport))
          return
      }
      if (g)
        try {
          S = JSON.parse(g)
        } catch {}
      if (!(typeof S > 'u'))
        switch (nt) {
          case 'a':
            Array.isArray(S) &&
              S.forEach(function (M) {
                ;(z('message', U.transport), U.dispatchEvent(new N(M)))
              })
            break
          case 'm':
            ;(z('message', this.transport), this.dispatchEvent(new N(S)))
            break
          case 'c':
            Array.isArray(S) && S.length === 2 && this._close(S[0], S[1], !0)
            break
        }
    }),
    (B.prototype._transportClose = function (Z, U) {
      if (
        (z('_transportClose', this.transport),
        this._transport &&
          (this._transport.removeAllListeners(), (this._transport = null), (this.transport = null)),
        !H(Z) && Z !== 2e3 && this.readyState === B.CONNECTING)
      ) {
        this._connect()
        return
      }
      this._close(Z, U)
    }),
    (B.prototype._open = function () {
      ;(z('_open', this._transport && this._transport.transportName, this.readyState),
        this.readyState === B.CONNECTING
          ? (this._transportTimeoutId &&
              (clearTimeout(this._transportTimeoutId), (this._transportTimeoutId = null)),
            (this.readyState = B.OPEN),
            (this.transport = this._transport.transportName),
            this.dispatchEvent(new y('open')),
            z('connected', this.transport))
          : this._close(1006, 'Server lost session'))
    }),
    (B.prototype._close = function (Z, U, nt) {
      z('_close', this.transport, Z, U, nt, this.readyState)
      var g = !1
      if (
        (this._ir && ((g = !0), this._ir.close(), (this._ir = null)),
        this._transport &&
          (this._transport.close(), (this._transport = null), (this.transport = null)),
        this.readyState === B.CLOSED)
      )
        throw new Error('InvalidStateError: SockJS has already been closed')
      ;((this.readyState = B.CLOSING),
        setTimeout(
          function () {
            ;((this.readyState = B.CLOSED), g && this.dispatchEvent(new y('error')))
            var S = new w('close')
            ;((S.wasClean = nt || !1),
              (S.code = Z || 1e3),
              (S.reason = U),
              this.dispatchEvent(S),
              (this.onmessage = this.onclose = this.onerror = null))
          }.bind(this),
          0
        ))
    }),
    (B.prototype.countRTO = function (Z) {
      return Z > 100 ? 4 * Z : 300 + Z
    }),
    (av = function (Z) {
      return ((R = u(Z)), N2()(B, Z), B)
    }),
    av
  )
}
var sv, SC
function M2() {
  if (SC) return sv
  SC = 1
  var t = p2()
  return ((sv = T2()(t)), '_sockjs_onload' in window && setTimeout(window._sockjs_onload, 1), sv)
}
var E2 = M2()
const D2 = Hu(E2)
function O2({ docId: t = 'demo', onPatch: e }) {
  const n = ce.useRef(null),
    i = ce.useRef(!1),
    s = ce.useRef([]),
    o = ce.useRef(crypto?.randomUUID?.() || Math.random().toString(36).slice(2, 10))
  return (
    ce.useEffect(() => {
      const c = 'https://35.188.196.28',
        h = new D2(`${c}/ws`),
        p = new t2({
          webSocketFactory: () => h,
          reconnectDelay: 1500,
          onConnect: () => {
            ;((i.current = !0),
              p.subscribe(`/topic/graph.${t}`, v => {
                try {
                  const C = JSON.parse(v.body)
                  if (C?._by === o.current) return
                  e?.(C)
                } catch (C) {
                  console.error('WS patch inválido:', C)
                }
              }))
            const y = s.current.splice(0, 200)
            for (const v of y)
              try {
                p.publish({ destination: `/app/graph.update.${t}`, body: JSON.stringify(v) })
              } catch {
                s.current.unshift(v)
                break
              }
          },
          onStompError: y => {
            ;(console.error('STOMP error', y), (i.current = !1))
          },
          onWebSocketClose: () => {
            i.current = !1
          },
        })
      return (
        p.activate(),
        (n.current = p),
        () => {
          ;((i.current = !1), p.deactivate())
        }
      )
    }, [t, e]),
    {
      sendPatch: ce.useCallback(
        c => {
          const h = { ...c, _by: o.current }
          try {
            const p = n.current
            if (!p || !i.current) {
              if (h?.t === 'move') {
                const y = s.current.findIndex(v => v?.t === 'move' && v?.id === h.id)
                y >= 0 ? s.current.splice(y, 1, h) : s.current.push(h)
              } else s.current.push(h)
              return
            }
            p.publish({ destination: `/app/graph.update.${t}`, body: JSON.stringify(h) })
          } catch {
            s.current.push(h)
          }
        },
        [t]
      ),
    }
  )
}
function L2({ lang: t = 'es-ES', interim: e = !0, continuous: n = !1, onResult: i } = {}) {
  const s = ce.useRef(null),
    [o, u] = ce.useState(!1),
    [c, h] = ce.useState(!1),
    [p, y] = ce.useState(null)
  ce.useEffect(() => {
    const w = window.SpeechRecognition || window.webkitSpeechRecognition
    if (!w) return
    u(!0)
    const N = new w()
    return (
      (N.lang = t),
      (N.interimResults = e),
      (N.continuous = n),
      (N.onresult = T => {
        let z = ''
        for (let R = T.resultIndex; R < T.results.length; R++) z += T.results[R][0].transcript
        i?.(z, { final: T.results[T.results.length - 1].isFinal })
      }),
      (N.onerror = T => y(T?.error || 'speech-error')),
      (N.onend = () => h(!1)),
      (s.current = N),
      () => {
        try {
          N.stop()
        } catch {}
      }
    )
  }, [t, e, n, i])
  const v = ce.useCallback(() => {
      if (s.current) {
        ;(y(null), h(!0))
        try {
          s.current.start()
        } catch {}
      }
    }, []),
    C = ce.useCallback(() => {
      try {
        s.current?.stop()
      } catch {}
    }, [])
  return { supported: o, isListening: c, start: v, stop: C, error: p }
}
function z2({ open: t, onCancel: e, onConfirm: n, value: i, onChange: s, loading: o }) {
  const {
    supported: u,
    isListening: c,
    start: h,
    stop: p,
    error: y,
  } = L2({
    lang: 'es-ES',
    interim: !0,
    continuous: !1,
    onResult: (w, { final: N }) => {
      if (w && N) {
        const T = (i?.trim() ? i + ' ' : '') + w
        s?.(T.trim())
      }
    },
  })
  if (
    (ce.useEffect(() => {
      t || p()
    }, [t, p]),
    !t)
  )
    return null
  const v = () => (c ? p() : h()),
    C = async w => {
      ;(w?.preventDefault?.(), i?.trim() && (await n?.()))
    }
  return Gt.jsxs('div', {
    className: 'modal-overlay',
    children: [
      Gt.jsxs('div', {
        className: 'modal',
        children: [
          Gt.jsx('h3', { children: 'Diagrama con IA' }),
          Gt.jsx('p', {
            className: 'muted',
            children: 'Describe lo que quieres (p. ej. “diagrama de clases para una clínica…”)',
          }),
          Gt.jsx('textarea', {
            value: i || '',
            onChange: w => s?.(w.target.value),
            placeholder: 'Escribe o dicta tu solicitud…',
            rows: 6,
            disabled: o,
          }),
          Gt.jsxs('div', {
            className: 'row gap',
            children: [
              Gt.jsx('button', { type: 'button', onClick: e, disabled: o, children: 'Cancelar' }),
              u
                ? Gt.jsx('button', {
                    type: 'button',
                    onClick: v,
                    className: c ? 'mic listening' : 'mic',
                    title: c ? 'Detener dictado' : 'Dictar con voz',
                    disabled: o,
                    children: c ? '🛑 Detener' : '🎤 Dictar',
                  })
                : Gt.jsx('button', {
                    type: 'button',
                    disabled: !0,
                    className: 'mic',
                    title: 'No soportado por este navegador',
                    children: '🎤 No disponible',
                  }),
              Gt.jsx('button', {
                onClick: C,
                disabled: o || !i?.trim(),
                children: o ? 'Generando…' : 'Generar',
              }),
            ],
          }),
          y &&
            Gt.jsxs('div', {
              style: { color: 'tomato', marginTop: 8 },
              children: ['Voz: ', String(y)],
            }),
        ],
      }),
      Gt.jsx('style', {
        jsx: !0,
        children: `
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:1000; }
        .modal { width:min(680px,92vw); background:#fff; border-radius:12px; padding:16px 18px; box-shadow:0 10px 40px rgba(0,0,0,.2); }
        h3 { margin:0 0 6px; }
        .muted { margin:0 0 10px; color:#666; font-size:.9rem; }
        textarea { width:100%; resize:vertical; padding:10px; border:1px solid #ddd; border-radius:8px; font-size:14px; }
        .row { display:flex; justify-content:flex-end; align-items:center; margin-top:12px; }
        .gap > * { margin-left:8px; }
        .mic.listening { background:#ffe8e8; border-color:#ffb3b3; }
        button { padding:8px 12px; border-radius:8px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer; }
        button[disabled] { opacity:.6; cursor:not-allowed; }
      `,
      }),
    ],
  })
}
function R2() {
  const [t, e] = ce.useState(!1),
    [n, i] = ce.useState([
      {
        role: 'assistant',
        content:
          '¡Hola! Soy tu asistente. Pregúntame cómo usar el Diagramador, generar código o PDF, etc.',
      },
    ]),
    [s, o] = ce.useState(''),
    [u, c] = ce.useState(!1),
    h = ce.useRef(null)
  ce.useEffect(() => {
    h.current?.scrollIntoView({ behavior: 'smooth' })
  }, [n, t])
  const p = async () => {
      const v = s.trim()
      if (!(!v || u)) {
        ;(i(C => [...C, { role: 'user', content: v }]), o(''))
        try {
          c(!0)
          const C = await fetch('/api/ai/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question: v }),
          })
          if (!C.ok) {
            const N = await C.text()
            throw new Error(N || 'Error del chat')
          }
          const w = await C.json()
          i(N => [...N, { role: 'assistant', content: w.answer || 'Sin respuesta.' }])
        } catch (C) {
          ;(i(w => [
            ...w,
            { role: 'assistant', content: 'Ups, no pude responder ahora. Intenta de nuevo.' },
          ]),
            console.error(C))
        } finally {
          c(!1)
        }
      }
    },
    y = v => {
      v.key === 'Enter' && !v.shiftKey && (v.preventDefault(), p())
    }
  return Gt.jsxs(Gt.Fragment, {
    children: [
      Gt.jsx('button', {
        className: 'help-bubble',
        onClick: () => e(v => !v),
        title: 'Ayuda',
        children: '?',
      }),
      t &&
        Gt.jsxs('div', {
          className: 'help-panel',
          children: [
            Gt.jsxs('div', {
              className: 'help-header',
              children: [
                Gt.jsx('strong', { children: 'Ayuda' }),
                Gt.jsx('button', { className: 'x', onClick: () => e(!1), children: '✕' }),
              ],
            }),
            Gt.jsxs('div', {
              className: 'help-body',
              children: [
                n.map((v, C) =>
                  Gt.jsx(
                    'div',
                    {
                      className: `msg ${v.role}`,
                      children: Gt.jsx('div', { className: 'bubble', children: v.content }),
                    },
                    C
                  )
                ),
                Gt.jsx('div', { ref: h }),
              ],
            }),
            Gt.jsxs('div', {
              className: 'help-input',
              children: [
                Gt.jsx('textarea', {
                  value: s,
                  onChange: v => o(v.target.value),
                  onKeyDown: y,
                  placeholder: 'Escribe tu pregunta…',
                  rows: 2,
                  disabled: u,
                }),
                Gt.jsx('button', {
                  onClick: p,
                  disabled: u || !s.trim(),
                  children: u ? '...' : 'Enviar',
                }),
              ],
            }),
          ],
        }),
      Gt.jsx('style', {
        jsx: !0,
        children: `
        .help-bubble {
          position: fixed; right: 16px; bottom: 16px; width: 48px; height: 48px;
          border-radius: 50%; border: none; background: #111; color: #fff; font-size: 20px;
          cursor: pointer; box-shadow: 0 6px 18px rgba(0,0,0,.25); z-index: 1100;
        }
        .help-panel {
          position: fixed; right: 16px; bottom: 76px; width: 340px; max-height: 60vh;
          background: #fff; border: 1px solid #e6e6e6; border-radius: 12px;
          display: flex; flex-direction: column; overflow: hidden; z-index: 1100;
          box-shadow: 0 10px 30px rgba(0,0,0,.25);
          color: #111;                 /* 👈 texto oscuro */
        }
        .help-header {
          display: flex; justify-content: space-between; align-items: center;
          padding: 8px 10px; background: #f7f7f9; border-bottom: 1px solid #eee;
          color: #111;                 /* 👈 texto oscuro */
        }
        .help-header .x { border: none; background: transparent; font-size: 18px; cursor: pointer; color: #111; }
        .help-body { padding: 10px; overflow: auto; flex: 1; background: #fafafb; color: #111; }  /* 👈 */
        .msg { display: flex; margin-bottom: 8px; }
        .msg.user { justify-content: flex-end; }
        .msg .bubble {
          max-width: 80%; padding: 8px 10px; border-radius: 10px; font-size: 14px; line-height: 1.3;
          white-space: pre-wrap; color: #111;   /* 👈 */
        }
        .msg.user .bubble { background: #dff1ff; }
        .msg.assistant .bubble { background: #eef0f3; }
        .help-input {
          display: flex; gap: 6px; padding: 8px; border-top: 1px solid #eee; background: #fff; color: #111;  /* 👈 */
        }
        .help-input textarea {
          flex: 1; border: 1px solid #ddd; border-radius: 8px; padding: 8px; resize: none; color: #111;       /* 👈 */
        }
        .help-input textarea::placeholder { color: #666; }  /* mejor contraste del placeholder */
        .help-input button { padding: 8px 12px; border: 1px solid #ccc; border-radius: 8px; background: #f7f7f7; color: #111; } /* 👈 */
        .help-input button[disabled] { opacity: .6; cursor: not-allowed; }
      `,
      }),
    ],
  })
}
function k2(t) {
  return btoa(unescape(encodeURIComponent(JSON.stringify(t))))
}
function _2(t) {
  try {
    return JSON.parse(decodeURIComponent(escape(atob(t))))
  } catch {
    return null
  }
}
function B2() {
  const t = ce.useRef(null),
    [e, n] = ce.useState(null),
    [i, s] = ce.useState(!1),
    [o, u] = ce.useState(!1),
    [c, h] = ce.useState(!1),
    [p, y] = ce.useState(!1),
    [v, C] = ce.useState(''),
    [w, N] = ce.useState(!1),
    T = 'https://35.188.196.28',
    z = ce.useMemo(() => {
      const ct = new URL(window.location.href),
        St = ct.searchParams.get('doc')
      if (St) return St
      const bt = (crypto?.randomUUID?.() || Math.random().toString(36).slice(2, 10)).slice(0, 8)
      return (ct.searchParams.set('doc', bt), window.history.replaceState({}, '', ct), bt)
    }, [])
  ce.useEffect(() => {
    if (!i) return
    const ct = window.location.hash
    if (ct.startsWith('#d=')) {
      const St = ct.slice(3),
        bt = _2(St)
      bt && t.current?.loadFromJSON(bt)
    }
  }, [i])
  const R = ct => {
      t.current?.applyPatch?.(ct)
    },
    { sendPatch: B } = O2({ docId: z, onPatch: R }),
    H = async () => {
      try {
        h(!0)
        const ct = t.current?.getGraphJSON?.()
        if (!ct?.cells?.length) {
          alert('No hay diagrama.')
          return
        }
        const St = mI(ct, {
            name: 'diagramador-generated',
            version: '0.0.1',
            packageBase: 'com.jezabel.healthgen',
          }),
          bt = await fetch(`${T}/api/generate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(St),
          })
        if (!bt.ok) throw new Error(await bt.text())
        const { id: kt } = await bt.json(),
          lt = await fetch(`${T}/api/ai/docs`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: kt, filename: `${St.name}-doc.pdf` }),
          })
        if (!lt.ok) throw new Error(await lt.text())
        const gt = await lt.blob(),
          Et = URL.createObjectURL(gt),
          Ft = document.createElement('a')
        ;((Ft.href = Et),
          (Ft.download = `${St.name}-doc.pdf`),
          document.body.appendChild(Ft),
          Ft.click(),
          Ft.remove(),
          URL.revokeObjectURL(Et))
      } catch (ct) {
        ;(console.error(ct),
          alert(
            `No se pudo generar el PDF IA.
` + (ct.message || ct)
          ))
      } finally {
        h(!1)
      }
    },
    Z = () => y(!0),
    U = () => {
      w || y(!1)
    },
    nt = {
      LONG: 'Long',
      INT: 'Int',
      BOOLEAN: 'Boolean',
      DECIMAL: 'BigDecimal',
      LOCAL_DATE: 'LocalDate',
      LOCAL_DATE_TIME: 'LocalDateTime',
      STRING: 'String',
    }
  function g(ct) {
    const St = [],
      bt = new Map(),
      kt = ct.entities || [],
      lt = 280,
      gt = 180
    let Et = 0,
      Ft = 0
    for (const Qt of kt) {
      const qt = crypto.randomUUID()
      bt.set(Qt.name, qt)
      const de = (Qt.attributes || []).map(Xt => {
        const E = nt[Xt.type] || 'String'
        return `${(Xt.pk, '+')} ${Xt.name}: ${E}${(Xt.generated, '')}`
      })
      ;(St.push({
        type: 'uml.Class',
        id: qt,
        name: Qt.name,
        attributes: de,
        methods: [],
        position: { x: 80 + Ft * lt, y: 80 + Et * gt },
        size: { width: 220, height: 120 },
        z: 1,
        attrs: {},
      }),
        Ft++,
        Ft >= 3 && ((Ft = 0), Et++))
    }
    for (const Qt of ct.relations || []) {
      const qt = bt.get(Qt.source),
        de = bt.get(Qt.target)
      if (!qt || !de) continue
      let Xt
      switch (Qt.type) {
        case 'association':
          Xt = 'uml.Association'
          break
        case 'aggregation':
          Xt = 'uml.Aggregation'
          break
        case 'composition':
          Xt = 'uml.Composition'
          break
        case 'generalization':
          Xt = 'uml.Generalization'
          break
        default:
          continue
      }
      const E = []
      if (Xt === 'uml.Association' || Xt === 'uml.Aggregation' || Xt === 'uml.Composition') {
        const P = Qt.multSource || '1',
          Y = Qt.multTarget || '0..*'
        ;(E.push({
          position: { distance: 35, offset: -10 },
          attrs: { text: { text: P }, rect: { fill: 'white' } },
        }),
          E.push({
            position: { distance: -35, offset: 10 },
            attrs: { text: { text: Y }, rect: { fill: 'white' } },
          }))
      }
      St.push({
        type: Xt,
        id: crypto.randomUUID(),
        source: { id: qt },
        target: { id: de },
        labels: E,
        z: 3,
        attrs: {},
      })
    }
    return { cells: St }
  }
  const S = async () => {
      try {
        N(!0)
        const ct = await fetch(`${T}/api/ai/diagram`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: v }),
        })
        if (!ct.ok) throw new Error(await ct.text())
        const St = await ct.json(),
          bt = g(St)
        ;(t.current?.loadFromJSON?.(bt), y(!1), C(''))
      } catch (ct) {
        ;(console.error(ct), alert('No se pudo generar el diagrama con IA.'))
      } finally {
        N(!1)
      }
    },
    M = () => t.current?.clear(),
    _ = async ct => {
      const St = await ct.text(),
        bt = JSON.parse(St)
      t.current?.loadFromJSON(bt)
    },
    W = () => {
      const ct = t.current?.getGraphJSON()
      Vz('diagramador_model.json', ct)
    },
    $ = async () => {
      const ct = t.current?.getGraphJSON(),
        St = k2(ct),
        kt = `${`${window.location.origin}${window.location.pathname}?doc=${encodeURIComponent(z)}`}#d=${St}`
      try {
        ;(await navigator.clipboard.writeText(kt), alert('Enlace copiado al portapapeles.'))
      } catch {
        prompt('Copia el enlace:', kt)
      }
    },
    X = async () => {
      try {
        u(!0)
        const ct = t.current?.getGraphJSON?.()
        if (!ct || !ct.cells?.length) {
          alert('No hay diagrama para generar.')
          return
        }
        const St = mI(ct, {
            name: 'diagramador-generated',
            version: '0.0.1',
            packageBase: 'com.jezabel.healthgen',
          }),
          bt = await fetch(`${T}/api/generate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(St),
          })
        if (!bt.ok) throw new Error(await bt.text())
        const { id: kt } = await bt.json()
        if (!kt) throw new Error('El backend no devolvió un id.')
        const lt = await fetch(`${T}/api/codegen/${kt}/zip`)
        if (!lt.ok) throw new Error(await lt.text())
        const gt = await lt.blob(),
          Et = URL.createObjectURL(gt),
          Ft = document.createElement('a')
        ;((Ft.href = Et),
          (Ft.download = `springboot_codegen_${kt}.zip`),
          document.body.appendChild(Ft),
          Ft.click(),
          Ft.remove(),
          URL.revokeObjectURL(Et))
      } catch (ct) {
        ;(console.error(ct),
          alert(`No se pudo generar el código.
${ct.message || ct}`))
      } finally {
        u(!1)
      }
    },
    Ct = () => {
      const ct = t.current?.addClass?.()
      ct?.id && B({ t: 'addClass', id: ct.id, name: ct.name, x: ct.x, y: ct.y })
    },
    Tt = ct => {
      const St = e?.id
      St && (t.current?.renameSelected?.(ct), B({ t: 'rename', id: St, name: ct }))
    },
    G = () => {
      const ct = e?.id
      ct &&
        (t.current?.addAttributeToSelected?.(),
        B({ t: 'addAttr', id: ct, value: '+ nuevo: String' }))
    },
    Q = (ct, St) => {
      const bt = e?.id
      bt &&
        (t.current?.updateAttributeOfSelected?.(ct, St),
        B({ t: 'updAttr', id: bt, index: ct, value: St }))
    },
    it = ct => {
      const St = e?.id
      St && (t.current?.removeAttributeOfSelected?.(ct), B({ t: 'delAttr', id: St, index: ct }))
    },
    st = () => {
      const ct = e?.id
      ct && (t.current?.deleteSelected?.(), B({ t: 'delClass', id: ct }))
    },
    F = ct => t.current?.setLinkMode(ct),
    ht = (ct, St) => {
      e?.id && t.current?.updateMultiplicity?.(ct, St)
    }
  return Gt.jsxs('div', {
    className: 'app-root',
    children: [
      Gt.jsx(bT, {
        onNew: M,
        onImport: _,
        onExport: W,
        onShare: $,
        onGenerateDocAi: H,
        docLoading: c,
        docDisabled: !i,
        onGenerateCode: X,
        genLoading: o,
        genDisabled: !i,
        onAiDiagramOpen: Z,
        aiLoading: w,
      }),
      Gt.jsx(z2, { open: p, value: v, onChange: C, onCancel: U, onConfirm: S, loading: w }),
      Gt.jsxs('div', {
        className: 'workspace',
        children: [
          Gt.jsx(IT, {
            onAddClass: Ct,
            onSetRelation: F,
            onAddAttribute: G,
            onRenameSelected: Tt,
            onUpdateAttribute: Q,
            onRemoveAttribute: it,
            onDeleteSelected: st,
            onUpdateMultiplicity: ht,
            selectedMeta: e,
          }),
          Gt.jsx(Hz, { ref: t, onSelectionChanged: n, onLocalPatch: B, onReady: () => s(!0) }),
        ],
      }),
      Gt.jsx(R2, {}),
    ],
  })
}
AT.createRoot(document.getElementById('root')).render(
  Gt.jsx(fT.StrictMode, { children: Gt.jsx(B2, {}) })
)
export { Hu as g }
